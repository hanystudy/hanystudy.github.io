
<!DOCTYPE HTML>
<html>
<head>
	<script data-cfasync="false" type="text/javascript" src="//use.typekit.net/axj3cfp.js"></script>
	<script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
	<meta charset="utf-8">
	<title>  | Wing of Dream 梦境之翼</title>

<meta name="author" content="Han Yi"> 

<meta name="description" content="　　前文我们对非MFC DLL和MFC规则DLL进行了介绍，现在开始详细分析DLL的最后一种类型――MFC扩展DLL。 　　6.1概论 　　MFC扩展DLL与MFC规则DLL的相同点在于在两种DLL的内部都可以使用MFC类库，其不同点在于MFC扩展DLL与应用程序的接口可以是MFC的。 &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Wing of Dream 梦境之翼" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el, 
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	
</head>



<body>
	<header id="header" class="inner"><h1><a href="/">Wing of Dream 梦境之翼</a></h1>
<h4></h4>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:www.hanyi.name">
			</form>
		</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-wu/">
		
			Visual C++动态链接库编程（五）</a>
	</h2>
	<div class="entry-content">
		<p>　　前文我们对非MFC DLL和MFC规则DLL进行了介绍，现在开始详细分析DLL的最后一种类型――MFC扩展DLL。</p>

<p>　　<strong>6.1概论</strong></p>

<p>　　MFC扩展DLL与MFC规则DLL的相同点在于在两种DLL的内部都可以使用MFC类库，其不同点在于MFC扩展DLL与应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的接口可以是MFC的。MFC扩展DLL的含义在于它是MFC的扩展，其主要功能是实现从现有MFC库类中派生出可重用的类。MFC扩展DLL使用MFC 动态链接库版本，因此只有用共享MFC 版本生成的MFC 可执行文件（应用程序或规则DLL）才能使用MFC扩展DLL。</p>

<p class="guanggao">　　从前文可知，MFC规则DLL被MFC向导自动添加了一个CWinApp的对象，而MFC扩展DLL则不包含该对象，它只是被自动添加了DllMain 函数。对于MFC扩展DLL，开发人员必须在DLL的DllMain函数中添加初始化和结束代码。</p>


<p>　　从下表我们可以看出三种DLL对DllMain入口函数的不同处理方式：</p>

<p><p class="guanggao">
<table border="1" align="center" width="90%" cellPadding="2" cellSpacing="0">
<tr>
<td>DLL类型</td>
<td>入口函数</td>
</tr>
<tr>
<td>非 MFC DLL</td>
<td>编程者提供DllMain函数</td>
</tr>
<tr>
<td>MFC规则 DLL</td>
<td>CWinApp对象的InitInstance 和 ExitInstance</td>
</tr>
<tr>
<td>MFC扩展 DLL</td>
<td>MFC DLL向导生成DllMain 函数</td>
</tr>
</table>
<p class="guanggao">　　对于MFC扩展DLL，系统会自动在工程中添加如下表所示的宏，这些宏为DLL和应用程序的编写提供了方便。像AFX_EXT_CLASS、AFX_EXT_API、AFX_EXT_DATA这样的宏，在DLL和应用程序中将具有不同的定义，这取决于<em>AFXEXT宏是否被定义。这使得在DLL和应用程序中，使用统一的一个宏就可以表示出输出和输入的不同意思。在DLL中，表示输出（因为</em>AFXEXT被定义，通常是在编译器的标识参数中指定/D_AFXEXT）；在应用程序中，则表示输入（_AFXEXT没有定义）。</p></p>

<p><p class="guanggao">
<table border="1" align="center" width="90%" cellPadding="2" cellSpacing="0">
<tr>
<td>宏</td>
<td>定义</td>
</tr>
<tr>
<td>AFX_CLASS_IMPORT</td>
<td><strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_API_IMPORT</td>
<td></strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_DATA_IMPORT</td>
<td><strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_CLASS_EXPORT</td>
<td></strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_API_EXPORT</td>
<td><strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_DATA_EXPORT</td>
<td></strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_EXT_CLASS</td>
<td>#ifdef _AFXEXT
　AFX_CLASS_EXPORT</p>

<h1>else</h1>

<p>　AFX_CLASS_IMPORT</td>
</tr>
<tr>
<td>AFX_EXT_API</td>
<td>#ifdef _AFXEXT
　AFX_API_EXPORT</p>

<h1>else</h1>

<p>　AFX_API_IMPORT</td>
</tr>
<tr>
<td>AFX_EXT_DATA</td>
<td>#ifdef _AFXEXT
　AFX_DATA_EXPORT</p>

<h1>else</h1>

<p>　AFX_DATA_IMPORT</td>
</tr>
</table>
<p class="guanggao">　　<strong>6.2 MFC扩展DLL导出MFC派生类</strong></p>
　　在这个例子中，我们将产生一个名为“ExtDll”的MFC扩展DLL工程，在这个DLL中导出一个对话框类，这个对话框类派生自MFC类CDialog。</p>

<p>　　使用MFC向导生成MFC扩展DLL时，系统会自动添加如下代码：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>static AFX_EXTENSION_MODULE ExtDllDLL = { NULL, NULL };
extern &ldquo;C&rdquo; int APIENTRYDllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
　// Remove this if you use lpReserved</p>

<p>　UNREFERENCED_PARAMETER( lpReserved );</p>

<p>　//说明：lpReserved是一个被系统所保留的参数，对于隐式链接是一个非零值，对于显式链接值是零</p>

<p>　if (dwReason == DLL_PROCESS_ATTACH)
　{
　　TRACE0( &ldquo;EXTDLL.DLL Initializing!\n&rdquo; );
　　// Extension DLL one-time initialization
　　if ( !AfxInitExtensionModule( ExtDllDLL, hInstance ))
　　　return 0;
　　　// Insert this DLL into the resource chain
　　new CDynLinkLibrary( ExtDllDLL );
　}
　else if (dwReason == DLL_PROCESS_DETACH)
　{
　　TRACE0( &ldquo;EXTDLL.DLL Terminating!\n&rdquo; );
　　// Terminate the library before destructors are called
　　AfxTermExtensionModule( ExtDllDLL );
　}
　return 1; // ok
}</td>
</tr>
</table>
<p class="guanggao">　　这一段代码含义晦涩，我们需要对其进行解读：</p>
　　（1）上述代码完成MFC扩展DLL的初始化和终止处理；</p>

<p>　　（2）初始化期间所创建的 CDynLinkLibrary 对象使MFC扩展 DLL 可以将 DLL中的CRuntimeClass 对象或资源导出到应用程序；</p>

<p>　　（3）AfxInitExtensionModule函数捕获模块的CRuntimeClass 结构和在创建 CDynLinkLibrary 对象时使用的对象工厂（COleObjectFactory 对象）；</p>

<p>　　（4）AfxTermExtensionModule函数使 MFC 得以在每个进程与扩展 DLL 分离时（进程退出或使用AfxFreeLibrary卸载DLL时）清除扩展 DLL；</p>

<p>　　（5）第一条语句static AFX_EXTENSION_MODULE ExtDllDLL = { NULL, NULL };定义了一个AFX_EXTENSION_MODULE类的静态全局对象，AFX_EXTENSION_MODULE的定义如下：</p>

<p><p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>struct AFX_EXTENSION_MODULE
{
　BOOL bInitialized;
　HMODULE hModule;
　HMODULE hResource;
　CRuntimeClass<em> pFirstSharedClass;
　COleObjectFactory</em> pFirstSharedFactory;
};</td>
</tr>
</table>
<p class="guanggao">　　由AFX_EXTENSION_MODULE的定义我们可以更好的理解（2）、（3）、（4）点。</p>
　　在资源编辑器中添加一个如图15所示的对话框，并使用MFC类向导为其添加一个对应的类CExtDialog，系统自动添加了ExtDialog.h和ExtDialog.cpp两个头文件。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/z44bxd805tf3.jpg" height="219" /><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/z44bxd805tf3.jpg" height="219" />
图15 MFC扩展DLL中的对话框</td>
</tr>
</table>
<p class="guanggao">　　修改ExtDialog.h中CExtDialog类的声明为：</p></p>

<p><p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class AFX_EXT_CLASS CExtDialog : public CDialog
{
　public:
　　CExtDialog( CWnd<em> pParent = NULL );
　　enum { IDD = IDD_DLL_DIALOG };
　protected:
　　virtual void DoDataExchange( CDataExchange</em> pDX );
　　DECLARE_MESSAGE_MAP()
};</td>
</tr>
</table>
<p class="guanggao">　　这其中最主要的改变是我们在class AFX_EXT_CLASS CExtDialog语句中添加了“AFX_EXT_CLASS”宏，则使得DLL中的CExtDialog类被导出。</p>
<p class="guanggao">　　<strong>6.3 MFC扩展DLL的加载</strong></p>
　　6.3.1 隐式加载</p>

<p>　　我们在6.2工程所在的工作区中添加一个LoadExtDllDlg工程，用于演示MFC扩展DLL的加载。在LoadExtDllDlg工程中添加一个如图16所示的对话框，这个对话框上包括一个“调用DLL”按钮。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="394" src="http://dev.yesky.com/imagelist/05/10/4o3b052d7377.jpg" height="138" /><img border="0" width="394" src="http://dev.yesky.com/imagelist/05/10/4o3b052d7377.jpg" height="138" />
图16 MFC扩展DLL调用工程中的对话框</td>
</tr>
</table>
　　在与图16对应对话框类实现文件的头部添加：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// LoadExtDllDlg.cpp : implementation file
//#include &ldquo;..\ExtDialog.h&rdquo;</p>

<h1>pragma comment( lib, &ldquo;ExtDll.lib&rdquo; )</h1>

<p>而“调用DLL”按钮的单击事件的消息处理函数为：</p>

<p>void CLoadExtDllDlg::OnDllcallButton()
{
　CExtDialog extDialog;
　extDialog.DoModal();
}</td>
</tr>
</table>
　　当我们单击“调用DLL”的时候，弹出了如图15的对话框。</p>

<p>　　为提供给用户隐式加载（MFC扩展DLL一般使用隐式加载，具体原因见下节），MFC扩展DLL需要提供三个文件：</p>

<p>　　（1）描述DLL中扩展类的头文件；</p>

<p>　　（2）与动态链接库对应的.LIB文件；</p>

<p>　　（3）动态链接库.DLL文件本身。</p>

<p>　　有了这三个文件，应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的开发者才可充分利用MFC扩展DLL。</p>

<p>　　6.3.2 显示加载</p>

<p>　　显示加载MFC扩展DLL应使用MFC全局函数AfxLoadLibrary而不是WIN32 API中的LoadLibrary。AfxLoadLibrary 最终也调用了 LoadLibrary这个API，但是在调用之前进行了线程同步的处理。</p>

<p>　　AfxLoadLibrary 的函数原型与 LoadLibrary完全相同，为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>HINSTANCE AFXAPI AfxLoadLibrary( LPCTSTR lpszModuleName );</td>
</tr>
</table>
　　与之相对应的是，MFC 应用程序应使用AfxFreeLibrary 而非FreeLibrary 卸载MFC扩展DLL。AfxFreeLibrary的函数原型也与 FreeLibrary完全相同，为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BOOL AFXAPI AfxFreeLibrary( HINSTANCE hInstLib );</td>
</tr>
</table>
　　如果我们把上例中的“调用DLL”按钮单击事件的消息处理函数改为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CLoadExtDllDlg::OnDllcallButton()
{
　HINSTANCE hDll = AfxLoadLibrary( &ldquo;ExtDll.dll&rdquo; );
　if(NULL == hDll)
　{
　　AfxMessageBox( &ldquo;MFC扩展DLL动态加载失败&rdquo; );
　　return;
　}　CExtDialog extDialog;
　extDialog.DoModal();
　AfxFreeLibrary(hDll);
}</td>
</tr>
</table>
　　则工程会出现link错误：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>LoadExtDllDlg.obj : error LNK2001: unresolved external symbol &ldquo;<strong>declspec(dllimport) public: virtual </strong>thiscall CExtDialog::~CExtDialog(void)&rdquo; (<strong>imp_??1CExtDialog@@UAE@XZ)LoadExtDllDlg.obj : error LNK2001: unresolved external symbol &ldquo;</strong>declspec(dllimport) public: <strong>thiscall CExtDialog::CExtDialog(class CWnd *)&rdquo; (</strong>imp_??0CExtDialog@@QAE@PAVCWnd@@@Z)</td>
</tr>
</table>
　　提示CExtDialog的构造函数和析构函数均无法找到！是的，对于派生MFC类的MFC扩展DLL，当我们要在应用程序中使用DLL中定义的派生类时，我们不宜使用动态加载DLL的方法。</p>

<p>　　<strong>6.4 MFC扩展DLL加载MFC扩展DLL</strong></p>

<p>　　我们可以在MFC扩展DLL中再次使用MFC扩展DLL，但是，由于在两个DLL中对于AFX_EXT_CLASS、AFX_EXT_API、AFX_EXT_DATA宏的定义都是输出，这会导致调用的时候出现问题。</p>

<p>　　我们将会在调用MFC扩展DLL的DLL中看到link错误：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>error LNK2001: unresolved external symbol …&hellip;&hellip;.</td>
</tr>
</table>
　　因此，在调用MFC扩展DLL的MFC扩展DLL中，在包含被调用DLL的头文件之前，需要临时重新定义AFX_EXT_CLASS的值。下面的例子显示了如何实现：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//临时改变宏的含义“输出”为“输入”#undef AFX_EXT_CLASS</p>

<h1>undef AFX_EXT_API</h1>

<h1>undef AFX_EXT_DATA</h1>

<h1>define AFX_EXT_CLASS AFX_CLASS_IMPORT</h1>

<h1>define AFX_EXT_API AFX_API_IMPORT</h1>

<h1>define AFX_EXT_DATA AFX_DATA_IMPORT</h1>

<p>//包含被调用MFC扩展DLL的头文件</p>

<h1>include &ldquo;CalledDLL.h&rdquo;</h1>

<p>//恢复宏的含义为输出</p>

<h1>undef AFX_EXT_CLASS</h1>

<h1>undef AFX_EXT_API</h1>

<h1>undef AFX_EXT_DATA</h1>

<h1>define AFX_EXT_CLASS AFX_CLASS_EXPORT</h1>

<h1>define AFX_EXT_API AFX_API_EXPORT</h1>

<h1>define AFX_EXT_DATA AFX_DATA_EXPORT</td></h1>

<p></tr>
</table>
　　<strong>6.5 MFC扩展DLL导出函数和变量</strong></p>

<p>　　MFC扩展DLL导出函数和变量的方法也十分简单，下面我们给出一个简单的例子。</p>

<p>　　我们在MFC向导生成的MFC扩展DLL工程中添加gobal.h和global.cpp两个文件：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//global.h:MFC扩展DLL导出变量和函数的声明extern &ldquo;C&rdquo;
{
　int AFX_EXT_DATA total; //导出变量
　int AFX_EXT_API add( int x, int y ); //导出函数
}</p>

<p>//global.cpp:MFC扩展DLL导出变量和函数定义</p>

<h1>include &ldquo;StdAfx.h&rdquo;</h1>

<h1>include &ldquo;global.h&rdquo;</h1>

<p>extern &ldquo;C&rdquo; int total;
int add(int x,int y)
{
　total = x + y;
　return total;
}</td>
</tr>
</table>
　　编写一个简单的控制台<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>来调用这个MFC扩展DLL：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;iostream.h&gt;</p>

<h1>include &lt;afxver<em>.h&gt;//AFX_EXT_DATA、AFX_EXT_API宏的定义在afxver</em>.h头文件中</h1>

<h1>pragma comment ( lib, &ldquo;ExtDll.lib&rdquo; )</h1>

<h1>include &ldquo;..\global.h&rdquo;</h1>

<p>int main(int argc, char* argv[])
{
　cout &lt;&lt; add(2,3) &lt;&lt; endl;
　cout &lt;&lt; total;
　return 0;
}</td>
</tr>
</table>
　　运行程序，在控制台上看到：</p>

<p>　　5</p>

<p>　　5</p>

<p>　　另外，在Visual C++下建立MFC扩展DLL时，MFC DLL向导会自动生成.def文件。因此，对于函数和变量，我们除了可以利用AFX_EXT_DATA、AFX_EXT_API宏导出以外，在.def文件中定义导出也是一个很好的办法。与之相比，在.def文件中导出类却较麻烦。通常需要从工程生成的.map文件中获得类的所有成员函数被C++编译器更改过的标识符，并且在.def文件中导出这些“奇怪”的标识符。因此，MFC扩展DLL通常以AFX_EXT_CLASS宏直接声明导出类。</p>

<p>　　<strong>6.6 MFC扩展DLL的应用</strong></p>

<p>　　上述各小节所举MFC扩展DLL的例子均只是为了说明某方面的问题，没有真实地体现“MFC扩展” 的内涵，譬如6.2派生自CDialog的类也不具备比CDialog更强的功能。MFC扩展DLL的真实内涵体现在它提供的类虽然派生自MFC类，但是提供了比MFC类更强大的功能、更丰富的接口。下面我们来看一个具体的例子（<a target="_blank" href="http://www.mydown.com/code/244/244724.html"><font color="#dd2222">单击此处下载本工程</font></a>）。</p>

<p>　　我们知道static控件所对应的CStatic类不具备设置背景和文本颜色的接口，这使得我们不能在对话框或其它用户界面上自由灵活地修改static控件的颜色风格，因此我们需要一个提供了SetBackColor和SetTextColor接口的CStatic派生类CMultiColorStatic。
　
　　这个类的声明如下：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class AFX_EXT_CLASS CMultiColorStatic : public CStatic
{
　// Construction　public:
　　CMultiColorStatic();
　　virtual ~CMultiColorStatic();
　　// Attributes
　protected:
　　CString m_strCaption;
　　COLORREF m_BackColor;
　　COLORREF m_TextColor;
　　// Operations
　public:
　　void SetTextColor( COLORREF TextColor );
　　void SetBackColor( COLORREF BackColor );
　　void SetCaption( CString strCaption );</p>

<p>　　// Generated message map functions
　protected:
　　afx_msg void OnPaint();
　　DECLARE_MESSAGE_MAP()
};</td>
</tr>
</table>
　　在这个类的实现文件中，我们需要为它提供WM_PAINT消息的处理函数（这是因为颜色的设置依赖于WM_PAINT消息）：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BEGIN_MESSAGE_MAP(CMultiColorStatic, CStatic)//{ {AFX_MSG_MAP(CMultiColorStatic)
　ON_WM_PAINT() //为这个类定义WM_PAINT消息处理函数
//}}AFX_MSG_MAP
END_MESSAGE_MAP()</td>
</tr>
</table>
　　下面是这个类中的重要成员函数：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//为CMultiColorStatic类添加“设置文本颜色”接口void CMultiColorStatic::SetTextColor( COLORREF TextColor )
{
　m_TextColor = TextColor; //设置文字颜色
}</p>

<p>//为CMultiColorStatic类添加“设置背景颜色”接口</p>

<p>void CMultiColorStatic::SetBackColor( COLORREF BackColor )
{
　m_BackColor = BackColor; //设置背景颜色
}</p>

<p>//为CMultiColorStatic类添加“设置标题”接口</p>

<p>void CMultiColorStatic::SetCaption( CString strCaption )
{
　m_strCaption = strCaption;
}</p>

<p>//重画Static，颜色和标题的设置都依赖于这个函数</p>

<p>void CMultiColorStatic::OnPaint()
{
　CPaintDC dc(this); // device context for painting
　CRect rect;
　GetClientRect( &amp;rect );
　dc.SetBkColor( m_BackColor );
　dc.SetBkMode( TRANSPARENT );
　CFont <em>pFont = GetParent()-&gt;GetFont();//得到父窗体的字体
　CFont </em>pOldFont;
　pOldFont = dc.SelectObject( pFont );//选用父窗体的字体
　dc.SetTextColor( m_TextColor );//设置文本颜色
　dc.DrawText( m_strCaption, &amp;rect, DT_CENTER );//文本在Static中央
　dc.SelectObject( pOldFont );
}</td>
</tr>
</table>
　　为了验证CMultiColorStatic类，我们制作一个基于对话框的应用程序，它包含一个如图17所示的对话框。该对话框上包括一个static控件和三个按钮，这三个按钮可分别把static控件设置为“红色”、“蓝色”和“绿色”。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="333" src="http://dev.yesky.com/imagelist/05/10/ui4t07vro853.jpg" height="166" /><img border="0" width="333" src="http://dev.yesky.com/imagelist/05/10/ui4t07vro853.jpg" height="166" />
图17 扩展的CStatic类调用演示</td>
</tr>
</table>
　　下面看看应如何编写与这个对话框对应的类。</p>

<p>　　包含这种Static的对话框类的声明如下：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &ldquo;..\MultiColorStatic.h&rdquo;</p>

<h1>pragma comment ( lib, &ldquo;ColorStatic.lib&rdquo; )// CCallDllDlg dialog</h1>

<p>class CCallDllDlg : public CDialog
{
　public:
　　CCallDllDlg(CWnd<em> pParent = NULL); // standard constructor
　　enum { IDD = IDD_CALLDLL_DIALOG };
　　CMultiColorStatic m_colorstatic; //包含一个CMultiColorStatic的实例
　protected:
　　virtual void DoDataExchange(CDataExchange</em> pDX);//DDX/DDV support
　　HICON m_hIcon;</p>

<p>　// Generated message map functions
　//{ {AFX_MSG(CCallDllDlg)</p>

<p>　virtual BOOL OnInitDialog();
　afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
　afx_msg void OnPaint();
　afx_msg HCURSOR OnQueryDragIcon();
　afx_msg void OnRedButton();
　afx_msg void OnBlueButton();
　afx_msg void OnGreenButton();
//}}AFX_MSG
DECLARE_MESSAGE_MAP()
};</td>
</tr>
</table>
　　下面是这个类中与使用CMultiColorStatic相关的主要成员函数：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CCallDllDlg::DoDataExchange(CDataExchange* pDX)
{
　CDialog::DoDataExchange(pDX);
　//{ {AFX_DATA_MAP(CCallDllDlg)
　　DDX_Control(pDX, IDC_COLOR_STATIC, m_colorstatic);
　//使m_colorstatic与IDC_COLOR_STATIC控件关联
　//}}AFX_DATA_MAP
}BOOL CCallDllDlg::OnInitDialog()
{
　…
　// TODO: Add extra initialization here</p>

<p>　// 初始static控件的显示</p>

<p>　m_colorstatic.SetCaption(&ldquo;最开始为黑色&rdquo;);
　m_colorstatic.SetTextColor(RGB(0,0,0));
　return TRUE; // return TRUE unless you set the focus to a control
}</p>

<p>//设置static控件文本颜色为红色</p>

<p>void CCallDllDlg::OnRedButton()
{
　m_colorstatic.SetCaption( &ldquo;改变为红色&rdquo; );
　m_colorstatic.SetTextColor( RGB( 255, 0, 0 ) );
　Invalidate( TRUE ); //导致发出WM_PAINT消息
}</p>

<p>//设置static控件文本颜色为蓝色</p>

<p>void CCallDllDlg::OnBlueButton()
{
　m_colorstatic.SetCaption( &ldquo;改变为蓝色&rdquo; );
　m_colorstatic.SetTextColor( RGB( 0, 0, 255 ) );
　Invalidate( TRUE ); //导致发出WM_PAINT消息
}</p>

<p>//设置static控件文本颜色为绿色</p>

<p>void CCallDllDlg::OnGreenButton()
{
　m_colorstatic.SetCaption( &ldquo;改变为绿色&rdquo; );
　m_colorstatic.SetTextColor( RGB(0,255,0) );
　Invalidate( TRUE ); //导致发出WM_PAINT消息
}</td>
</tr>
</table>
　　至此，我们已经讲解完成了所有类型的动态链接库，即非MFC DLL、MFC规则DLL和MFC扩展DLL。下一节将给出DLL的三个工程实例，与读者朋友们共同体会DLL的应用范围和使用方法。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:14:54+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-wu//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-si/">
		
			Visual C++动态链接库编程（四）</a>
	</h2>
	<div class="entry-content">
		<p>第4节我们对非MFC DLL进行了介绍，这一节将详细地讲述MFC规则DLL的创建与使用技巧。</p>

<p>　　另外，自从本文开始连载后，收到了一些读者的e-mail。有的读者提出了一些问题，笔者将在本文的最后一次连载中选取其中的典型问题进行解答。由于时间的关系，对于读者朋友的来信，笔者暂时不能一一回复，还望海涵！由于笔者的水平有限，文中难免有错误和纰漏，也热诚欢迎读者朋友不吝指正！</p>

<p>　　5. MFC规则DLL</p>

<p>　　5.1 概述</p>

<p>　　MFC规则DLL的概念体现在两方面：</p>

<p>　　（1） 它是MFC的
　　
　　“是MFC的”意味着可以在这种DLL的内部使用MFC；</p>

<p>　　（2） 它是规则的</p>

<p>　　“是规则的”意味着它不同于MFC扩展DLL，在MFC规则DLL的内部虽然可以使用MFC，但是其与应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的接口不能是MFC。而MFC扩展DLL与应用程序的接口可以是MFC，可以从MFC扩展DLL中导出一个MFC类的派生类。</p>

<p>　　Regular DLL能够被所有支持DLL技术的语言所编写的应用程序调用，当然也包括使用MFC的应用程序。在这种动态连接库中，包含一个从CWinApp继承下来的类，DllMain函数则由MFC自动提供。</p>

<p>　　Regular DLL分为两类：</p>

<p>　　（1）静态链接到MFC 的规则DLL</p>

<p>　　静态链接到MFC的规则DLL与MFC库（包括MFC扩展 DLL）静态链接，将MFC库的代码直接生成在.dll文件中。在调用这种DLL的接口时，MFC使用DLL的资源。因此，在静态链接到MFC 的规则DLL中不需要进行模块状态的切换。</p>

<p>　　使用这种方法生成的规则DLL其程序较大，也可能包含重复的代码。</p>

<p>　　（2）动态链接到MFC 的规则DLL</p>

<p>　　动态链接到MFC 的规则DLL 可以和使用它的可执行文件同时动态链接到 MFC DLL 和任何MFC扩展 DLL。在使用了MFC共享库的时候，默认情况下，MFC使用主应用程序的资源句柄来加载资源模板。这样，当DLL和应用程序中存在相同ID的资源时（即所谓的资源重复问题），系统可能不能获得正确的资源。因此，对于共享MFC DLL的规则DLL，我们必须进行模块切换以使得MFC能够找到正确的资源模板。</p>

<p>　　我们可以在Visual C++中设置MFC规则DLL是静态链接到MFC DLL还是动态链接到MFC DLL。如图8，依次选择Visual C++的project -&gt; Settings -&gt; General菜单或选项，在Microsoft Foundation Classes中进行设置。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="1" src="http://dev.yesky.com/imagelist/05/10/496tcjb95zkf.jpg" height="1" /><img border="0" width="1" src="http://dev.yesky.com/imagelist/05/10/496tcjb95zkf.jpg" height="1" />
图8 设置动态/静态链接MFC DLL</td>
</tr>
</table>


<p>　　5.2 MFC规则DLL的创建</p>

<p>　　我们来一步步讲述使用MFC向导创建MFC规则DLL的过程，首先新建一个project，如图9，选择project的类型为MFC AppWizard(dll)。点击OK进入如图10所示的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="438" src="http://dev.yesky.com/imagelist/05/10/181ysg7l3l3w.jpg" height="283" /><img border="0" width="438" src="http://dev.yesky.com/imagelist/05/10/181ysg7l3l3w.jpg" height="283" />
图9 MFC DLL工程的创建</td>
</tr>
</table>


<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" /><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" />
图10所示对话框中的1区选择MFC DLL的类别。</td>
</tr>
</table>


<p>　　2区选择是否支持automation（自动化）技术， automation 允许用户在一个应用程序中操纵另外一个应用程序或组件。例如，我们可以在应用程序中利用 Microsoft Word 或Microsoft Excel的工具，而这种使用对用户而言是透明的。自动化技术可以大大简化和加快应用程序的开发。</p>

<p>　　3区选择是否支持Windows Sockets，当选择此项目时，应用程序能在 TCP/IP <a target="_blank" href="http://product.yesky.com/net/" class="bluekey"><font color="#003399">网络</font></a>上进行通信。 CWinApp派生类的InitInstance成员函数会初始化通讯端的支持，同时工程中的StdAfx.h文件会自动include &lt;AfxSock.h&gt;头文件。</p>

<p>　　添加socket通讯支持后的InitInstance成员函数如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BOOL CRegularDllSocketApp::InitInstance()
{
　if (!AfxSocketInit())
　{
　　AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
　　return FALSE;
　}
　return TRUE;
}</td>
</tr>
</table>


<p>　　4区选择是否由MFC向导自动在源代码中添加注释，一般我们选择“Yes,please”。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" /><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" />
图10 MFC DLL的创建选项</td>
</tr>
</table>


<p>　　5.3 一个简单的MFC规则DLL</p>

<p>　　这个DLL的例子（属于静态链接到MFC 的规则DLL）中提供了一个如图11所示的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/6hb0hlv43ptr.jpg" />
图11 MFC规则DLL例子</td>
</tr>
</table>


<p>　　在DLL中添加对话框的方式与在MFC应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>中是一样的。 在图11所示DLL中的对话框的Hello按钮上点击时将MessageBox一个“Hello,pconline的网友”对话框，下面是相关的文件及源代码，其中删除了MFC向导自动生成的绝大多数注释（下载本工程）：</p>

<p>　　第一组文件：CWinApp继承类的声明与实现</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// RegularDll.h : main header file for the REGULARDLL DLL#if !defined(AFX_REGULARDLL_H__3E9CB22B_588B_4388_B778_B3416ADB79B3__INCLUDED_)
#define AFX_REGULARDLL_H__3E9CB22B_588B_4388_B778_B3416ADB79B3__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#ifndef __AFXWIN_H__
#error include ’stdafx.h’ before including this file for PCH
#endif
#include &#8220;resource.h&#8221; // main symbols

class CRegularDllApp : public CWinApp
{
　public:
　　CRegularDllApp();
　　DECLARE_MESSAGE_MAP()
};

#endif

// RegularDll.cpp : Defines the initialization routines for the DLL.

#include &#8220;stdafx.h&#8221;
#include &#8220;RegularDll.h&#8221;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CRegularDllApp, CWinApp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////

// CRegularDllApp construction

CRegularDllApp::CRegularDllApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRegularDllApp object

CRegularDllApp theApp;</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　在这一组文件中定义了一个继承自CWinApp的类CRegularDllApp，并同时定义了其的一个实例theApp。乍一看，您会以为它是一个MFC应用程序，因为MFC应用程序也包含这样的在工程名后添加“App”组成类名的类（并继承自CWinApp类），也定义了这个类的一个全局实例theApp。</p>

<p>　　我们知道，在MFC应用程序中CWinApp取代了SDK程序中WinMain的地位，SDK程序WinMain所完成的工作由CWinApp的三个函数完成：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>virtual BOOL InitApplication( );virtual BOOL InitInstance( );

virtual BOOL Run( ); //传说中MFC程序的“活水源头”</td>
</tr>
</table>


<p>　　但是MFC规则DLL并不是MFC应用程序，它所继承自CWinApp的类不包含消息循环。这是因为，MFC规则DLL不包含CWinApp::Run机制，主消息泵仍然由应用程序拥有。如果DLL 生成无模式对话框或有自己的主框架窗口，则应用程序的主消息泵必须调用从DLL 导出的函数来调用PreTranslateMessage成员函数。</p>

<p>　　另外，MFC规则DLL与MFC 应用程序中一样，需要将所有 DLL中元素的初始化放到InitInstance 成员函数中。</p>

<p>　　第二组文件 自定义对话框类声明及实现</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#if !defined(AFX_DLLDIALOG_H__CEA4C6AF_245D_48A6_B11A_A5521EAD7C4E__INCLUDED_)
#define AFX_DLLDIALOG_H__CEA4C6AF_245D_48A6_B11A_A5521EAD7C4E__INCLUDED_#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// DllDialog.h : header file
/////////////////////////////////////////////////////////////////////////////
// CDllDialog dialog

class CDllDialog : public CDialog
{
　// Construction
　public:
　　CDllDialog(CWnd* pParent = NULL); // standard constructor
　　enum { IDD = IDD_DLL_DIALOG };
　protected:
　　virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support
　　// Implementation
　protected:
　　afx_msg void OnHelloButton();
　　DECLARE_MESSAGE_MAP()
};
#endif

// DllDialog.cpp : implementation file

#include &#8220;stdafx.h&#8221;
#include &#8220;RegularDll.h&#8221;
#include &#8220;DllDialog.h&#8221;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDllDialog dialog

CDllDialog::CDllDialog(CWnd* pParent /*=NULL*/)
: CDialog(CDllDialog::IDD, pParent)
{}

void CDllDialog::DoDataExchange(CDataExchange* pDX)
{
　CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CDllDialog, CDialog)
　ON_BN_CLICKED(IDC_HELLO_BUTTON, OnHelloButton)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDllDialog message handlers

void CDllDialog::OnHelloButton()
{
　MessageBox(&#8220;Hello,pconline的网友&#8221;,&#8221;pconline&#8221;);
}</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　这一部分的编程与一般的应用程序根本没有什么不同，我们照样可以利用MFC类向导来自动为对话框上的控件添加事件。MFC类向导照样会生成类似ON_BN_CLICKED(IDC_HELLO_BUTTON, OnHelloButton)的消息映射宏。</p>

<p>　　第三组文件 DLL中的资源文件</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//// Microsoft Developer Studio generated include file.

// Used by RegularDll.rc

//

#define IDD_DLL_DIALOG 1000

#define IDC_HELLO_BUTTON 1000</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　在MFC规则DLL中使用资源也与在MFC应用程序中使用资源没有什么不同，我们照样可以用Visual C++的资源编辑工具进行资源的添加、删除和属性的更改。</p>

<p>　　第四组文件 MFC规则DLL接口函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &#8220;StdAfx.h&#8221;
#include &#8220;DllDialog.h&#8221;extern &#8220;C&#8221; __declspec(dllexport) void ShowDlg(void)
{
　CDllDialog dllDialog;
　dllDialog.DoModal();
}</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　这个接口并不使用MFC，但是在其中却可以调用MFC扩展类CdllDialog的函数，这体现了“规则”的概类。</p>

<p>　　与非MFC DLL完全相同，我们可以使用__declspec(dllexport)声明或在.def中引出的方式导出MFC规则DLL中的接口。
　　5.4 MFC规则DLL的调用</p>

<p>　　笔者编写了如图12的对话框MFC<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>（下载本工程）来调用5.3节的MFC规则DLL，在这个程序的对话框上点击“调用DLL”按钮时弹出5.3节MFC规则DLL中的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/y661eb38d8t2.jpg" />
图12 MFC规则DLL的调用例子</td>
</tr>
</table>


<p>　　下面是“调用DLL”按钮单击事件的消息处理函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CRegularDllCallDlg::OnCalldllButton()
{
　typedef void (*lpFun)(void);
　HINSTANCE hDll; //DLL句柄
　hDll = LoadLibrary(&#8220;RegularDll.dll&#8221;);
　if (NULL==hDll)
　{
　　MessageBox(&#8220;DLL加载失败&#8221;);
　}　lpFun addFun; //函数指针
　lpFun pShowDlg = (lpFun)GetProcAddress(hDll,&#8221;ShowDlg&#8221;);
　if (NULL==pShowDlg)
　{
　　MessageBox(&#8220;DLL中函数寻找失败&#8221;);
　}
　pShowDlg();
}</td>
</tr>
</table>


<p>　　上述例子中给出的是显示调用的方式，可以看出，其调用方式与第4节中非MFC DLL的调用方式没有什么不同。</p>

<p>　　我们照样可以在EXE程序中隐式调用MFC规则DLL，只需要将DLL工程生成的.lib文件和.dll文件拷入当前工程所在的目录，并在RegularDllCallDlg.cpp文件（图12所示对话框类的实现文件）的顶部添加：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#pragma comment(lib,&#8221;RegularDll.lib&#8221;)
void ShowDlg(void);</td>
</tr>
</table>


<p>　　并将void CRegularDllCallDlg::OnCalldllButton() 改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CRegularDllCallDlg::OnCalldllButton()
{
　ShowDlg();
}</td>
</tr>
</table>


<p>　　5.5 共享MFC DLL的规则DLL的模块切换</p>

<p>　　应用程序进程本身及其调用的每个DLL模块都具有一个全局唯一的HINSTANCE句柄，它们代表了DLL或EXE模块在进程虚拟空间中的起始地址。进程本身的模块句柄一般为0x400000，而DLL模块的缺省句柄为0x10000000。如果程序同时加载了多个DLL，则每个DLL模块都会有不同的HINSTANCE。应用程序在加载DLL时对其进行了重定位。</p>

<p>　　共享MFC DLL（或MFC扩展DLL）的规则DLL涉及到HINSTANCE句柄问题，HINSTANCE句柄对于加载资源特别重要。EXE和DLL都有其自己的资源，而且这些资源的ID可能重复，应用程序需要通过资源模块的切换来找到正确的资源。如果应用程序需要来自于DLL的资源，就应将资源模块句柄指定为DLL的模块句柄；如果需要EXE文件中包含的资源，就应将资源模块句柄指定为EXE的模块句柄。</p>

<p>　　这次我们创建一个动态链接到MFC DLL的规则DLL（下载本工程），在其中包含如图13的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/qy3n1xcn12i7.jpg" />
图13 DLL中的对话框</td>
</tr>
</table>


<p>　　另外，在与这个DLL相同的工作区中生成一个基于对话框的MFC程序，其对话框与图12完全一样。但是在此工程中我们另外添加了一个如图14的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/d5qj203lursc.jpg" />
图14 EXE中的对话框</td>
</tr>
</table>


<p>　　图13和图14中的对话框除了caption不同（以示区别）以外，其它的都相同。</p>

<p>　　尤其值得特别注意，在DLL和EXE中我们对图13和图14的对话框使用了相同的资源ID=2000，在DLL和EXE工程的resource.h中分别有如下的宏：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//DLL中对话框的ID#define IDD_DLL_DIALOG 2000

//EXE中对话框的ID

#define IDD_EXE_DIALOG 2000</td>
</tr>
</table>


<p>　　与5.3节静态链接MFC DLL的规则DLL相同，我们还是在规则DLL中定义接口函数ShowDlg，原型如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &#8220;StdAfx.h&#8221;
#include &#8220;SharedDll.h&#8221;void ShowDlg(void)
{
　CDialog dlg(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　而为应用工程主对话框的“调用DLL”的单击事件添加如下消息处理函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CSharedDllCallDlg::OnCalldllButton()
{
　ShowDlg();
}</td>
</tr>
</table>


<p>　　我们以为单击“调用DLL”会弹出如图13所示DLL中的对话框，可是可怕的事情发生了，我们看到是图14所示EXE中的对话框！
　　惊讶？</p>

<p>　　产生这个问题的根源在于应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>与MFC规则DLL共享MFC DLL（或MFC扩展DLL）的程序总是默认使用EXE的资源，我们必须进行资源模块句柄的切换，其实现方法有三：</p>

<p>　　方法一 在DLL接口函数中使用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AFX_MANAGE_STATE(AfxGetStaticModuleState());</td>
</tr>
</table>


<p>　　我们将DLL中的接口函数ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　//方法1:在函数开始处变更，在函数结束时恢复
　//将AFX_MANAGE_STATE(AfxGetStaticModuleState());作为接口函数的第一//条语句进行模块状态切换　AFX_MANAGE_STATE(AfxGetStaticModuleState());
　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　这次我们再点击EXE程序中的“调用DLL”按钮，弹出的是DLL中的如图13的对话框！嘿嘿，弹出了正确的对话框资源。</p>

<p>　　AfxGetStaticModuleState是一个函数，其原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td height="21">AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState( );</td>
</tr>
</table>


<p>　　该函数的功能是在栈上（这意味着其作用域是局部的）创建一个AFX_MODULE_STATE类（模块全局数据也就是模块状态）的实例，对其进行设置，并将其指针pModuleState返回。</p>

<p>　　AFX_MODULE_STATE类的原型如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// AFX_MODULE_STATE (global data for a module)class AFX_MODULE_STATE : public CNoTrackObject
{
　public:
　　#ifdef _AFXDLL
　　　AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion);
　　　AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion,BOOL bSystem);
　　#else
　　　AFX_MODULE_STATE(BOOL bDLL);
　　#endif
　　~AFX_MODULE_STATE();

　　CWinApp* m_pCurrentWinApp;
　　HINSTANCE m_hCurrentInstanceHandle;
　　HINSTANCE m_hCurrentResourceHandle;
　　LPCTSTR m_lpszCurrentAppName;

　　… //省略后面的部分
}</td>
</tr>
</table>


<p>　　AFX_MODULE_STATE类利用其构造函数和析构函数进行存储模块状态现场及恢复现场的工作，类似汇编中call指令对pc指针和sp寄存器的保存与恢复、中断服务程序的中断现场压栈与恢复以及<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>线程调度的任务控制块保存与恢复。</p>

<p>　　许多看似不着边际的知识点居然有惊人的相似！</p>

<p>　　AFX_MANAGE_STATE是一个宏，其原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AFX_MANAGE_STATE( AFX_MODULE_STATE* pModuleState )</td>
</tr>
</table>


<p>　　该宏用于将pModuleState设置为当前的有效模块状态。当离开该宏的作用域时（也就离开了pModuleState所指向栈上对象的作用域），先前的模块状态将由AFX_MODULE_STATE的析构函数恢复。</p>

<p>　　方法二 在DLL接口函数中使用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AfxGetResourceHandle();AfxSetResourceHandle(HINSTANCE xxx);</td>
</tr>
</table>


<p>　　AfxGetResourceHandle用于获取当前资源模块句柄，而AfxSetResourceHandle则用于设置程序目前要使用的资源模块句柄。</p>

<p>　　我们将DLL中的接口函数ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　//方法2的状态变更
　HINSTANCE save_hInstance = AfxGetResourceHandle();
　AfxSetResourceHandle(theApp.m_hInstance);
　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();　//方法2的状态还原
　AfxSetResourceHandle(save_hInstance);
}</td>
</tr>
</table>


<p>　　通过AfxGetResourceHandle和AfxSetResourceHandle的合理变更，我们能够灵活地设置程序的资源模块句柄，而方法一则只能在DLL接口函数退出的时候才会恢复模块句柄。方法二则不同，如果将ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>extern CSharedDllApp theApp; //需要声明theApp外部全局变量void ShowDlg(void)
{
　//方法2的状态变更
　HINSTANCE save_hInstance = AfxGetResourceHandle();
　AfxSetResourceHandle(theApp.m_hInstance);

　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();

　//方法2的状态还原

　AfxSetResourceHandle(save_hInstance);

　//使用方法2后在此处再进行操作针对的将是应用程序的资源

　CDialog dlg1(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg1.DoModal();
}</td>
</tr>
</table>


<p>　　在应用程序主对话框的“调用DLL”按钮上点击，将看到两个对话框，相继为DLL中的对话框（图13）和EXE中的对话框（图14）。</p>

<p>　　方法三 由应用程序自身切换</p>

<p>　　资源模块的切换除了可以由DLL接口函数完成以外，由应用程序自身也能完成（下载本工程）。</p>

<p>　　现在我们把DLL中的接口函数改为最简单的：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　CDialog dlg(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　而将应用程序的OnCalldllButton函数改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CSharedDllCallDlg::OnCalldllButton()
{
　//方法3：由应用程序本身进行状态切换
　//获取EXE模块句柄　HINSTANCE exe_hInstance = GetModuleHandle(NULL);

　//或者HINSTANCE exe_hInstance = AfxGetResourceHandle();
　//获取DLL模块句柄

　HINSTANCE dll_hInstance = GetModuleHandle(&#8220;SharedDll.dll&#8221;);
　AfxSetResourceHandle(dll_hInstance); //切换状态
　ShowDlg(); //此时显示的是DLL的对话框
　AfxSetResourceHandle(exe_hInstance); //恢复状态

　//资源模块恢复后再调用ShowDlg
　ShowDlg(); //此时显示的是EXE的对话框
}</td>
</tr>
</table>


<p>　　方法三中的Win32函数GetModuleHandle可以根据DLL的文件名获取DLL的模块句柄。如果需要得到EXE模块的句柄，则应调用带有Null参数的GetModuleHandle。</p>

<p>　　方法三与方法二的不同在于方法三是在应用程序中利用AfxGetResourceHandle和AfxSetResourceHandle进行资源模块句柄切换的。同样地，在应用程序主对话框的“调用DLL”按钮上点击，也将看到两个对话框，相继为DLL中的对话框（图13）和EXE中的对话框（图14）。</p>

<p>　　在下一节我们将对MFC扩展DLL进行详细分析和实例讲解，欢迎您继续关注本系列连载。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:10:42+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-si//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-san/">
		
			Visual C++动态链接库编程（三）</a>
	</h2>
	<div class="entry-content">
		<p>　　第4节我们对非MFC DLL进行了介绍，这一节将详细地讲述MFC规则DLL的创建与使用技巧。</p>

<p>　　另外，自从本文开始连载后，收到了一些读者的e-mail。有的读者提出了一些问题，笔者将在本文的最后一次连载中选取其中的典型问题进行解答。由于时间的关系，对于读者朋友的来信，笔者暂时不能一一回复，还望海涵！由于笔者的水平有限，文中难免有错误和纰漏，也热诚欢迎读者朋友不吝指正！</p>

<p>　　5. MFC规则DLL</p>

<p>　　5.1 概述</p>

<p>　　MFC规则DLL的概念体现在两方面：</p>

<p>　　（1） 它是MFC的
　　
　　“是MFC的”意味着可以在这种DLL的内部使用MFC；</p>

<p>　　（2） 它是规则的</p>

<p>　　“是规则的”意味着它不同于MFC扩展DLL，在MFC规则DLL的内部虽然可以使用MFC，但是其与应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的接口不能是MFC。而MFC扩展DLL与应用程序的接口可以是MFC，可以从MFC扩展DLL中导出一个MFC类的派生类。</p>

<p>　　Regular DLL能够被所有支持DLL技术的语言所编写的应用程序调用，当然也包括使用MFC的应用程序。在这种动态连接库中，包含一个从CWinApp继承下来的类，DllMain函数则由MFC自动提供。</p>

<p>　　Regular DLL分为两类：</p>

<p>　　（1）静态链接到MFC 的规则DLL</p>

<p>　　静态链接到MFC的规则DLL与MFC库（包括MFC扩展 DLL）静态链接，将MFC库的代码直接生成在.dll文件中。在调用这种DLL的接口时，MFC使用DLL的资源。因此，在静态链接到MFC 的规则DLL中不需要进行模块状态的切换。</p>

<p>　　使用这种方法生成的规则DLL其程序较大，也可能包含重复的代码。</p>

<p>　　（2）动态链接到MFC 的规则DLL</p>

<p>　　动态链接到MFC 的规则DLL 可以和使用它的可执行文件同时动态链接到 MFC DLL 和任何MFC扩展 DLL。在使用了MFC共享库的时候，默认情况下，MFC使用主应用程序的资源句柄来加载资源模板。这样，当DLL和应用程序中存在相同ID的资源时（即所谓的资源重复问题），系统可能不能获得正确的资源。因此，对于共享MFC DLL的规则DLL，我们必须进行模块切换以使得MFC能够找到正确的资源模板。</p>

<p>　　我们可以在Visual C++中设置MFC规则DLL是静态链接到MFC DLL还是动态链接到MFC DLL。如图8，依次选择Visual C++的project -&gt; Settings -&gt; General菜单或选项，在Microsoft Foundation Classes中进行设置。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="439" src="http://dev.yesky.com/imagelist/05/10/496tcjb95zkf.jpg" height="288" /><img border="0" width="439" src="http://dev.yesky.com/imagelist/05/10/496tcjb95zkf.jpg" height="288" />
图8 设置动态/静态链接MFC DLL</td>
</tr>
</table>


<p>　　5.2 MFC规则DLL的创建</p>

<p>　　我们来一步步讲述使用MFC向导创建MFC规则DLL的过程，首先新建一个project，如图9，选择project的类型为MFC AppWizard(dll)。点击OK进入如图10所示的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="438" src="http://dev.yesky.com/imagelist/05/10/181ysg7l3l3w.jpg" height="283" /><img border="0" width="438" src="http://dev.yesky.com/imagelist/05/10/181ysg7l3l3w.jpg" height="283" />
图9 MFC DLL工程的创建</td>
</tr>
</table>


<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" /><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" />
图10所示对话框中的1区选择MFC DLL的类别。</td>
</tr>
</table>


<p>　　2区选择是否支持automation（自动化）技术， automation 允许用户在一个应用程序中操纵另外一个应用程序或组件。例如，我们可以在应用程序中利用 Microsoft Word 或Microsoft Excel的工具，而这种使用对用户而言是透明的。自动化技术可以大大简化和加快应用程序的开发。</p>

<p>　　3区选择是否支持Windows Sockets，当选择此项目时，应用程序能在 TCP/IP <a target="_blank" href="http://product.yesky.com/net/" class="bluekey"><font color="#003399">网络</font></a>上进行通信。 CWinApp派生类的InitInstance成员函数会初始化通讯端的支持，同时工程中的StdAfx.h文件会自动include &lt;AfxSock.h&gt;头文件。</p>

<p>　　添加socket通讯支持后的InitInstance成员函数如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BOOL CRegularDllSocketApp::InitInstance()
{
　if (!AfxSocketInit())
　{
　　AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
　　return FALSE;
　}
　return TRUE;
}</td>
</tr>
</table>


<p>　　4区选择是否由MFC向导自动在源代码中添加注释，一般我们选择“Yes,please”。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" /><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" />
图10 MFC DLL的创建选项</td>
</tr>
</table>


<p>　　5.3 一个简单的MFC规则DLL</p>

<p>　　这个DLL的例子（属于静态链接到MFC 的规则DLL）中提供了一个如图11所示的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="331" src="http://dev.yesky.com/imagelist/05/10/6hb0hlv43ptr.jpg" height="193" /><img border="0" width="331" src="http://dev.yesky.com/imagelist/05/10/6hb0hlv43ptr.jpg" height="193" />
图11 MFC规则DLL例子</td>
</tr>
</table>


<p>　　在DLL中添加对话框的方式与在MFC应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>中是一样的。 在图11所示DLL中的对话框的Hello按钮上点击时将MessageBox一个“Hello,pconline的网友”对话框，下面是相关的文件及源代码，其中删除了MFC向导自动生成的绝大多数注释（下载本工程）：</p>

<p>　　第一组文件：CWinApp继承类的声明与实现</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// RegularDll.h : main header file for the REGULARDLL DLL#if !defined(AFX_REGULARDLL_H__3E9CB22B_588B_4388_B778_B3416ADB79B3__INCLUDED_)
#define AFX_REGULARDLL_H__3E9CB22B_588B_4388_B778_B3416ADB79B3__INCLUDED_#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#ifndef __AFXWIN_H__
#error include ’stdafx.h’ before including this file for PCH
#endif
#include &#8220;resource.h&#8221; // main symbols

class CRegularDllApp : public CWinApp
{
　public:
　　CRegularDllApp();
　　DECLARE_MESSAGE_MAP()
};

#endif

// RegularDll.cpp : Defines the initialization routines for the DLL.

#include &#8220;stdafx.h&#8221;
#include &#8220;RegularDll.h&#8221;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CRegularDllApp, CWinApp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////

// CRegularDllApp construction

CRegularDllApp::CRegularDllApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRegularDllApp object

CRegularDllApp theApp;</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　在这一组文件中定义了一个继承自CWinApp的类CRegularDllApp，并同时定义了其的一个实例theApp。乍一看，您会以为它是一个MFC应用程序，因为MFC应用程序也包含这样的在工程名后添加“App”组成类名的类（并继承自CWinApp类），也定义了这个类的一个全局实例theApp。</p>

<p>　　我们知道，在MFC应用程序中CWinApp取代了SDK程序中WinMain的地位，SDK程序WinMain所完成的工作由CWinApp的三个函数完成：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>virtual BOOL InitApplication( );virtual BOOL InitInstance( );virtual BOOL Run( ); //传说中MFC程序的“活水源头”</td>
</tr>
</table>


<p>　　但是MFC规则DLL并不是MFC应用程序，它所继承自CWinApp的类不包含消息循环。这是因为，MFC规则DLL不包含CWinApp::Run机制，主消息泵仍然由应用程序拥有。如果DLL 生成无模式对话框或有自己的主框架窗口，则应用程序的主消息泵必须调用从DLL 导出的函数来调用PreTranslateMessage成员函数。</p>

<p>　　另外，MFC规则DLL与MFC 应用程序中一样，需要将所有 DLL中元素的初始化放到InitInstance 成员函数中。</p>

<p>　　第二组文件 自定义对话框类声明及实现</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#if !defined(AFX_DLLDIALOG_H__CEA4C6AF_245D_48A6_B11A_A5521EAD7C4E__INCLUDED_)
#define AFX_DLLDIALOG_H__CEA4C6AF_245D_48A6_B11A_A5521EAD7C4E__INCLUDED_#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// DllDialog.h : header file
/////////////////////////////////////////////////////////////////////////////
// CDllDialog dialogclass CDllDialog : public CDialog
{
　// Construction
　public:
　　CDllDialog(CWnd* pParent = NULL); // standard constructor
　　enum { IDD = IDD_DLL_DIALOG };
　protected:
　　virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support
　　// Implementation
　protected:
　　afx_msg void OnHelloButton();
　　DECLARE_MESSAGE_MAP()
};
#endif

// DllDialog.cpp : implementation file

#include &#8220;stdafx.h&#8221;
#include &#8220;RegularDll.h&#8221;
#include &#8220;DllDialog.h&#8221;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDllDialog dialog

CDllDialog::CDllDialog(CWnd* pParent /*=NULL*/)
: CDialog(CDllDialog::IDD, pParent)
{}

void CDllDialog::DoDataExchange(CDataExchange* pDX)
{
　CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CDllDialog, CDialog)
　ON_BN_CLICKED(IDC_HELLO_BUTTON, OnHelloButton)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDllDialog message handlers

void CDllDialog::OnHelloButton()
{
　MessageBox(&#8220;Hello,pconline的网友&#8221;,&#8221;pconline&#8221;);
}</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　这一部分的编程与一般的应用程序根本没有什么不同，我们照样可以利用MFC类向导来自动为对话框上的控件添加事件。MFC类向导照样会生成类似ON_BN_CLICKED(IDC_HELLO_BUTTON, OnHelloButton)的消息映射宏。</p>

<p>　　第三组文件 DLL中的资源文件</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//// Microsoft Developer Studio generated include file.// Used by RegularDll.rc

//

#define IDD_DLL_DIALOG 1000

#define IDC_HELLO_BUTTON 1000</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　在MFC规则DLL中使用资源也与在MFC应用程序中使用资源没有什么不同，我们照样可以用Visual C++的资源编辑工具进行资源的添加、删除和属性的更改。</p>

<p>　　第四组文件 MFC规则DLL接口函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &#8220;StdAfx.h&#8221;
#include &#8220;DllDialog.h&#8221;extern &#8220;C&#8221; __declspec(dllexport) void ShowDlg(void)
{
　CDllDialog dllDialog;
　dllDialog.DoModal();
}</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　这个接口并不使用MFC，但是在其中却可以调用MFC扩展类CdllDialog的函数，这体现了“规则”的概类。</p>

<p>　　与非MFC DLL完全相同，我们可以使用__declspec(dllexport)声明或在.def中引出的方式导出MFC规则DLL中的接口。</p>

<p>　　5.4 MFC规则DLL的调用</p>

<p>　　笔者编写了如图12的对话框MFC<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>（下载本工程）来调用5.3节的MFC规则DLL，在这个程序的对话框上点击“调用DLL”按钮时弹出5.3节MFC规则DLL中的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="327" src="http://dev.yesky.com/imagelist/05/10/y661eb38d8t2.jpg" height="201" /><img border="0" width="327" src="http://dev.yesky.com/imagelist/05/10/y661eb38d8t2.jpg" height="201" />
图12 MFC规则DLL的调用例子</td>
</tr>
</table>


<p>　　下面是“调用DLL”按钮单击事件的消息处理函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CRegularDllCallDlg::OnCalldllButton()
{
　typedef void (*lpFun)(void);
　HINSTANCE hDll; //DLL句柄
　hDll = LoadLibrary(&#8220;RegularDll.dll&#8221;);
　if (NULL==hDll)
　{
　　MessageBox(&#8220;DLL加载失败&#8221;);
　}　lpFun addFun; //函数指针
　lpFun pShowDlg = (lpFun)GetProcAddress(hDll,&#8221;ShowDlg&#8221;);
　if (NULL==pShowDlg)
　{
　　MessageBox(&#8220;DLL中函数寻找失败&#8221;);
　}
　pShowDlg();
}</td>
</tr>
</table>


<p>　　上述例子中给出的是显示调用的方式，可以看出，其调用方式与第4节中非MFC DLL的调用方式没有什么不同。</p>

<p>　　我们照样可以在EXE程序中隐式调用MFC规则DLL，只需要将DLL工程生成的.lib文件和.dll文件拷入当前工程所在的目录，并在RegularDllCallDlg.cpp文件（图12所示对话框类的实现文件）的顶部添加：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#pragma comment(lib,&#8221;RegularDll.lib&#8221;)
void ShowDlg(void);</td>
</tr>
</table>


<p>　　并将void CRegularDllCallDlg::OnCalldllButton() 改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CRegularDllCallDlg::OnCalldllButton()
{
　ShowDlg();
}</td>
</tr>
</table>


<p>　　5.5 共享MFC DLL的规则DLL的模块切换</p>

<p>　　应用程序进程本身及其调用的每个DLL模块都具有一个全局唯一的HINSTANCE句柄，它们代表了DLL或EXE模块在进程虚拟空间中的起始地址。进程本身的模块句柄一般为0x400000，而DLL模块的缺省句柄为0x10000000。如果程序同时加载了多个DLL，则每个DLL模块都会有不同的HINSTANCE。应用程序在加载DLL时对其进行了重定位。</p>

<p>　　共享MFC DLL（或MFC扩展DLL）的规则DLL涉及到HINSTANCE句柄问题，HINSTANCE句柄对于加载资源特别重要。EXE和DLL都有其自己的资源，而且这些资源的ID可能重复，应用程序需要通过资源模块的切换来找到正确的资源。如果应用程序需要来自于DLL的资源，就应将资源模块句柄指定为DLL的模块句柄；如果需要EXE文件中包含的资源，就应将资源模块句柄指定为EXE的模块句柄。</p>

<p>　　这次我们创建一个动态链接到MFC DLL的规则DLL（下载本工程），在其中包含如图13的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/qy3n1xcn12i7.jpg" height="219" /><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/qy3n1xcn12i7.jpg" height="219" />
图13 DLL中的对话框</td>
</tr>
</table>


<p>　　另外，在与这个DLL相同的工作区中生成一个基于对话框的MFC程序，其对话框与图12完全一样。但是在此工程中我们另外添加了一个如图14的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="375" src="http://dev.yesky.com/imagelist/05/10/d5qj203lursc.jpg" height="219" /><img border="0" width="375" src="http://dev.yesky.com/imagelist/05/10/d5qj203lursc.jpg" height="219" />
图14 EXE中的对话框</td>
</tr>
</table>


<p>　　图13和图14中的对话框除了caption不同（以示区别）以外，其它的都相同。</p>

<p>　　尤其值得特别注意，在DLL和EXE中我们对图13和图14的对话框使用了相同的资源ID=2000，在DLL和EXE工程的resource.h中分别有如下的宏：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//DLL中对话框的ID#define IDD_DLL_DIALOG 2000//EXE中对话框的ID

#define IDD_EXE_DIALOG 2000</td>
</tr>
</table>


<p>　　与5.3节静态链接MFC DLL的规则DLL相同，我们还是在规则DLL中定义接口函数ShowDlg，原型如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &#8220;StdAfx.h&#8221;
#include &#8220;SharedDll.h&#8221;void ShowDlg(void)
{
　CDialog dlg(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　而为应用工程主对话框的“调用DLL”的单击事件添加如下消息处理函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CSharedDllCallDlg::OnCalldllButton()
{
　ShowDlg();
}</td>
</tr>
</table>


<p>　　我们以为单击“调用DLL”会弹出如图13所示DLL中的对话框，可是可怕的事情发生了，我们看到是图14所示EXE中的对话框！</p>

<p>　　惊讶？</p>

<p>　　产生这个问题的根源在于应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>与MFC规则DLL共享MFC DLL（或MFC扩展DLL）的程序总是默认使用EXE的资源，我们必须进行资源模块句柄的切换，其实现方法有三：</p>

<p>　　方法一 在DLL接口函数中使用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AFX_MANAGE_STATE(AfxGetStaticModuleState());</td>
</tr>
</table>


<p>　　我们将DLL中的接口函数ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　//方法1:在函数开始处变更，在函数结束时恢复
　//将AFX_MANAGE_STATE(AfxGetStaticModuleState());作为接口函数的第一//条语句进行模块状态切换　AFX_MANAGE_STATE(AfxGetStaticModuleState());
　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　这次我们再点击EXE程序中的“调用DLL”按钮，弹出的是DLL中的如图13的对话框！嘿嘿，弹出了正确的对话框资源。</p>

<p>　　AfxGetStaticModuleState是一个函数，其原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td height="21">AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState( );</td>
</tr>
</table>


<p>　　该函数的功能是在栈上（这意味着其作用域是局部的）创建一个AFX_MODULE_STATE类（模块全局数据也就是模块状态）的实例，对其进行设置，并将其指针pModuleState返回。</p>

<p>　　AFX_MODULE_STATE类的原型如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// AFX_MODULE_STATE (global data for a module)class AFX_MODULE_STATE : public CNoTrackObject
{
　public:
　　#ifdef _AFXDLL
　　　AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion);
　　　AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion,BOOL bSystem);
　　#else
　　　AFX_MODULE_STATE(BOOL bDLL);
　　#endif
　　~AFX_MODULE_STATE();　　CWinApp* m_pCurrentWinApp;
　　HINSTANCE m_hCurrentInstanceHandle;
　　HINSTANCE m_hCurrentResourceHandle;
　　LPCTSTR m_lpszCurrentAppName;

　　… //省略后面的部分
}</td>
</tr>
</table>


<p>　　AFX_MODULE_STATE类利用其构造函数和析构函数进行存储模块状态现场及恢复现场的工作，类似汇编中call指令对pc指针和sp寄存器的保存与恢复、中断服务程序的中断现场压栈与恢复以及<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>线程调度的任务控制块保存与恢复。</p>

<p>　　许多看似不着边际的知识点居然有惊人的相似！</p>

<p>　　AFX_MANAGE_STATE是一个宏，其原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AFX_MANAGE_STATE( AFX_MODULE_STATE* pModuleState )</td>
</tr>
</table>


<p>　　该宏用于将pModuleState设置为当前的有效模块状态。当离开该宏的作用域时（也就离开了pModuleState所指向栈上对象的作用域），先前的模块状态将由AFX_MODULE_STATE的析构函数恢复。</p>

<p>　　方法二 在DLL接口函数中使用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AfxGetResourceHandle();AfxSetResourceHandle(HINSTANCE xxx);</td>
</tr>
</table>


<p>　　AfxGetResourceHandle用于获取当前资源模块句柄，而AfxSetResourceHandle则用于设置程序目前要使用的资源模块句柄。</p>

<p>　　我们将DLL中的接口函数ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　//方法2的状态变更
　HINSTANCE save_hInstance = AfxGetResourceHandle();
　AfxSetResourceHandle(theApp.m_hInstance);
　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();　//方法2的状态还原
　AfxSetResourceHandle(save_hInstance);
}</td>
</tr>
</table>


<p>　　通过AfxGetResourceHandle和AfxSetResourceHandle的合理变更，我们能够灵活地设置程序的资源模块句柄，而方法一则只能在DLL接口函数退出的时候才会恢复模块句柄。方法二则不同，如果将ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>extern CSharedDllApp theApp; //需要声明theApp外部全局变量void ShowDlg(void)
{
　//方法2的状态变更
　HINSTANCE save_hInstance = AfxGetResourceHandle();
　AfxSetResourceHandle(theApp.m_hInstance);　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();

　//方法2的状态还原

　AfxSetResourceHandle(save_hInstance);

　//使用方法2后在此处再进行操作针对的将是应用程序的资源

　CDialog dlg1(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg1.DoModal();
}</td>
</tr>
</table>


<p>　　在应用程序主对话框的“调用DLL”按钮上点击，将看到两个对话框，相继为DLL中的对话框（图13）和EXE中的对话框（图14）。</p>

<p>　　方法三 由应用程序自身切换</p>

<p>　　资源模块的切换除了可以由DLL接口函数完成以外，由应用程序自身也能完成（下载本工程）。</p>

<p>　　现在我们把DLL中的接口函数改为最简单的：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　CDialog dlg(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　而将应用程序的OnCalldllButton函数改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CSharedDllCallDlg::OnCalldllButton()
{
　//方法3：由应用程序本身进行状态切换
　//获取EXE模块句柄　HINSTANCE exe_hInstance = GetModuleHandle(NULL);　//或者HINSTANCE exe_hInstance = AfxGetResourceHandle();
　//获取DLL模块句柄

　HINSTANCE dll_hInstance = GetModuleHandle(&#8220;SharedDll.dll&#8221;);
　AfxSetResourceHandle(dll_hInstance); //切换状态
　ShowDlg(); //此时显示的是DLL的对话框
　AfxSetResourceHandle(exe_hInstance); //恢复状态

　//资源模块恢复后再调用ShowDlg
　ShowDlg(); //此时显示的是EXE的对话框
}</td>
</tr>
</table>


<p>　　方法三中的Win32函数GetModuleHandle可以根据DLL的文件名获取DLL的模块句柄。如果需要得到EXE模块的句柄，则应调用带有Null参数的GetModuleHandle。</p>

<p>　　方法三与方法二的不同在于方法三是在应用程序中利用AfxGetResourceHandle和AfxSetResourceHandle进行资源模块句柄切换的。同样地，在应用程序主对话框的“调用DLL”按钮上点击，也将看到两个对话框，相继为DLL中的对话框（图13）和EXE中的对话框（图14）。</p>

<p>　　在下一节我们将对MFC扩展DLL进行详细分析和实例讲解，欢迎您继续关注本系列连载。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:01:46+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-san//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-er/">
		
			Visual C++动态链接库编程（二）</a>
	</h2>
	<div class="entry-content">
		<p>　　4.1一个简单的DLL</p>

<p>　　第2节给出了以静态链接库方式提供add函数接口的方法，接下来我们来看看怎样用动态链接库实现一个同样功能的add函数。</p>

<p class="guanggao">　　如图6，在VC++中new一个Win32 Dynamic-Link Library工程dllTest（<a target="_blank" href="http://www.mydown.com/code/244/244551.html"><font color="#000000">单击此处下载本工程</font></a>）。注意不要选择MFC AppWizard(dll)，因为用MFC AppWizard(dll)建立的将是第5、6节要讲述的MFC 动态链接库。</p>




<p><p class="guanggao">
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/z197lah23li0.jpg" />
图6 建立一个非MFC DLL</td>
</tr>
</table>
<p class="guanggao">
　　在建立的工程中添加lib.h及lib.cpp文件，源代码如下：
<p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/<em> 文件名：lib.h　</em>/</p>

<h1>ifndef LIB_H</h1>

<h1>define LIB_H</h1>

<p>extern &ldquo;C&rdquo; int __declspec(dllexport)add(int x, int y);</p>

<h1>endif</h1>

<p>/<em> 文件名：lib.cpp　</em>/</p>

<h1>include &ldquo;lib.h&rdquo;</h1>

<p>int add(int x, int y)
{
　return x + y;
}</td>
</tr>
</table>
<p class="guanggao">
　　与第2节对静态链接库的调用相似，我们也建立一个与DLL工程处于同一工作区的应用工程dllCall，它调用DLL中的函数add，其源代码如下：
<p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;</p>

<h1>include &lt;windows.h&gt;</h1>

<p>typedef int(<em>lpAddFun)(int, int); //宏定义函数指针类型
int main(int argc, char </em>argv[])
{
　HINSTANCE hDll; //DLL句柄
　lpAddFun addFun; //函数指针
　hDll = LoadLibrary(&ldquo;..\Debug\dllTest.dll&rdquo;);
　if (hDll != NULL)
　{
　　addFun = (lpAddFun)GetProcAddress(hDll, &ldquo;add&rdquo;);
　　if (addFun != NULL)
　　{
　　　int result = addFun(2, 3);
　　　printf(&ldquo;%d&rdquo;, result);
　　}
　　FreeLibrary(hDll);
　}
　return 0;
}</td>
</tr>
</table>
<p class="guanggao">
　　分析上述代码，dllTest工程中的lib.cpp文件与第2节静态链接库版本完全相同，不同在于lib.h对函数add的声明前面添加了__declspec(dllexport)语句。这个语句的含义是声明函数add为DLL的导出函数。DLL内的函数分为两种：</p>

<p>　　(1)DLL导出函数，可供应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>调用；</p>

<p>　　(2) DLL内部函数，只能在DLL程序使用，应用程序无法调用它们。</p>

<p>　　而应用程序对本DLL的调用和对第2节静态链接库的调用却有较大差异，下面我们来逐一分析。</p>

<p>　　首先，语句typedef int ( * lpAddFun)(int,int)定义了一个与add函数接受参数类型和返回值均相同的函数指针类型。随后，在main函数中定义了lpAddFun的实例addFun；</p>

<p>　　其次，在函数main中定义了一个DLL HINSTANCE句柄实例hDll，通过Win32 Api函数LoadLibrary动态加载了DLL模块并将DLL模块句柄赋给了hDll；</p>

<p>　　再次，在函数main中通过Win32 Api函数GetProcAddress得到了所加载DLL模块中函数add的地址并赋给了addFun。经由函数指针addFun进行了对DLL中add函数的调用；</p>

<p>　　最后，应用工程使用完DLL后，在函数main中通过Win32 Api函数FreeLibrary释放了已经加载的DLL模块。</p>

<p>　　通过这个简单的例子，我们获知DLL定义和调用的一般概念：</p>

<p>　　(1)DLL中需以某种特定的方式声明导出函数（或变量、类）；</p>

<p>　　(2)应用工程需以某种特定的方式调用DLL的导出函数（或变量、类）。</p>

<p>　　下面我们来对“特定的方式进行”阐述。</p>

<p>　　4.2 声明导出函数</p>

<p>　　DLL中导出函数的声明有两种方式：一种为4.1节例子中给出的在函数声明中加上__declspec(dllexport)，这里不再举例说明；另外一种方式是采用模块定义(.def) 文件声明，.def文件为链接器提供了有关被链接程序的导出、属性及其他方面的信息。</p>

<p>　　下面的代码演示了怎样同.def文件将函数add声明为DLL导出函数（需在dllTest工程中添加lib.def文件）：
<p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>; lib.def : 导出DLL函数</p>

<p>LIBRARY dllTest</p>

<p>EXPORTS</p>

<p>add @ 1</td>
</tr>
</table>
<p class="guanggao">
　　.def文件的规则为：</p>

<p>　　(1)LIBRARY语句说明.def文件相应的DLL；</p>

<p>　　(2)EXPORTS语句后列出要导出函数的名称。可以在.def文件中的导出函数名后加@n，表示要导出函数的序号为n（在进行函数调用时，这个序号将发挥其作用）；</p>

<p>　　(3).def 文件中的注释由每个注释行开始处的分号 (;) 指定，且注释不能与语句共享一行。</p>

<p>　　由此可以看出，例子中lib.def文件的含义为生成名为“dllTest”的动态链接库，导出其中的add函数，并指定add函数的序号为1。</p>

<p>　　4.3 DLL的调用方式</p>

<p>　　在4.1节的例子中我们看到了由“LoadLibrary-GetProcAddress-FreeLibrary”系统Api提供的三位一体“DLL加载-DLL函数地址获取-DLL释放”方式，这种调用方式称为DLL的动态调用。</p>

<p>　　动态调用方式的特点是完全由编程者用 API 函数加载和卸载 DLL，程序员可以决定 DLL 文件何时加载或不加载，显式链接在运行时决定加载哪个 DLL 文件。</p>

<p>　　与动态调用方式相对应的就是静态调用方式，“有动必有静”，这来源于物质世界的对立统一。“动与静”，其对立与统一竟无数次在技术领域里得到验证，譬如静态IP与DHCP、静态路由与动态路由等。从前文我们已经知道，库也分为静态库与动态库DLL，而想不到，深入到DLL内部，其调用方式也分为静态与动态。“动与静”，无处不在。《周易》已认识到有动必有静的动静平衡观，《易．系辞》曰：“动静有常，刚柔断矣”。哲学意味着一种普遍的真理，因此，我们经常可以在枯燥的技术领域看到哲学的影子。</p>

<p>　　静态调用方式的特点是由编译系统完成对DLL的加载和应用程序结束时 DLL 的卸载。当调用某DLL的应用程序结束时，若系统中还有其它程序使用该 DLL，则Windows对DLL的应用记录减1，直到所有使用该DLL的程序都结束时才释放它。静态调用方式简单实用，但不如动态调用方式灵活。</p>

<p>　　下面我们来看看静态调用的例子（<a target="_blank" href="http://www.mydown.com/code/244/244556.html"><font color="#0000ff">单击此处下载本工程</font></a>），将编译dllTest工程所生成的.lib和.dll文件拷入dllCall工程所在的路径，dllCall执行下列代码：
<p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#pragma comment(lib,&ldquo;dllTest.lib&rdquo;)</p>

<p>//.lib文件中仅仅是关于其对应DLL文件中函数的重定位信息</p>

<p>extern &ldquo;C&rdquo; __declspec(dllimport) add(int x,int y);</p>

<p>int main(int argc, char* argv[])
{
　int result = add(2,3);
　printf(&ldquo;%d&rdquo;,result);
　return 0;
}</td>
</tr>
</table>
<p class="guanggao">
　　由上述代码可以看出，静态调用方式的顺利进行需要完成两个动作：</p>

<p>　　(1)告诉编译器与DLL相对应的.lib文件所在的路径及文件名，#pragma comment(lib,&ldquo;dllTest.lib&rdquo;)就是起这个作用。</p>

<p>　　程序员在建立一个DLL文件时，连接器会自动为其生成一个对应的.lib文件，该文件包含了DLL 导出函数的符号名及序号（并不含有实际的代码）。在应用程序里，.lib文件将作为DLL的替代文件参与编译。</p>

<p>　　(2)声明导入函数，extern &ldquo;C&rdquo; <strong>declspec(dllimport) add(int x,int y)语句中的</strong>declspec(dllimport)发挥这个作用。</p>

<p>　　静态调用方式不再需要使用系统API来加载、卸载DLL以及获取DLL中导出函数的地址。这是因为，当程序员通过静态链接方式编译生成应用程序时，应用程序中调用的与.lib文件中导出符号相匹配的函数符号将进入到生成的EXE 文件中，.lib文件中所包含的与之对应的DLL文件的文件名也被编译器存储在 EXE文件内部。当应用程序运行过程中需要加载DLL文件时，Windows将根据这些信息发现并加载DLL，然后通过符号名实现对DLL 函数的动态链接。这样，EXE将能直接通过函数名调用DLL的输出函数，就象调用程序内部的其他函数一样。</p>

<p><p class="guanggao">　　4.4 DllMain函数</p>

<p>　　Windows在加载DLL的时候，需要一个入口函数，就如同控制台或DOS<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>需要main函数、WIN32程序需要WinMain函数一样。在前面的例子中，DLL并没有提供DllMain函数，应用工程也能成功引用DLL，这是因为Windows在找不到DllMain的时候，系统会从其它运行库中引入一个不做任何操作的缺省DllMain函数版本，并不意味着DLL可以放弃DllMain函数。</p>

<p>　　根据编写规范，Windows必须查找并执行DLL里的DllMain函数作为加载DLL的依据，它使得DLL得以保留在内存里。这个函数并不属于导出函数，而是DLL的内部函数。这意味着不能直接在应用工程中引用DllMain函数，DllMain是自动被调用的。</p>

<p>　　我们来看一个DllMain函数的例子（<a target="_blank" href="http://www.mydown.com/code/244/244555.html"><font color="#0000ff">单击此处下载本工程</font></a>）。
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
　switch (ul_reason_for_call)
　{
　　case DLL_PROCESS_ATTACH:
　　　printf(&ldquo;\nprocess attach of dll&rdquo;);
　　　break;
　　case DLL_THREAD_ATTACH:
　　　printf(&ldquo;\nthread attach of dll&rdquo;);
　　　break;
　　case DLL_THREAD_DETACH:
　　　printf(&ldquo;\nthread detach of dll&rdquo;);
　　　break;
　　case DLL_PROCESS_DETACH:
　　　printf(&ldquo;\nprocess detach of dll&rdquo;);
　　　break;
　}
　return TRUE;
}</td>
</tr>
</table>
　　DllMain函数在DLL被加载和卸载时被调用，在单个线程启动和终止时，DLLMain函数也被调用，ul_reason_for_call指明了被调用的原因。原因共有4种，即PROCESS_ATTACH、PROCESS_DETACH、THREAD_ATTACH和THREAD_DETACH，以switch语句列出。</p>

<p>　　来仔细解读一下DllMain的函数头BOOL APIENTRY DllMain( HANDLE hModule, WORD ul_reason_for_call, LPVOID lpReserved )。</p>

<p>　　APIENTRY被定义为__stdcall，它意味着这个函数以标准Pascal的方式进行调用，也就是WINAPI方式；</p>

<p>　　进程中的每个DLL模块被全局唯一的32字节的HINSTANCE句柄标识，只有在特定的进程内部有效，句柄代表了DLL模块在进程虚拟空间中的起始地址。在Win32中，HINSTANCE和HMODULE的值是相同的，这两种类型可以替换使用，这就是函数参数hModule的来历。</p>

<p>　　执行下列代码：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>hDll = LoadLibrary(&ldquo;..\Debug\dllTest.dll&rdquo;);
if (hDll != NULL)
{
　addFun = (lpAddFun)GetProcAddress(hDll, MAKEINTRESOURCE(1));
　//MAKEINTRESOURCE直接使用导出文件中的序号
　if (addFun != NULL)
　{
　　int result = addFun(2, 3);
　　printf(&ldquo;\ncall add in dll:%d&rdquo;, result);
　}
　FreeLibrary(hDll);
}</td>
</tr>
</table>
　　我们看到输出顺序为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>process attach of dll
call add in dll:5
process detach of dll</td>
</tr>
</table>
　　这一输出顺序验证了DllMain被调用的时机。</p>

<p>　　代码中的GetProcAddress ( hDll, MAKEINTRESOURCE ( 1 ) )值得留意，它直接通过.def文件中为add函数指定的顺序号访问add函数，具体体现在MAKEINTRESOURCE ( 1 )，MAKEINTRESOURCE是一个通过序号获取函数名的宏，定义为（节选自winuser.h）：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#define MAKEINTRESOURCEA(i) (LPSTR)((DWORD)((WORD)(i)))</p>

<h1>define MAKEINTRESOURCEW(i) (LPWSTR)((DWORD)((WORD)(i)))</h1>

<h1>ifdef UNICODE</h1>

<h1>define MAKEINTRESOURCE MAKEINTRESOURCEW</h1>

<h1>else</h1>

<h1>define MAKEINTRESOURCE MAKEINTRESOURCEA</td></h1>

<p></tr>
</table>
　　4.5 __stdcall约定</p>

<p>　　如果通过VC++编写的DLL欲被其他语言编写的程序调用，应将函数的调用方式声明为<strong>stdcall方式，WINAPI都采用这种方式，而C/C++缺省的调用方式却为</strong>cdecl。<strong>stdcall方式与</strong>cdecl对函数名最终生成符号的方式不同。若采用C编译方式(在C++中需将函数声明为extern &ldquo;C&rdquo;)，<strong>stdcall调用约定在输出函数名前面加下划线，后面加“@”符号和参数的字节数，形如_functionname@number；而</strong>cdecl调用约定仅在输出函数名前面加下划线，形如_functionname。</p>

<p>　　Windows编程中常见的几种函数类型声明宏都是与<strong>stdcall和</strong>cdecl有关的（节选自windef.h）：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#define CALLBACK __stdcall //这就是传说中的回调函数</p>

<h1>define WINAPI __stdcall //这就是传说中的WINAPI</h1>

<h1>define WINAPIV __cdecl</h1>

<h1>define APIENTRY WINAPI //DllMain的入口就在这里</h1>

<h1>define APIPRIVATE __stdcall</h1>

<h1>define PASCAL __stdcall</td></h1>

<p></tr>
</table>
　　在lib.h中，应这样声明add函数：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>int <strong>stdcall add(int x, int y);</td>
</tr>
</table>
　　在应用工程中函数指针类型应定义为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>typedef int(</strong>stdcall <em>lpAddFun)(int, int);</td>
</tr>
</table>
　　若在lib.h中将函数声明为__stdcall调用，而应用工程中仍使用typedef int (</em> lpAddFun)(int,int)，运行时将发生错误（因为类型不匹配，在应用工程中仍然是缺省的__cdecl调用），弹出如图7所示的对话框。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/vrn4lm2rlf11.jpg" />
图7 调用约定不匹配时的运行错误</td>
</tr>
</table>
　　图8中的那段话实际上已经给出了错误的原因，即“This is usually a result of　…”。</p>

<p>　　<a target="_blank" href="http://www.mydown.com/code/244/244554.html"><font color="#000000">单击此处下载__stdcall调用例子工程源代码</font></a>。</p>

<p><p class="guanggao">　　4.6 DLL导出变量</p>

<p>　　DLL定义的全局变量可以被调用进程访问；DLL也可以访问调用进程的全局数据，我们来看看在应用工程中引用DLL中变量的例子（<a target="_blank" href="http://www.mydown.com/code/244/244552.html"><font color="#000000">单击此处下载本工程</font></a>）。
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/<em> 文件名：lib.h　</em>/</p>

<h1>ifndef LIB_H</h1>

<h1>define LIB_H</h1>

<p>extern int dllGlobalVar;</p>

<h1>endif</h1>

<p>/<em> 文件名：lib.cpp </em>/</p>

<h1>include &ldquo;lib.h&rdquo;</h1>

<h1>include &lt;windows.h&gt;</h1>

<p>int dllGlobalVar;</p>

<p>BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
　switch (ul_reason_for_call)
　{
　　case DLL_PROCESS_ATTACH:
　　　dllGlobalVar = 100; //在dll被加载时，赋全局变量为100
　　　break;
　　case DLL_THREAD_ATTACH:
　　case DLL_THREAD_DETACH:
　　case DLL_PROCESS_DETACH:
　　　break;
　}
　return TRUE;
}</td>
</tr>
</table>
　　;文件名：lib.def</p>

<p>　　;在DLL中导出变量
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>LIBRARY &ldquo;dllTest&rdquo;</p>

<p>EXPORTS</p>

<p>dllGlobalVar CONSTANT</p>

<p>;或dllGlobalVar DATA</p>

<p>GetGlobalVar</td>
</tr>
</table>
　　从lib.h和lib.cpp中可以看出，全局变量在DLL中的定义和使用方法与一般的<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>设计是一样的。若要导出某全局变量，我们需要在.def文件的EXPORTS后添加：</p>

<p>　　变量名　CONSTANT　　　//过时的方法</p>

<p>　　或</p>

<p>　　变量名　DATA　　　 　//VC++提示的新方法</p>

<p>　　在主函数中引用DLL中定义的全局变量：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;</p>

<h1>pragma comment(lib,&ldquo;dllTest.lib&rdquo;)</h1>

<p>extern int dllGlobalVar;</p>

<p>int main(int argc, char <em>argv[])
{
　printf(&ldquo;%d &rdquo;, </em>(int<em>)dllGlobalVar);
　</em>(int<em>)dllGlobalVar = 1;
　printf(&ldquo;%d &rdquo;, </em>(int<em>)dllGlobalVar);
　return 0;
}</td>
</tr>
</table>
　　特别要注意的是用extern int dllGlobalVar声明所导入的并不是DLL中全局变量本身，而是其地址，应用程序必须通过强制指针转换来使用DLL中的全局变量。这一点，从</em>(int*)dllGlobalVar可以看出。因此在采用这种方式引用DLL全局变量时，千万不要进行这样的赋值操作：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>dllGlobalVar = 1;</td>
</tr>
</table>
　　其结果是dllGlobalVar指针的内容发生变化，程序中以后再也引用不到DLL中的全局变量了。</p>

<p>　　在应用工程中引用DLL中全局变量的一个更好方法是：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;</p>

<h1>pragma comment(lib,&ldquo;dllTest.lib&rdquo;)</h1>

<p>extern int <em>declspec(dllimport) dllGlobalVar; //用</em>declspec(dllimport)导入
int main(int argc, char *argv[])
{
　printf(&ldquo;%d &rdquo;, dllGlobalVar);
　dllGlobalVar = 1; //这里就可以直接使用, 无须进行强制指针转换
　printf(&ldquo;%d &rdquo;, dllGlobalVar);
　return 0;
}</td>
</tr>
</table>
　　通过_declspec(dllimport)方式导入的就是DLL中全局变量本身而不再是其地址了，笔者建议在一切可能的情况下都使用这种方式。</p>

<p>　　4.7 DLL导出类</p>

<p>　　DLL中定义的类可以在应用工程中使用。</p>

<p>　　下面的例子里，我们在DLL中定义了point和circle两个类，并在应用工程中引用了它们（<a target="_blank" href="http://www.mydown.com/code/244/244553.html"><font color="#0000ff">单击此处下载本工程</font></a>）。
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//文件名：point.h，point类的声明</p>

<h1>ifndef POINT_H</h1>

<h1>define POINT_H</h1>

<h1>ifdef DLL_FILE</h1>

<p>　class _declspec(dllexport) point //导出类point</p>

<h1>else</h1>

<p>　class _declspec(dllimport) point //导入类point</p>

<h1>endif</h1>

<p>{
　public:
　　float y;
　　float x;
　　point();
　　point(float x_coordinate, float y_coordinate);
};</p>

<h1>endif</h1>

<p>//文件名：point.cpp，point类的实现</p>

<h1>ifndef DLL_FILE</h1>

<p>　#define DLL_FILE</p>

<h1>endif</h1>

<h1>include &ldquo;point.h&rdquo;</h1>

<p>//类point的缺省构造函数</p>

<p>point::point()
{
　x = 0.0;
　y = 0.0;
}</p>

<p>//类point的构造函数</p>

<p>point::point(float x_coordinate, float y_coordinate)
{
　x = x_coordinate;
　y = y_coordinate;
}</p>

<p>//文件名：circle.h，circle类的声明</p>

<h1>ifndef CIRCLE_H</h1>

<h1>define CIRCLE_H</h1>

<h1>include &ldquo;point.h&rdquo;</h1>

<h1>ifdef DLL_FILE</h1>

<p>class _declspec(dllexport)circle //导出类circle</p>

<h1>else</h1>

<p>class _declspec(dllimport)circle //导入类circle</p>

<h1>endif</h1>

<p>{
　public:
　　void SetCentre(const point &amp;centrePoint);
　　void SetRadius(float r);
　　float GetGirth();
　　float GetArea();
　　circle();
　private:
　　float radius;
　　point centre;
};</p>

<h1>endif</h1>

<p>//文件名：circle.cpp，circle类的实现</p>

<h1>ifndef DLL_FILE</h1>

<h1>define DLL_FILE</h1>

<h1>endif</h1>

<h1>include &ldquo;circle.h&rdquo;</h1>

<h1>define PI 3.1415926</h1>

<p>//circle类的构造函数</p>

<p>circle::circle()
{
　centre = point(0, 0);
　radius = 0;
}</p>

<p>//得到圆的面积</p>

<p>float circle::GetArea()
{
　return PI *radius * radius;
}</p>

<p>//得到圆的周长</p>

<p>float circle::GetGirth()
{
　return 2 *PI * radius;
}</p>

<p>//设置圆心坐标</p>

<p>void circle::SetCentre(const point &amp;centrePoint)
{
　centre = centrePoint;
}</p>

<p>//设置圆的半径</p>

<p>void circle::SetRadius(float r)
{
　radius = r;
}</td>
</tr>
</table>
　　类的引用：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &ldquo;..\circle.h&#8221;　　//包含类声明头文件</p>

<h1>pragma comment(lib,&ldquo;dllTest.lib&rdquo;);</h1>

<p>int main(int argc, char *argv[])
{
　circle c;
　point p(2.0, 2.0);
　c.SetCentre(p);
　c.SetRadius(1.0);
　printf(&ldquo;area:%f girth:%f&rdquo;, c.GetArea(), c.GetGirth());
　return 0;
}</td>
</tr>
</table>
　　从上述源代码可以看出，由于在DLL的类实现代码中定义了宏DLL_FILE，故在DLL的实现中所包含的类声明实际上为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class <em>declspec(dllexport) point //导出类point
{
　…
}</td>
</tr>
</table>
　　和
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class </em>declspec(dllexport) circle //导出类circle
{
　…
}</td>
</tr>
</table>
　　而在应用工程中没有定义DLL_FILE，故其包含point.h和circle.h后引入的类声明为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class <em>declspec(dllimport) point //导入类point
{
　…
}</td>
</tr>
</table>
　　和
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class </em>declspec(dllimport) circle //导入类circle
{
　…
}</td>
</tr>
</table>
　　不错，正是通过DLL中的
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class <em>declspec(dllexport) class_name //导出类circle　
{
　…
}</td>
</tr>
</table>
　　与应用程序中的
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class </em>declspec(dllimport) class_name //导入类
{
　…
}</td>
</tr>
</table>
　　匹对来完成类的导出和导入的！</p>

<p>　　我们往往通过在类的声明头文件中用一个宏来决定使其编译为class <em>declspec(dllexport) class_name还是class </em>declspec(dllimport) class_name版本，这样就不再需要两个头文件。本程序中使用的是：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#ifdef DLL_FILE
　class _declspec(dllexport) class_name //导出类</p>

<h1>else</h1>

<p>　class _declspec(dllimport) class_name //导入类</p>

<h1>endif</td></h1>

<p></tr>
</table>
　　实际上，在MFC DLL的讲解中，您将看到比这更简便的方法，而此处仅仅是为了说明<em>declspec(dllexport)与</em>declspec(dllimport)匹对的问题。</p>

<p>　　由此可见，应用工程中几乎可以看到DLL中的一切，包括函数、变量以及类，这就是DLL所要提供的强大能力。只要DLL释放这些接口，应用程序使用它就将如同使用本工程中的程序一样！</p>

<p>　　本章虽以VC++为平台讲解非MFC DLL，但是这些普遍的概念在其它语言及开发环境中也是相同的，其思维方式可以直接过渡。 接下来，我们将要研究MFC规则DLL。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T14:49:07+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-er//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-yi/">
		
			Visual C++动态链接库编程（一）</a>
	</h2>
	<div class="entry-content">
		<p> 最近在网上闲逛，一是为了巩固和拓展一下对C/C++的研习，二是大致感受下windows编程原理。当然最近被汇编也搞的比较晕乎，找机会出来透点新鲜空气。</p>

<p> 要说我接触VC的时间很短，仅凭一两个工程实例和一本本科阶段教材恐怕也是微不足道。下面这篇文章就是对书本之外相当不错的补充，当然此类书籍绝不缺少字纸版本。只不过，文章作者宋宝华老师所展现给我们的，却不比任何动辄数百页的书商们逊色。</p>

<p> 　　<strong>1.概论</strong></p>

<p>　　先来阐述一下DLL(Dynamic Linkable Library)的概念，你可以简单的把DLL看成一种仓库，它提供给你一些可以直接拿来用的变量、函数或类。在仓库的发展史上经历了“无库－静态链接库－动态链接库”的时代。静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib中的指令都被直接包含在最终生成的EXE文件中了。但是若使用DLL，该DLL不必被包含在最终EXE文件中，EXE文件执行时可以“动态”地引用和卸载这个与EXE独立的DLL文件。静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</p>

<p>  对动态链接库，我们还需建立如下概念：</p>

<p>　　（1）DLL 的编制与具体的编程语言及编译器无关</p>

<p>　　只要遵循约定的DLL接口规范和调用方式，用各种语言编写的DLL都可以相互调用。譬如Windows提供的系统DLL（其中包括了Windows的API），在任何开发环境中都能被调用，不在乎其是Visual Basic、Visual C++还是Delphi。</p>

<p>　　（2）动态链接库随处可见</p>

<p>　　我们在Windows目录下的system32文件夹中会看到kernel32.dll、user32.dll和gdi32.dll，windows的大多数API都包含在这些DLL中。kernel32.dll中的函数主要处理内存管理和进程调度；user32.dll中的函数主要控制用户界面；gdi32.dll中的函数则负责图形方面的操作。</p>

<p>　　一般的<a target="_blank" href="http://dev.yesky.com/" class="bluekey">程序</a>员都用过类似MessageBox的函数，其实它就包含在user32.dll这个动态链接库中。由此可见DLL对我们来说其实并不陌生。</p>

<p>　　(3)VC动态链接库的分类</p>

<p>　　Visual C++支持三种DLL，它们分别是Non-MFC DLL（非MFC动态库）、MFC Regular DLL（MFC规则DLL）、MFC Extension DLL（MFC扩展DLL）。</p>

<p>　　非MFC动态库不采用MFC类库结构，其导出函数为标准的C接口，能被非MFC或MFC编写的应用程序所调用；MFC规则DLL 包含一个继承自CWinApp的类，但其无消息循环；MFC扩展DLL采用MFC的动态链接版本创建，它只能被用MFC类库所编写的应用程序所调用。</p>

<p>　　由于本文篇幅较长，内容较多，势必需要先对阅读本文的有关事项进行说明，下面以问答形式给出。</p>

<p>　　问：本文主要讲解什么内容？</p>

<p>　　答：本文详细介绍了DLL编程的方方面面，努力学完本文应可以对DLL有较全面的掌握，并能编写大多数DLL程序。</p>

<p>　　问：如何看本文？</p>

<p>　　答：本文每一个主题的讲解都附带了源代码例程，可以随文下载（每个工程都经WINRAR压缩）。所有这些例程都由笔者编写并在VC++6.0中调试通过。</p>

<p>　　当然看懂本文不是读者的最终目的，读者应亲自动手实践才能真正掌握DLL的奥妙。</p>

<p>　　问：学习本文需要什么样的基础知识？</p>

<p>　　答：如果你掌握了C，并大致掌握了C++，了解一点MFC的知识，就可以轻松地看懂本文。</p>

<p>　<strong>　2.静态链接库</strong></p>

<p>　　对静态链接库的讲解不是本文的重点，但是在具体讲解DLL之前，通过一个静态链接库的例子可以快速地帮助我们建立“库”的概念。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/6v58bw881n81.jpg" />
图1 建立一个静态链接库</td>
</tr>
</table>


<p>　　如图1，在VC++6.0中new一个名称为libTest的static library工程（单击此处下载本工程），并新建lib.h和lib.cpp两个文件，lib.h和lib.cpp的源代码如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//文件：lib.h

#ifndef LIB_H
#define LIB_H
extern &#8220;C&#8221; int add(int x,int y);　　　//声明为C编译、连接方式的外部函数
#endif

//文件：lib.cpp

#include &#8220;lib.h&#8221;
int add(int x,int y)
{
　return x + y;
}</td>
</tr>
</table>


<p>　　编译这个工程就得到了一个.lib文件，这个文件就是一个函数库，它提供了add的功能。将头文件和.lib文件提交给用户后，用户就可以直接使用其中的add函数了。</p>

<p>　　标准Turbo C2.0中的C库函数（我们用来的scanf、printf、memcpy、strcpy等）就来自这种静态库。</p>

<p>　　下面来看看怎么使用这个库，在libTest工程所在的工作区内new一个libCall工程。libCall工程仅包含一个main.cpp文件，它演示了静态链接库的调用方法，其源代码如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;
#include &#8220;..\lib.h&#8221;
#pragma comment( lib, &#8220;..&#92;debug&#92;libTest.lib&#8221; ) 　//指定与静态库一起连接

int main(int argc, char* argv[])
{
　printf( &#8220;2 + 3 = %d&#8221;, add( 2, 3 ) );
}</td>
</tr>
</table>


<p>　　静态链接库的调用就是这么简单，或许我们每天都在用，可是我们没有明白这个概念。代码中#pragma comment( lib , &ldquo;..\debug\libTest.lib&rdquo; )的意思是指本文件生成的.obj文件应与libTest.lib一起连接。如果不用#pragma comment指定，则可以直接在VC++中设置，如图2，依次选择tools、options、directories、library files菜单或选项，填入库文件路径。图2中加红圈的部分为我们添加的libTest.lib文件的路径。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/rcw6s5cz52wb.jpg" />
图2 在VC中设置库文件路径</td>
</tr>
</table>


<p>　　这个静态链接库的例子至少让我们明白了库函数是怎么回事，它们是哪来的。我们现在有下列模糊认识了：</p>

<p>　　（1）库不是个怪物，编写库的程序和编写一般的程序区别不大，只是库不能单独执行；</p>

<p>　　（2）库提供一些可以给别的程序调用的东东，别的程序要调用它必须以某种方式指明它要调用之。</p>

<p>　　以上从静态链接库分析而得到的对库的懵懂概念可以直接引申到动态链接库中，动态链接库与静态链接库在编写和调用上的不同体现在库的外部接口定义及调用方式略有差异。</p>

<p><strong>3.库的调试与查看</p>

<p></strong>　　在具体进入各类DLL的详细阐述之前，有必要对库文件的调试与查看方法进行一下介绍，因为从下一节开始我们将面对大量的例子工程。</p>

<p>　　由于库文件不能单独执行，因而在按下F5（开始debug模式执行）或CTRL+F5（运行）执行时，其弹出如图3所示的对话框，要求用户输入可执行文件的路径来启动库函数的执行。这个时候我们输入要调用该库的EXE文件的路径就可以对库进行调试了，其调试技巧与一般应用工程的调试一样。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/xupwa5a7t93h.jpg" />
图3 库的调试与“运行”</td>
</tr>
</table>


<p>　　通常有比上述做法更好的调试途径，那就是将库工程和应用工程（调用库的工程）放置在同一VC工作区，只对应用工程进行调试，在应用工程调用库中函数的语句处设置断点，执行后按下F11，这样就单步进入了库中的函数。第2节中的libTest和libCall工程就放在了同一工作区，其工程结构如图4所示。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/lv690b4m255y.jpg" />
图4　把库工程和调用库的工程放入同一工作区进行调试</td>
</tr>
</table>


<p>　　上述调试方法对静态链接库和动态链接库而言是一致的。所以本文提供下载的所有源代码中都包含了库工程和调用库的工程，这二者都被包含在一个工作区内，这是笔者提供这种打包下载的用意所在。</p>

<p>　　动态链接库中的导出接口可以使用Visual C++的Depends工具进行查看，让我们用Depends打开系统目录中的user32.dll，看到了吧？红圈内的就是几个版本的MessageBox了！原来它真的在这里啊，原来它就在这里啊！</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/4q1kv1nrlhov.jpg" />
图5　用Depends查看DLL</td>
</tr>
</table>


<p>　　当然Depends工具也可以显示DLL的层次结构，若用它打开一个可执行文件则可以看出这个可执行文件调用了哪些DLL。</p>

<p>　　好，让我们正式进入动态链接库的世界，先来看看最一般的DLL，即非MFC DLL。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T14:44:45+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-yi//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/03/31/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-san/">
		
			C++学习笔记(重温计划之三)</a>
	</h2>
	<div class="entry-content">
		<p>3、数据类型(上)</p>

<p> c++中的数据类型,主要分为内部数据类型和外部数据类型两大类。其中，内部数据类型主要有：</p>

<p>  1）整数类型int;</p>

<p>   计算机内部是以二进制补码的形式表示整数的。从十进制转换的具体方法为除二取余、高位补零、再取反。整形数的表示范围如下:</p>

<table align="center" style="border-collapse: collapse">
<tr>
<td rowSpan="2" width="122" vAlign="top" style="padding-right: 5.4pt; padding-left: 5.4pt; padding-bottom: 0pt; width: 91.6pt; padding-top: 0pt; border: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">类型</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td rowSpan="2" width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">字节数</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td rowSpan="2" width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">位数</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td colSpan="2" width="184" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 138.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">表示范围</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td rowSpan="2" width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">解释</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">下限</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">上限</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">char</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">8</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-128</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">128</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^7~(2^7-1)</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">signed char</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">8</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-128</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">128</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^7~(2^7-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">un</span><span style="font-size: 10.5pt; font-family: '宋体'">signed char</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">8</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">255</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0~(2^8-1)</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">short int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">16</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-32768</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32767</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^15~(2^15-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">signed short int</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">16</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-32768</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32767</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^15~(2^15-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">un</span><span style="font-size: 10.5pt; font-family: '宋体'">signed short int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">16</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">65535</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0~(2^16-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2147483648</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2147483647</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^31~(2^31-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">signed int</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2147483648</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2147483647</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^31~(2^31-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">un</span><span style="font-size: 10.5pt; font-family: '宋体'">signed int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4294967295</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0~(2^32-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">long int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2147483648</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2147483647</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^31~(2^31-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">signed long int</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2147483648</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2147483647</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^31~(2^31-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">unsigned long int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4294967295</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0~(2^32-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
</table>


<p> 不过，随着64位cpu的应用，上表内容将有进一步扩充。同时在进位计数制中，以0起始的数字表示八进制，以0x起始表示十六进制。在基本取余运算%中，余数的符号决定于被除数的符号。<!--EndFragment--></p>

<p>  2）字符类型char;</p>

<p>   ASCII码有128个字符，字符型需加&#8217; &lsquo;。例如ASCII码为65的字符&#8217;A&#8217;。下面是除此之外的转义字符。</p>

<table align="center" style="border-collapse: collapse">
<tr>
<td width="94" vAlign="top" style="padding-right: 5.4pt; padding-left: 5.4pt; padding-bottom: 0pt; width: 71pt; padding-top: 0pt; border: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">字符形式</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">整数值</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">代表符号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">字符形式</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">整数值</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">代表符号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\a</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x07</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">响铃bell</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">&#34;</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x22</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">双引号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\b</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x08</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">退格backspace</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">&#39;</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x27</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">单引号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\t</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x09</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">水平制表符HT</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\?</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x3F</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">问号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\n</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x0A</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">换行return</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">&#92;</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x5C</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">反斜杠字符</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\v</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x0B</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">垂直制表符VT</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\ddd</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0ddd</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1~3<font face="宋体">位八进制数</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\r</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x0C</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">回车</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\xhh</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0xhh</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1~2<font face="宋体">位十六进制数</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
</table>


<p><!--EndFragment--><!--EndFragment-->  3）枚举类型enum;</p>

<p>   枚举型是对整数区间的自定义类型，通常用于整数常量。例如：</p>

<p>   enum Week{mon,tue,wed,thu.fri,sat,sun};</p>

<p>   默认第一个枚举符mon=0,以此类推。或者：</p>

<p>   enum Color{Red=5,Green,Yellow,Blue=20,Orange};</p>

<p>   由上可知，Green=6&hellip;Orange=21;枚举的好处是，在代替整数常量的过程中，枚举不需要初始化常量而直接使用，提高编写效率。</p>

<p>  4）布尔类型bool;</p>

<p>   布尔类型实际的存在意义为:</p>

<p>   enum bool{false,true};</p>

<p>   因此可以进行0或1的逻辑运算。例如：</p>

<p>   bool a = 3;  //a为true;</p>

<p>   在i/o流中，cout&lt;&lt;boolalpha&lt;&lt;a&lt;&lt;endl;//输出结果为false，如果不做boolalpha设置则输出为0;</p>

<p>  5）浮点型;</p>

<p>   浮点型包含单精度浮点float、双精度浮点double以及长双精度浮点long double。其中float、double、long double的十进制有效位数分别为7位、15位和19位。</p>

<p>  外部数据类型等变异类型：</p>

<p>  1）整形数组int[];</p>

<p>  2）浮点应用double&amp;;</p>

<p>  3）字符指针char*;</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-03-31T11:05:59+08:00" pubdate data-updated="true">2008-03-31</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/03/31/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-san//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/03/30/jian-dan-de-winapi-shi-xian/">
		
			简单的winapi实现</a>
	</h2>
	<div class="entry-content">
		<p>　第一次接触windows编程，初步领略了下api的复杂程度。修改了一个基本的窗口显示程序，并加入了md5算法模块。较费时的地方在md5和win函数本身的结合部分，包括格式转换和部分函数的参数限制。现在的想法是先了解下mfc，以便进行下一步的设计实现。</p>

<p>　<a href="http://www.hanyi.name/blog/wp-content/uploads/2008/03/md5.jpg" title="md5.jpg"><img src="http://www.hanyi.name/blog/wp-content/uploads/2008/03/md5.thumbnail.jpg" alt="md5.jpg" /></a></p>

<p> scode download:<a href="http://www.hanyi.name/blog/wp-content/uploads/2008/03/md5.rar" title="md5">md5</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-03-30T13:13:16+08:00" pubdate data-updated="true">2008-03-30</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/xiang-mu/'>项目</a>

</div>


	
		<span class="comments"><a href="/blog/2008/03/30/jian-dan-de-winapi-shi-xian//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/03/30/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-er/">
		
			C++学习笔记(重温计划之二)</a>
	</h2>
	<div class="entry-content">
		<p>2、基本编程语句</p>

<p> 沿用c语言的方法,c++包含了说明语句、赋值语句、表达式语句、过程控制语句。其中，过程控制语句又分为条件语句、循环语句和转移语句。</p>

<p> 2.1 说明语句(略)</p>

<p> 2.2 条件语句</p>

<p>  1）if语句: if(条件) 语句 or if(条件) 语句1 else 语句2；</p>

<p>  2）条件表达式:（条件）?表达式1:表达式2</p>

<p>  3）switch语句:switch(表达式){</p>

<p>                                                          case 常量表达式1:语句1;break;</p>

<p>                                                          case 常量表达式1:语句2;break;</p>

<p>                                                          // &hellip;</p>

<p>                                                          case 常量表达式n:语句n;break;</p>

<p>                                                          default:                   语句n+1;break;</p>

<p>                                                       }</p>

<p> 2.3循环语句</p>

<p>  1)for循环结构:for(i=0;i&lt;n;i++){ 语句};</p>

<p>  2)while循环结构:while(条件){语句};</p>

<p>  3)do-while循环结构:do{语句}while(条件);</p>

<p> 2.4输入输出语句</p>

<p>  1)标准I\O流:cout&lt;&lt;类型&lt;&lt;内容&lt;&lt;格式&lt;&lt;(条件判断);</p>

<p>  2)设置参数 setw(int)宽度、setfill(char)填充字符、setprecision(int)设置精度和有效位数;</p>

<p>  3)文件流:ifstream fin(filename,openmode=ios::in);</p>

<p>                  ofstream fout(filename,openmode=ios::out);</p>

<p> 2.5转移语句</p>

<p>  1)break语句:跳出本级循环；</p>

<p>  2)continue语句:结束本次循环，直接进入下次循环。</p>

<p>  3)goto语句:略。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-03-30T12:53:46+08:00" pubdate data-updated="true">2008-03-30</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/03/30/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-er//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/03/29/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-yi/">
		
			C++学习笔记(重温计划之一)</a>
	</h2>
	<div class="entry-content">
		<p>1、C++新特点</p>

<p> 这里所说的新特点,是相较于C语言而言的.本笔记旨在加强记忆和理解,本身内容并未超出教材的范围.我们仍将沿用《面向对象程序设计c++版》（刘振安，机械工业出版）和《c++程序设计教程第二版》（钱能，清华大学出版社）的基本思路，开始都是最基本的东西。</p>

<p> C++与C语言的关系，向来是众说纷纭的。但在我结束首轮学习之后发现，C++与C的关系，仅表明C++包含了C，C++完全可以当作一门新语言来学习，有C基础的人也未必比没有基础而开始学习C++的占多大优势。以下是C++一则例示:</p>

<p>/<em>功能:将结构的两个域值相加，乘以2再减去50</em>/</p>

<h1>include&lt;iostream&gt;</h1>

<p>//&mdash;&mdash;&mdash;&mdash;hanyi.name 1.1&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>using namespace std;</p>

<p>int result(int,int);</p>

<p>const int k = 2;</p>

<p>struct Point{
 
 int x,y;</p>

<p>};</p>

<p>int main(){</p>

<p> int z(0),b(50);
 
 Point a;
 
 cout  &lt;&lt;&ldquo;输入两个整数（以空格区分）:&rdquo;;</p>

<p>    cin  &gt;&gt;a.x&gt;&gt;a.y;</p>

<p>    z = (a.x + a.y)*k;</p>

<p>    z = result(z,b);</p>

<p>    cout  &lt;&lt;&ldquo;计算结果如下:&rdquo;&lt;&lt;endl;</p>

<p>    cout  &lt;&lt;&ldquo;((&rdquo;&lt;&lt;a.x&lt;&lt;&ldquo;+&rdquo;&lt;&lt;a.y&lt;&lt;&ldquo;)*&rdquo;&lt;&lt;k&lt;&lt;&ldquo;)-&rdquo;&lt;&lt;b&lt;&lt;&ldquo;=&rdquo;&lt;&lt;z&lt;&lt;endl;</p>

<p>    return 0;</p>

<p>}</p>

<p>int result(int a,int b){</p>

<p> a = a - b;
 
 return a;</p>

<p>}</p>

<p> 下面对以上内容作一说明:</p>

<p> 1、c++源程序以.cpp作为文件扩展名，其中main()主函数只能有一个。由于main()是过程化语言的标志，c++也被称为混合型语言。</p>

<p> 2、注释符号基本以/<em> </em>/和左起开头//为主。</p>

<p> 3、引入“流”的概念，例如cin和cout分别是c++标准输入输出库iostream的一员，这类库总称为STL(standard library标准函数库)。endl类似于转义字符\n，功能均为换行。</p>

<p> 4、头文件中iostream.h的.h可以省略，但必须新标准类库的使用头文件载入的方法:using namespace std;</p>

<p> 5、对象定义和初始化，新引入了int z(0);定义的方法，此方法功能与int z = 0相同。</p>

<p> 6、函数必须有类型声明，例如int main()，且必须有返回值return。当然void类型也是被允许的，但不和return同时使用。</p>

<p> 7、const修饰符。</p>

<p>       在c语言中，我们使用宏定义#define定义常量，这里推荐使用const。以下文章摘自csdn: </p>

<p>====================================================================================     </p>

<h3 style="margin: 13pt 0cm"><span style="font-family: 宋体"><font size="3">对于基本声明</font></span></h3>


<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">1.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">const int r=100; //</font></span></font><font size="3"><span style="font-family: 宋体">标准</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">变量声明加初始化，因为默认内部连接所以必须被初始化，其作用域为此文件，编译器经过类型检查后直接用</span><span lang="EN-US"><font face="Times New Roman">100</font></span><span style="font-family: 宋体">在编译时替换</span></font></p>


<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">2.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">extend const int r=100; //</font></span></font><font size="3"><span style="font-family: 宋体">将</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">改为外部连接，作用于扩大至全局，编译时会分配内存，并且可以不进行初始化，仅仅作为声明，编译器认为在程序其他地方进行了定义</span></font></p>


<p><span lang="EN-US"><font face="Times New Roman"><font size="3">3.</font><span style="font: 7pt 'Times New Roman'">       </span></font></span><font size="3"><span lang="EN-US"><font face="Times New Roman">const int r[ ]={1,2,3,4};</font></span></font><font size="3"><span lang="EN-US"><font face="Times New Roman">struct S {int a,b;};
const S s[ ]={(1,2),(3.4)}; //<span style="font-family: 宋体">以上两种都是常量集合，编译器会为其分配内存，所以不能在编译期间使用其中的值，例如：</span><span lang="EN-US"><font face="Times New Roman">int temp[r[2]];</font></span><span style="font-family: 宋体">这样的编译器会报告不能找到常量表达式</span></font></span></font></p>

<h3 style="margin: 13pt 0cm"><span style="font-family: 宋体"><font size="3">对于指针</font></span></h3>


<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">1.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">const int *r=&amp;x; //</font></span></font><font size="3"><span style="font-family: 宋体">声明</span><span lang="EN-US"><font face="Times New Roman">r</font></span><span style="font-family: 宋体">为一个指向常量的</span><span lang="EN-US"><font face="Times New Roman">x</font></span><span style="font-family: 宋体">的指针，</span><span lang="EN-US"><font face="Times New Roman">r</font></span><span style="font-family: 宋体">指向的对象不能被修改，但他可以指向任何地址的常量</span></font></p>


<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">2.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">int const *r=&amp;x; //</font></span></font><font size="3"><span style="font-family: 宋体">与用法</span><span lang="EN-US"><font face="Times New Roman">1</font></span><span style="font-family: 宋体">完全等价，没有任何区别</span></font></p>


<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">3.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">int * const r=&amp;x; //</font></span></font><font size="3"><span style="font-family: 宋体">声明</span><span lang="EN-US"><font face="Times New Roman">r</font></span><span style="font-family: 宋体">为一个常量指针，他指向</span><span lang="EN-US"><font face="Times New Roman">x</font></span><span style="font-family: 宋体">，</span><span lang="EN-US"><font face="Times New Roman">r</font></span><span style="font-family: 宋体">这个指针的指向不能被修改，但他指向的地址的内容可以修改</span></font></p>


<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">4.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">const int * const r=&amp;x; //</font></span></font><font size="3"><span style="font-family: 宋体">综合</span><span lang="EN-US"><font face="Times New Roman">1</font></span><span style="font-family: 宋体">、</span><span lang="EN-US"><font face="Times New Roman">3</font></span><span style="font-family: 宋体">用法，</span><span lang="EN-US"><font face="Times New Roman">r</font></span><span style="font-family: 宋体">是一个指向常量的常量型指针</span></font></p>




<h3 style="margin: 13pt 0cm"><span style="font-family: 宋体"><font size="3">对于类型检查</font></span></h3>


<p><p style="margin: 0cm 0cm 0pt" class="MsoNormal"><font size="3"><span style="font-family: 宋体">可以把一个非</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象赋给一个指向</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">的指针，因为有时候我们不想从这个指针来修改其对象的值；但是不可以把一个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象赋值给一个非</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">指针，因为这样可能会通过这个指针改变指向对象的值，但也存在使这种操作通过的合法化写法，使用类型强制转换可以通过指针改变</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象：</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">const int r=100;
int * ptr = const_cast&lt;int<em>&gt;(&amp;r);<span>  </span>//C++</font></span><font size="3"><span style="font-family: 宋体">标准，</span><span lang="EN-US"><font face="Times New Roman">C</font></span><span style="font-family: 宋体">语言使用：</span><span lang="EN-US"><font face="Times New Roman">int * ptr =(int</em>)&amp;r;</font></span></font>
<h3 style="margin: 13pt 0cm"><span style="font-family: 宋体"><font size="3">对于字符数组</font></span></h3>
<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><font size="3"><span style="font-family: 宋体">如</span><span lang="EN-US"><font face="Times New Roman">char * name = “china”; </font></span><span style="font-family: 宋体">这样的语句，在编译时是能够通过的，但是</span><span lang="EN-US"><font face="Times New Roman">”china”</font></span><span style="font-family: 宋体">是常量字符数组，任何想修改他的操作也能通过编译但会引起运行时错误，如果我们想修改字符数组的话就要使用</span><span lang="EN-US"><font face="Times New Roman">char name[ ] = “china”; </font></span><span style="font-family: 宋体">这种形式。</span></font></p></p>

<p><h3 style="margin: 13pt 0cm"><span style="font-family: 宋体"><font size="3">对于函数</font></span></h3>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">1.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">void Fuction1 ( const int r ); //</font></span></font><font size="3"><span style="font-family: 宋体">此处为参数传递</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">值，意义是变量初值不能被函数改变</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">2.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">const int Fuction1 (int); //</font></span></font><font size="3"><span style="font-family: 宋体">此处返回</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">值，意思指返回的原函数里的变量的初值不能被修改，但是函数按值返回的这个变量被制成副本，能不能被修改就没有了意义，它可以被赋给任何的</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">或非</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">类型变量，完全不需要加上这个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">关键字。但这只对于内部类型而言（因为内部类型返回的肯定是一个值，而不会返回一个变量，不会作为左值使用），对于用户自定义类型，返回值是常量是非常重要的，见下面条款</span><span lang="EN-US"><font face="Times New Roman">3</font></span><span style="font-family: 宋体">。</span></font></p></p>

<p><p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">3.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">Class CX; //</font></span></font><span style="font-family: 宋体"><font size="3">内部有构造函数，声明如</font></span><font size="3"><span lang="EN-US"><font face="Times New Roman">CX(int r =0)
CX<span>  </span>Fuction1 () { return CX(); }
const CX Fuction2 () { return CX(); }
</font></span><span style="font-family: 宋体">如有上面的自定义类</span><span lang="EN-US"><font face="Times New Roman">CX</font></span><span style="font-family: 宋体">，和函数</span><span lang="EN-US"><font face="Times New Roman">Fuction1()</font></span><span style="font-family: 宋体">和</span><span lang="EN-US"><font face="Times New Roman">Fuction2(),</font></span><span style="font-family: 宋体">我们进行如下操作时：</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">Fuction1() = CX(1); //</font></span><span style="font-family: 宋体"><font size="3">没有问题，可以作为左值调用</font></span><span lang="EN-US">
<font size="3" face="Times New Roman">Fuction2() = CX(1); //</font></span><font size="3"><span style="font-family: 宋体">编译错误，</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">返回值禁止作为左值调用。因为左值把返回值作为变量会修改其返回值，</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">声明禁止这种修改。</span></font></p>

<p><p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><span lang="EN-US"><font face="Times New Roman"><font size="3">4.</font><span style="font: 7pt 'Times New Roman'">       </span></font></span><font size="3"><span style="font-family: 宋体">函数中指针的</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">传递和返回：</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">int F1 (const char * pstr); //</font></span><font size="3"><span style="font-family: 宋体">作为传递的时候使用</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">修饰可以保证不会通过这个指针来修改传递参数的初值，这里在函数内部任何修改</span><span lang="EN-US"><font face="Times New Roman">*pstr</font></span><span style="font-family: 宋体">的企图都会引起编译错误。</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">const char * F2 (); //</font></span><font size="3"><span style="font-family: 宋体">意义是函数返回的指针指向的对象是一个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象，它必须赋给一个同样是指向</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象的指针。</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">const char * const F3(); //</font></span><font size="3"><span style="font-family: 宋体">比上面多了一个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">，这个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">的意义只是在他被用作左值时有效，它表明了这个指针除了指向</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象外，它本身也不能被修改，所以就不能当作左值来处理。</span></font></p>

<p><p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><span lang="EN-US"><font face="Times New Roman"><font size="3">5.</font><span style="font: 7pt 'Times New Roman'">       </span></font></span><font size="3"><span style="font-family: 宋体">函数中引用的</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">传递：</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">void F1 ( const X&amp; px); //</font></span><font size="3"><span style="font-family: 宋体">这样的一个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">引用传递和最普通的函数按值传递的效果是一模一样的，他禁止对引用的对象的一切修改，唯一不同的是按值传递会先建立一个类对象的副本，然后传递过去，而它直接传递地址，所以这种传递比按值传递更有效。</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">**</font></span><font size="3"><span style="font-family: 宋体">另外只有引用的</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">传递可以传递一个<strong>临时对象</strong>，因为临时对象都是</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">属性，且是不可见的，他短时间存在一个局部域中，所以不能使用指针，只有引用的</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">传递能够捕捉到这个家伙。</span></font>
<h3 style="margin: 13pt 0cm"><span style="font-family: 宋体"><font size="3">对于类</font></span></h3>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><span lang="EN-US"><font face="Times New Roman"><font size="3">1.</font><span style="font: 7pt 'Times New Roman'">       </span></font></span><font size="3"><span style="font-family: 宋体">首先，对于</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">的成员变量，只能在构造函数里使用初始化成员列表来初始化，试图在构造函数体内进行初始化</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">成员变量会引起编译错误。初始化成员列表形如：</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">X:: X ( int ir ): r(ir) {} //</font></span><font size="3"><span style="font-family: 宋体">假设</span><span lang="EN-US"><font face="Times New Roman">r</font></span><span style="font-family: 宋体">是类</span><span lang="EN-US"><font face="Times New Roman">X</font></span><span style="font-family: 宋体">的</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">成员变量</span></font></p>

<p><p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font face="Times New Roman"><span lang="EN-US"><font size="3">2.</font><span style="font: 7pt 'Times New Roman'">       </span></span><span lang="EN-US"><font size="3">const</font></span></font><font size="3"><span style="font-family: 宋体">成员函数。提到这个概念首先要谈到</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象，正象内置类型能够定义</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象一样（</span><span lang="EN-US"><font face="Times New Roman">const int r=10;</font></span><span style="font-family: 宋体">），用户自定义类型也可以定义</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象</span><span lang="EN-US"><font face="Times New Roman">(const X px(10);)</font></span><span style="font-family: 宋体">，编译器要保证这个对象在其生命周期内不能够被改变。如果你定义了这样的一个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象，那么对于这个对象的一切非</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">成员函数的调用，编译器为了保证对象的</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">特性，都会禁止并在编译期间报错。所以如果你想让你的成员函数能够在</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">对象上进行操作的话，就要把这个函数声明为</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">成员函数。假如</span><span lang="EN-US"><font face="Times New Roman">f( )</font></span><span style="font-family: 宋体">是类中的成员函数的话，它的声明形如：</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">int f( ) const; //const</font></span><font size="3"><span style="font-family: 宋体">放在函数的最后，编译器会对这个函数进行检查，在这个函数中的任何试图改变成员变量和调用非</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">成员函数的操作都被视为非法</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">**</font></span><font size="3"><span style="font-family: 宋体">类的构造和析构函数都不能是</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">函数。</span></font></p>

<p><span lang="EN-US"><font face="Times New Roman"><font size="3">3.</font><span style="font: 7pt 'Times New Roman'">       </span></font></span><font size="3"><span style="font-family: 宋体">建立了一个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">成员函数，但仍然想用这个函数改变对象内部的数据。这样的一个要求也会经常遇到，尤其是在一个苛刻的面试考官那里。首先我们要弄清楚考官的要求，因为有两种方法可以实现，如果这位考官要求不改变原来类的任何东西，只让你从当前这个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">成员函数入手，那么你只有使用前面提到的类型强制转换方法。实例如下：</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">//</font></span><font size="3"><span style="font-family: 宋体">假如有一个叫做</span><span lang="EN-US"><font face="Times New Roman">X</font></span><span style="font-family: 宋体">的类，它有一个</span><span lang="EN-US"><font face="Times New Roman">int</font></span><span style="font-family: 宋体">成员变量</span><span lang="EN-US"><font face="Times New Roman">r</font></span><span style="font-family: 宋体">，我们需要通过一个</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">成员函数</span><span lang="EN-US"><font face="Times New Roman">f( )</font></span><span style="font-family: 宋体">来对这个</span><span lang="EN-US"><font face="Times New Roman">r</font></span><span style="font-family: 宋体">进行</span><span lang="EN-US"><font face="Times New Roman">++r</font></span><span style="font-family: 宋体">操作，代码如下</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">void X::f( ) const
{<span>  </span>(const_cast&lt;X*&gt;(this)) -&gt; ++r; <span> </span>} //</font></span><font size="3"><span style="font-family: 宋体">通过</span><span lang="EN-US"><font face="Times New Roman">this</font></span><span style="font-family: 宋体">指针进行类型强制转换实现</span></font><span lang="EN-US"></span><span lang="EN-US"><font size="3"><span style="font-family: 宋体">另外一种方法就是使用关键字：</span><strong><span lang="EN-US"><font face="Times New Roman">mutable</font></span></strong><strong><span style="font-family: 宋体">。</span></strong><span style="font-family: 宋体">如果你的成员变量在定义时是这个样子的：</span></font><span lang="EN-US">
<font size="3" face="Times New Roman">mutable int r ;
</font></span><font size="3"><span style="font-family: 宋体">那么它就告诉编译器这个成员变量可以通过</span><span lang="EN-US"><font face="Times New Roman">const</font></span><span style="font-family: 宋体">成员函数改变。编译器就不会再理会对他的检查了。</span></font></span><span lang="EN-US"><font size="3"><span style="font-family: 宋体">===========================================================================================================</span></font><font size="3" face="Georgia"><span style="font-family: 宋体"> </span></font></p>

<p></span>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体"></span></font><font size="3" face="Georgia"><span style="font-family: 宋体">8、变量对象命名以及初始化</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体"></span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体"></span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体"> c++本身区别字母的大小写语言，以<em>开头的标识符一般为系统使用，应当尽量避免。同时宏定义标识符需用大写字母标</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体"></span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">识。另外，名字的第1个字母不能是数字或运算符，也不能包含运算符。为标识符命名时可遵循如下规律:</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体"></span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   1）使用能代表数据类型的前缀；</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   2）名称与变量的作用尽量接近；</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   3）如果名称由多个英文单词组成，每个英文单词首字母大写；</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   4）在库函数中尽量不要使用以</em>开头的名字，以免与系统命名冲突；</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   5）局部变量名称较短，尤其是循环控制变量；</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   6）外部变量应使用较长的名字，并能与其代表的变量含义接近；</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体"></span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体"> 9、程序的书写格式:</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   </span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   1)括号需紧跟在函数名的后面，但在for和while后面，应用一个空格和左括号隔开以增加可读性；</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   2)数学运算符的左右两边各留一个空格，与表达式区别；</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   3)在表示参数时括号后面留一个空格；</span></font></p>
<p style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt" class="MsoNormal"><font size="3" face="Georgia"><span style="font-family: 宋体">   4)在for、do&hellip;while、while中，应合理使用缩进、一对话括号和空行；</span></font></p></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-03-29T20:11:06+08:00" pubdate data-updated="true">2008-03-29</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/03/29/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-yi//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/03/29/C-chong-wen-ji-hua/">
		
			C++重温计划</a>
	</h2>
	<div class="entry-content">
		<p>Dear Mr.Bjarne Stroustrup,</p>

<p> 如果让您看到我至今对令嫒仍一知半解的状况，恐怕接下来的生产工作就很难继续进行下去了。因此，我也愿意拿出部分时间来弥补这一缺憾。相信这次我们能真正相互了解，提高今后衍生产品基因的质量。</p>

<p> 再次感谢！</p>

<p>                                                                                                                                          您真诚的</p>

<p>                                                                                                                                               mp77</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-03-29T19:30:53+08:00" pubdate data-updated="true">2008-03-29</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/03/29/C-chong-wen-ji-hua//posts/23/index.html#disqus_thread">Comments</a></span>
	
</div></article>

<nav id="pagenavi">
    
    	
        	<a href="/posts/22" class="prev">Prev</a>
        
    
    
        <a href="/posts/24" class="next">Next</a>
    
    <div class="center"><a href="/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2019

    Han Yi

<br>
Powered by Octopress.
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'hanyi';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-49392954-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>
