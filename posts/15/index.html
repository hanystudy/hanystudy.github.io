
<!DOCTYPE HTML>
<html>
<head>
	<script data-cfasync="false" type="text/javascript" src="//use.typekit.net/axj3cfp.js"></script>
	<script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
	<meta charset="utf-8">
	<title>  | Wing of Dream 梦境之翼</title>

<meta name="author" content="Han Yi"> 

<meta name="description" content=" 抽空写了写GPCT 6th，由于空闲时间实在太少，对C#.net也就大概看了半天时间，代码终于越写越冗长&hellip;不过心疼自习时间急剧压缩，还是下决心release了。清明前去村里旧书店淘了几本思修、马原等书回家来看，可是《Programmer》上明明有“RIA战火纷争”呀， &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Wing of Dream 梦境之翼" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el, 
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	
</head>



<body>
	<header id="header" class="inner"><h1><a href="/">Wing of Dream 梦境之翼</a></h1>
<h4></h4>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:www.hanyi.name">
			</form>
		</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/04/03/programming-competition/">
		
			Programming Competition</a>
	</h2>
	<div class="entry-content">
		<p> 抽空写了写GPCT 6th，由于空闲时间实在太少，对C#.net也就大概看了半天时间，代码终于越写越冗长&hellip;不过心疼自习时间急剧压缩，还是下决心release了。清明前去村里旧书店淘了几本思修、马原等书回家来看，可是《Programmer》上明明有“RIA战火纷争”呀，看来只能赶明天下午的校车了呵呵。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-04-03T17:24:35+08:00" pubdate data-updated="true">2009-04-03</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/tian-xuan-zhi-zuo/'>天选之作</a>, <a class='category' href='/blog/categories/kao-yan-slash-bo/'>考研/bo?</a>

</div>


	
		<span class="comments"><a href="/blog/2009/04/03/programming-competition//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/03/07/lian-zai-zan-ting/">
		
			连载暂停</a>
	</h2>
	<div class="entry-content">
		<p> 持续时间没人能知道，也许做1600题的时候会出专题&hellip;不过那最快也是4个月以后的事情了。最近笔记本用的飞快&hellip;一周能写干6根笔&hellip;回家也是收集信息，不过感觉还是在学校充实一点&hellip;给人感觉可能是有点过，不过一年以后恐怕每个人都可以理解了吧。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-03-07T00:09:34+08:00" pubdate data-updated="true">2009-03-07</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/tian-xuan-zhi-zuo/'>天选之作</a>, <a class='category' href='/blog/categories/kao-yan-slash-bo/'>考研/bo?</a>

</div>


	
		<span class="comments"><a href="/blog/2009/03/07/lian-zai-zan-ting//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/22/AS3-0-xue-xi-bi-ji/">
		
			AS3.0学习笔记(2)</a>
	</h2>
	<div class="entry-content">
		<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">二、AS3.0语法概要</span></span><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">我们知道，按照adobe的说法，AS3.0是完全依据ECMAScript 4.0（草案）标准的。尽管无意提起JavaScript和ActionScript的争端，但ECMA委员会延用v3.1标准已是板上钉钉的事实，似乎预示着Ajax和Flex即将实现不同目标的分离—在我看来这未必是一件坏事，当然，各方的众多支持者恐怕都不会放弃“吃着碗里，看着锅里”的想法。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">AS3.0<span style="font-family: 宋体;">延用了Java的制式包含了许多内置类，如类型封装类Number、String、Boolean等，还有一些内置类如Array、Math和XML等定义了更多复杂的数据结构以及运算。所有的类，无论是内置类还是用户自定义类，都是由一个共同的类Object派生的。但是有一种特殊的变量被称为无类型变量，它们的定义方式如下：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var example;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var example:*;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">它们可以用来存储一些特殊值，这是指定类型Object或其派生类所不具备的。声明并创建类的对象的语句如下:</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var timeNow:Date = new Date();</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">new<span style="font-family: 宋体;">运算符的用法，和C++/Java是惊人的相似！</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">1<span style="font-family: 宋体;">、包和命名空间</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">包packge</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">用于管理一段共享代码中的类文件，它的目的是使程序更易于被复用以及维护—这也是现代OOP的一个重要思想之一。下面一段代码用来创建一个简单类的包：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">package samples</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    public class SampleCode</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    {</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        public var sampleGreeting:String;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        public function sampleFunction()</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        {</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">            trace(sampleGreeting + &#8221; from sampleFunction()&#8221;);</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        }</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    }</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">注意包的名称samples，当编译器编译时会把类名称变为完全限定名称，如samples.SampleCode，其方法的调用也相应变成samples.SampleCode.sampleFunction()。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">AS3.0<span style="font-family: 宋体;">还有一个特点，即包内不仅仅可以含有一个顶级类，还可以定义顶级变量、函数甚至语句，这些内容将可以被包内成员访问。同时在包的顶级只能允许public和internal两种访问说明符。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">与Java不同的是，AS3.0不支持私有类和嵌套类，你会发现包内一般也只能定义一个类。这是因为对于一个.as文件，程序只允许调用其中的一个类，Java中只需将类定义为public即可，AS3.0中这个类必须是在包中。如果要实现类似私有类的定义，那么可以在同一文件的包外进行定义—例如上一篇中的包外类，这种用法在AS中很常见。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">包是可以嵌套的，通常称其为</span></span><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">嵌套包</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">。嵌套包可以在逻辑上与父包相关，也可以不相关。有时我们定义嵌套包，仅仅是为了防止对同一类名的引用发生冲突。而且到</span></span><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">目前为止，AS的作者还未对包赋予任何类似类继承的概念</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">，例如下段代码。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">package samples.sample1</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    public class SampleCode</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    {</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    }</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">当我们在程序中同时导入了两个包时，以下调用会发生名称错误：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var object:SampleCode = new SampleCode();</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">只有当使用完全限定名称时才能避免此错误：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var object:samples.SampleCode = new samples.SampleCode();</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">调用前一个类</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">调用包的方法也很简单，在程序头中输入以下代码：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">import samples.*;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">完整导入包</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">import samples.sample1.SampleCode;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">直接指定类</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">一般提倡程序员使用第二种方法导入包，否则可能会引发类名冲突等问题，这一点上与Java有一定区别。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">命名空间namespace</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">是一种用来控制类、类的属性及其方法可见性的标识符，它也是OOP中一项重要的讨论内容。AS3.0中的命名空间分为五种，其中内置包括了public、private、protected 和 internal四种，另一种则可以由用户自定义。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">首先介绍自定义的命名空间，我们通常需要三个简单步骤完成对命名空间的声明定义和使用，例如以下代码。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">namespace v1;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">声明一个命名空间</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">v1 function testNamespace():void{}</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">定义一个以v1为命名空间的函数</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">use namespace v1;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">调用具有命名空间v1的函数</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">testNamespace();</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">v1::testNamespace()</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">或者利用限定运算符直接引用该函数</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">自定义命名空间的目标是使程序员自己定义成员的可见性。例如我们有不同的类分别位于不同的包中，而这些包是由不同的程序调用的。当某个方法需要无条件被其它类使用时，程序员可以将其声明为自定义命名空间，这样即实现了既定目标，又不至于令该方法成为一个公共方法。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">2、</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">变量</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">通过前面的例子我们可以知道，AS3.0中的变量声明基本遵循以下格式：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var i;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var i:int;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">其中标识符var必须作为声明语句开端，当我们要赋值时，其基本形式和一般语言是相通的：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var i:int=10;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">i=20;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">这表示变量既可以在声明时被赋值，也可以单独赋值。例如数组的声明时赋值：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var example:Array=[&#8220;first&#8221;,&#8221;second&#8221;,&#8221;third&#8221;];</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">创建一个类的对象时var同样适用，例如：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var exam:ClassCode=new ClassCode();</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">多个变量的声明和赋值是可以放在同一语句内的，但细节上与其他语言有所区别。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var firstvar:int,secondvar:int,thirdvar:int;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var firstvar:int=1;secondvar:int=2,thirdvar:int=3;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">研究变量的作用域是个有趣的问题，因为它并不仅仅是全局变量和局部变量区别。例如在C++或Java中就对变量作用域做出了严格限制：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">int cFunction(int input)</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">这是一个错误的语言示例</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">if(input&gt;0)</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 42pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">int result=10;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">else</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 42pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">result=5;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">result=input+result;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">return result;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">以上程序段会发生编译错误，这是因为result声明的作用域仅仅在if语句块内，这就是所谓的块级作用域。而在AS3.0中并不错在类似的限制，这种情况的出现似乎得益于编译器对声明语句的“自动提升”机制，也就是说将函数中的全部变量声明语句自动提前到代码段前端执行，因此就导致了块级作用域的失效。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">但是，AS的编译器仅仅对声明语句具备自动提升的功能，对赋值语句而言并不存在这些“待遇”，因此我们可能会遇到如下语句段：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">function example:int()</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">num=10;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var num:int;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">声明语句滞后，但本段程序是可以通过编译的</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">return num;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">3、</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">数据类型</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">AS3.0<span style="font-family: 宋体;">的数据类型种类较少，且比较特殊。不过值得注意的是，AS3.0的类型检查通常是在程序运行时执行的，这一类语言被称为动态类型语言（注意与动态语言的区别），例如Python。但是在Adobe Flash CS3 professional中编译器是可以选择运行在严格模式或标准模式下的（默认为严格模式），因此不同模式下编译器所遵循的编译规则也有不同。例如严格模式就要求在编译时也执行类型检查工作。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">AS3.0<span style="font-family: 宋体;">的编译器标准模式扩展了运行时类型检查机制，将其扩展到了对实例化对象的检查，即允许以基类声明的对象最终按子类实例化。我们知道，在过去的编译器中，动态语义分析是几乎不可能实现的，因此许多OO语言为了实现对象对基类和子类方法的动态选择问题，制定了动态绑定的规则。但这似乎在AS3.0中变得更为简便了。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">AS3.0<span style="font-family: 宋体;">共有七种基本数据类型，分别为：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">Boolean</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">，包含true和false两个值，默认为false；</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">int</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">，表示32位整数，</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">Null</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">，只包含一个值null，这是对String数据类型和定义所有复杂数据类型的初始值。null是一个极为特殊的值，如果将null赋给非String或复杂数据类型，则编译器会将其自动转换为相应的默认值；</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">Number</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">，用于表示整数、无符号整数和浮点数，由于AS3.0本身含有int和uint类型，因此一般仅在需要用到浮点数表示时才会使用。Number的默认值为NaN，这在计算结果应当为数字而不是数字时返回的结果，例如除零运算；</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">String</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">，用于表示16位字符序列，字符串在内部存储为unicode字符，String的值是不能被更改的。其默认值为null，另外空字符串&#8221;&#8220;与null尽管都表示无字符，但本质上并不相等；</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">uint</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">用来表示32位无符号整数，默认为0；</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">void</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">仅包含一个值undefine，当使用无类型变量时可以赋予undefine，但一般情况下void仅能在声明返回值类型时使用。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">ActionScript<span style="font-family: 宋体;">内部类还定义了如下数据类型（尽管每种语言的表述方式可能不尽一致）：Object、Array、Date、Error、Function、RegExp、XML 和 XMLList，其中</span></span><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">object</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">是所有类的基类，其默认值为null。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">4、</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">数据类型转换</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">AS3.0<span style="font-family: 宋体;">的类型转换相当方便，其主要分为两种形式：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">1）</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">隐式转换，一般只在运行时发生。例如在赋值语句中、函数传参、函数返回值或者是表达式转换；</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">2）</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">显示转换，一些转换在严格模式下并不能通过，例如下段代码：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var example:String=&#8221;150&#8221;;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var intexample:int=example;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">这时只能应用显示转换来进行：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var intexample:int=int(example);</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">替换上段代码第二句</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">我们可以发现，AS3.0的显示类型转换是通过一种类似于类型名函数的方式进行的，事实上这些函数也是语言的内置函数，他们通过一类特殊算法实现了几乎所有类型的互相转换操作。但是一些转换规则需要引起注意：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">int()<span style="font-family: 宋体;">和uint()执行浮点数“去尾制”，含有非数字字符则直接置0的规则。Boolean()只有在0时代表false，其余数字均代表true，通常值为null的字符串、未初始化的对象或空字符串（即值为&#8221;&#8220;）也将转换为false，有时Boolean可直接通过隐式转换完成。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">在转换String()时，默认值为null的量将转换为&#8221;null&#8221;字符串，其他量直接转换为字符串类型。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">5、</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">动态类</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">动态类是一个特殊的机制。其作用是在运行时在对象中声明新的属性或方法，这在其他语言中还没有遇到（作者如此）。</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">动态类的声明需要关键字dynamic，例如：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">dynamic class exampleClass</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">public property:int=200;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var varinstance:exampleClass=new exampleClass();</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">varinstance.property=100;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">varinstance.newproperty:int=200;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">新申请的属性</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">我们甚至可以为动态类定义新的方法：</span></span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">exampleClass.getValue = function()</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">return this.property;</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span></p>


<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt;"><span style="font-weight: normal; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">应当注意这里用到了this关键字，这是因为通过动态类方式产生的属性或方法永远不能引用私有属性或方法，即使引用了公共属性或方法，也需要用this关键字，或者使用类名加限定符的方式。</span></span></p>




<!--EndFragment-->


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-22T20:01:59+08:00" pubdate data-updated="true">2009-02-22</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/actionscript/'>actionscript</a>

</div>


	
		<span class="comments"><a href="/blog/2009/02/22/AS3-0-xue-xi-bi-ji//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/21/jia-qi-lian-zai-zhi-shi-wu/">
		
			假期连载之十五</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt; tab-stops: 93.75pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">（树、图补完篇）</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; tab-stops: 93.75pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">本篇的主要目的是对树和图部分内容中的代码进行分析，涉及构造哈夫曼树、图的几种主流应用算法等问题。本篇结束后假期系列的基本数据结构部分就暂告一段落了。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">构建哈夫曼树<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">现在讨论构建哈夫曼树的算法实现问题。在前文已经对构造哈夫曼树的算法思路有了一定的介绍，易知哈夫曼树中没有度为<span lang="EN-US">1</span>的结点，因而一棵有<span lang="EN-US">n</span>个叶子的哈夫曼树共有<span lang="EN-US">2n-1</span>个结点，可以用一个大小为<span lang="EN-US">2n-1</span>的一维数组存放哈夫曼树的各个结点。由于每个结点同时还包含其双亲信息和孩子结点的信息，所以构成一个静态三叉链表。其结点结构分别是权值域、双亲序号、左子女序号、右子女序号。各结点存储在一维数组中，<span lang="EN-US">0</span>号单元不用，从<span lang="EN-US">1</span>号位置开始使用。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">对于有<span lang="EN-US">n</span>个叶子结点的哈夫曼树，结点总数为<span lang="EN-US">2n-1</span>个，为实现方便，将叶子结点集中存储在前面部分<span lang="EN-US">1-n</span>个位置，而后面的<span lang="EN-US">n-1</span>个位置中存储其余非叶子结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">我们给出静态三叉链表实现的哈夫曼树类型<span lang="EN-US">C</span>语言描述：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>#define N 20</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>#define M 2*N-1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>typedef struct</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>int weight;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>int parent;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>int LChild;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>int RChild;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}HTNode,HuffmanTree[M+1];</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">使用上述结构实现创建哈夫曼树算法：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">void CrtHuffmanTree(HuffmanTree ht,int w[],int n)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>for(i=1;i&lt;=n;i++)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span>ht[i]={w[i],0,0,0}<span style="mso-tab-count: 1;">  </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">初始化<span lang="EN-US">1</span>—<span lang="EN-US">n</span>单元的叶结点<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">m=2*n-1;<span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">统计结点总数<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">for(i=n+1;i&lt;=m;i++)<span style="mso-tab-count: 1;"> </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">从<span lang="EN-US">n+1</span>至<span lang="EN-US">m</span>个结点为非叶结点<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>select(ht,i-1,&amp;s1,&amp;s2);<span style="mso-tab-count: 1;"> </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">从<span lang="EN-US">ht</span>中选择两个<span lang="EN-US">parent</span>为<span lang="EN-US">0</span>且<span lang="EN-US">weight</span>最小的结点，将其序号分别赋值给<span lang="EN-US">s1</span>、<span lang="EN-US">s2</span>返回<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>ht[i].weight=ht[s1].weight+ht[s2].weight;<span style="mso-tab-count: 1;">   </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">计算每次结合后根结点的权值<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>ht[s1].parent=i;<span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">将<span lang="EN-US">s1</span>、<span lang="EN-US">s2</span>的父结点指定为第<span lang="EN-US">i</span>个结点<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>ht[s2].parent=i;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>ht[i].LChild=s1;<span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">对第<span lang="EN-US">i</span>个结点的左右子女结点赋值<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>ht[i].RChild=s2;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">计算哈夫曼编码<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">我们知道，构建哈夫曼树的最终目的是求解哈夫曼编码，从而方便信息传输和数据压缩。因此基于哈夫曼树的哈夫曼编码计算算法就显得尤为重要了。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>void CrtHuffmanCode(HuffmanTree ht,HuffmanCode hc,int n)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>char *cd;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span>cd=(char*)malloc((n+1)*sizeof(char));<span style="mso-tab-count: 1;">   </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">初始化空间<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span>cd[n-1]=”\0”;<span style="mso-tab-count: 7;">                         </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">首先存放结束符<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>for(int i=1;i&lt;=n;i++)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span><span style="mso-tab-count: 1;">    </span>start=n-1;<span style="mso-tab-count: 3;">          </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">编码起始位置<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">            </span>c=i;<span style="mso-tab-count: 4;">                </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 3;">            </span>p=ht[i].parent;<span style="mso-tab-count: 2;">     </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">从叶结点开始倒推<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">            </span>while(p!=0)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">            </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 4;">                </span>&#8211;start;<span style="mso-tab-count: 2;">        </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">倒推一层，判断左<span lang="EN-US">0</span>右<span lang="EN-US">1</span>，再推一层，直到根结点<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 4;">                </span>if(ht[p].LChild==c)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 4;">                </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 5;">                    </span>cd[start]=’0’;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 84pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 84pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">else</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 84pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 84pt; tab-stops: 21.0pt 42.0pt 63.0pt 84.0pt 105.0pt 126.0pt 147.0pt 168.0pt 189.0pt 216.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>cd[start]=’1’;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 84pt; tab-stops: 21.0pt 42.0pt 63.0pt 84.0pt 105.0pt 126.0pt 147.0pt 168.0pt 189.0pt 216.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 84pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">c=p;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 84pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">p=ht[p].parent;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">hc[i]=(char*)malloc((n-start)*sizeof(char));<span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">建立哈夫曼编码存放空间<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">strcpy(hc[i],&amp;cd[start]);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">free(cd);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">深度优先的简单路径算法<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">在图这一部分中，简单路径是指任意两结点路径中不含相同结点的一条。为求解图的简单路径，需要先对图中所有结点进行统一标识，每访问一个结点，则更改该结点标识符，从而达到求简单路径的目的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">算法外围的核心是给所有结点统一赋值，并且建立对应于结点且独立的带值空间。下面给出用深度优先搜索寻找从<span lang="EN-US">u</span>到<span lang="EN-US">v</span>的简单路径算法<span lang="EN-US">C</span>语言描述。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>void DFS_path(Graph *G,int u,int v)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>int j;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>for(j=firstadj(G,u);j&gt;=0;j=nextadj(G,u,j))</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span><span style="mso-tab-count: 1;">    </span>if(pre[j]==-1)<span style="mso-tab-count: 2;">      </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">默认结点标识为<span lang="EN-US">-1</span>，一旦使用过即将标识符置为<span lang="EN-US">u</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span><span style="mso-tab-count: 1;">    </span>pre[j]=u;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span><span style="mso-tab-count: 1;">    </span>if(j==v)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">            </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 4;">                </span>print_path(pre,v);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 63pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 63pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">else</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 63pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>DFS_path(G,j,v);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 63pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">生成树<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">生成树涉及到很多实际应用，例如搭桥问题<span lang="EN-US">…</span>但利用<span lang="EN-US">MST</span>性质求<span lang="EN-US">MST</span>（<span lang="EN-US">Minimum Spanning Tree</span>）还分别有<span lang="EN-US">Prim</span>和<span lang="EN-US">kruskal</span>两种角度不同的算法。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">Prim</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">算法通常被称为“加点法”，这是因为算法是在一个初始化为空的结点空间中，判断能令<span lang="EN-US">(u,v)</span>最短的<span lang="EN-US">u</span>对应的<span lang="EN-US">v</span>结点，然后加入到空的结点空间中，反复执行直到该结点空间与图的结点空间相等。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">Kruskal</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">算法是根据权值最小的边，同时必须确保两个顶点不在同一个结点集合内，故有时<span lang="EN-US">Kruskal</span>算法也被称为“加边法”。事实上以上两种算法除却初始化的部分，真正涉及到原理的代码段就已经非常简单了。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">总结<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">对于拓扑排序、关键路径、最短路径等问题，读者应重点参照“图的应用”这一节连载，其原理已经比较详细，但由于经典算法时间复杂度高，已经有越来越多的专家学者对此提出了许多改进方案，并给出了许多算法解决方案，因此在此基础上参照相关科技文献，才能确保算法的实用性。<span lang="EN-US"></span></span></span></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-21T22:23:25+08:00" pubdate data-updated="true">2009-02-21</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
		<span class="comments"><a href="/blog/2009/02/21/jia-qi-lian-zai-zhi-shi-wu//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/21/2010-kao-yan-fu-xi-gang-yao/">
		
			2010考研复习纲要</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: center;" align="center"><strong style="mso-bidi-font-weight: normal;"><span style="font-size: 14pt;" lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-size: 14pt; font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">考研复习纲要</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-size: 14pt;" lang="EN-US"></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">本纲要初定于</span><span lang="EN-US"><span style="font-family: Times New Roman;">2009</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">年</span><span lang="EN-US"><span style="font-family: Times New Roman;">2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">月</span><span lang="EN-US"><span style="font-family: Times New Roman;">21</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">日</span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">星期六，是</span><span lang="EN-US"><span style="font-family: Times New Roman;">2008-2009</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">学年度大学三年级第二学期开学后第六天。制定本纲要的目的是对</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">年全国硕士研究生入学统一考试复习工作进行全面规划、安排，同时对复习期间附带其它的学习项目进行评估。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">目标学校</span></strong><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">：暂定，由于信息收集工作的原因，本项于</span><span lang="EN-US"><span style="font-family: Times New Roman;">2009</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">年</span><span lang="EN-US"><span style="font-family: Times New Roman;">5</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">月</span><span lang="EN-US"><span style="font-family: Times New Roman;">31</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">日前</span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">确定。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">目标专业</span></strong><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">、方向：计算机科学与技术专业、计算机软件与理论方向（方向正式录取后才能最终确定）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">考试科目及教材</span></strong><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">高等数学（同济大学第五版），工程数学线性代数（同济大学第三版），概率论与数理统计（浙江大学第三版）、数据结构（高等教育出版社</span><span lang="EN-US"><span style="font-family: Times New Roman;">C</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">语言版、清华大学</span><span lang="EN-US"><span style="font-family: Times New Roman;">C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">版）、计算机组成原理（白中英第四版）、计算机操作系统（西电汤子瀛第二版）、计算机网络（清华大学出版社吴功宜，备选电子工业出版社谢希仁第五版）、思想道德修养与法律基础（高等教育出版社）、中国近现代史纲要（西北大学出版社、备选高等教育出版社）、马克思主义原理基本概论（高等教育出版社）、毛泽东思想、邓小平理论和三个代表重要思想概论（高等教育出版社）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">具体考试科目介绍</span></strong><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">（严格依据</span><span lang="EN-US"><span style="font-family: Times New Roman;">2009</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">年全国硕士研究生入学统一考试大纲）：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt; mso-list: l0 level1 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">数学一（满分</span><span lang="EN-US"><span style="font-family: Times New Roman;">150</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，考试时间为</span><span lang="EN-US"><span style="font-family: Times New Roman;">180</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分钟）</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: -21pt; tab-stops: list 42.0pt; mso-list: l0 level2 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">a)</span><span style="font: 7pt &quot;Times New Roman&quot;;">         </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">试卷内结构：高等数学</span><span lang="EN-US"><span style="font-family: Times New Roman;">55%</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，工程数学线性代数</span><span lang="EN-US"><span style="font-family: Times New Roman;">22%</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">、概率论与数理统计</span><span lang="EN-US"><span style="font-family: Times New Roman;">22%</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: -21pt; tab-stops: list 42.0pt; mso-list: l0 level2 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">b)</span><span style="font: 7pt &quot;Times New Roman&quot;;">        </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">试卷题型结构：单项选择题</span><span lang="EN-US"><span style="font-family: Times New Roman;">8</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题</span><span lang="EN-US"><span style="font-family: Times New Roman;">*4</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，填空题</span><span lang="EN-US"><span style="font-family: Times New Roman;">6</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题</span><span lang="EN-US"><span style="font-family: Times New Roman;">*4</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，解答题</span><span lang="EN-US"><span style="font-family: Times New Roman;">9</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题共</span><span lang="EN-US"><span style="font-family: Times New Roman;">94</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt; mso-list: l0 level1 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">政治（满分</span><span lang="EN-US"><span style="font-family: Times New Roman;">100</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，考试时间为</span><span lang="EN-US"><span style="font-family: Times New Roman;">180</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分钟）</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: -21pt; tab-stops: list 42.0pt; mso-list: l0 level2 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">a)</span><span style="font: 7pt &quot;Times New Roman&quot;;">         </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">试卷内结构：由于课程改革，试卷结构将在</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">年考研政治大纲公布后确定。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: -21pt; tab-stops: list 42.0pt; mso-list: l0 level2 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">b)</span><span style="font: 7pt &quot;Times New Roman&quot;;">        </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">试卷题型结构：单项选择题</span><span lang="EN-US"><span style="font-family: Times New Roman;">16</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题</span><span lang="EN-US"><span style="font-family: Times New Roman;">*1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，不定向选择题</span><span lang="EN-US"><span style="font-family: Times New Roman;">17</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题</span><span lang="EN-US"><span style="font-family: Times New Roman;">*2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，问答题</span><span lang="EN-US"><span style="font-family: Times New Roman;">10</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题</span><span lang="EN-US"><span style="font-family: Times New Roman;">*4</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，二选一论述题</span><span lang="EN-US"><span style="font-family: Times New Roman;">10</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt; mso-list: l0 level1 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">英语（满分</span><span lang="EN-US"><span style="font-family: Times New Roman;">100</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，考试时间为</span><span lang="EN-US"><span style="font-family: Times New Roman;">180</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分钟）</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: -21pt; tab-stops: list 42.0pt; mso-list: l0 level2 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">a)</span><span style="font: 7pt &quot;Times New Roman&quot;;">         </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">词汇量要求：</span><span lang="EN-US"><span style="font-family: Times New Roman;">2009</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">考研英语大纲要求的词汇量为</span><span lang="EN-US"><span style="font-family: Times New Roman;">5500</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">词，但根据各方数据为了全面应对考试，考生应具备</span><span lang="EN-US"><span style="font-family: Times New Roman;">8000</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">左右的词汇量，达到大学英语专业四级的词汇水平。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: -21pt; tab-stops: list 42.0pt; mso-list: l0 level2 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">b)</span><span style="font: 7pt &quot;Times New Roman&quot;;">        </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">试卷题型结构：完型填空（</span><span lang="EN-US"><span style="font-family: Times New Roman;">20</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题</span><span lang="EN-US"><span style="font-family: Times New Roman;">*0.5</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分），阅读（</span><span lang="EN-US"><span style="font-family: Times New Roman;">A</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">阅读理解</span><span lang="EN-US"><span style="font-family: Times New Roman;">20</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题</span><span lang="EN-US"><span style="font-family: Times New Roman;">*2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，</span><span lang="EN-US"><span style="font-family: Times New Roman;">B</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">新题型</span><span lang="EN-US"><span style="font-family: Times New Roman;">5</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题</span><span lang="EN-US"><span style="font-family: Times New Roman;">*2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，</span><span lang="EN-US"><span style="font-family: Times New Roman;">C</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">翻译</span><span lang="EN-US"><span style="font-family: Times New Roman;">5</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题</span><span lang="EN-US"><span style="font-family: Times New Roman;">*2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分），作文（书信小作文</span><span lang="EN-US"><span style="font-family: Times New Roman;">10</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，图画大作文</span><span lang="EN-US"><span style="font-family: Times New Roman;">20</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 18pt; text-indent: -18pt; tab-stops: list 18.0pt; mso-list: l0 level1 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">4、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">计算机学科专业基础综合考试（满分</span><span lang="EN-US"><span style="font-family: Times New Roman;">150</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，考试时间为</span><span lang="EN-US"><span style="font-family: Times New Roman;">180</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分钟）</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: -21pt; tab-stops: list 42.0pt; mso-list: l0 level2 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">a)</span><span style="font: 7pt &quot;Times New Roman&quot;;">         </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">试卷内结构：数据结构</span><span lang="EN-US"><span style="font-family: Times New Roman;">45</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，计算机组成原理</span><span lang="EN-US"><span style="font-family: Times New Roman;">45</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，操作系统</span><span lang="EN-US"><span style="font-family: Times New Roman;">35</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分，计算机网络</span><span lang="EN-US"><span style="font-family: Times New Roman;">25</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: -21pt; tab-stops: list 42.0pt; mso-list: l0 level2 lfo1;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">b)</span><span style="font: 7pt &quot;Times New Roman&quot;;">        </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">试卷题型结构：单项选择题</span><span lang="EN-US"><span style="font-family: Times New Roman;">80</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分（</span><span lang="EN-US"><span style="font-family: Times New Roman;">40</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题，每小题</span><span lang="EN-US"><span style="font-family: Times New Roman;">2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分），综合应用题</span><span lang="EN-US"><span style="font-family: Times New Roman;">70</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">分。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 18pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">参考书目及辅导班计划</span><span lang="EN-US"></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">由于参考书目众多且辅导班较为庞杂，因此这里仅列出重点要求。另一些已列书目可能会包含在辅导班计划之内，例如政治任汝芬系列。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">数学：</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">数学复习全书（数学一，李永乐），</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">数学历年试题解析（数学一，李永乐），全真模拟</span><span lang="EN-US"><span style="font-family: Times New Roman;">400</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题（李永乐）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">英语：历年考研英语真题解析及复习思路（新华出版社，张剑），</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">考研英语词汇星火式巧记速记精练（新华出版社，马德高）、</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">考研英语阅读理解精读</span><span lang="EN-US"><span style="font-family: Times New Roman;">200</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">篇（高等教育出版社，胡敏）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">政治：任汝芬教授考研政治序列之一、序列之二、序列之三（西安交通大学出版社），启航考研政治</span><span lang="EN-US"><span style="font-family: Times New Roman;">20</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">天</span><span lang="EN-US"><span style="font-family: Times New Roman;">20</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">题（中国市场出版社，每年１月初出版）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span>计算机学科专业基础综合：算法与数据结构考研试题精析（第二版）、计算机组成原理—学习指导与习题解答（唐朔飞），计算机网络知识要点与习题解析（哈尔滨工程大学出版社），操作系统学习指导和考试指导（浙江大学出版社，李善平）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span>根据目前所掌握的信息并结合<span style="font-family: Times New Roman;">2009</span>年时间安排情况，辅导班重点关注考研政治（西安人信学校），数学（西安海文学校）、英语两科按照</span><span><span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">5</span>月<span style="font-family: Times New Roman;">31</span>日</span><span>之前的基础复习情况以及之后的初步评估最终决定。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span><strong><span style="font-size: small;">复习时间流程</span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span>由于<span style="font-family: Times New Roman;">7</span>月初开始需要进行为期四个半月的实习项目，因此时间安排上比较紧凑，同时仍要考虑到辅导班的日程安排，因此规划如下。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span><span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">1</span>月<span style="font-family: Times New Roman;">11</span>日</span><span style="color: black; font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">至</span><span><span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">5</span>月<span style="font-family: Times New Roman;">31</span>日</span><span>，重点完成对高等数学、线性代数、概率论与数理统计三门课的课本复习，同时进行英语<span style="font-family: Times New Roman;">8000</span>词汇的记忆工作，力争在时间内初步解决。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span><span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">6</span>月<span style="font-family: Times New Roman;">1</span>日</span><span style="color: black; font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">至</span><span><span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">8</span>月<span style="font-family: Times New Roman;">31</span>日</span><span>，开展暑期强化工作，除了继续基础阶段的强化外，要开始进行专业课的基础复习工作（在暑期实习期间完成）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span><span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">9</span>月<span style="font-family: Times New Roman;">1</span>日</span><span style="color: black; font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">至</span><span><span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">11</span>月<span style="font-family: Times New Roman;">30</span>日</span><span>，继续强化基础课程，并开始进行专业课强化复习。开始政治课全面复习，期间考虑申报最终阶段辅导班。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span><span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">12</span>月<span style="font-family: Times New Roman;">1</span>日</span><span>至考试前夕，对整个复习流程进行总结，并根据复习期间积累的重点习题册和真题进行最后复查，政治课进行强化复习。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span><strong><span style="font-size: small;">考研复习期间学习项目计划</span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span>尽管复习任务艰巨，情况复杂，但不应忽视对本专业上层能力的扩展。<span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">6</span>月<span style="font-family: Times New Roman;">31</span>日前应重点学习<span style="font-family: Times New Roman;">ActionScript3.0</span>编程、计算机算法设计部分（<span style="font-family: Times New Roman;">C/C++</span>版），</span><span><span style="font-family: Times New Roman;">2009</span>年<span style="font-family: Times New Roman;">7</span>月<span style="font-family: Times New Roman;">1</span>日</span><span>起开始重点学习实习有关内容（预计为<span style="font-family: Times New Roman;">VC++</span>，<span style="font-family: Times New Roman;">MFC</span>）、设计模式、<span style="font-family: Times New Roman;">C#</span>（<span style="font-family: Times New Roman;">ASP.NET</span>）。以上内容应在<span style="font-family: Times New Roman;">2010</span>年２月底以前全部完成。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span><strong><span style="font-size: small;">总结</span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: black; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为了不产生误导作用，本文自发布起将设置隐藏。根据以往统考惯例，</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">年的研招考试预计将在</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">年</span><span lang="EN-US"><span style="font-family: Times New Roman;">1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">月</span><span lang="EN-US"><span style="font-family: Times New Roman;">9</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">日</span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">至</span><span lang="EN-US"><span style="font-family: Times New Roman;">10</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">日进行，本纲要的作者可在</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">年</span><span lang="EN-US"><span style="font-family: Times New Roman;">1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">月</span><span lang="EN-US"><span style="font-family: Times New Roman;">9</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">日</span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">以前对本纲要进行任何修改，但需保留原计划内容并标明修改时间，</span><span lang="EN-US"><span style="font-family: Times New Roman;">2010</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">年</span><span lang="EN-US"><span style="font-family: Times New Roman;">2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">月底（距制定时间一周年以后）本纲要的隐藏设置将解除。</span></span></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-21T16:41:51+08:00" pubdate data-updated="true">2009-02-21</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/kao-yan-slash-bo/'>考研/bo?</a>

</div>


	
		<span class="comments"><a href="/blog/2009/02/21/2010-kao-yan-fu-xi-gang-yao//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/16/AS3-0-xue-xi-bi-ji/">
		
			AS3.0学习笔记(1)</a>
	</h2>
	<div class="entry-content">
		<div class="Section0" style="layout-grid: 15.6pt none;">
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">即日起我们推出一部新的连载系列——《AS3.0》，原有的“假期系列”改为周末仍以假期形式不间断放出。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">ActionScript<span style="font-family: 宋体;">是针对Adobe Flash Player运行时环境的编程语言。它实现了Flash在动画制作、图像处理、数据处理以及人机交互等方面的众多功能。ActionScript是由Flash Player中的ActionScript虚拟机AVM来执行的，与Java类似，AS的程序代码通常被IDE内嵌的编译器编译成“字节码格式”并放入swf最终文件中，最后由Flash Player统一执行。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">自ActionScript的第一个完整版v1.0与Flash 5共同发布以来，AS就随着Flash的不断更新而变得越来越强大，从MX时代起AS就被Macromedia确立为RIA战略的重要工具。</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">AS3.0<span style="font-family: 宋体;">是随着Flash 9的发布而正式亮相的，我们今后连载所使用的编程环境也是Flash CS3(v9)，但我们更多的只是关注语言本身，并不会过于脱离主题。内容也是严格依据adobe官方manual和livedocs编写，如果对本文有任何疑问的话，可以直接前往adobe.com查阅相关文章。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">尽管adobe宣称AS3.0同样适合无程序设计语言基础者学习，但为了能够更效率地写出有用的程序，请至少拥有一种语言基础，例如C语言。当然，如果你在此基础上还拥有Javascript基础那么学习起来将感到一些似曾相识，如果你还系统学习过Java—那么看半个小时manual你就可以直接上手AS3.0了！</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">请再次注意，由于作者本人几乎没有接触过AS3.0以前的版本，因此本文的版本衔接并不能满足一些读者的需要。另外对于RIA的另一个重要工具Flex我们暂时还不会涉及，因此以后的例解程序并不会出现关于AS3.0在Flex中的应用。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">一、</span><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">构建自己的AS应用程序</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">现在讨论如何利用Adobe Flash CS3 professional创建一个应用程序，通常我们会有两种做法：</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">1、</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">将代码存储在时间轴中的帧中；</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">2、</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">将代码存储在ActionScript文件中；</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">前一种方法较为简单，在代码复杂度不高、没有重用需求的情况下经常使用。首先开启Adobe Flash CS3 Professional应用程序，在引导界面中选择“Flash文件(ActionScript 3.0)”，如果没有引导界面，可以选择菜单“文件-新建”，随后直接点击“确定”。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">现在点击图层中某一帧，例如当前flash文档“图层1”的第一帧，按“F9”，此时会弹出脚本编辑器，在编辑窗口中填入相关代码即可（如图1-1）。</span></span> <img class="alignleft size-full wp-image-147" title="1-1" src="http://www.hanyi.name/blog/wp-content/uploads/2009/02/1-1.jpg" alt="1-1" width="246" height="75" /></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">在创建大型应用程序时，为了方便代码维护，或者希望代码能够在其他程序中得到重用，此时采取前文所说的第二种方法：选择菜单“文件-新建”，选择“常规”选项卡中的“ActionScript文件选项”，点击“确定”就可以进入脚本编辑页面了。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">图1-1</span></span></span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">在了解了上述内容后，让我们来制作一个简单的应用程序，本程序将采用第二种代码存储方式进行构建，其中涉及到了关于IDE本身的一些基本操作，以及面向对象程序设计的一些知识。当然，本文的重点并不在这些方面，该程序段仅仅起到演示作用。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">程序例1-1</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤1</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、首先启动Flash并新建一个ActionScript文件，选择一个指定文件夹并将其保存为HelloWorld.as文件。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤2</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、在编辑区内输入以下代码，并保存。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">package</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">定义一个&#8221;包&#8221;,我们会在今后详细讨论 </span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    public class HelloWorld</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">声明一个类HelloWorld</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    {</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">private var sthSaved:String;</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">声明一个String类型变量sthSaved</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">public function HelloWorld()</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">类的构造方法</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        {</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">            sthSaved = &#8221;Hello World!by hanyi.name!&#8221;;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        }</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        public function getSaved():String </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">使对象返回sthSaved值的方法</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        {</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">            return sthSaved;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        }</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    }</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤3</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、新建一个Flash文件(ActionScript3.0)，保存至与.as文件相同的文件夹中，并取名为HelloWorld.fla。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤4</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、现在在一个传统的Flash工作界面中，首先点击界面左侧工具栏的“文本工具”（快捷键为“T”），用鼠标点击拖动在舞台中创建一个文本字段，并在下方“属性”标签栏(ctrl+F3)内选择“动态文本”，并调整其“宽”、“高”分别为300、50，并设定实例名称为“textOutput”，如图1-2。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><img class="alignleft size-full wp-image-144" title="1-2" src="http://www.hanyi.name/blog/wp-content/uploads/2009/02/1-2.jpg" alt="1-2" width="178" height="146" /></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤5</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、单击时间轴第一帧，并按“F9”，在脚本编辑框内写入如下代码。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var object:HelloWorld=new HelloWorld(); //<span style="font-family: 宋体;">定义对象object</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textOutput.text=object.getSaved(); //<span style="font-family: 宋体;">设置文本框显示的内容</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤6</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、ctrl+c保存文档，此时文档创建结束。按下ctrl+enter即可测试影片。此时测试舞台上应出现“Hello World!by hanyi.name!”。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">在上述程序中，有一些其他语言程序员值得注意的地方。其中package包的概念和用法，与Java类似，在后面的部分中会详细介绍。注意变量的声明方式：var 变量名:类型</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">这样的用法，这在声明类的方法时同样适用。尽管以上程序中的效果可能在Flash中仅仅用两个简单操作就能实现，但是比较完整地体现出了AS运行的方式。下面我们对上述程序作出一些改进，这些改进主要体现在交互功能方面。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">程序例1-1改进版</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤1</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、打开HelloWorld.as文件，对源文件做以下修改。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">package</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">定义一个&#8221;包&#8221;,我们会在今后详细讨论 </span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    public class HelloWorld </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">声明一个类HelloWorld</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    {</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">private var sthSaved:String;</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">声明一个String类型变量sthSaved</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">private var exam:ShortTest;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">public function HelloWorld() </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">类的构造方法</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        {</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">            sthSaved = &#8221;Hello World!by hanyi.name!&#8221;;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        }</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">public function getSaved():String </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">使对象返回sthSaved值的方法</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        {</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">            return sthSaved;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        }</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">public function startAnswer():String</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">声明ShortTest类对象,并初始化显示器</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">exam = new ShortTest();</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">return exam.showQuestion();</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">public function input(answer:int):String</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">返回结果</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">if(exam.updateResult(answer))</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">return &#8221;Congratulations!&#8221;;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">else</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">return &#8221;Sorry,Try again!&#8221;;</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    }</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">class ShortTest</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">包外类</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">public function updateResult(finalResult:int):Boolean</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">接收传入的答案,并判断正误</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">if(finalResult == 18)</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">return true;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">else</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">return false;</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">public function showQuestion():String</span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">//<span style="font-family: 宋体;">显示题目</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var question:String = &#8221;2*9=?&#8221;;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">return question;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤2</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、打开HelloWorld.fla文件，对第一帧上的脚本作以下修改。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var object:HelloWorld=new HelloWorld();</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">var flag:Boolean;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textOutput.border=true;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textInput.border=true;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textOutput.text=object.getSaved();</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textInput.text=&#8221;continue&#8230;&#8221;;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textInput.addEventListener(KeyboardEvent.KEY_UP, keyPressed); //<span style="font-family: 宋体;">监听键盘事件</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">function keyPressed(keyevent:KeyboardEvent):void //<span style="font-family: 宋体;">委托事件处理</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    if (keyevent.keyCode == Keyboard.ENTER)</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    {</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">if(flag==false)</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textInput.replaceText(0,textOutput.length,&#8221;&#8220;);</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">        </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"> </span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textOutput.text = object.startAnswer(); //<span style="font-family: 宋体;">进入答题</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">flag=true;</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">else</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">{</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textOutput.text = object.input(int(textInput.text)); //<span style="font-family: 宋体;">显示答案</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">textInput.replaceText(0,textOutput.length,&#8221;&#8220;);</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">    }</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';">}</span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤3</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、在textOutput下方重新插入一个文本工具，属性选择“输入文本”，实例名称为“textInput”，其他选项与textOutput相同。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-weight: bold; font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">步骤4</span></span><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">、测试影片，首先选定下面的“continue&#8230;”框并按enter，此时出现题目，在下方文本框中输入答案，并按enter，检查结果。</span></span></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"><span style="font-family: 宋体;">本例作为例1-1的改进版本，功能上主要体现在交互性的增强。另外需要注意HelloWorld.as文件内包外类ShortTest，这表示ShortTest仅具备被.as文件内其他类访问的权限，并不能被包外数据访问。另一方面，AS3.0的事件委托机制与Java是极其类似的，该程序最终结果显示如下图。</span></span> </p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 21pt; text-align: justify;"><img class="alignleft size-full wp-image-143" title="1-3" src="http://www.hanyi.name/blog/wp-content/uploads/2009/02/1-3.jpg" alt="1-3" width="358" height="158" /></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><span style="font-size: 10.5pt; font-family: '宋体'; mso-spacerun: 'yes';"></span><img class="alignleft size-full wp-image-146" title="1-4" src="http://www.hanyi.name/blog/wp-content/uploads/2009/02/1-4.jpg" alt="1-4" width="353" height="169" /></p>
<p class="p0" style="margin-top: 0pt; margin-bottom: 0pt; margin-left: 21pt; text-indent: 21pt; text-align: justify;"><img class="alignleft size-full wp-image-145" title="1-5" src="http://www.hanyi.name/blog/wp-content/uploads/2009/02/1-5.jpg" alt="1-5" width="351" height="163" /></p>

</div>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-16T21:21:08+08:00" pubdate data-updated="true">2009-02-16</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/bian-cheng-yu-yan/'>编程语言</a>

</div>


	
		<span class="comments"><a href="/blog/2009/02/16/AS3-0-xue-xi-bi-ji//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/13/bai-pian-zong-jie/">
		
			百篇总结</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">确切的说本文已经是<span lang="EN-US">blog</span>建立以来第一百零三篇了，原本想在第<span lang="EN-US">100</span>篇写，后来发现需要赶工做完一些尚未完成的工作，于是竟推后了这么多，就像前几天错过重建周年一样<span lang="EN-US">…</span>其实看看<span lang="EN-US">url</span>的记录，<span lang="EN-US">p</span>值已经接近<span lang="EN-US">150</span>，这是因为<span lang="EN-US">wp</span>在文章备份时欠虑周全的结果<span lang="EN-US">…</span>使得在后台不得不强删了许多<span lang="EN-US">bak</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">关于假期连载，开始考虑回学校以后是否该换个名字了，后来发现届时恐怕依然不会改变发布的时间，因此就会沿用这一名称。连载之外还是仿照去年的做法发布一些好玩有用的东西出来。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">首页又要颠覆了<span lang="EN-US">…</span>原因是现在的功能性太差，不符合我们的风格，况且完全基于<span lang="EN-US">web</span>我们也已经能做的够好<span lang="EN-US">…</span>不过鉴于美观性还是要依赖一定的<span lang="EN-US">Flash</span>，我不是搞外观设计的<span lang="EN-US">…</span></span></span></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-13T22:41:22+08:00" pubdate data-updated="true">2009-02-13</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/tian-xuan-zhi-zuo/'>天选之作</a>

</div>


	
		<span class="comments"><a href="/blog/2009/02/13/bai-pian-zong-jie//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/13/jia-qi-lian-zai-zhi-shi-si/">
		
			假期连载之十四</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">(</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">图—图的遍历、应用<span lang="EN-US">)</span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">图是我们在简单数据结构部分中讨论的最后一篇，其重点主要包括离散数学中关于图论的一些理论介绍，各种性质图的存储表示优缺点分析，图的遍历算法以及部分基于遍历算法的一些实际应用问题等。可以说在图之前，数据结构所利用到的一些简单算法依然属于“入门级”，而从图开始，就要建立在较为复杂的算法分析基础上进行算法设计了。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">但今后当我们接触到高级数据结构部分的内容时，恐怕又会对图这一部分稍带不屑了。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">图的遍历<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">图的遍历从大的方向来看与树形结构类似，分深度优先和广度优先两种类型。但图有其极其特殊的一面，使它和树的算法设计上有着根本区别。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">一是图不同于树的一对多的关系，而是多对多的关系，在这些关系中可能是非连通图，也有可能含有回路存在。这有点类似于我们曾提到的迷宫解法，但事实上用图来解迷宫问题有点杀鸡用牛刀的感觉，且在一些情况中甚至还无法用图来构建。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">总之图的遍历一般情况下需要回溯，为了防止重复访问结点，需要额外设置一个访问标志数组<span lang="EN-US">visited[n]</span>，用于记录已访问过的结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; tab-stops: list 39.0pt; mso-list: l6 level1 lfo1;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">深度优先搜索<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">图的深度优先搜索是从树的先根遍历算法推广而来的，其原则是按深度方向搜索。其算法思想是：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; tab-stops: list 39.0pt; mso-list: l2 level1 lfo2;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1）</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">从图中某个顶点<span lang="EN-US">v0</span>出发，首先访问<span lang="EN-US">v0</span>；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; tab-stops: list 39.0pt; mso-list: l2 level1 lfo2;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2）</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">找出刚访问过的顶点的第一个未被访问的邻接点，然后访问该结点。以该结点为新结点，重复此步骤，直到刚访问过的顶点没有未被访问的邻接点为止；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; tab-stops: list 39.0pt; mso-list: l2 level1 lfo2;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">3）</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点，然后执行步骤<span lang="EN-US">2</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">我们用深度优先顺序模拟遍历图，在算法前进的方向所连成的结点序列构成以<span lang="EN-US">A</span>为根的树，称为<strong style="mso-bidi-font-weight: normal;">深度优先搜索树</strong>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">下面给出<span lang="EN-US">C</span>语言描述的深度优先搜索—邻接矩阵法表示。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">void DepthFirstSearch(AdjMatrix g,int v0)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>visit(v0);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>visited[v0]=True;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>for(vj=0;vj&lt;g.vexnum;vj++)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>if(!visited[vj]&amp;&amp;g.arcs[v0][vj].adj==1)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">            </span>DepthFirstSearch(g,vj);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">}//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">如果读者有兴趣，可以自己写出工作栈条件下的非递归算法，两种同样重要<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; tab-stops: list 39.0pt; mso-list: l6 level1 lfo1;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广度优先搜索<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广度优先搜索即是从树和森林的广度优先遍历算法推广而来的。其算法的基本思想是：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）从图中某个顶点<span lang="EN-US">v0</span>出发，首先访问<span lang="EN-US">v0</span>；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）依次访问<span lang="EN-US">v0</span>的各个未被访问的邻接点；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">3</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）分别从这些邻接点出发，依次访问它们的各个未被访问的邻接点。在访问时应保证以下规则：<strong style="mso-bidi-font-weight: normal;">如果<span lang="EN-US">vi</span>和<span lang="EN-US">vk</span>为当前端接点，且<span lang="EN-US">vi</span>在<span lang="EN-US">vk</span>之前被访问，则<span lang="EN-US">vi</span>的所有未被访问的邻接点应在<span lang="EN-US">vk</span>的所有未被访问的邻接点之前被访问</strong>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">由于广度优先搜索实质上是按层次顺序搜索，因此算法不涉及回溯，借鉴树的经验，我们依然采用队列一次存储一层结点的方式组织算法，便于确保访问该层所有结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">图的应用<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">图的应用是广泛且复杂的。在介绍其具体应用之前，需要了解几个关于图应用的几个前置概念。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、连通分量<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">当无向图为非连通图时，从图中某一个顶点出发，利用深度或广度优先搜索算法无法遍历所有顶点，而只能访问到该结点所在的最大连通子图中的所有顶点，这些顶点构成一个<strong style="mso-bidi-font-weight: normal;">连通分量</strong><span lang="EN-US">connected component</span>。在这种情况下，对图的遍历应以连通分量为单位进行，才能确保遍历全部顶点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">以此作为推广，在无向连通图中，顶点<span lang="EN-US">v</span>被称为关节点<span lang="EN-US">articulation point</span>，当且仅当删去<span lang="EN-US">v</span>及依附于<span lang="EN-US">v</span>的所有边之后，<span lang="EN-US">G</span>被分割为至少两个连通分量。我们把没有关节点的图称为<strong style="mso-bidi-font-weight: normal;">重连通图</strong><span lang="EN-US">biconnected graph</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、简单路径<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">简单路径</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">是指图中顶点<span lang="EN-US">u</span>到顶点<span lang="EN-US">v</span>的一条路径中，其顶点均不相同的路径。通过简单分析可知，两顶点间可能存在多条简单路径，我们可以对遍历算法进行适当改进，使求得的解为简单路径。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">3</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、生成树<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">一个连通图的<strong style="mso-bidi-font-weight: normal;">生成树</strong>是指一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的<span lang="EN-US">n-1</span>条边。如果在生成树上添加一条边，则必然形成一个环。一个有<span lang="EN-US">n</span>个顶点的生成树仅有<span lang="EN-US">n-1</span>条边，如果多余<span lang="EN-US">n-1</span>则必然有回路，但是含有<span lang="EN-US">n-1</span>条边的土并非是连通图，就不一定存在生成树，如果一个图的边数少于<span lang="EN-US">n-1</span>，则其必然是非连通图。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的最小代价生成树<span lang="EN-US">Minimum Cost Spanning Tree</span>，简称为<strong style="mso-bidi-font-weight: normal;">最小生成树</strong><span lang="EN-US">MST</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">最小生成树具有一条重要性质：<strong style="mso-bidi-font-weight: normal;">设<span lang="EN-US">N={V,{E}}</span>是一个连通网，<span lang="EN-US">U</span>是顶点集<span lang="EN-US">V</span>的一个非空子集。若<span lang="EN-US">(u,v)</span>是一条具有最小权值的边，其中<span lang="EN-US">u</span>属于<span lang="EN-US">U</span>，<span lang="EN-US">v</span>属于<span lang="EN-US">V-U</span>，则存在一棵包含边<span lang="EN-US">(u,v)</span>的最小生成树</strong>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">利用<span lang="EN-US">MST</span>的上述性质，我们可以生成一个连通网的最小生成树。其中<span lang="EN-US">Kruskal</span>算法和<span lang="EN-US">Prim</span>算法是最为经典的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）<span lang="EN-US">Kruskal</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">假设<span lang="EN-US">N=(V,{E})</span>是连通网，将<span lang="EN-US">N</span>中的边按权值从小到大的顺序排列。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>a</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）将<span lang="EN-US">n</span>个结点看成<span lang="EN-US">n</span>个集合；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>b</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）按权值从小到大的顺序选择边，所选边应满足两个顶点不在同一个顶点集合内，将该边放到生成树边的集合中，同时将该边的两个顶点所在的顶点集合合并。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>c</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）重复<span lang="EN-US">b</span>直到所有的顶点都在同一个顶点集合内。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）<span lang="EN-US">Prim</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">假设<span lang="EN-US">N=(V,{E})</span>是连通网，<span lang="EN-US">TE</span>为最小生成树中边的集合。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>a</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）初始<span lang="EN-US">U={u0|u0</span>属于<span lang="EN-US">V</span>，<span lang="EN-US">TE</span>为空<span lang="EN-US">}</span>；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>b</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）在所有<span lang="EN-US">u</span>属于<span lang="EN-US">U</span>，<span lang="EN-US">v</span>属于<span lang="EN-US">V-U</span>的边种选择一条代价最小的边（<span lang="EN-US">u0,v0</span>）并入集合<span lang="EN-US">TE</span>，同时将<span lang="EN-US">v0</span>并入<span lang="EN-US">U</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>c</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">）重复<span lang="EN-US">b</span>直到<span lang="EN-US">U=V</span>为止，此时<span lang="EN-US">TE</span>中必含有<span lang="EN-US">n-1</span>条边，则<span lang="EN-US">T=( V,{TE})</span>为<span lang="EN-US">N</span>的最小生成树。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">4</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、拓扑排序<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">有向无环图</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">Directed Acyclic Graph</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">是指一个无环的有向图，简称<span lang="EN-US">DAG</span>。我们一般用顶点表示活动，用弧表示活动间的优先关系的有向无环图，称为顶点表示活动的网<span lang="EN-US">Activity On Vertex Network</span>，简称<span lang="EN-US">AOV-</span>网。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">在有向图<span lang="EN-US">G=(V,{E})</span>中，<span lang="EN-US">V</span>中顶点的线性序列（<span lang="EN-US">v1,v2,…,vn</span>）称为拓扑序列。如果此序列中任意两个顶点<span lang="EN-US">vi</span>、<span lang="EN-US">vj</span>，在<span lang="EN-US">G</span>中有一条从<span lang="EN-US">vi</span>到<span lang="EN-US">vj</span>的路径，则在序列中<span lang="EN-US">vi</span>必排在<span lang="EN-US">vj</span>之前。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">现已知<span lang="EN-US">AOV-</span>网的特性如下：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l0 level1 lfo3;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">AOV-</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">网中不能存在回路，否则回路中的活动就会互为前驱，从而无法执行。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l0 level1 lfo3;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">AOV-</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">网的拓扑序列是不唯一的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">为求有向无环图的拓扑序列，就是<strong style="mso-bidi-font-weight: normal;">拓扑排序</strong>问题<span lang="EN-US">Topological Sort</span>。其基本思想为：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l1 level1 lfo4;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">从有向图中选一个无前驱的结点数出。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l1 level1 lfo4;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">将此结点和以它为起点的弧删除。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l1 level1 lfo4;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">重复<span lang="EN-US">1</span>、<span lang="EN-US">2</span>，直到不存在无前驱的结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l1 level1 lfo4;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">4、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">若此时输出的结点数小于有向图中的结点数，则说明有向图存在回路，否则输出的顶点顺序即为一个拓扑序列。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l1 level1 lfo4;" align="left"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">5、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">关键路径<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">有向图通常被用来表示工程计划时有两种方法：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l4 level1 lfo5;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">用顶点表示活动，即<span lang="EN-US">AOV-</span>网；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l4 level1 lfo5;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">用顶点表示事件，用弧表示活动，弧的权值表示活动所需要的时间。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">把第二种方法构造的有向无环图称为边表示活动的网<span lang="EN-US">Activity On Edge Network</span>。简称<span lang="EN-US">AOE-</span>网。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">AOE-</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">网中存在唯一的、入度为<span lang="EN-US">0</span>的顶点，叫做源点。存在唯一的，出度为<span lang="EN-US">0</span>的点，叫做汇点。从源点到汇点的最长路径的长度即为完成整个工程任务所需要的时间，该路径叫做<strong style="mso-bidi-font-weight: normal;">关键路径</strong>，关键路径上的活动称为关键活动。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">求关键路径的基本步骤如下：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l3 level1 lfo6;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">对图中顶点进行拓扑排序，在排序过程中按拓扑序列求出每个事件的最早发生时间<span lang="EN-US">ve(i)</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l3 level1 lfo6;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">按逆拓扑序列求每个事件的最晚发生时间<span lang="EN-US">vl(i)</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l3 level1 lfo6;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">求出每个活动<span lang="EN-US">ai</span>的最早开始时间<span lang="EN-US">e(i)</span>和最晚发生时间<span lang="EN-US">l(i)</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l3 level1 lfo6;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">4、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">找出<span lang="EN-US">e(i)=l(i)</span>的活动<span lang="EN-US">ai</span>，即为关键活动。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l1 level1 lfo4;" align="left"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">6、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">最短路径问题<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-align: left;" align="left"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">所谓最短路径<span lang="EN-US">Shortest Path</span>问题是指：从在带权图的某一个顶点（称为源点）出发，找出一条通往另一顶点（称为终点）的最短路径。所谓“最短”，也就是沿路径各边的权值达到最小。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">最短路径问题分为以下三种情况表示：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l5 level1 lfo7;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">非负权值的单源最短路径<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">求此类型的最短路径，经典算法是由计算机大拿<span lang="EN-US">Dijkstra</span>提出的按路径长度的递增次序确定最短路径的<span lang="EN-US">Dijkstra</span>算法。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l5 level1 lfo7;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">任意权值的单源最短路径<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">假设有向带权图某条边的长度为负，那么根据<span lang="EN-US">Dijkstra</span>算法，结果并不正确。为了求解这种情况下的最短路径问题，<span lang="EN-US">Bellman</span>和<span lang="EN-US">Ford</span>提出了从源点逐次绕过其他顶点，以缩短到达终点的最短路径长度算法。该方法有一个限制条件，即有向图中不能包含带有负值边的回路。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; text-align: left; tab-stops: list 39.0pt; mso-list: l5 level1 lfo7;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">所有顶点之间的最短路径<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">对于一个各边权值均大于<span lang="EN-US">0</span>的有向带权图，求出所有顶点之间的最短路径和最短路径长度，一个办法是轮流以每个顶点为源点，重复执行<span lang="EN-US">Dijkstra</span>算法<span lang="EN-US">n</span>次，就可求得每一对顶点之间的最短路径和最短路径长度。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">为了使算法结构更为清晰，<span lang="EN-US">Floyd</span>算法实现了这一要求，尽管其时间复杂度上与前者相当。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">Floyd</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">算法使用图的邻接矩阵<span lang="EN-US">Edge[n][n]</span>来表示有向带权图。算法的基本思想是，设置一个<span lang="EN-US">n</span>阶方阵<span lang="EN-US">A</span>，其中除对角线的矩阵元素为<span lang="EN-US">0</span>外，其他元素<span lang="EN-US">a[i][j]</span>表示从点<span lang="EN-US">vi</span>到<span lang="EN-US">vj</span>的有向路径长度。在<span lang="EN-US">vi</span>、<span lang="EN-US">vj</span>间插入<span lang="EN-US">v0</span>、<span lang="EN-US">v1</span>、<span lang="EN-US">…</span>直到<span lang="EN-US">n-1</span>次，每步比较前者和后者的长度，并取较短的路径作为中间顶点号不大于<span lang="EN-US">0</span>的最短路径。最终得到的必是<span lang="EN-US">vi</span>和<span lang="EN-US">vj</span>的最短路径。事实证明<span lang="EN-US">Floyd</span>算法在逻辑上更符合题设的要求。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">在今后的连载中，我们会特别针对图的六个核心应用问题进行专题讨论，并且陆续放出相关算法的最终代码。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">至此，简单数据结构部分的内容就全部讨论完毕。这些结构都是被经常用在各种程序设计当中，并被作为程序设计的核心问题之一。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">接下来的连载，除了开辟必要的两篇来丰富和总结前面的不足之外，我们会进入简单算法设计部分的讨论，这些算法都是基于上述十四篇连载的内容而来，使数据结构的实际应用更加深入了一步。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-align: left;" align="left"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">（未完待续）<span lang="EN-US"></span></span></span></strong></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-13T22:24:05+08:00" pubdate data-updated="true">2009-02-13</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
		<span class="comments"><a href="/blog/2009/02/13/jia-qi-lian-zai-zhi-shi-si//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/13/jia-qi-lian-zai-zhi-shi-san/">
		
			假期连载之十三</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">（图—图的基本概念、<span lang="EN-US">ADT</span>、存储结构表示）</span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">图<span lang="EN-US">graph</span>部分涉及到了许多离散数学方面的理论知识，因此本节需要读者具备一定的离散数学背景—当然，重要的概念和性质我们会附带说明。图是一种更为灵活复杂的非线性结构，理论上讲它比树的实用性更强，但算法设计的复杂度上也存在很大提升。图最典型的应用领域有电路分析、寻找最短路线、项目规划、鉴别化合物、统计力学、遗传学、控制论、语言学以及一些社会科学。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">图的基本概念</span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">图是一种网状数据结构，其形式定义如下：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>Graph=(V,R);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>V={x|x</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">属于<span lang="EN-US">DataObject};</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>R={VR};</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>VR={&lt;x,y&gt;|P(x,y)</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">交<span lang="EN-US">(x,y</span>属于<span lang="EN-US">V)};</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">其中<span lang="EN-US">DataObject</span>是一个数据集合，其中所有的元素都具有相同的特性。<span lang="EN-US">V</span>中的数据元素通常称为顶点<span lang="EN-US">Vertex</span>，<span lang="EN-US">VR</span>是两个顶点之间的关系的集合，<span lang="EN-US">P(x,y)</span>表示<span lang="EN-US">x</span>和<span lang="EN-US">y</span>之间有特定的关联属性<span lang="EN-US">P</span>。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">若有<span lang="EN-US">VR</span>内的元素<span lang="EN-US">&lt;x,y&gt;</span>，则其表示从顶点<span lang="EN-US">x</span>到顶点<span lang="EN-US">y</span>的一条<strong style="mso-bidi-font-weight: normal;">弧</strong><span lang="EN-US">Arc</span>，并称<span lang="EN-US">x</span>为<strong style="mso-bidi-font-weight: normal;">弧尾</strong><span lang="EN-US">Tail</span>或起始点，称<span lang="EN-US">y</span>为<strong style="mso-bidi-font-weight: normal;">弧头</strong><span lang="EN-US">Head</span>或终端点，此时图中的边是有方向的，称这样的图为<strong style="mso-bidi-font-weight: normal;">有向图</strong>。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">若有<span lang="EN-US">VR</span>内的元素<span lang="EN-US">&lt;x,y&gt;</span>，必有<span lang="EN-US">&lt;y,x&gt;</span>，即<span lang="EN-US">VR</span>是对称关系，这时用无序对的表示方法来代替两个有序对<span lang="EN-US">(x,y)</span>，表示<span lang="EN-US">x</span>和<span lang="EN-US">y</span>之间的一条边，此时的图称为无向图。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">设<span lang="EN-US">n</span>表示图中的顶点个数，用<span lang="EN-US">e</span>表示图中边或弧的数目，且不考虑图中每个顶点到其自身的边或弧。对于无向图而言，如果<span lang="EN-US">e=n(n-1)/2</span>，则称其为<strong style="mso-bidi-font-weight: normal;">无向完全图</strong>，对应的有向图被称为<strong style="mso-bidi-font-weight: normal;">有向完全图</strong>。对于<span lang="EN-US">e&lt;nlogn</span>的图称为<strong style="mso-bidi-font-weight: normal;">稀疏图</strong>，否则称<strong style="mso-bidi-font-weight: normal;">稠密图</strong>。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">子图是指一个图的顶点结构和关联不发生改变，只存在其中一部分的图。在无向图<span lang="EN-US">G=(V,{E})</span>中，如果边<span lang="EN-US">(v1,v2)</span>属于<span lang="EN-US">E</span>，则称<span lang="EN-US">v1</span>、<span lang="EN-US">v2</span>互为<strong style="mso-bidi-font-weight: normal;">邻接点</strong>，并且边<span lang="EN-US">(v1,v2)</span>依附于顶点<span lang="EN-US">v1</span>、<span lang="EN-US">v2</span>，或者说边与<span lang="EN-US">v1</span>、<span lang="EN-US">v2</span>相关联。而对于有向图而言，如果存在弧<span lang="EN-US">&lt;v1,v2&gt;</span>属于<span lang="EN-US">A</span>，则称顶点<span lang="EN-US">v1</span>邻接到顶点<span lang="EN-US">v2</span>，顶点<span lang="EN-US">v2</span>邻接自顶点<span lang="EN-US">v1</span>，或者说弧<span lang="EN-US">&lt;v1,v2&gt;</span>与顶点<span lang="EN-US">v1</span>、<span lang="EN-US">v2</span>相关联。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">度</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">是指与顶点<span lang="EN-US">v</span>关联的边数，记作<span lang="EN-US">deg(v)</span>。在有向图中顶点为弧头则称其为<strong style="mso-bidi-font-weight: normal;">入度</strong><span lang="EN-US">ID(v)</span>，为弧尾则称其为<strong style="mso-bidi-font-weight: normal;">出度</strong><span lang="EN-US">OD(v)</span>，顶点的入度的数目必然和出度相等。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">在实际应用中，往往赋给边或弧一定的数值，成为<strong style="mso-bidi-font-weight: normal;">权</strong>。这种带权信息的图被称为<strong style="mso-bidi-font-weight: normal;">赋权图</strong>或<strong style="mso-bidi-font-weight: normal;">网</strong>。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">路径是指任意两个顶点之间沿边或弧方向的顶点序列。如果<span lang="EN-US">G</span>是有向图，则其路径也是有向的。在一个路径中，如果第一个顶点和最后一个顶点相同，则称该路径为一个<strong style="mso-bidi-font-weight: normal;">回路</strong>或<strong style="mso-bidi-font-weight: normal;">环</strong>。若表示路径的顶点序列中的顶点各不相同，则称这样的路径为<strong style="mso-bidi-font-weight: normal;">简单路径</strong>。除第一个和最后一个顶点外，其余个顶点均不重复出现的回路称为<strong style="mso-bidi-font-weight: normal;">简单回路</strong>。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">在无向图<span lang="EN-US">G</span>中，如果从<span lang="EN-US">vi</span>到<span lang="EN-US">vj</span>有路径相通，则称其是连通的。如果对于任意两个顶点均是连通的，则图被称为连通图。无向图的极大连通子图被称为无向图的<strong style="mso-bidi-font-weight: normal;">连通分量</strong>。而对有向图而言，如果对于每对顶点，都有互相连通的路径，则称其为强连通图，它的极大连通子图被称为<strong style="mso-bidi-font-weight: normal;">强连通分量</strong>。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">现在给出图的抽象数据类型定义：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">ADT Graph</span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">数据对象<span lang="EN-US">V:</span>一个集合，集合中所有元素有相同的特性</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">数据关系<span lang="EN-US">R:R={VR};</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">基本操作<span lang="EN-US">:</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>CreateGraph(G);<span style="mso-tab-count: 2;">     </span><span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">创建图<span lang="EN-US">G</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>DestoryGraph(G);<span style="mso-tab-count: 1;">    </span><span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">销毁图<span lang="EN-US">G</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>LocateVertex(G,v);<span style="mso-tab-count: 1;">  </span><span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">若存在顶点<span lang="EN-US">v</span>，则返回<span lang="EN-US">v</span>的位置，否则返回<span lang="EN-US">NULL</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>GetVertex(G,i);<span style="mso-tab-count: 2;">     </span><span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">返回<span lang="EN-US">G</span>中顶点<span lang="EN-US">v</span>的第<span lang="EN-US">i</span>个顶点的值</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>FirstAdjVertex(G,v);<span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">返回<span lang="EN-US">G</span>中顶点<span lang="EN-US">v</span>的第<span lang="EN-US">i</span>个邻接点的值</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>NextAdjVertex(G,v,w);<span style="mso-tab-count: 1;">   </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">返回返回<span lang="EN-US">G</span>中顶点<span lang="EN-US">v</span>的下一个<span lang="EN-US">(w</span>个后面<span lang="EN-US">)</span>邻接点的值，如果<span lang="EN-US">w</span>为最后一个邻接点，则返回<span lang="EN-US">NULL</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>InsertVertex(G,u);<span style="mso-tab-count: 2;">      </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">添加一个点<span lang="EN-US">u</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>DeleteVertex(G,v);<span style="mso-tab-count: 2;">      </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">删除图中的顶点<span lang="EN-US">v</span>以及相关联的弧</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>InsertArc(G,v,w);<span style="mso-tab-count: 2;">       </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">向图中添加一条从<span lang="EN-US">v</span>指向<span lang="EN-US">w</span>的弧</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; tab-stops: 21.0pt 42.0pt 63.0pt 84.0pt 105.0pt 126.0pt 168.75pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>DeleteArc(G,v,w);<span style="mso-tab-count: 1;">       </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">删除图中从<span lang="EN-US">v</span>指向<span lang="EN-US">w</span>的弧</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt; tab-stops: 21.0pt 42.0pt 63.0pt 84.0pt 105.0pt 126.0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>TraverseGraph(G);<span style="mso-tab-count: 2;">       </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">遍历图<span lang="EN-US">G</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">图的基本存储结构</span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">现在，我们按照图的性质，介绍四种常用的存储表示法。大体上来说依然为顺序存储和链式存储两种类型。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo2; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">图的邻接矩阵表示</span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">邻接矩阵<span lang="EN-US">adjacency matrix</span>表示法实际上就是数组表示法。它采用两个数组来表示图：一个是用于存储顶点信息的一维数组，另一个是用于存储图中顶点之间关联关系的二维数组，这个关联关系数组被称为<strong style="mso-bidi-font-weight: normal;">邻接矩阵</strong>。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">在储存关联关系的二维数组中，<span lang="EN-US">1</span>代表了无权图中两顶点间路径连通，<span lang="EN-US">0</span>则反之，其阶为顶点个数。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">邻接矩阵表示的特点如下：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">a)</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">存储空间方面，对无向图而言，其邻接矩阵为对称矩阵，因而可采用相关的压缩存储法。但对于有向图而言，由于顶点间不一定互相连通，因此需要<span lang="EN-US">n^2</span>个存储空间。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">b)</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">便于计算，由于采用了数组表示，关于图中顶点的基本运算就相对简便。综合而言，邻接矩阵不适合存储稀疏图。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span><strong style="mso-bidi-font-weight: normal;">2</strong></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、邻接表表示法</span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">邻接表<span lang="EN-US">adjacency matrix</span>吸取了邻接矩阵的优点，同时凭借链式结构的特点对上述方法做出改进，在节省存储空间上起到了很大作用。邻接表对图中每个顶点建立一个带头结点的边链表。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">表头结点有两部分构成：<strong style="mso-bidi-font-weight: normal;">数据域</strong><span lang="EN-US">vexdata</span>以及<strong style="mso-bidi-font-weight: normal;">链域</strong><span lang="EN-US">firstarc</span>，用于指向链表中第一个顶点。对于边表，由表示图中顶点间邻接关系的<span lang="EN-US">n</span>个边链表构成。因而结点在包括了上述两个结点域之外，还附带一个<strong style="mso-bidi-font-weight: normal;">邻接点域</strong><span lang="EN-US">adjvex</span>，用于存放与该点相邻的顶点在图中的位置。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">邻接表虽然进一步节省了存储空间，但在一些基本运算过程中，例如求某个顶点的入度，则必须遍历整个邻接表，在时间复杂度上并不如邻接矩阵优异。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">为了解决一些计算上的问题，还可以另外设置一个逆邻接表，就可以满足一些常用运算的需要。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">3、</span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">正交链表（十字链表）</span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">正交链表<span lang="EN-US">Orthogonal Lists</span>是<strong style="mso-bidi-font-weight: normal;">有向图</strong>的另一种存储结构，它在邻接表表示法所不擅长的有向图运算领域做到了很好的效果。其实质是将邻接表和逆邻接表结合起来形成的一种链表。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">正交链表的弧结点结构包括了<span lang="EN-US">tailvex</span>弧尾顶点位置、<span lang="EN-US">headvex</span>弧头顶点位置、<span lang="EN-US">hlink</span>指向与此弧的弧头相同的下一条弧、<span lang="EN-US">tlink</span>指向与此弧的弧尾相同的下一条弧、<span lang="EN-US">info</span>该弧的相关信息。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">其顶点结点包括了<span lang="EN-US">data</span>数据域、<span lang="EN-US">firstin</span>指向该顶点作为弧头的第一个弧结点、<span lang="EN-US">firstout</span>指向该顶点作为弧尾的第一个弧结点。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">4、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">邻接多重表</span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">邻接多重表<span lang="EN-US">Adjacency Multi_list</span>是<strong style="mso-bidi-font-weight: normal;">无向图</strong>的另外一种存储结构。这种结构相较于邻接表来说结构复杂，运算算法难度较高，但在处理无向图的边信息时却大大节省了算法时间，是一种高效的无向图存储表示。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">其边结点的结构包括了<span lang="EN-US">mark</span>标记该条边是否已被搜索、<span lang="EN-US">ivex/jvex</span>为该边依附的两个顶点在图中的位置、<span lang="EN-US">ilink</span>指向下一条依附于顶点<span lang="EN-US">ivex</span>的边、<span lang="EN-US">jlink</span>指向下一条依附于顶点<span lang="EN-US">jvex</span>的边、<span lang="EN-US">info</span>边信息。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">顶点结点结构包括了<span lang="EN-US">data</span>数据域、<span lang="EN-US">firstedge</span>指向第一条依附于该顶点的边。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">以上四种存储策略分别适用于不同的需求环境，具体应采取何种存储结构应按照实际情况而定。为统一起见今后我们涉及到图的基本运算时，一般以邻接矩阵和邻接表这两个基本结构为例。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">(</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">未完待续<span lang="EN-US">)</span></span></strong></span></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-13T16:49:46+08:00" pubdate data-updated="true">2009-02-13</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
		<span class="comments"><a href="/blog/2009/02/13/jia-qi-lian-zai-zhi-shi-san//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/12/jia-qi-lian-zai-zhi-shi-er-100/">
		
			假期连载之十二(100)</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">（树形结构—树和森林、哈夫曼树）<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">本篇为<span lang="EN-US">12</span>号的第三篇连载，基于时间、理论连贯性上的考虑，我们利用下午的时间完成了前两篇关于树的基本概念及其<span lang="EN-US">ADT</span>，二叉树及其相关等内容，现在我们介绍树形结构对基础概念的扩展—一般树，以及森林。最后我们会研究一种特殊的二叉树结构，它通常被人称为最优二叉树，是信息传输、数据压缩领域的重要工具。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树、森林和二叉树的关系<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">在一般树的条件下，分支个数是不定的，因此会出现所谓的多叉树。对于这种一般的树，我们就需要采用一种不同于二叉树二叉链表的存储表示。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo1; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表表示法<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表表示树是一种非常有效的方法，树中结点可以分三种：叶结点、根结点以及除根结点之外的其它非叶结点（也称分支结点）。因此在广义表中也可以有三种结点与之对应：原子结点、表头结点、子表结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">在子表结点内部，我们同样使用从上至下、从左至右的顺序对结点进行排序。其运算也是基于广义表的基本运算进行的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">我们在前面的连载中介绍了广义表的头尾链表和扩展线性链表等存储表示方法，并附加了相关基础运算，但必须注意的是，广义表在一些高级语言中能够特别方便地使用，这也是这种数据结构诞生的初衷，因此在其它高级语言中应尽量在实际应用中避免采用这种并不擅长的方式进行运算。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo1; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">父指针表示法<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">利用一组连续的空间来存储树中的结点，在保存每个结点的同时附设一个指示器来指示其父结点在表中的位置。这种结构易于求指定结点的父结点，但当求某结点的子女结点时需遍历结构数组。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo1; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">子女表示法<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">这种方法通常是把每个结点的子女结点排列起来，构成一个单链表，称其为子女链表。<span lang="EN-US">n</span>个结点共有<span lang="EN-US">n</span>个子女链表，其中叶子结点的子女链表为空。而<span lang="EN-US">n</span>个结点的数据和<span lang="EN-US">n</span>个子女链表的头指针又组成一个顺序表。这种结构适合需要频繁寻找子女结点的应用，并可以和父指针表示法结合，使寻找父结点或子女结点都很方便。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo1; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">4、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">子女<span lang="EN-US">-</span>兄弟表示法<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">这种方法是一种二叉树表示法，也被称为二叉链表表示法。其链表结点中包含三个结点域，分别指向该结点的第一个子女结点指针，指向下一个兄弟结点指针以及数据域。这种存储结构首先比较清晰地描绘了树形结构的容貌，同时非常方便实现树的各类操作。与以上三种表示法相比，子女兄弟表示法既在操作上容易实现了许多，且在空间和时间的效能上也具有一定优势。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">根据子女兄弟表示法的启示，我们发现一般树和二叉树均可以用二叉链表进行表示，换一个角度说，我们可以通过一定转换，将一般树按原二叉链表表示的序列转化为二叉树形式，且并不影响对树进行的各种基本运算的结果。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l3 level1 lfo2; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">树转换为二叉树<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">将一棵树转换为二叉树的方法是，将树中的所有兄弟结点之间加一条连线，对树中的每个结点，只保留其与第一个子女结点之间的连线，删去其与其它子女结点之间的连线。最后以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">可以证明，通过这种方法树转换成的二叉树是唯一的。而且此时二叉树的链表表示与树本身的子女<span lang="EN-US">-</span>兄弟表示法所生成的二叉链表完全一致，这时就可以展开对树的各种基本操作。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l3 level1 lfo2; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">森林转换为二叉树<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">森林是若干树的集合。那么采用如下方法可以将森林转换为二叉树表示：首先将森林中的每棵树转换成相应的二叉树，第一棵二叉树不动，从第二棵二叉树开始依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右子结点，当所有二叉树连在一起后，得到的二叉树即是由森林转换得到的二叉树。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l3 level1 lfo2; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">二叉树还原为树或森林<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">树转换成的二叉树，其特点是必无右子结点，而森林转换成的二叉树，其必含右子结点。根据以上特征区分还原的对象。然后按照以下方法还原二叉树：若某结点是其父结点的左子结点，则把该结点的右子结点、右子结点的右子结点、<span lang="EN-US">…</span>均与该结点的父结点用线连接起来。此时删除掉原二叉树中所有父结点与右子结点的连线，并加以整理即可。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">树与森林的遍历<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">基于前面建立的子女兄弟存储表示，我们可以得出树和森林的一般遍历算法，它们与二叉树的相关遍历算法有很深厚的联系。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">从大方面看，树与森林的遍历分为深度优先遍历和广度优先遍历两种。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l2 level1 lfo3; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">深度优先遍历</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">是一种与二叉树遍历类似的遍历算法<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 63pt; text-indent: -21pt; mso-list: l2 level2 lfo3; tab-stops: list 63.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">a)</span><span style="font: 7pt &quot;Times New Roman&quot;;">       </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">树的<strong style="mso-bidi-font-weight: normal;">先根遍历</strong>算法，类似于二叉树遍历的先序顺序。其结果与直接用先序遍历算法所演示的结果是相一致的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 63pt; text-indent: -21pt; mso-list: l2 level2 lfo3; tab-stops: list 63.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">b)</span><span style="font: 7pt &quot;Times New Roman&quot;;">       </span></span></span><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">后根遍历</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，实际上类似于二叉树遍历的后序顺序。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">我们以树的递归先根次序遍历算法为例，给出具体编程实现先根的两种方法：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">if(root!=NULL)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>Visit(root-&gt;data);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>p=root-&gt;FirstChild;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>while(p!=NULL)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span>RootFirst(p);<span style="mso-tab-count: 2;">       </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">访问以<span lang="EN-US">p</span>为根的子树<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>p=p-&gt;nextSibling;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">}//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">以上是方法一<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">if(root!=NULL)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>Visit(root-&gt;data);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>RootFirst(root-&gt;FirstChild);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>RootFirst(root-&gt;NextSibling);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">}//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">方法二消除了循环，也以递归的方式呈现<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">对于森林的遍历，一般也分先序遍历、中序遍历以及后序遍历，值得注意的是在森林的后序遍历中第一棵树的根结点应放在最后访问，以后其它各树的根结点依次倒数访问，这点需特别留意。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>2</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、<strong style="mso-bidi-font-weight: normal;">广度优先遍历</strong>是一种新的遍历方法，它是以结点的序号排列为顺序直接遍历的。在这种算法中并不存在递归结构，通常使用队列的方法，扫描至每一层时，将该层的所有结点入队，然后依次访问。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">哈夫曼树<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">哈夫曼树<span lang="EN-US">Huffman Tree</span>又称最优二叉树，是一类加权路径长度最短的二叉树。其在编码设计、决策和算法设计等领域有着广泛的应用。我们大家现今经常使用的图像格式<span lang="EN-US">JPEG</span>，就是一种基于<span lang="EN-US">DCT(</span>离散余弦变换<span lang="EN-US">)</span>和哈夫曼编码的有损高压缩比编码标准。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">我们首先给出哈夫曼树的一些概念。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">路径<span lang="EN-US">path</span>，指从树中一个结点到另一个结点之间的分支构成该两点之间的路径。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">路径长度<span lang="EN-US">path length</span>，指路径上的分支条数。树的路径长度一般指树的根结点到每个结点的路径长度之和。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">由树的定义可知，从根结点到达树中的每一个结点有且仅有一条路径。若设树的根结点位于第<span lang="EN-US">1</span>层，某结点处于第<span lang="EN-US">k</span>层，则其路径上的分支条数为<span lang="EN-US">k-1</span>，因此从根结点到其它各个结点的路径长度等于该结点所处的层次<span lang="EN-US">k-1</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">一般来说，当结点数相同时，越接近完全二叉树的结构其路径长度越短。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">定义一个带权路径长度<span lang="EN-US">Weighted Path Length(WPL)</span>，假设有<span lang="EN-US">n</span>个权值的集合中，若<span lang="EN-US">T</span>是一棵有<span lang="EN-US">n</span>个叶结点的二叉树，且将集合中的权值分别赋给<span lang="EN-US">T</span>的<span lang="EN-US">n</span>个叶结点，此时我们称<span lang="EN-US">T</span>是权值为相关值的扩充二叉树。带权结点被称为外结点，其余结点被称做内结点。外结点的带权路径长度为从<span lang="EN-US">T</span>的根到该结点的路径长度与该结点上权值的乘积。此时将整个扩充二叉树的带权路径长度定义为<span lang="EN-US">WPL</span>，就是每个外结点带权路径长度之和。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">我们把<span lang="EN-US">WPL</span>最小的扩充二叉树称为最优二叉树。在这种情况里，最小带权路径长度的扩充二叉树就不再一定是完全二叉树。从直观上看，最优二叉树应该是权值大的外结点离根结点越近的扩充二叉树，就是<span lang="EN-US">Huffman</span>树。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">构造哈夫曼树<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">构造哈夫曼树的算法是由<span lang="EN-US">Huffman</span>提出的，其基本思路为：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo4; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">根据给定的<span lang="EN-US">n</span>个权值，构造具有<span lang="EN-US">n</span>棵扩充二叉树的森林，其中每一棵二叉树都有一只权值为相关值的根结点，其左右子树为空。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo4; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">找最小树，在森林中选择两棵根结点权值最小的二叉树，作为一棵新二叉树的左右子树，标记新二叉树的根结点权值为其左右子树的根结点权值之和。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo4; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">删除与加入，从森林中删除被选中的那两棵二叉树，同时把新构成的二叉树加入到森林中。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo4; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">4、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">判断，重复<span lang="EN-US">2</span>、<span lang="EN-US">3</span>步骤，直到森林中只含有一棵二叉树时为止。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">程序构建哈夫曼树，首先须确定一个静态三叉链表的结点结构，这种结点由四个域构成：分别是权值域、父结点序号、左子结点序号以及右子结点序号。为了计算方便，<span lang="EN-US">0</span>号单元不用，从<span lang="EN-US">1</span>号开始使用，程序也按照静态链表的构建方法进行。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">哈夫曼编码<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">构造哈夫曼树的实质还是为了求哈夫曼编码。通常计算机中存储的图形符号是以二进制码进行处理的。例如<span lang="EN-US">ASCII</span>码就是一种<span lang="EN-US">8</span>位二进制编码，且还是一种定长编码。为了压缩数据存储空间，有必要采用不定长编码的方式进行编码。首先介绍几个概念：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、<strong style="mso-bidi-font-weight: normal;">前缀码</strong>，如果在一个编码系统中，任一个编码都不是其它任何编码的前缀（即最左子串），则成该编码系统中的编码是前缀码。例如一组编码<span lang="EN-US">01</span>，<span lang="EN-US">001</span>，<span lang="EN-US">010</span>，<span lang="EN-US">100</span>，<span lang="EN-US">110</span>就不是前缀码，因为<span lang="EN-US">01</span>是<span lang="EN-US">010</span>的前缀，去掉其中之一后即为前缀码。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">如果采用前缀码，我们就可以在各字符对应的编码之间不需要分隔符。如果非前缀码，不使用分隔符则会产生二义性。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、<strong style="mso-bidi-font-weight: normal;">哈夫曼编码</strong>，对一棵具有<span lang="EN-US">n</span>个叶子的哈夫曼树，若对树中的每个左分支赋予<span lang="EN-US">0</span>，右分支赋予<span lang="EN-US">1</span>，则从根到每个叶子的通路上，各分支的赋值分别构成一个二进制串，该二进制串即位哈夫曼编码。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">求解哈夫曼编码的方法也有很多，一般而言，我们首先根据带权结点构建哈夫曼树，此时将哈夫曼树的左分支标记为<span lang="EN-US">0</span>，右分支标记为<span lang="EN-US">1</span>，根结点不计，我们从根结点出发，把抵达相关叶结点的路径按先后顺序编码，则就构成了哈夫曼编码。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">在实际编程中，对<span lang="EN-US">0</span>和<span lang="EN-US">1</span>的赋值是在求编码的算法中直接进行判断的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">（未完待续）<span lang="EN-US"></span></span></span></strong></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-12T21:19:53+08:00" pubdate data-updated="true">2009-02-12</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
		<span class="comments"><a href="/blog/2009/02/12/jia-qi-lian-zai-zhi-shi-er-100//posts/15/index.html#disqus_thread">Comments</a></span>
	
</div></article>

<nav id="pagenavi">
    
    	
        	<a href="/posts/14" class="prev">Prev</a>
        
    
    
        <a href="/posts/16" class="next">Next</a>
    
    <div class="center"><a href="/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2018

    Han Yi

<br>
Powered by Octopress.
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'hanyi';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-49392954-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>
