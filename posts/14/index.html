
<!DOCTYPE HTML>
<html>
<head>
	<script data-cfasync="false" type="text/javascript" src="//use.typekit.net/axj3cfp.js"></script>
	<script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
	<meta charset="utf-8">
	<title>  | Wing of Dream 梦境之翼</title>

<meta name="author" content="Han Yi"> 

<meta name="description" content="(树形结构—树的基本概念及抽象数据类型)       树形结构的亮点在于其应用广泛。尽管本节仅介绍概念以及理论上的内容，但无论如何都不能忽视对实际应用的渗入，否则将失去其本身研究的意义。       树的基本概念       在计算机科学中，树作为组织信息的重要形式之一， &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Wing of Dream 梦境之翼" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el, 
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	
</head>



<body>
	<header id="header" class="inner"><h1><a href="/">Wing of Dream 梦境之翼</a></h1>
<h4></h4>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:www.hanyi.name">
			</form>
		</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/12/jia-qi-lian-zai-zhi-shi/">
		
			假期连载之十</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">(</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树形结构—树的基本概念及抽象数据类型<span lang="EN-US">)</span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树形结构的亮点在于其应用广泛。尽管本节仅介绍概念以及理论上的内容，但无论如何都不能忽视对实际应用的渗入，否则将失去其本身研究的意义。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树的基本概念<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">在计算机科学中，树作为组织信息的重要形式之一，代表了非线性数据结构的一般特征。这里有两种基本的树，一种被称为自由树<span lang="EN-US">free tree</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">自由树</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">指定义一个二元组<span lang="EN-US">Tf=(V,E)</span>，其中<span lang="EN-US">V={v1,v2,…,vn}</span>是由<span lang="EN-US">n</span>个结点构成的优先集合<span lang="EN-US">(n&gt;=0)</span>，称为顶点集合<span lang="EN-US">vertex</span>，<span lang="EN-US">vi</span>称为顶点，其中<span lang="EN-US">1&lt;=i&lt;=n</span>。<span lang="EN-US">E={(vi,vj)|vi,vj</span>属于<span lang="EN-US">V</span>，且<span lang="EN-US">i&gt;=1,j&lt;=n}</span>是由<span lang="EN-US">n-1</span>个元素组成的序对集合，称为边集合。<span lang="EN-US">E</span>中的元素<span lang="EN-US">(vi,vj)</span>为边<span lang="EN-US">edge</span>的分支<span lang="EN-US">branch</span>。<span lang="EN-US">E</span>使得<span lang="EN-US">Tf</span>成为一个连通图。综上可知，自由树的概念类似于图，且对其讨论的范围仅限于图论部分的内容，本文不作涉及。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">另一种树称为<strong style="mso-bidi-font-weight: normal;">有根树</strong><span lang="EN-US">rooted tree</span>。一棵有根树<span lang="EN-US">T</span>，简称为树，它是由<span lang="EN-US">n&gt;=0</span>个结点的有限集合。当<span lang="EN-US">n=0</span>时，<span lang="EN-US">T</span>称为空树，否则<span lang="EN-US">T</span>是非空树，记作：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span><span style="mso-spacerun: yes;">   </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">Φ<span lang="EN-US">,<span style="mso-tab-count: 3;">          </span>n=0</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">T={r,T1,…,Tn},n&gt;0</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">其中<span lang="EN-US">r</span>是<span lang="EN-US">T</span>的一个特殊结点，称为根<span lang="EN-US">root</span>。<span lang="EN-US">T1,…,Tn</span>是除<span lang="EN-US">r</span>之外其它结点构成的互不相交的<span lang="EN-US">m&gt;=0</span>个子集合。每个子集合也是一棵树，称为根的子树<span lang="EN-US">subtree</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">每棵子树的根结点有且仅有一个直接前驱，但可以有<span lang="EN-US">0</span>个或多个直接后继，<span lang="EN-US">m</span>称为<span lang="EN-US">r</span>的分支数。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">在计算机系统和其它领域中，树的表示方法不尽相同。基本上有以下几种方法：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">倒置树结构，即最常用的树形表示方法。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">文氏图表示法，使用嵌套集合的形式。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表形式，即嵌套括号的表示方法。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">4、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">凹入表示法，用位置的缩进表示其层次，如目录表的编排格式。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">树的一些基本术语<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">结点<span lang="EN-US">node</span>，包含一个数据元素及若干指向其它结点的分支信息。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">结点的度<span lang="EN-US">degree</span>，是一个结点所拥有的子树的棵数。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">叶结点<span lang="EN-US">leaf</span>，指度为<span lang="EN-US">0</span>的结点，也称为终端结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">分支结点<span lang="EN-US">branch</span>，除叶结点以外的其它结点，也称为非终端结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">结点层次<span lang="EN-US">level</span>，从根结点开始，根结点层次为<span lang="EN-US">1</span>，根结点的直接后继层次为<span lang="EN-US">2</span>，依次类推。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">结点的层序编号<span lang="EN-US">No.of node</span>，是指按从上层到下层，同层从左至右的顺序对结点以自然数编号。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">树的度<span lang="EN-US">degree</span>，树中所有结点度的最大值。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">树的高度<span lang="EN-US">height</span>，树中所有结点层次的最大值。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">有序树<span lang="EN-US">ordered tree</span>，在树<span lang="EN-US">T</span>中，若各子树<span lang="EN-US">Ti</span>之间是有先后次序的，称为有序树。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">森林<span lang="EN-US">forest</span>，指<span lang="EN-US">m&gt;=0</span>棵不相交的树的集合。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">同构<span lang="EN-US">isomorphism</span>，对于两棵树，通过对结点适当地重命名，就可以使两棵树完全相等，则称这两棵树同构。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">为了描述结点之间层次关系，我们还借助人类家族术语进行定义：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">子女结点<span lang="EN-US">child</span>，一个结点的直接后继称为这个结点的<span lang="EN-US">child</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">父结点<span lang="EN-US">parent</span>，一个结点的直接前驱称为这个结点的<span lang="EN-US">parent</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">兄弟结点<span lang="EN-US">sibling</span>，同一双亲结点的子女结点之间互称为<span lang="EN-US">sibling</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">祖先结点<span lang="EN-US">ancestor</span>，一个结点的祖先结点是指从根结点到该结点路径上的所有结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">子孙结点<span lang="EN-US">descendant</span>，一个结点的直接后继和间接后继称为该结点的子孙结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">另外，按照结点序号的大小，结点又可以前辈、后辈表示，父结点为兄弟结点的子女结点之间互称为堂兄弟结点。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">树的抽象数据类型<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">ADT Tree</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">数据对象<span lang="EN-US">D:</span>一个集合，该集合中的所有元素具有相同特性<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">数据关系<span lang="EN-US">R:</span>见树的定义<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">基本操作<span lang="EN-US">:</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>InitTree(Tree);<span style="mso-tab-count: 4;">             </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">初始化<span lang="EN-US">Tree</span>为空树<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>DestoryTree(Tree);<span style="mso-tab-count: 3;">          </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">销毁树<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>CreateTree(Tree);<span style="mso-tab-count: 3;">           </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">创建树<span lang="EN-US">Tree</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>TreeEmpty(Tree);<span style="mso-tab-count: 3;">            </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">若<span lang="EN-US">Tree</span>为空，返回<span lang="EN-US">TRUE</span>，否则返回<span lang="EN-US">FALSE</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>Root(Tree);<span style="mso-tab-count: 5;">                 </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">返回树<span lang="EN-US">Tree</span>的根<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>Parent(Tree,x);<span style="mso-tab-count: 4;">             </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树<span lang="EN-US">Tree</span>存在，<span lang="EN-US">x</span>是<span lang="EN-US">Tree</span>中的某个结点，若<span lang="EN-US">x</span>为非根结点，则返回其父结点，否则返回空<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>FirstChild(Tree,x);<span style="mso-tab-count: 3;">         </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树<span lang="EN-US">Tree</span>存在，<span lang="EN-US">x</span>是<span lang="EN-US">Tree</span>中的某个结点，若<span lang="EN-US">x</span>为非叶结点，则返回其第一个孩子结点，否则返回空<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>NextSibling(Tree,x);<span style="mso-tab-count: 2;">        </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树<span lang="EN-US">Tree</span>存在，<span lang="EN-US">x</span>是<span lang="EN-US">Tree</span>中的某个结点，若<span lang="EN-US">x</span>为不是父结点的最后一个子女结点，则返回其下一个兄弟结点，否则返回空<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>InsertChild(Tree,p,Child);<span style="mso-tab-count: 1;">  </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树<span lang="EN-US">Tree</span>存在，<span lang="EN-US">p</span>指向<span lang="EN-US">Tree</span>中的某个结点，非空树<span lang="EN-US">Child</span>与<span lang="EN-US">Tree</span>不相交，将<span lang="EN-US">Child</span>插入<span lang="EN-US">Tree</span>中，其中<span lang="EN-US">p</span>是该子树的根结点<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 42pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">DeleteChild(Tree,p,i);<span style="mso-tab-count: 2;">      </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树<span lang="EN-US">Tree</span>存在，<span lang="EN-US">p</span>指向<span lang="EN-US">Tree</span>中的某个结点<span lang="EN-US">1&lt;=i&lt;=d</span>，<span lang="EN-US">d</span>为<span lang="EN-US">p</span>所指向结点的度，删除<span lang="EN-US">Tree</span>中<span lang="EN-US">p</span>所指向结点的第<span lang="EN-US">i</span>棵子树<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 42pt; mso-char-indent-count: 4.0;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">TraverseTree(Tree,Visit());<span style="mso-tab-count: 1;"> </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">树<span lang="EN-US">Tree</span>存在，<span lang="EN-US">Visit()</span>是对结点进行访问的函数，按照某种次序对<span lang="EN-US">Tree</span>的每个结点调用<span lang="EN-US">Visit()</span>函数最多访问一次，若<span lang="EN-US">Visit()</span>失败，则操作失败<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">鉴于树结构重要性，我们将本块内容分成多个连载分别进行讨论，方便读者进行整理。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">(</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">未完待续<span lang="EN-US">)</span></span></strong></span></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-12T14:06:35+08:00" pubdate data-updated="true">2009-02-12</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/11/jia-qi-lian-zai-zhi-jiu/">
		
			假期连载之九</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">（数组和广义表）<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">本节介绍线性表的两个推广结构—数组和广义表，这也是线性结构和表结构部分最后两个重要内容。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">数组<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">我们在介绍线性表基本存储结构时曾提到数组，这是因为在大多数高级程序设计语言中，数组即被用来表示一段连续的存储空间，它对一般线性表的概念和原理起到了很好的诠释作用。但是，在很多工程领域中，数组并不单以一维数组的形态出现，我们大量接触到了二维甚至是三维数组，它们通常是计算机图形学、工业设计、医疗等领域的计算工具。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">本部分内容重点介绍多维数组的计算及其内部存储实现。<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">数组是由下标<span lang="EN-US">index</span>和值<span lang="EN-US">value</span>组成的序对的集合。在数组中，每个有定义的下标都有一个值对应，这个值被称作数组元素。前面的讲解中曾介绍过<span lang="EN-US">C++</span>独特的静态数组和动态数组，在其它一些高级语言中数组的定义也是大同小异，例如在<span lang="EN-US">Visual Basic</span>中还可以定义变长的数组。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">二维数组，其数学模型实际上就是矩阵。相对于一维数组给定下标值即可唯一确定一个元素，以及该元素的直接前驱和直接后继，二维数组需要同时给定两个下标值，且其直接前驱分为<span lang="EN-US">x</span>向和<span lang="EN-US">y</span>向两类。例如对于二维数组<span lang="EN-US">a[m][n]</span>，元素<span lang="EN-US">a[j][k]</span>的直接前驱分别为<span lang="EN-US">a[j-1][k]</span>和<span lang="EN-US">a[j][k-1]</span>，其直接后继分别为<span lang="EN-US">a[j+1][k]</span>和<span lang="EN-US">a[j][k+1]</span>。因此可以把二维数组可以看作最简单的非线性结构。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">对于任意三维数组<span lang="EN-US">a[m][n][o]</span>，我们先将<span lang="EN-US">a</span>看作一维数组<span lang="EN-US">a[m]</span>，其中任意元素<span lang="EN-US">a[j]</span>中还存在一个二维数组，相应地，其直接前驱和直接后继就有三个。上述结论推广至<span lang="EN-US">n</span>维数组，其直接前驱与后继个数即为<span lang="EN-US">n</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">多维数组的存储表示<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">多维数组之所以复杂，是因为在计算机存储内部并没有真正涉及到多维数组存储，其存储表示是基于一维数组来实现的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">一般地对于一维数组<span lang="EN-US">a[n]</span>，若设它的第一个数组元素的存储起始地址为<span lang="EN-US">a</span>，每一个数组元素的存储大小为<span lang="EN-US">l</span>，则任一数组元素的存储地址<span lang="EN-US">LOC(i)</span>可以用如下的递推公式计算：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">            </span>a<span style="mso-tab-count: 2;">       </span>,i=0</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>LOC(i)={LOC(i-1),i&gt;1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">因此有：<span lang="EN-US">LOC(i)=LOC(i-1)+l=a+i*l</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">对于二维数组<span lang="EN-US">a[n][m]</span>，为能根据它们的数组元素的下标计算出在相应一维数组种对应的下标，需要区分两种存储方式，即行优先顺序和列优先顺序。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">按照行优先顺序，所有数组元素按行向量排列，第<span lang="EN-US">i+1</span>个行向量紧跟在第<span lang="EN-US">i</span>个行向量后面，这样得到数组元素存于一维数组的一种线性序列。这种行优先策略被使用在如<span lang="EN-US">ALGOL</span>、<span lang="EN-US">PASCAL</span>、<span lang="EN-US">C/C++</span>、<span lang="EN-US">BASIC</span>和<span lang="EN-US">Ada</span>等多数高级语言中。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">相应地，存在一种按列优先的顺序，所有数组元素按列向量依次排列。<span lang="EN-US">FORTRAN</span>语言即是以此为策略实现二维数组的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">现在我们以行优先顺序为例，讨论二维数组地址的映射方法。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">设二维数组<span lang="EN-US">a[n][m]</span>的第一个元素<span lang="EN-US">a[0][0]</span>存于相应一维数组的第一个位置，其地址为<span lang="EN-US">a</span>，每个元素占<span lang="EN-US">1</span>大小的空间，根据一维数组元素<span lang="EN-US">a[j][k]</span>地址计算公式：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">LOC(j,k)=LOC(j,0)+k</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>=LOC(j-1)+m+k</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>…</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>=LOC(0,0)+j*m+k</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>=a+j*m+k</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">以上就是二维数组对一维数组元素地址的映射公式。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">对于三维数组<span lang="EN-US">a[m][n][o]</span>，其优先顺序就不简单地判定为“谁优先”的问题，而是分优先级别。假设<span lang="EN-US">m</span>为页号，<span lang="EN-US">n</span>、<span lang="EN-US">o</span>分别为页内二维数组的行列号，则有页最优先，其次为行优先的策略，同样可能共有六种不同的顺序。我们先以第一种策略为例计算其对一维数组元素地址的映射公式：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">LOC(i,j,k)=LOC(i,0,0)+j*o+k</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span><span style="mso-spacerun: yes;">  </span>=LOC(i-1,0,0)+n*o+j*o+k</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span><span style="mso-spacerun: yes;">  </span>…</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span><span style="mso-spacerun: yes;">  </span>=LOC(0,0,0)+i*m*o+j*o+k</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span><span style="mso-spacerun: yes;">  </span>=a+i*m*o+j*o+k</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">推广至<span lang="EN-US">n</span>维数组<span lang="EN-US">a[m1]…[mn]</span>来说，设其第一个数组元素<span lang="EN-US">a[0]…[0]</span>在相应一维数组中也是第一个位置，其下标为<span lang="EN-US">a</span>，优先顺序随着下标维数增大而逐渐变小，则一个数组元素<span lang="EN-US">a[i1]…[in]</span>在相应一维数组中的存储地址为：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">LOC(i1,i2,…,in)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 15.75pt; mso-char-indent-count: 1.5;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">=LOC(0,0,…,0)+i1*m2*m3…*mn+i2*m3*m4…*mn+…+in</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 15.75pt; mso-char-indent-count: 1.5;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">特殊矩阵<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">矩阵操作是多维数组最广泛的应用。矩阵的知识最初介绍于大学理工类科目基础课程线性代数中，它是科学计算、工程数学，尤其是数值分析经常研究的对象。而在一些高级矩阵中，存在大量<span lang="EN-US">0</span>元素，使得非零元素极少（远小于<span lang="EN-US">m*n</span>），如果仍然根据普通数组存储顺序存放，将造成存储空间的很大浪费。基于节省存储空间的考虑，我们进一步讨论特殊矩阵的内部规律，以及利用这些规律制定策略，实现压缩存储，达到提高存储空间利用率的目的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span><strong style="mso-bidi-font-weight: normal;">1</strong></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、对称矩阵<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">对于特殊矩阵的研究通常基于两点，一是矩阵内部元素的分布有明显规律，二是矩阵内部非零元素个数远小于<span lang="EN-US">m*n</span>。对称矩阵即属于第一种情况。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">在一个<span lang="EN-US">n</span>阶方阵<span lang="EN-US">A</span>中，对<span lang="EN-US">A</span>中任意元素<span lang="EN-US">a[i][j]</span>有<span lang="EN-US">i&lt;j</span>时，<span lang="EN-US">aij=c(</span>通常<span lang="EN-US">c=0)</span>，则称其为下三角矩阵，相反地为上三角矩阵。对于三角阵其元素包括了对角线以及对角线一边的元素，其个数共有<span lang="EN-US">n+(n-1)+…2+1=n(n-1)/2</span>。要压缩存储矩阵，即只要存储三角阵中非零一边的元素即可，其核心实际上为三角阵对一维数组元素地址的映射问题。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">同样以行优先为顺序，当只存储下三角部分时，对于<span lang="EN-US">i&gt;j</span>时的任意元素<span lang="EN-US">aij</span>，其前方有<span lang="EN-US">i</span>行的元素及<span lang="EN-US">i+1</span>行的前<span lang="EN-US">j</span>个元素，则其地址事实上可以转换为简单的求和公式：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>LOC(i,j)=1+2+3+…+i+j=i*(i+1)/2+j</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">对于对称矩阵，可以据此求出未被实际存储的元素<span lang="EN-US">aji</span>的值：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>LOC(i,j)=LOC(j,i)=(j+1)*j/2+i</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">当存储上三角矩阵时，第<span lang="EN-US">0</span>行存放<span lang="EN-US">n</span>个元素，第<span lang="EN-US">i+1</span>行从<span lang="EN-US">aii</span>算起，<span lang="EN-US">aij</span>前共有<span lang="EN-US">j-i</span>个元素，则其地址映射公式为：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>LOC(i,j)=n+n-1+…+n-i+1+j-i=(2n-i+1)*i/2+j-i=(2n-i-1)*i/2+j</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">则当<span lang="EN-US">i&gt;j</span>时的对称矩阵元素<span lang="EN-US">aji</span>的值可由以下公式求得：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>LOC(i,j)=LOC(j,i)=(2n-j-1)*j/2+i</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span><strong style="mso-bidi-font-weight: normal;">2</strong></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、带状矩阵<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">带状矩阵实际上是一种特殊的稀疏矩阵，其元素一般分布在主对角线为中心的带状区域内。其中最常见的是三对角带状矩阵。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">三对角线矩阵中，除了主对角线及其左右两条对角线的元素外，其余元素值均为<span lang="EN-US">0</span>。对于三对角线矩阵的压缩存储，其实质和三角矩阵相比并无太大区别。依然以行优先为顺序，三对角线矩阵的非零元素个数为<span lang="EN-US">3n-2</span>。<strong style="mso-bidi-font-weight: normal;">由此推广至多对角线矩阵存储，假设主对角线一侧分别有<span lang="EN-US">b</span>条次对角线包含非零元素</strong>，据此求得多对角线矩阵的非零元素个数为<span lang="EN-US">n+2(n-1+n-2+…+n-b)=n+b(2n-b-1)=(2b+1)n-b-b*b</span>。对于求带状矩阵对一维数组元素地址的映射公式，我们要基于以下三种情况分别考虑：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">当<span lang="EN-US">1&lt;=i&lt;=b</span>时，此时元素属于矩阵的上部区域。则元素<span lang="EN-US">aij</span>的定位：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>LOC(i,j)=b+1+b+2+b+3+…+b+i-1+j-1=(2b+i)(i-1)/2+j-1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">当<span lang="EN-US">b&lt;i&lt;n-b+1</span>时，元素处于矩阵的中部区域。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>LOC(i,j)=(b+1)+(b+2)+(b+3)+…+(b+b)+(i-b-1)(2b+1)+j-i+b=(3b+1)b/2+(i-b-1)(2b+1)+j-i+b</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">当<span lang="EN-US">n-b+1&lt;=i&lt;=n</span>时，元素处于矩阵的下部区域，则：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>LOC(i,j)=(3b+1)/2+(n-2b)(2b+1)+(3b-i+n+2)(i-n+b-1)/2+j-i+b</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">综上即可求出各种情况下按行优先的带状矩阵对一维数组元素的映射地址。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">特殊地，对于三对角线矩阵，公式简化为：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>LOC(i,j)=2(i-1)+j-1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span><strong style="mso-bidi-font-weight: normal;">3</strong></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、稀疏矩阵<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">稀疏矩阵<span lang="EN-US">Sparse Matrix</span>是非零元素个数远小于零元素个数的一类矩阵的统称。大多数的稀疏矩阵其非零元素分布上一般无规律可循。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">一般在<span lang="EN-US">n*m</span>矩阵中定义一个稀疏因子δ，其非零元素个数为<span lang="EN-US">t</span>，有δ<span lang="EN-US">=t/(m+n)</span>，当δ<span lang="EN-US">&lt;0.05</span>时可以认为该矩阵为稀疏矩阵。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">为了合理表示和存储稀疏矩阵，一般采取三元组表的方法。对于稀疏矩阵只存储非零元素，则先定义一个三元组结构：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>#define MaxSize 1000<span style="mso-tab-count: 2;">        </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">非零元素的个数最多为<span lang="EN-US">1000</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>typedef struct</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span>int row,col;<span style="mso-tab-count: 3;">            </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">记录了非零元素在原矩阵中的行号、列号<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span>ElementType e;<span style="mso-tab-count: 3;">          </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">值<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}Triple;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">再根据此结构建立三元组表<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">typedef struct</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>Triple data[MaxSize+1];<span style="mso-tab-count: 1;"> </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">设定三元组表，<span lang="EN-US">data[0]</span>未用<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>int m,n,len;<span style="mso-tab-count: 3;">            </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">记录矩阵的行数、列数以及非零元素的个数<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">稀疏矩阵的转置运算<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">矩阵转置是指变换元素位置，使位于<span lang="EN-US">(row,col)</span>上的元素与<span lang="EN-US">(col,row)</span>上的元素进行互换，即行列互换运算。这是矩阵的一种基本运算形式。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">稀疏矩阵由于其特殊的存储结构，转置操作就与普通矩阵转置有很大不同。我们先来看一般矩阵的经典转置算法：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">TransMatrix(ElementType source[m][n]</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，<span lang="EN-US">ElementType dest[n][m])</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>int i,j;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>for(i=0;i&lt;m;i++)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>for(j=0;j&lt;n;j++)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">            </span>dest[j][i]=source[i][j];</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">显然稀疏矩阵的三元组表形式无法使用经典算法转置。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">有一种简单的转置方法，首先把三元组表中元素的<span lang="EN-US">row</span>和<span lang="EN-US">col</span>值互换，然后按新<span lang="EN-US">row</span>值递增序列重新排序。此方法理论上达到了转置的目的，但排序效率较低，并不是合适的转置算法。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">一般来说三元组表的转置有两种普遍算法：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、“列序”递增转置法<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">算法开始按照<span lang="EN-US">col</span>列序为<span lang="EN-US">1</span>，行序递增的顺序从头到尾找出转置后的第一行元素，行列值互换后存入<span lang="EN-US">dest</span>，然后再从头到尾按列序位<span lang="EN-US">2</span>，行序递增的顺序重复操作<span lang="EN-US">……</span>直到找出第<span lang="EN-US">k</span>行全部元素，其中<span lang="EN-US">1&lt;=k&lt;=n</span>。程序主体为双循环结构：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">for(k=1;k&lt;=A.n;k++)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>for(i=1;i&lt;A.len;i++)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">互换<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span>j++;//j</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">值储存的是<span lang="EN-US">dest</span>中下一个转置后元素的位置下标<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">该算法的时间复杂度为<span lang="EN-US">O(A.n*A.len)</span>，最坏情况时<span lang="EN-US">A.n*A.m=A.len</span>，即全部为非零元素，则时间复杂度为<span lang="EN-US">O(A.m*A.n*A.n0)</span>，反而远高于经典算法的<span lang="EN-US">O(A.m*A.n)</span>，因此此算法仅适用于三元组表转置。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">、“一次定位快速转置”法<span lang="EN-US"></span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">现在对第一种算法进行性能优化，突破点在消除双重循环上。<strong style="mso-bidi-font-weight: normal;">我们从前几节的连载中得到一种经验，在类似于将一种结构按一定规律转化为另一种结构的过程中，如果要进行性能优化，就必须深入探究原有结构内部的规律，凭借此规律取得的一部分资源，恰可以替代外层循环的作用</strong>。例如连载七中对字符串简单模式匹配算法的改进算法<span lang="EN-US">KMP</span>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">现在我们分析三元组表，根据此表的分析我们可以得出两个有益的信息：一是转置后每行非零元素的个数，二是转置后每行第一个非零元素的位置。这两个信息足以达到消除一层循环的目的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">设<span lang="EN-US">num[col]</span>记录三元组表<span lang="EN-US">col=1,2,…,n</span>中元素的个数，<span lang="EN-US">position[col]</span>记录三元组表<span lang="EN-US">col=1,2,…,n</span>中第一个元素在表中的下标值。算法程序主体为单循环结构（我们省略了计算两个辅助数组的部分）：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">for(p=1;p&lt;=A.len;p++)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">该方法的原理是，由于转置后每列第一个非零元素必然在三元组表中优先出现，因此直接与<span lang="EN-US">position</span>在相应列的位置配对，算法结束后相应位置加<span lang="EN-US">1</span>以便放入该列内的剩余元素<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>col=A.data[p].col;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>q=position[col];</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>//dest[q]</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">与<span lang="EN-US">A.data[p]</span>互换数值<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>position[col]++;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">实际程序中由于数组初始化等因素，共用到四个单循环，总的时间复杂度为<span lang="EN-US">O(A.n+A.len)</span>，较第一种方法而言在性能上有了很大提高，但也必须看到，由于所需存储空间增加，事实上说明<strong style="mso-bidi-font-weight: normal;">算法在时间上的节省是以更多的存储空间为代价</strong>。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">稀疏矩阵的正交链表存储<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">这里我们忽略了三元组表中对于稀疏矩阵四则运算操作的实现，这是因为矩阵加减法较为简单，而乘法虽然规则清晰，但由于依然涉及到遍历的问题，有时甚至需要三重循环来实现运算，较为复杂，且不符合本次系列连载的目的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">但矩阵运算所带来的问题却不容忽视，尤其是其对三元组表可能发生元素值的修改、元素个数的增减等等复杂运算。为了更有利于实际应用，有时候稀疏矩阵使用正交链表的存储形式，也称“十字链表”。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">稀疏矩阵的正交链表结点共有六个域，分别为<span lang="EN-US">row</span>、<span lang="EN-US">col</span>、<span lang="EN-US">down(</span>链接列链表中下一个结点<span lang="EN-US">)</span>、<span lang="EN-US">right(</span>链接行链表中下一个结点<span lang="EN-US">)</span>、<span lang="EN-US">head</span>（是否为附加头结点）、<span lang="EN-US">value</span>。因此正交链表其实就是将矩阵的每一行与每一列分别建立链表，逻辑上是“十字交叉”状的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表同样作为线性表的一种推广，但更准确地讲，广义表才能真正意义上被称为“表”，线性表可以被当作一种特殊的表，但在实际中往往可能特殊的结构反而更容易被广泛使用。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表<span lang="EN-US">generalized list</span>长期以来主要用于人工智能领域的研究，向前继承了离散数学的部分内容。在<span lang="EN-US">List processor</span>语言<span lang="EN-US">LISP</span>中，其表达式就是用表的形式来实现的。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表的显著特点是允许表中有表，广义表也是一组有限的序列，表中第一个元素被称为广义表表头<span lang="EN-US">head</span>，除此之外的其它元素所组成的表称作表尾<span lang="EN-US">tail</span>。下面给出一些广义表的实例：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">D=()</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，空表，长度为<span lang="EN-US">0</span>；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">A=(a,(b,c))</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，表长度为<span lang="EN-US">2</span>，表头为<span lang="EN-US">a</span>，表尾为<span lang="EN-US">((b,c))</span>；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">B=(A,A,D)</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，长度为<span lang="EN-US">3</span>，表头为<span lang="EN-US">A</span>，第三个元素为空表<span lang="EN-US">D</span>；<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">C=(a,C)</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，表长为<span lang="EN-US">2</span>的递归定义的广义表，<span lang="EN-US">C</span>相当于无穷表。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">由上可得出广义表的五个性质：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo1; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">有次序性</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，因为表中元素是按线性排列的，其前驱、后继关系依然存在。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo1; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">有长度</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，广义表元素的个数是一定的，不能是无限长，且可以为空。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo1; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">有深度</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，广义表的元素可以是原表的子表，子表的元素还可以是子表<span lang="EN-US">……</span>从而形成多层次结构。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo1; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">4、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">可递归的</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，广义表本身可以是自己的子表。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l1 level1 lfo1; tab-stops: list 39.0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">5、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">可共享的</span></strong><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">，广义表可以被其它表共享。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表存储结构的实现<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">由于广义表本身结构的不确定性，因此凭借顺序结构很难对其进行表示，因此一般使用链式存储结构来表示。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo2; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表的头尾链表存储结构<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表链式存储的结点分为两类，一类是单个元素结点，其结点由标志域和值域构成；另一类是子表结点，其结点由标志域、指向标头的指针域和指向表尾的指针域构成。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">现在给出<span lang="EN-US">C</span>语言描述的广义表头尾链表存储结构的类型定义：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">typedef enum{ATOM,LIST} ElemTag;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">typedef stuct GLNode</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>ElemTag tag;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>union</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>AtomType atom;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>struct</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 4;">                </span>struct GLNode *hp,*tp;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}htp;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}atom_htp;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}GLNode,*Glist;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo2; tab-stops: list 39.0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体;" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;"> </span></span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表的扩展线性链表存储结构<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">扩展线性链表存储结构的特点是，其子表结点和元素结点均由三个域构成：标志域、表头指针<span lang="EN-US">/</span>值域、表尾指针。在两种表示形式中需要注意，标志域虽然为<span lang="EN-US">enum</span>型，但实际默认<span lang="EN-US">ATOM</span>为<span lang="EN-US">0</span>，<span lang="EN-US">LIST</span>为<span lang="EN-US">1</span>，在绘制结构图时需要特别注意。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">广义表的递归运算<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">由于广义表的递归性，因此很多关于广义表的基本运算也是递归的。我们省略了取表头、表尾、长度等几个较简单的运算，直接举例求解广义表深度的<span lang="EN-US">C</span>语言算法描述：<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">int Depth(Glist L)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>int d,max;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>GLNode *x;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>if(L==NULL)<span style="mso-tab-count: 3;">         </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">为空表，默认为深度为<span lang="EN-US">1</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>return 1;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>if(L-&gt;tag==ATOM)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">        </span>return 0;<span style="mso-tab-count: 2;">       </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">元素结点深度为<span lang="EN-US">0</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>s=L;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>max=0;<span style="mso-tab-count: 4;">              </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">初始化表<span lang="EN-US">/</span>子表深度值<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>while(s!=NULL)<span style="mso-tab-count: 2;">      </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">求每个子表的最大深度值，回溯结束后即为最深子表的深度<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">    </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>d=Depth(s-&gt;atom_htp.htp.hp);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>if(d&gt;max)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">            </span>max=d;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">        </span>s=s-&gt;atom_htp.htp.tp;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">    </span>return max+1;<span style="mso-tab-count: 2;">       </span>//</span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">最终深度等于最深子表的深度加<span lang="EN-US">1</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">现在，我们已经介绍了简单数据结构线性表部分的全部内容，按照计划，后面的几期连载将继续介绍几种简单的数据结构。近期会制定总结出返校后本连载的内容方向，以及其它一些内容。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">（未完待续）<span lang="EN-US"></span></span></span></strong></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-11T20:26:19+08:00" pubdate data-updated="true">2009-02-11</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/10/jia-qi-lian-zai-zhi-ba/">
		
			假期连载之八</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">本篇为连载七未完成内容的后续补充部分。我们继续讨论关于字符串的一些问题，最后将对</span><span lang="EN-US"><span style="font-family: Times New Roman;">STL</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中关于</span><span lang="EN-US"><span style="font-family: Times New Roman;">String</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的部分进行一些说明。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">字符串的模式匹配</span><span lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">字符串的模式匹配问题描述如下：设有两个字符串</span><span lang="EN-US"><span style="font-family: Times New Roman;">pat</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">和</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，若打算在串</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中查找是否有与串</span><span lang="EN-US"><span style="font-family: Times New Roman;">pat</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">相等的字串，则称串</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为目标</span><span lang="EN-US"><span style="font-family: Times New Roman;">Target</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，</span><span lang="EN-US"><span style="font-family: Times New Roman;">pat</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为模式</span><span lang="EN-US"><span style="font-family: Times New Roman;">Pattern</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，并称查找模式串在目标串中位置的运算成为模式匹配</span><span lang="EN-US"><span style="font-family: Times New Roman;">Pattern Matching</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="font-family: Times New Roman;">1</span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">、</span><span style="font-family: Times New Roman;"> </span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">朴素（简单）的模式匹配</span><span lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　这种被称为</span><span lang="EN-US"><span style="font-family: Times New Roman;">B-F</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的模式匹配算法是由</span><span lang="EN-US"><span style="font-family: Times New Roman;">Brute</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">和</span><span lang="EN-US"><span style="font-family: Times New Roman;">Force</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">共同提出的一种基于简单穷举算法。该算法的思想是用</span><span lang="EN-US"><span style="font-family: Times New Roman;">pat</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的字符依次与</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中的字符做比较，如果对应元素均相同，则匹配成功，返回模式串第</span><span lang="EN-US"><span style="font-family: Times New Roman;">0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">个字符</span><span lang="EN-US"><span style="font-family: Times New Roman;">P0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在目标串</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中的位置；如果其中某个位置</span><span lang="EN-US"><span style="font-family: Times New Roman;">i</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中有</span><span lang="EN-US"><span style="font-family: Times New Roman;">Ti</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">！</span><span lang="EN-US"><span style="font-family: Times New Roman;">=Pi</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，则比较不等，此时将模式串</span><span lang="EN-US"><span style="font-family: Times New Roman;">pat</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">右移一位，并用</span><span lang="EN-US"><span style="font-family: Times New Roman;">pat</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中的字符从头开始与</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中的字符依次比较，反复执行上述过程，直到出现下列两种情况之一时结束算法：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">　　执行过程中发现存在与模式串匹配的目标串子串，即匹配成功；</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　当模式串已经移到最后可能与</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">比较的位置，但并不能保证每个字符均可与</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">匹配，此时匹配失败，返回</span><span lang="EN-US"><span style="font-family: Times New Roman;">-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">；</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　下面给出</span><span lang="EN-US"><span style="font-family: Times New Roman;">B-F</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">算法的</span><span lang="EN-US"><span style="font-family: Times New Roman;">C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">描述：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;">int Find(Astring&amp; pat,int k) const</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;">{<span style="mso-tab-count: 1;">     </span>//Astring</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">是默认定义的一个</span><span lang="EN-US"><span style="font-family: Times New Roman;">String</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">类，</span><span lang="EN-US"><span style="font-family: Times New Roman;">k</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为在目标串中开始匹配的位置，</span><span lang="EN-US"><span style="font-family: Times New Roman;">const</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">声明为常成员函数，这里有两重意义：首先常成员函数不能修改数据成员，也不能调用非</span><span lang="EN-US"><span style="font-family: Times New Roman;">const</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">成员；其次在被声明为</span><span lang="EN-US"><span style="font-family: Times New Roman;">const</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的常对象中只能调用常成员函数。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>int i,j;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>for(i=k;i&lt;=curLength-pat.Length;i++)</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>{//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">利用到了回溯的方法进行逐次匹配</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>for(j=0;j&lt;pat.Length;j++)</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>if(ch[i+j]!=pat.ch[j])</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 4;">                            </span>break;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>if(j==pat.Length)</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>return i;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>}</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">　　</span><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>return -1;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">由上述算法可知，在最坏情况下，算法最多将比较</span><span lang="EN-US"><span style="font-family: Times New Roman;">n-m+1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">次，假设模式串长度远小于目标串，则算法运行时间为</span><span lang="EN-US"><span style="font-family: Times New Roman;">O(n*m)</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="font-family: Times New Roman;">2</span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">、模式匹配的改进算法</span><span lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为了改进</span><span lang="EN-US"><span style="font-family: Times New Roman;">B-F</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">算法的性能，需消除其自带的回溯因素，因此需要对串本身进行进一步分析。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>D.E.Knuth</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">、</span><span lang="EN-US"><span style="font-family: Times New Roman;">J.H.Mprris</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">和</span><span lang="EN-US"><span style="font-family: Times New Roman;">V.R.Pratt</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">同时提出了基于简单模式匹配的改进算法—</span><span lang="EN-US"><span style="font-family: Times New Roman;">KMP</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">算法，这种算法大大降低了字符串模式匹配算法的时间复杂度。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span><strong style="mso-bidi-font-weight: normal;">KMP</strong></span></span></span><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">算法本身可使用详细的图表进行说明，限于篇幅原因本文仅提供文字叙述，由于</span><span lang="EN-US"><span style="font-family: Times New Roman;">KMP</span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">算法的普遍性，众多文献均有丰富讲解，有兴趣的读者可以额外查阅。</span><span lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在简单模式匹配中我们发现，由于</span><span lang="EN-US"><span style="font-family: Times New Roman;">P</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">串一旦与</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">串发生“失配”，则无条件直接回溯至</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">串的</span><span lang="EN-US"><span style="font-family: Times New Roman;">k+1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">个位置重新匹配，其中浪费了很多</span><span lang="EN-US"><span style="font-family: Times New Roman;">P</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">串内部规律的资源。理由如下：假设我们在</span><span lang="EN-US"><span style="font-family: Times New Roman;">Pj</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">处发现“失配”，此时并不求助于</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">串，而是寻求一个非负整数</span><span lang="EN-US"><span style="font-family: Times New Roman;">k&lt;j-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，使得</span><span lang="EN-US"><span style="font-family: Times New Roman;">P0…Pk=Pj-k-1…pj-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，由于</span><span lang="EN-US"><span style="font-family: Times New Roman;">P0…Pk</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">肯定和</span><span lang="EN-US"><span style="font-family: Times New Roman;">T</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">串对应于</span><span lang="EN-US"><span style="font-family: Times New Roman;">Pj-k-1…Pj-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的元素一一对应且相等，则将模式串第</span><span lang="EN-US"><span style="font-family: Times New Roman;">k</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">位与目标串失配位置对齐，并从模式串的第</span><span lang="EN-US"><span style="font-family: Times New Roman;">k</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">位开始比较即可。如果不能找到</span><span lang="EN-US"><span style="font-family: Times New Roman;">k</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">值，则将模式串第</span><span lang="EN-US"><span style="font-family: Times New Roman;">0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">位与目标串失配位置对齐，并从模式串的第</span><span lang="EN-US"><span style="font-family: Times New Roman;">0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">位开始比较。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为了易于编程，一般我们先计算出</span><span lang="EN-US"><span style="font-family: Times New Roman;">P</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">串对</span><span lang="EN-US"><span style="font-family: Times New Roman;">j=0,1,2,…,n</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的所有</span><span lang="EN-US"><span style="font-family: Times New Roman;">k</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">值，据此求出下一次匹配模式串中与目标串上次失配位置对齐的相应位置。此距离使用数组</span><span lang="EN-US"><span style="font-family: Times New Roman;">next[]</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">表示，我们先给出其数学规律：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span><span style="mso-tab-count: 2;">              </span>-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，</span><span lang="EN-US"><span style="mso-tab-count: 2;"><span style="font-family: Times New Roman;">        </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">当</span><span lang="EN-US"><span style="font-family: Times New Roman;">j=0;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">next[j]={k+1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，</span><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">      </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">当</span><span lang="EN-US"><span style="font-family: Times New Roman;">0&lt;=k&lt;j-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">且使得</span><span lang="EN-US"><span style="font-family: Times New Roman;">P0P1…Pk=Pj-k-1…Pj-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的最大整数</span><span lang="EN-US"><span style="font-family: Times New Roman;">;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 105pt; text-indent: -42pt; mso-list: l0 level1 lfo1; tab-stops: list 105.0pt;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">0，</span><span style="font: 7pt &quot;Times New Roman&quot;;">                  </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">其他所有情况</span><span lang="EN-US"><span style="font-family: Times New Roman;">;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">j=0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的情况，即模式串的第</span><span lang="EN-US"><span style="font-family: Times New Roman;">0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">位元素与目标串位置失配，此时将第</span><span lang="EN-US"><span style="font-family: Times New Roman;">0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">位与目标串失配位置的下一位置对齐即可。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">例如对于字符串</span><span lang="EN-US"><span style="font-family: Times New Roman;">P=”abaabcac”</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，有</span><span lang="EN-US"><span style="font-family: Times New Roman;">next[]</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">如下：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>j<span style="mso-tab-count: 1;">      </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>2<span style="mso-tab-count: 1;">     </span>3<span style="mso-tab-count: 1;">     </span>4<span style="mso-tab-count: 1;">     </span>5<span style="mso-tab-count: 1;">     </span>6<span style="mso-tab-count: 1;">     </span>7</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>P<span style="mso-tab-count: 1;">     </span>a<span style="mso-tab-count: 1;">      </span>b<span style="mso-tab-count: 1;">     </span>a<span style="mso-tab-count: 1;">      </span>a<span style="mso-tab-count: 1;">      </span>b<span style="mso-tab-count: 1;">     </span>c<span style="mso-tab-count: 1;">     </span>a<span style="mso-tab-count: 1;">      </span>c</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">next(j)<span style="mso-tab-count: 1;">     </span>-1<span style="mso-tab-count: 1;">    </span>0<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>2<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">我们对其中</span><span lang="EN-US"><span style="font-family: Times New Roman;">j=2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">、</span><span lang="EN-US"><span style="font-family: Times New Roman;">j=5</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的情况进行简短分析。当</span><span lang="EN-US"><span style="font-family: Times New Roman;">j=2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">时，得知</span><span lang="EN-US"><span style="font-family: Times New Roman;">k</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">可能为</span><span lang="EN-US"><span style="font-family: Times New Roman;">0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，当</span><span lang="EN-US"><span style="font-family: Times New Roman;">k=0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">时，有</span><span lang="EN-US"><span style="font-family: Times New Roman;">P0!=P1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，因此</span><span lang="EN-US"><span style="font-family: Times New Roman;">k</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">不存在，</span><span lang="EN-US"><span style="font-family: Times New Roman;">next(2)=0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">；当</span><span lang="EN-US"><span style="font-family: Times New Roman;">j=5</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">时，</span><span lang="EN-US"><span style="font-family: Times New Roman;">k</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">可能在</span><span lang="EN-US"><span style="font-family: Times New Roman;">0-3</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">之间，由大到小比较，</span><span lang="EN-US"><span style="font-family: Times New Roman;">P0…P3!=P1…P4</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，故</span><span lang="EN-US"><span style="font-family: Times New Roman;">k!=3</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，</span><span lang="EN-US"><span style="font-family: Times New Roman;">P0P1P2!=P2P3P4</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，故</span><span lang="EN-US"><span style="font-family: Times New Roman;">k!=2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，有</span><span lang="EN-US"><span style="font-family: Times New Roman;">P0P1=P3P4</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，故</span><span lang="EN-US"><span style="font-family: Times New Roman;">k=1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，因此</span><span lang="EN-US"><span style="font-family: Times New Roman;">next(5)=k+1=2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">据此我们给出计算</span><span lang="EN-US"><span style="font-family: Times New Roman;">next[]</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的一般方法：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">getNext(int next[])</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>int j=0,k=-1,lengthP=curLength;<span style="mso-tab-count: 1;">   </span>//curLength</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为模式串长度</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>next[0]=-1;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>while(j&lt;lengthP)</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>{</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>if(k==-1||ch[j]==ch[k])</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>{</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 63pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">j++;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>k++;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span><span style="mso-tab-count: 1;">       </span>next[j]=k;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>}</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>else</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>k=next[k];</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在求出</span><span lang="EN-US"><span style="font-family: Times New Roman;">next[]</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">后，我们可以根据以下</span><span lang="EN-US"><span style="font-family: Times New Roman;">KMP</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">算法实现快速匹配：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">int fastFind(Astring&amp; pat,int k,int next[])const</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">{<span style="mso-tab-count: 1;">     </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">此程序段的有关疑问请参考</span><span lang="EN-US"><span style="font-family: Times New Roman;">B-F</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">程序段</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>int posP=0,posT=k;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>int lengthP=pat.curLength;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>int length=curLength;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>while(posP&lt;lengthP&amp;&amp;posT&lt;lengthT)</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>{</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>if(posP==-1||pat.ch[posP]==ch[posT])</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>{</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>posP++;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>posT++;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">else</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>posP=next[posP];</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">if(posP&lt;lengthP)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>return -1;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">else</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>return posT-lengthP;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">易知整个算法的时间复杂度为</span><span lang="EN-US"><span style="font-family: Times New Roman;">O(lengthP+lengthT)</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">字符串的模式匹配是一个应用极其广泛、重要的一种计算机算法问题。在普通的文本编辑器中随处可见模式匹配的功能用例，在目前流行的各种信息检索中模式匹配算法也是核心研究之一。数十年来不断有科研人员在寻找更加智能、更加高效的算法中取得成果，并不断产生革新。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在实际应用中，我们并不一定必须自己定义原始的模式匹配算法。例如正则表达式</span><span lang="EN-US"><span style="font-family: Times New Roman;">Regular Expression</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，就是一种建立在元字符基础上描述文本规则的强大工具。目前正则表达式被制作成了众多库，广泛支持各种高级语言，许多主流高级语言也已经内嵌了正则表达式。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;">STL String</span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">STL</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中对于</span><span lang="EN-US"><span style="font-family: Times New Roman;">String</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的操作有了进一步规范，其在运算符重载、串查找函数的实现方面均有很大提高。以下为</span><span lang="EN-US"><span style="font-family: Times New Roman;">STL String</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中所定义的函数列表：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">begin<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">得到指向字符串开头的<span lang="EN-US">Iterator<span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">end<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">得到指向字符串结尾的<span lang="EN-US">Iterator<span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">rbegin<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">得到指向反向字符串开头的<span lang="EN-US">Iterator<span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">rend<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">得到指向反向字符串结尾的<span lang="EN-US">Iterator<span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">size<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">得到字符串的大小<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">length<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">和<span lang="EN-US">size</span>函数功能相同<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">max_size<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">字符串可能的最大大小<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">capacity<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">在不重新分配内存的情况下，字符串可能的大小<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">empty<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">判断是否为空<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">operator[]<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">取第几个元素，相当于数组<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">c_str<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">取得<span lang="EN-US">C</span>风格的<span lang="EN-US">const char* </span>字符串<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">data<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">取得字符串内容地址<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">operator=<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">赋值操作符<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">reserve<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">预留空间<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">swap<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">交换函数<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">insert<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">插入字符<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">append<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">追加字符<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">push_back<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">追加字符<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">operator+=<span style="mso-spacerun: yes;">  </span>+= </span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">操作符<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">erase<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">删除字符串<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">clear<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">清空字符容器中所有内容<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">resize<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">重新分配空间<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">assign<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">和赋值操作符一样<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">replace<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">替代<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">copy<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">字符串到空间<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">find<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">查找<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">rfind<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">反向查找<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">find_first_of<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">查找包含子串中的任何字符，返回第一个位置<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">find_first_not_of<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">查找不包含子串中的任何字符，返回第一个位置<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">find_last_of<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">查找包含子串中的任何字符，返回最后一个位置<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">find_last_not_of<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">查找不包含子串中的任何字符，返回最后一个位置<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">substr<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">得到字串<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">compare<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">比较字符串<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">operator+<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">字符串链接<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">operator==<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">判断是否相等<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">operator!=<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">判断是否不等于<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">operator&lt;<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">判断是否小于<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">operator&gt;&gt;<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">从输入流中读入字符串<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">operator&lt;&lt;<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">字符串写入输出流<span lang="EN-US"><span style="mso-spacerun: yes;">  </span></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US">getline<span style="mso-spacerun: yes;">  </span></span><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;">从输入流中读入一行<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">由于多数读者从<span lang="EN-US">C</span>开始接触到一些字符串操作的库函数，因此在学习<span lang="EN-US">C++</span>后对同类型的部分容易发生混淆，唯一的办法只能是多实践，并经常总结相关内容，才能逐步熟练掌握。<span lang="EN-US"></span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">（未完待续）<span lang="EN-US"></span></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-10T16:47:33+08:00" pubdate data-updated="true">2009-02-10</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/09/jia-qi-lian-zai-zhi-qi/">
		
			假期连载之七</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">（串，串在</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C/C++</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中的应用—上）</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">前记：本篇的前半部分事实上在上周末即已完成，原本无意分为两个部分来写，不过身体突发小恙，卧床了两天，为不至于拖延太长时间故先把已完成的发布出来，下不为例。就这样了。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">本节我们介绍字符串—一般简称为串，它在计算机数据类型中具有非常重要的地位。无论从汇编语言、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C/C++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">还是到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Java</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，串操作都是语言本身必不可少的一部分内容。尽管每种语言在串的存储形式上存在一些差异，但对其本身的定义和操作却完全一致。最后我们会以</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">String</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">容器为例，综合介绍字符串操作的规则及原理。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">字符串</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">字符串是指由零个或多个字符组成的有限序列。每个字符可以是字母、数字或其他字符，串中字符的个数称为字符串长度，当长度为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">时称为空串。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">学习过</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">语言的都知道，字符一般用单引号括起来，而字符串则使用双引号。事实上在一般数据结构描述中串默认代表了单个字符的情况，因此都使用单引号表示。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">子串是指任意个连续的字符组成的子序列。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">主串指包含子串的串，字串是主串的一部分。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">字串在主串中的位置，是指字串的第一个字符在主串中的位置。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">串相等的条件是两个串的长度相等，并且每个对应位置的字符也都相等。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">现在，我们可以认识到，<strong style="mso-bidi-font-weight: normal;">串也是一种特定的线性表，其特性主要体现在数据元素的类型为字符</strong>。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">事实上，在</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C/C++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中，所谓的字符串其实是以字符串数组</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">char[]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的形式来进行操作的，这一点与</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Java</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">lang.String</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的实现有所区别，一般而言</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Java</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">String</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">类更符合字符串的存储形式。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">串的抽象数据类型的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">语言描述表示如下：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>ADT String</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">数据对象</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">:D={a1,a2,…,an},</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">其中</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">an</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">char</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">类型</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">基本操作</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">:</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>……</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">这里省略了字符串的基本运算函数，主要是因为在</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C/C++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中既有从</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">语言继承而来的标准库函数，又有</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">独立具备的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">STL</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">String</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">容器，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Java</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">String</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">类也自成体系。对于众多运算必须明确地加以区别，否则会在实际编程中引起很多困难。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">借助于</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Internet</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，我们收集了</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C/C++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">库函数中关于字符串操作的函数集：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">void *memccpy (void *dest, const void *src, int c, size_t n);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">从</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">src</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象复制</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象中。如果复制过程中遇到了字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">则停止复制，返回指针指向</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的下一个位置；否则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">NULL</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">void *memcpy (void *dest, const void *src, size_t n);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">从</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">src</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象复制</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象中。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">void *memchr (const void *s, int c, size_t n);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象的前</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符中搜索字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。如果搜索到，返回指针指向字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">第一次出现的位置；否则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">NULL</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">int memcmp (const void *s1, const void *s2, size_t n);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">比较</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象和</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象的前</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符。返回值是</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">与</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">第一个不同的字符差值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">int memicmp (const void *s1, const void *s2, size_t n);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">比较</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象和</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象的前</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符，忽略大小写。返回值是</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">与</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">第一个不同的字符差值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">void *memmove (void *dest, const void *src, size_t n);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">从</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">src</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象复制</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象中。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。不会发生内存重叠。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *stpcpy (char *dest, const char *src);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">复制字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">src</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest + len(src)</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strcpy (char *dest, const char *src);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">复制字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">src</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strchr (const char *s, int c);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中搜索字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。如果搜索到，返回指针指向字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">第一次出现的位置；否则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">NULL</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">int strcmp (const char *s1, const char *s2);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">比较字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">和字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。返回值是</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">与</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">第一个不同的字符差值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">int stricmp (const char *s1, const char *s2);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">比较字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">和字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，忽略大小写。返回值是</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">与</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">第一个不同的字符差值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">size_t strcspn (const char *s1, const char *s2);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">返回值是字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的完全由不包含在字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中的字符组成的初始串长度。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">size_t strspn (const char *s1, const char *s2);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">返回值是字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的完全由包含在字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中的字符组成的初始串长度。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strdup (const char *s);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">得到一个字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的复制。返回指针指向复制后的字符串的首地址。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strerror(int errnum);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">返回指针指向由</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">errnum</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所关联的出错消息字符串的首地址。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">errnum</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的宏定义见</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">errno.h</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">size_t strlen (const char *s);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">返回值是字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的长度。不包括结束符’</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">\0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">′。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">计算长度</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">len</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">时不包括结束符’</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">\0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">′，计算</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">size</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">时要包括结束符’</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">\0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">′，亦即</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">size=len+1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strlwr (char *s);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">将字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">全部转换成小写。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strupr (char *s);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">将字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">全部转换成大写。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strncat (char *dest, const char *src, size_t maxlen);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">将字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">src</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">添加到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">尾部，最多添加</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">maxlen</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strcat (char *dest, const char *src);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">将字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">src</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">添加到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">尾部。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">int strncmp (const char *s1, const char *s2, size_t maxlen);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">比较字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">和字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，最多比较</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">maxlen</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符。返回值是</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">与</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">第一个不同的字符差值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strncpy (char *dest, const char *src, size_t maxlen);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">复制字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">src</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中，最多复制</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">maxlen</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">dest</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">int strnicmp(const char *s1, const char *s2, size_t maxlen);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">比较字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">和字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，忽略大小写，最多比较</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">maxlen</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符。返回值是</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">与</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">第一个不同的字符差值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strnset (char *s, int ch, size_t n);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">设置字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中的前</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符全为字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">void *memset (void *s, int c, size_t n);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">设置</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所指向的对象的前</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">个字符为字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strset (char *s, int ch);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">设置字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中的字符全为字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。返回指针为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strpbrk (const char *s1, const char *s2);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">返回指针指向字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的任意字符第一次出现的位置；如果未出现返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">NULL</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strrchr (const char *s, int c);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中搜索字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。如果搜索到，返回指针指向字符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">c</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">最后一次出现的位置；否则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">NULL</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strrev (char *s);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">将字符串全部翻转，返回指针指向翻转后的字符串。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strstr (const char *s1, const char *s2);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中搜索字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。如果搜索到，返回指针指向字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">第一次出现的位置；否则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">NULL</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">char *strtok (char *s1, const char *s2);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">用字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中的字符做分隔符将字符串</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">分割。返回指针指向分割后的字符串。第一次调用后需用</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">NULLL</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">替代</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">s1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">作为第一个参数。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">串的存储实现</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">由于串是一种特定的线性表，因而其存储结构与普通线性表之间并无很大差异。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">最常用的即是前文已介绍的定长顺序串，其类型定义如下。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">#define MAXLEN 40<span style="mso-tab-count: 1;">    </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">typedef struct</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>char ch[MAXLEN];</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">              </span>int len;<span style="mso-tab-count: 4;">                         </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">存储字符串实际长度</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}SString;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">还有一种堆串，其串中的字符仍然存放在一组地址连续的存储单元中，但它们的存储空间是在程序执行过程中动态分配的。系统将一个地址连续、容量很大的存储空间作为字符串的可用空间，每当建立一个新串时，系统就会从这个空间中分配一个大小和字符串长度相同的空间存储新串的串值。其类型定义如下</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">:</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">typedef struct</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>char *ch;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 2;">              </span>int len;<span style="mso-tab-count: 4;">                         </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">存储字符串实际长度</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}HString;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">由于堆串在实际应用中可以动态分配存储空间，其较定长顺序串而言方便了许多。但由于其本质未能发生变化，故操作上要不断生成新串、销毁旧串。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">同时字符串还可以用链式存储结构表示。在这种结构中，结点值可以存放一个字符，也可以存放多个字符，故结点被称为块，链表相应被称为块链表。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">鉴于块链表的特殊结构，在实际应用中要考虑几个重要因素。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">结点大小：结点大小是指结点</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">data</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">域中存放的字符个数。由于存储密度</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">=</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">串值所占用的存储位</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">/</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">实际为串分配的存储位，得知当存储密度越小，块链表操作越容易，但需耗费更多的存储空间，这就需要根据实际情况来判断。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">结点大小大于</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，为节约空间而采用结点大小大于</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的方法，尽管存储密度得到了提高，但结点内部串的操作就变得较为复杂，尤其是在进行删除、合并操作时需要充分考虑到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">data</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">域自身的运算。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;"><span style="font-size: small;">（未完待续）</span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-09T17:15:54+08:00" pubdate data-updated="true">2009-02-09</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/07/yong-bu-yan-qi-Slumdog-Slumdog/">
		
			永不言弃—《Slumdog Millionaire》</a>
	</h2>
	<div class="entry-content">
		<p> 最初是准备发第七篇技术连载，突然想起由于这几天长期沉浸《Friends》，自己很久都没有认真看一部完整的电影了。</p>

<p> 随意在mtime上翻了一翻新片海报。现在回想起来那几乎与普通海报无异，顶部印着电影在多伦多电影节上取得的荣誉，以及转载Time的一句话点评。但影片独特的构思就体现在正下方，一个单项选择题：</p>

<p>what does it take to find a lost love?</p>

<p>a.MONEY     b.LUCK     c.SMARTS     d.DESTINY</p>

<p> 起初是好奇，观赏完全片后便不由得被原著《Q&amp;A》的作者所折服。</p>

<p> 影片的画面开始于一个电视节目《who wants to be a millinaire?》的现场，开始感觉像是小时候喜欢看得国内一出同题材的电视节目—尽管后来愈觉得这类节目缺乏吸引力。结果还没太看明白，画面又切入审讯室里，同样的男主角承受着酷刑逼供。事实上后来全片所体现出的剪辑思路完全突破了传统的框架，产生了令人意料之外的效果。</p>

<p> 影片前半部分故事发在孟买的贫民窟里，有点像曾经看过的一部电影《上帝之城》，事实上最初的感觉是两部影片极其相似—贫民窟里发生的令人心酸的丑恶，以及男主角一颗宁静而执着的心。然而影片的叙事手法却是凭借着电视节目里主持人提出的问题—当然，“现在”已经是不幸而又万幸的主角坐在节目录像前向调查警官“坦白罪行”了。</p>

<p>　从贫民窟走出来以后，影片的线索就随着主角对latika的苦苦追寻而展开。主角的哥哥salim也就开始为人所留意，其实之前有一段salim偷拿jamal心爱的明星签名照去卖钱的情节，但并没有引起我太大注意。直到兄弟俩逃出魔窟的当晚，salim不顾一切地拯救弟弟，却面带阴笑地松开了latika的手，对和谐电影的一贯做法使人隐约感觉到了salim悲剧性的结局。</p>

<p>　弟弟对latika的感情发展依照这样一条线索，在一次大规模的种族宗教械斗中两人共同丧失了双亲，事后主角对latika产生了同病相怜的感情—此时两人互相结识。不幸落入魔掌之后，哥哥的凶狠受到了犯罪分子的怂恿，而最终逃脱使主角对latika的不幸感到万分懊悔，历尽艰辛两人生存了下来，出于对latika的依恋弟弟执意再次回到孟买。salim在这里枪杀了犯罪集团的头目，并与弟弟一道救出了latika，然而此时几乎疯狂的salim投靠了贫民窟的黑老大，并成为其手下一名打手。此时的salim显然对刚刚成年的latika打起了主意，为此不惜拔出手枪将弟弟赶出了旅店。</p>

<p>　影片最巧妙的地方位于片尾，事实上前面已经有多处伏笔显示jamal将利用游戏规则“打电话”的方式与latika通话，此时的jamal深知自己将不再失去，于是毫不犹豫地“乱”选了一个答案。导演选择了“正确”作为最终解答，并让主角抱得两千万与美人同归。</p>

<p>　怪不得海报中的影评里写道“A bouyant hymn to life&hellip;”，这确实是一出喜剧，哥哥最终完成了教科书般的自我救赎。剧末众人在维多利亚火车站跳起滑稽的印度舞蹈，网上有评论说本部分毫无存在的价值—但仔细想想，导演和编剧所要向人传递的一种贫民窟人民对生活的乐观，这不仅仅是影片所体现的对贫民窟人民由衷的敬意，同时也是教化大众所要秉持的一种生活态度。</p>

<p>　影片的主题似乎是Destiny，命运，但更像是升华着一种永不言弃的精神，童年的“弟弟”在当今世界里又有多少？在高楼上重逢后，兄弟俩有这样一段对白：</p>

<p>jamal:Salim&hellip;where&rsquo;s latika?</p>

<p>salim:Still?&hellip;&hellip;</p>

<p> 哥哥对弟弟的衷情感到有些不可理解，但幸运的是，这段感情最终得到了所有人的认可—可能除了被salim杀掉的黑老大。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-07T00:09:45+08:00" pubdate data-updated="true">2009-02-07</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/tian-xuan-zhi-zuo/'>天选之作</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/05/jia-qi-lian-zai-zhi-liu/">
		
			假期连载之六</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">（<strong style="mso-bidi-font-weight: normal;">限定性线性表——队列，</strong></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">一个初级迷宫解法的讨论及延伸</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">B</span></strong><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">）</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">本节我们介绍另外一个重要的线性表——队列。首先会讨论队列的几种不同的存储结构，以及相关结构的基本运算问题，最后，我们会对<strong style="mso-bidi-font-weight: normal;">连载五</strong>中介绍的迷宫</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Maze</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">解法进行第一步优化工作。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">队列</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Queue</span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">与栈相类似，队列也是一种限定存储位置的线性表。它只允许在表的一端插入，在另一端删除。通常把允许插入的一端称为队尾</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Rear</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，而把允许删除的一端称为队头</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Front</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。队列所具有的这种特性就被称为先进先出</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">First in First out</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">首先给出队列的抽象数据类型定义：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">ADT Queue</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>InitQueue(&amp;Q);<span style="mso-tab-count: 2;">           </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">队列初始化</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>IsEmpty(Q);<span style="mso-tab-count: 3;">                 </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">判空操作，为空返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">TRUE</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，否则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">NULL</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>IsFull(Q);<span style="mso-tab-count: 3;">                     </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">与上相反</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>EnterQueue(&amp;Q,x);<span style="mso-tab-count: 1;">     </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">进队操作，在队列</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Q</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的队尾插入</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">x</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>DeleteQueue(&amp;Q,&amp;x);<span style="mso-tab-count: 1;"> </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">出队操作，用</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">x</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">取得队头元素的值</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>GetHead(Q,&amp;x);<span style="mso-tab-count: 2;">          </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">取对头元素操作，同样用</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">x</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">取得，成功则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">TRUE</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，否则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">NULL</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>ClearQueue(&amp;Q);<span style="mso-tab-count: 2;">              </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">队列置空操作</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>DestoryQueue(&amp;Q);<span style="mso-tab-count: 1;">    </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">队列销毁操作</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">相应地，队列也分为顺序存储和链式存储两种表示形式，但这与其它线性表中所定义的顺序表和链表有所不同，需要注意。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">循环队列</span></strong><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">循环队列是一种基于数组的顺序队列。对于数组队列</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">elements[maxSize]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，我们首先设置其队头和队尾指针</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">front</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">和</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">rear</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。初始化后</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">front=rear=0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。当加入新元素时，先将新元素加入</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">rear</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">所在位置，并使</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">rear</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">进</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。如果要退出对头元素，应当前将</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">front</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">位置的元素记录下来，并且使</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">front</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">进</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，这就构成了顺序队列的基本运算原理。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">由于顺序队列的特性，其最大空间固定，且随着</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">front</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">递增，其</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">front</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">位置不断进</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，逻辑上造成队列所能容纳元素个数的逐步递减。为了能充分利用数组空间，一般将数组的前端和后端连接起来，形成一个环形的表，当</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">front</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">和队尾指针</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">rear</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">进到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">maxSize-1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">后，再前进一个位置就自动到</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，这就是循环队列</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">circular queue</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">判断是否进</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">或为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的方法如下：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">front=(front+1)%maxSize;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">rear=(rear+1)%maxSize;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">同时为了避免当队列满时发生</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">rear==front</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的情况，还应增加一个判断队列是否已满的条件：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">(rear+1)%maxSIze==front;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">下面给出</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">语言描述的队列入队出队操作：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">int EnterQueue(SeqQueue *Q,QueueElementType x)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>if((Q-&gt;rear+1)%maxSize==Q-&gt;front)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>return FALSE;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>Q-&gt;element[Q-&gt;rear]=x;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>Q-&gt;rear=(Q-&gt;rear+1)%maxSize;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>return TRUE;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">int DeleteQueue(SeqQueue *Q,QueueElementType *x)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>if((Q-&gt;rear==Q-&gt;front)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>return FALSE;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">*x=Q-&gt;element[Q-&gt;front];</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>Q-&gt;front=(Q-&gt;front+1)%maxSize;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>return TRUE;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">这里另外给出一个</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">C++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">队列类中对于一次输出队列中所有元素值的方法函数，其原理是对</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">&lt;&lt;</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">运算符进行了重载，这在需要顺序输出的数据结构算法中经常用到。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">friend ostream&amp; operator &lt;&lt; (ostream&amp; os,SeqQueue&lt;T&gt;&amp; Q)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>os&lt;&lt;”font=”&lt;&lt;Q.front&lt;&lt;”,rear=”&lt;&lt;Q.rear&lt;&lt;endl;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>for(int i=front;i!=rear;i=(i+1)%maxSize)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>os&lt;&lt;i&lt;&lt;”:”&lt;&lt;Q.elements[i]&lt;&lt;endl;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>return os;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">链式队列</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">顾名思义，链式队列是基于单链表的一种存储表示。链式队列的优点在于，由于单链表本身可以设置队头指针和队尾指针，因而其入队出队运算非常方便，同时由于不存在队列满的情况，故实际应用上比循环链表的性能更好。在一些需要多个队列的程序中，大多数使用链式存储方式，相较循环队列而言将大大节约系统资源。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">由于链式队列的代码与循环队列、单链表操作较为相似，因此这里就不再详述。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">OS</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">process scheduling</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">机制中我们了解到，系统对于就绪队列的操作方法有很多种，并不限于</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">FCFS</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">形式，例如</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">SPF</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。这说明在一些高级别算法中，产生了一种区别于传统意义上的队列，有时统称为优先级队列</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Priority Queue</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。这种队列的应用同样非常广泛。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">优先级队列可以为最大优先级队列，也可以是最小优先级队列，以需求不同而论。其一般原理是，当队列初始化后，新元素首先放至队尾，然后调用调整函数。调整函数是一个从队末向队首递增的迭代算法，旨在比较当前元素与新插入元素的优先级大小，如果新元素优先级较高，则与当前元素互换位置，类似于一次冒泡排序。由于算法涉及到了循环操作，其时间复杂度达到了</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">O(n)</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，为了进一步提升算法性能，今后我们会介绍一种最高效的优先级队列存储结构“堆”，它将使类似算法的性能有较大提高。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">双端队列</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">我们在连载四中给出了双端栈</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Destack</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的概念，其目的主要是为了解决一个程序中应用两个栈时存在的空间利用问题。这里介绍的双端队列</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Double-ended Queue</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，与最初引入双端栈的目的并不一致，主要是为了提供一种算法更为灵活的存储结构。但了解双端队列后可以知道，双端栈有时也是双端队列的一类特例。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">双端队列，即队列本身并不拘泥于</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">FIFO</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">规则，有可能为两端均能执行插入、删除操作，也有可能插入、删除操作在一端执行、另一端只执行插入操作。这种形式对于栈、一般队列来说灵活的多。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">但是，在实际应用中我们会发现大量类似于栈或者队列的存储结构，却很少能碰到有双端对列类似要求的结构，因此其实际利用度并不十分高。<strong style="mso-bidi-font-weight: normal;">尽管如此，这并不影响双端队列被列为第三种限定性线性表结构，这也是引入本部分的目的。</strong></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">初级迷宫</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Maze</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">解法的优化讨论</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">现在我们回顾上节内容中介绍的一个初级迷宫解法。在上一节我们介绍了在解决简单二维迷宫时一般用到的两种算法——递归回溯和栈回溯。我们知道，栈回溯相较于递归回溯而言算法性能上得到了提高，并且在智能化扩展上也有了很大进步。但是我们同样意识到，由于算法的原理是在不断探索中，一旦发现终点则退出，就可能产生解出的路径是否为最优解的问题。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">事实上连载五中程序结果显示的例子证明，其最终路径并不是路程最短的解。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">为了解决这一问题，通常需要在发现终点后，要根据起点和终点及其相互联系区域之间所存在的关系而定。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>0<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>0</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">首先我们假定起点</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Maze[1][0]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的值为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，把与起点相邻的方格标记为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">3…</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">依次类推，直到探索出终点位置，为此我们得到以下矩阵：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>2<span style="mso-tab-count: 1;">     </span>3<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>3<span style="mso-tab-count: 1;">     </span>4<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>4<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>6<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>5<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>5<span style="mso-tab-count: 1;">     </span>6<span style="mso-tab-count: 1;">     </span>7</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">根据以上数据可知最优解的路径总数为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">7-2=5</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，此时我们从终点出发，选择相邻小于</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的元素作为路径点，并按此规律回溯到起点。最终所能得出的路径即为最优路径。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">值得注意的是，由于规则和迷宫形态的不确定性，有时可能会出现多条最优解的情况，但这恐怕也就说明了该迷宫的复杂度较低吧。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">这里选择队列作为本算法的存储表示，那么除了要参考栈的迭代回溯算法的原理之外，另需构建一个双循环回溯算法，下面仅提供该部分内容：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>for(j=PathLen-1;j&gt;=0;j&#8211;)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>//nbr</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">为下一个移动的目标元素，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">offsets[]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">为前进方向表，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">here</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">为当前位置，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">grid</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">为保存探索中已经过元素的矩阵</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>for(i=0;i&lt;NumOfNbs;i++)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>nbr.row=here.row+offsets[i].row;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>nbr.col=here.col+offsets[i].col;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>if(grid[nbr.row][nbr.col]==j+2)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>break;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">here=nbr;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">这里我们仅介绍一种简单的迷宫最优解的解法，并不涉及到高级算法设计中关于最优解的讨论，但由于本部分内容实际上为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">ACM</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的重要组成部分，因此在今后的连载中我们将予以详细说明。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">(</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">未完待续</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">)</span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></span></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-05T18:05:10+08:00" pubdate data-updated="true">2009-02-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/04/jia-qi-lian-zai-zhi-wu/">
		
			假期连载之五</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">（迷宫</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">Maze</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的魅力——一个初级迷宫解法的讨论及延伸</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">A</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）</span></strong><strong style="mso-bidi-font-weight: normal;"></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">现在，我们根据以上连载中的内容来研究一个有趣的应用问题。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">假设在一个二位数组</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">maze[m+2][p+2]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">表示的迷宫中，除</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">maze[1][0]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">以及</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">maze[m][p+1]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">分别表示入口、出口外，包括第</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">m+1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">行、第</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">p+1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">列的元素均表示迷宫的围墙，用</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">表示，其它元素同样用</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">表示围墙，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">表示通路，如下图例：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>0<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>0<span style="mso-tab-count: 1;">     </span>0</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1<span style="mso-tab-count: 1;">     </span>1</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">以上是一个</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">6*6</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的迷宫图示，其中</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">(1,0)</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">和</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">(4,5)</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">表示了迷宫的出口和入口。对于迷宫中除边界外的任意元素</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">maze[i][j]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，有</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">0&lt;i&lt;m</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">0&lt;j&lt;p</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，并且当</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">maze[i][j]==0</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">时路通，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">maze[i][j]==1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">时不通。我们假设迷宫中的个体一次可移动八个方向——</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">N</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">NE</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">E</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">SE</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">S</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">SW</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">W</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">NW</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，其数据关系据此可知。我们先根据可前进的方向建立一个前进方向表，给出各个方向的偏移量。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>struct offsets</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span>int a,b;<span style="mso-tab-count: 2;">          </span>//a</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">b</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">分别表示在</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">x</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">和</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">y</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">方向上的偏移量。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span>char *dir;<span style="mso-tab-count: 1;">       </span>//dir</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">为方向。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">};</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">offsets move[8];<span style="mso-tab-count: 1;">   </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">各个方向的偏移量表。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在使用上述数据结构时，需要初始化</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">move[8]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中８个方向的元素值，如果该前进方向走不通，则在前进路径上回退一步，再尝试其他的允许方向。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">同时为了防止重走原路，另外设置一个标志矩阵</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">mark[m+2][p+2]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，它的所有元素都初始化为０，一旦进行到迷宫的某个位置</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">[i][j]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，则将</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">mark[i][j]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">置为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，下次这个位置则被屏蔽。下面给出解决迷宫问题的递归算法</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">C++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">语言描述：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">int SeekPath(int x,int y)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在本例中我们首先从</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">Maze[1][1]</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">开始探索，如果找到出口则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，否则返回</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">0;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>int i,g,h;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span>char *d;<span style="mso-tab-count: 9;">                                                          </span>//g,h</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">记录位置信息，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">dir</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">记录方向</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>if(x==n&amp;&amp;y==p)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>return 1;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span>for(i=0;i&lt;8;i++)<span style="mso-tab-count: 7;">                                               </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">每次选择一个方向探索</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>g=x+move[i].a;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>h=y+move[i].b;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>d=move[i].dir;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>if(Maze[g][h]==0&amp;&amp;mark[g][h]==0)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>mark[g][h]=1;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 3;">                     </span>if(SeekPath(g,h))<span style="mso-tab-count: 5;">                             </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">选择此位置递归探索</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>cout&lt;&lt;”(”&lt;&lt;g&lt;&lt;”,”&lt;&lt;h&lt;&lt;”),”&lt;&lt;”Direction ”&lt;&lt;dir&lt;&lt;endl;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 4;">                            </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">此处输出路径的顺序是逆向的</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>return 1;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 63pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">if(x==1&amp;&amp;y==1)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>cout&lt;&lt;”no path in Maze”&lt;&lt;endl;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">return 0;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">我们将上述迷宫数据经由此算法检查，</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">g++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">给出了如下输出：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">(4,4),Direction W</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">(4,5),Direction SE</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">(3,4),Direction NE</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">(4,3),Direction SE</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">(3,2),Direction S</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">(2,2),Direction SE</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">(1,1),Direction E</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">由于算法本身的问题，输出逻辑上存在一些偏差，但并不影响其正确性。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">现在，我们对递归算法作出一些改进，使其能通过栈处理的方式提高算法性能。为了达到这一目标，我们需要设置一个三元组来存储已走过路径的信息，如下所示：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">struct items</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span>int x,y,dir;<span style="mso-tab-count: 2;">             </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">位置和前进方向的序号</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">此算法的原理是，我们对当前位置的信息进行记录并压栈，按照前进方向表给出的数据向某一个允许的方向前进一位，并将此位置压栈，继续进行上述过程。如果当前位置无法走通，则将前进方向退栈，并在前进路径上回退一步，并尝试其它方向，如果栈空则表示已回退到开始位置。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">下面给出迷宫非递归算法的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">C++</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">描述，需要提前说明的是，我们已假设存在一个完整的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">Stack</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">类，并具备连载四包含的所有栈操作函数。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">int path(int m,int p)<span style="mso-tab-count: 3;">                    </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">关于参数的介绍请借鉴上例</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>int i,j,d,g,h;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span>mark[1][0]=1;<span style="mso-tab-count: 4;">                            </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">假定</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">(1,0)</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">为入口</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span>Stack&lt;items&gt;st(m*p);<span style="mso-tab-count: 2;">         </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">初始化栈</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">st</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，其大小为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">m*p</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，这是根据迷宫空间设置的最大可能值。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span>items tmp;<span style="mso-tab-count: 4;">                          </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">选择当前位置信息</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>tmp.x=1;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>tmp.y=0;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>tmp.dir=2;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 1;">       </span>st.Push(tmp);<span style="mso-tab-count: 4;">                            </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">将初始位置压栈</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>while(st.IsEmpty()==FALSE)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 2;">              </span>st.Pop(tmp);<span style="mso-tab-count: 3;">                </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">将栈顶位置信息弹出，并设置为当前位置</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>i=tmp.x;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>j=tmp.y;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>d=tmp.dir;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 2;">              </span>while(d&lt;8)<span style="mso-tab-count: 3;">                   </span>//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">选择前进方向</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>g=i+move[d].a;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>h=j+move[d].b;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>if(g==m&amp;&amp;h==p)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 3;">                     </span>{//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">已找到出口</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>cout&lt;&lt;st;<span style="mso-tab-count: 1;">       </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 84pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">这里在</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">Stack</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">类的内部重载了操作符</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">&lt;&lt;</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，用于输出</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">st</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">中保存的路径</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>cout&lt;&lt;m&lt;&lt;&#8221; &#8220;&lt;&lt;p&lt;&lt;endl;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>return;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>if(Maze[g][h]==0&amp;&amp;mark[g][h]==0)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="mso-tab-count: 3;">                     </span>{//</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">选择新的可通位置并前进</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>mark[g][h]=1;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>tmp.x=i;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>tmp.y=j;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>tmp.dir=d;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>st.Push(tmp);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>i=g;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>j=h;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 4;">                            </span>d=0;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>else d++;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>cout&lt;&lt;&#8221;no path Maze&#8221;&lt;&lt;endl;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;">};</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在上述算法中，由于涉及到了栈的操作，可能会使算法难度增加，但事实证明其在性能及智能化的扩展方面存在很大的提高。对于小型、简单的二维迷宫，均可根据以上算法对其进行有效的处理。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在今后涉及到树或图部分的内容时，我们将再次回顾迷宫</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">Maze</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">问题，届时的迷宫实例将具备更多复杂的元素以及更巧妙的规则，使当前的算法复杂度大幅提高，也不仅仅是一般数据结构或算法就能够轻松解决的。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">(</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">未完待续</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;">)</span></strong></span></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-04T23:30:57+08:00" pubdate data-updated="true">2009-02-04</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/02/03/jia-qi-lian-zai-zhi-si/">
		
			假期连载之四</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">（<strong style="mso-bidi-font-weight: normal;">限定性线性表——栈，栈的递归应用</strong>）</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-size: small; font-family: Times New Roman;">       </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">五）限定性线性表——栈和队列</span><span lang="EN-US"></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">前面我们介绍了几种简单线性表的抽象数据结构及其基本运算，在一些应用中，通常还有一些逻辑结构与线性表相同，但含额外运算限制的数据结构需求，例如栈和队列。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-size: small; font-family: Times New Roman;">       </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">栈</span><span lang="EN-US"></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span></strong><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">栈</span><span lang="EN-US"><span style="font-family: Times New Roman;">Stack</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">被广泛应用于计算机基础应用中，例如汇编程序中的中断、句法识别以及表达式运算，函数的传参、函数值返回等各种机制。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">栈的定义是<strong style="mso-bidi-font-weight: normal;">一种只允许在表的末端进行插入和删除的线性表</strong>。通常允许相关操作的一端称为栈顶</span><span lang="EN-US"><span style="font-family: Times New Roman;">Top</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，而不允许进行插入和删除操作的一端称为栈底</span><span lang="EN-US"><span style="font-family: Times New Roman;">bottom</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。当栈中没有任何元素时称为空栈。由栈的定义可知，栈又是一种后进先出（</span><span lang="EN-US"><span style="font-family: Times New Roman;">LIFO</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，</span><span lang="EN-US"><span style="font-family: Times New Roman;">Last In First Out</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">）的线性表。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">栈的抽象数据类型定义与普通线性表相类似，例如下面的</span><span lang="EN-US"><span style="font-family: Times New Roman;">C</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">语言形式描述：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>ADT Stack</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">数据元素：可以是任意类型的数据，但必须属于同一个数据对象。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">结点关系：栈中数据元素之间是线性关系。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>InitStack(S);<span style="mso-tab-count: 2;">          </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">初始化空栈</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>ClearStack(S);<span style="mso-tab-count: 2;">              </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">将</span><span lang="EN-US"><span style="font-family: Times New Roman;">S</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">置为空栈</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>IsEmpty(S);<span style="mso-tab-count: 2;">           </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">判断是否栈空，是则返回</span><span lang="EN-US"><span style="font-family: Times New Roman;">TRUE</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，否则返回</span><span lang="EN-US"><span style="font-family: Times New Roman;">FALSE</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>IsFull(S);<span style="mso-tab-count: 3;">               </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">判断是否栈满，与上类似。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>Push(S,x);<span style="mso-tab-count: 2;">             </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在</span><span lang="EN-US"><span style="font-family: Times New Roman;">S</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">栈顶压入元素</span><span lang="EN-US"><span style="font-family: Times New Roman;">x</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，成功返回</span><span lang="EN-US"><span style="font-family: Times New Roman;">TRUE</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，否则返回</span><span lang="EN-US"><span style="font-family: Times New Roman;">FALSE</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>Pop(S,x);<span style="mso-tab-count: 3;">                     </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在</span><span lang="EN-US"><span style="font-family: Times New Roman;">S</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">栈顶弹出元素，并保存入</span><span lang="EN-US"><span style="font-family: Times New Roman;">x</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">返回，与上类似。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>GetTop(S,x);<span style="mso-tab-count: 2;">         </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">取</span><span lang="EN-US"><span style="font-family: Times New Roman;">S</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">栈顶元素并保存入</span><span lang="EN-US"><span style="font-family: Times New Roman;">x</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">返回，但不弹出该值，与上类似。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">通常对于一种线性表，一般具备顺序存储和链式存储两种形式，栈相应分为顺序栈和链栈。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">顺序栈按定义可知其是建立在顺序存储结构的基础上，通常用一维数组表示。下面是顺序栈的结构类型定义：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">#define Stack_Size 50</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">typedef struct</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>stackElementType elements[Stack_Size];</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>int top;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">用</span><span lang="EN-US"><span style="font-family: Times New Roman;">C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">描述的顺序栈初始化构造函数如下：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">template &lt;class T&gt;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">seqStack&lt;T&gt;::SeqStack(int sz):top(-1), Stack_Size (sz)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>elements = new T[Stack_Size];</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>assert(elements != NULL);<span style="mso-tab-count: 1;">    </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">判断动态存储分配是否成功</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">上段程序需要注意的是，构造函数在声明部分就初始化了数据成员的值，并在参数部分声明了一个局部变量，这里的</span><span lang="EN-US"><span style="font-family: Times New Roman;">Stack_Size</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">并非</span><span lang="EN-US"><span style="font-family: Times New Roman;">const</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">类型，这可以使用户自己定义顺序栈空间的大小，</span><span lang="EN-US"><span style="font-family: Times New Roman;">top=-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">表示栈顶指针指空，这种<strong style="mso-bidi-font-weight: normal;">写法需要注意</strong>。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">下面以链栈为例，给出栈的几种基本运算的伪码描述。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">）进栈操作</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>Push(top,x)<span style="mso-tab-count: 6;">                                       </span>//top</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为栈顶指针，</span><span lang="EN-US"><span style="font-family: Times New Roman;">x</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为数据元素值，下同</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>temp=(LinkStackNode *)malloc(sizeof(LinkStackNode));</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>if temp==NULL then</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>return FALSE;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>else then</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>temp-&gt;data=x;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>temp-&gt;next=top-&gt;next;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>top-&gt;next=temp;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>return TRUE;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">）出栈操作</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>Pop(top,*x)</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>temp=top-&gt;next;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>if temp==NULL then</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>return FALSE;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>else then</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>top-&gt;next=temp-&gt;next;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>*x=temp-&gt;data;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>free(temp);</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>return TRUE;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在以上两例中，栈由带头结点</span><span lang="EN-US"><span style="font-family: Times New Roman;">top</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的单链表实现，具体操作时采用了头插法入栈。实际应用中还可以采用尾指针进行尾插法入栈。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">3</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">）多栈共享</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在实际应用中，可能会遇到一个程序使用多个栈的情况。当使用顺序栈时，会由于栈空间预估不足，造成有的栈溢出、有的栈空闲过多等问题，为了解决上述问题，通常采用多个数组共享一个数组空间，并利用栈操作的特性对其存储空间互相补充，这就是多栈共享技术。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">多栈共享中又存在两种情况，其一是程序需要使用最多两个栈的情况，通常采用双端栈技术予以解决，这种栈的特点如下：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 39.0pt;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">1、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span></span><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">首先申请一个数组空间</span><span lang="EN-US"><span style="font-family: Times New Roman;">S[M]</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，将两个栈的栈底分别放在一维数组的两端，分别为</span><span lang="EN-US"><span style="font-family: Times New Roman;">0</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，</span><span lang="EN-US"><span style="font-family: Times New Roman;">M-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 39.0pt;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">2、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">通过简单对比可知，由于栈顶动态变化，两栈在空间上形成互补关系，逻辑上实现了栈空间由其所需求空间动态决定的机制，从而提高了空间利用率。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 39pt; text-indent: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 39.0pt;"><span style="mso-fareast-font-family: 'Times New Roman';" lang="EN-US"><span style="mso-list: Ignore;"><span style="font-family: Times New Roman;"><span style="font-size: small;">3、</span><span style="font: 7pt &quot;Times New Roman&quot;;">  </span></span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">在实际应用中通常将两个栈编号标记，方便调用。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">另一种情况，是当程序需求两个以上栈的情况。显然双端栈无法满足这一需求。因此当我们遇到这种情况时，一般采用链栈形式，并用一个统一的一维结构指针数组管理每个栈的栈顶指针。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">栈与递归</span><span lang="EN-US"></span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><strong style="mso-bidi-font-weight: normal;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></strong></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">递归</span><span lang="EN-US"><span style="font-family: Times New Roman;">recurve</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在数学和计算机科学中有着十分重要的作用。在计算机科学中，递归从编译原理的句法定义，到数据结构中的树形结构搜索、排序等问题，都是必不可少的应用。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">递归在数学及程序设计方法学中的定义是：若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的，而且若一个过程直接地或间接地调用自己，则称这个过程是递归过程。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-spacerun: yes;"><span style="font-family: Times New Roman;"> </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">有人可能注意到了“直接”或“间接”的表述，“直接递归函数”顾名思义就是在自己的定义中直接调用自己的方法函数。“间接”主要是指方法函数通过一系列的中间语句，通过其它函数调用自己。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">一般在以下</span><span lang="EN-US"><span style="font-family: Times New Roman;">3</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">种情况下，需要使用递归方法。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">）定义上是递归的</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">例如数学上常用的阶乘函数、幂函数、</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">斐波拉契数列等，其定义运算都是递归的。例如斐波那契数列，这是一个从前两项为自然数</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，第三项开始为前两项之和的无穷数列，即：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">3</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">5</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">8</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">13</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">…</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。在计算机实现时，我们只需给出此数列的递归关系“</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">f(n)=f(n-1)+f(n-2)</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，其中</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n&gt;=2<span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial;" lang="EN-US"><span lang="EN-US">”</span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial;" lang="EN-US">，即可实现递归运算。</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）数据结构是递归的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在我们已经讨论过的单链表结构中，可以明显地看到一种递归关系。即</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">LinkNode</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">由数据域</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">data</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">和指针域</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">next</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">构成，而</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">next</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">又由</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">LinkNode</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">定义。利用递归关系我们可以写出寻找单链表中某一结点的算法的递归形式。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">3</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）问题的解法是递归的</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">递归是解决一些应用问题唯一有效的解决方案。典型例题即是著名的汉诺塔</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Tower of Hanoi</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">问题。问题介绍可以看</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">wiki</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><a href="http://zh.wikipedia.org/w/index.php?title=%E6%B1%89%E8%AF%BA%E5%A1%94&amp;variant=zh-cn"><span style="font-size: small; color: #800080;">http://zh.wikipedia.org/w/index.php?title=%E6%B1%89%E8%AF%BA%E5%A1%94&amp;variant=zh-cn</span></a></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">这里给出简单的伪码演示：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 1;">       </span>Hanoi(n,A,B,C)</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>If n==1 then printf Move top disk from A to C;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 2;">              </span>Else then</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>Hanoi(n-1,A,C,B);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>printf Move top disk from A to C;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"><span style="mso-tab-count: 3;">                     </span>Hanoi(n-1,B,A,C);</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">这里重申递推和递归的关系，递推是利用问题本身所具有的递推关系对问题求解的一种方法，而这种递推性质决定了已知</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">i-1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的解，由此可求得</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">…</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">、</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">i-1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">的一系列的解，其问题规模为</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">i</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">，例如</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">n!</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">问题。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">递推问题通常可以用递归方法求解，同时也可以使用循环迭代的方法求解</span></strong><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在程序设计语言中，递归的实现主要得益于递归工作栈的工作原理。每一层递归调用所需要保存的的信息包括：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）返回地址，即上一层中本次调用自己的语句的后继语句处。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）在本次过程调用时，为与形参结合的实参创建副本。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">3</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）本层的局部变量。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在每进入一层递归时，系统就要建立一个新的工作记录，把上述项目登入并加入到递归工作栈的栈顶位置。每退出一层递归，就从递归工作栈退出一个工作记录。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在实际应用中，递归通常体现出两个特性：</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）递归算法简单有效，通常可用来解决一些复杂问题。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）由于实现机制的问题，递归算法效率较低。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">因此在求解一些问题时，我们一般用递归方法分析问题，而使用非递归方法求解相关问题。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">1</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）用栈实现递归过程的非递归算法</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">一般的递归过程可以用递归调用树进行表示，因此可以由栈代替递归算法实现树的运算，这将在以后树结构的介绍中作一说明。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span>2</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">）用迭代法实现递归过程</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">实际上就是使用循环结构，有一类递归可以使用循环结构简单表示，即单向递归。单向递归是指递归函数中虽然有一处以上的递归调用语句，但各次递归调用语句的参数只和主调用函数有关，相互之间参数无关，并且这些递归调用的语句处于算法的最后，例如斐波那契数列。还有一种递归，指递归调用语句只有一个，而且是处于算法最后，显然这是单向递归的一个特例，称为尾递归。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">无论使用何种非递归方法实现递归过程，一般应先根据递归算法画出程序流程图，然后建立起循环结构。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="mso-tab-count: 1;">       </span></span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">在下一节，我们将继续扩展递归应用，使用回溯法</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">backracking</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">解决较复杂的迷宫</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US">Maze</span><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">问题，并对几种高级编程技术进行介绍，并加以综合利用。</span><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial;">（未完待续）</span></strong><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"></span></strong></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><strong style="mso-bidi-font-weight: normal;"><span style="font-family: Arial; mso-bidi-font-size: 10.5pt;" lang="EN-US"><span style="font-size: small;"> </span></span></strong></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-02-03T16:39:55+08:00" pubdate data-updated="true">2009-02-03</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/01/26/jia-qi-lian-zai-zhi-san/">
		
			假期连载之三</a>
	</h2>
	<div class="entry-content">
		<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">(</span></span><strong style="mso-bidi-font-weight: normal;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">线性表的链式存储—循环链表、双向链表、静态链表</span></strong><span lang="EN-US"><span style="font-family: Times New Roman;">)</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">上节我们介绍了线性表的链式存储结构中最重要的一种—单链表结构，但在这样的结构中也存在一些问题，而这些在顺序存储中却能得到较好的体现。为此，我们需要对单链表的存储结构进行一些改进，以实现我们需要的功能。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">例如，在单链表中有时会给出某个结点的地址，并要求寻找其它所有结点，我们知道单链表结点中包括了指向其直接后继的指针域，但并不能回溯执行，因此在大多数情况下并不能实现题设的要求。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">我们提供一种“首尾相接”的链表，其原理是将尾结点的</span><span lang="EN-US"><span style="font-family: Times New Roman;">next</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">指针由</span><span lang="EN-US"><span style="font-family: Times New Roman;">null</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">改为指向表头结点，于是就形成了单链表形式的循环链表，简称循环链表。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在不带附加头结点链表中，尾结点的情况为</span><span lang="EN-US"><span style="font-family: Times New Roman;">rear-&gt;next=head</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，其中</span><span lang="EN-US"><span style="font-family: Times New Roman;">head</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为头指针。而在带头结点链表中这种情况就变成</span><span lang="EN-US"><span style="font-family: Times New Roman;">rear-&gt;next=head-&gt;next</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。相应地，关于单链表操作的循环条件</span><span lang="EN-US"><span style="font-family: Times New Roman;">p!=NULL</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">或</span><span lang="EN-US"><span style="font-family: Times New Roman;">p-&gt;next!=NULL</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">将变为</span><span lang="EN-US"><span style="font-family: Times New Roman;">p!=head</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">或</span><span lang="EN-US"><span style="font-family: Times New Roman;">p!=head-&gt;next</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，具体由是否附加头结点决定。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">下面来看一个关于循环链表的应用问题——约瑟夫环（</span><span lang="EN-US"><span style="font-family: Times New Roman;">Josephus</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">约瑟夫环问题原本为一个数学应用，是由古罗马的史学家约瑟夫（</span><span lang="EN-US"><span style="font-family: Times New Roman;">Josephus</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">）提出的。它的具体数学抽象为：设有编号为</span><span lang="EN-US"><span style="font-family: Times New Roman;">1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，</span><span lang="EN-US"><span style="font-family: Times New Roman;">2</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，……，</span><span lang="EN-US"><span style="font-family: Times New Roman;">n</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的</span><span lang="EN-US"><span style="font-family: Times New Roman;">n(n&gt;0)</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">个人围成一个圈，从第</span><span lang="EN-US"><span style="font-family: Times New Roman;">1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">个人开始报数，报到</span><span lang="EN-US"><span style="font-family: Times New Roman;">m</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">时停止报数，报</span><span lang="EN-US"><span style="font-family: Times New Roman;">m</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的人出圈，再从他的下一个人起重新报数，报到</span><span lang="EN-US"><span style="font-family: Times New Roman;">m</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">时停止报数，报</span><span lang="EN-US"><span style="font-family: Times New Roman;">m</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">的出圈，……，如此下去，直到所有人全部出圈为止。当任意给定</span><span lang="EN-US"><span style="font-family: Times New Roman;">n</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">和</span><span lang="EN-US"><span style="font-family: Times New Roman;">m</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">后，设计算法求最后一个出圈的人的最初序号。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">事实上数学家们早已给出了这个问题或以此为基础衍生出的各种问题的数学解答，我们仅需要根据简单的递推公式即可轻松解决此类问题。但事实上，它其实也是一个循环链表的典型问题。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">这是因为，其一，环事实上就是循环链表的抽象表现，在本题中环链的大小不断发生改变，也恰符合链表设置的最初意义，另外，约瑟夫环所对应的操作几乎囊括了循环链表的所有基本运算问题。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">下面给出</span><span lang="EN-US"><span style="font-family: Times New Roman;">C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">描述的约瑟夫环求解代码：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">template&lt;class T&gt;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">void Josephus(CircList&lt;T&gt;&amp;Js,int n,int m)<span style="mso-tab-count: 2;">         </span>//n</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为结点数，</span><span lang="EN-US"><span style="font-family: Times New Roman;">m</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为间隔数</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">{</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>CircLinkNode&lt;T&gt;*p=Js.getHead(),*pre=NULL;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>int i,j;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>for(i=0;i&lt;n-1;i++)</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>{</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>for(j=1;j&lt;m;j++)</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>{</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 3;">                     </span>pre=p;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 63pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">p=p-&gt;link;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">cout&lt;&lt;”</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">出圈的是：</span><span lang="EN-US"><span style="font-family: Times New Roman;">”&lt;&lt;p-&gt;data&lt;&lt;endl;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">pre-&gt;link=p-&gt;link;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">delete p;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 42pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">p=pre-&gt;link;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt 21pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">}</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">};</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">注：本例仅给出约瑟夫环的求解方法函数，</span><span lang="EN-US"><span style="font-family: Times New Roman;">CircLinkNode</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">及</span><span lang="EN-US"><span style="font-family: Times New Roman;">CircList</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">类需要自行写出。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">循环链表实现了一定的回溯操作，丰富了单链表的功能。但其在寻找直接前驱时的时间复杂度仍为</span><span lang="EN-US"><span style="font-family: Times New Roman;">O(n)</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，我们要使用更为高效的替代算法以实现</span><span lang="EN-US"><span style="font-family: Times New Roman;">O(1)</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，则就产生了双向循环链表，简称双向链表。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">顾名思义，双向链表的结点中包含了三个数据成员，除原有的数据域，直接后继指针</span><span lang="EN-US"><span style="font-family: Times New Roman;">*next</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">外，又添加了指向直接前驱的指针</span><span lang="EN-US"><span style="font-family: Times New Roman;">*prior</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">在实际应用中，双向循环链表在仅需求后继结点的情况下和单链表的基本用法相类似。但当需同时顾及到前驱和后继两方面结点时就会发生改变。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">首先我们知道在双向链表中存在下式成立：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">p-&gt;prior-&gt;next==p;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">p==p-&gt;next-&gt;prior;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">我们据此给出双向链表前插操作的伪码表示：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;">DlinkIns(L,i,e)<span style="mso-tab-count: 6;">                                          </span>//L</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为原链表，</span><span lang="EN-US"><span style="font-family: Times New Roman;">i</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为插入位置，</span><span lang="EN-US"><span style="font-family: Times New Roman;">e</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为插入数据</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">检查位置</span><span lang="EN-US"><span style="font-family: Times New Roman;">i</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">是否合法，否则返回</span><span lang="EN-US"><span style="font-family: Times New Roman;">-1</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span lang="EN-US"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>//</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">设置</span><span lang="EN-US"><span style="font-family: Times New Roman;">*p</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">指向第</span><span lang="EN-US"><span style="font-family: Times New Roman;">i</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">个结点</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>S=(DNode*)malloc(sizeof(DNode));</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>If(s) then</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>s-&gt;data=e;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>s-&gt;prior=p-&gt;prior;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>p-&gt;prior-&gt;next=s;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>s-&gt;next=p;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>p-&gt;prior=s;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>return OK</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>else then</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 2;">              </span>return -1</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">执行循环链表删除运算时，需要注意应从两个方面同时补链，例如：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">p-&gt;prior-&gt;next=p-&gt;next;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;">p-&gt;next-&gt;prior=p-&gt;prior;</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt; text-indent: 21pt;"><span style="font-size: small;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">通过连载一和连载二我们较详细地介绍了线性表的几种存储结构和运算方法，它们都是基于</span><span lang="EN-US"><span style="font-family: Times New Roman;">C/C++</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">或</span><span lang="EN-US"><span style="font-family: Times New Roman;">Java</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">语言而言的。在一些语言诸如</span><span lang="EN-US"><span style="font-family: Times New Roman;">BASIC</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">、</span><span lang="EN-US"><span style="font-family: Times New Roman;">FORTRAN</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中并不包含“指针”这种数据类型（当然</span><span lang="EN-US"><span style="font-family: Times New Roman;">Java</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">中也不存在</span><span lang="EN-US"><span style="font-family: Times New Roman;">C</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">语言意义上的指针，但并这不影响其对链表结构的诠释）。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-size: small; font-family: Times New Roman;">       </span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在我们同样需要在此类领域中实现链表应用时，数组就成为最为可靠的手段，但这并不同于顺序表的动态存储，而是采用结构体数组的形式，通过设置数据域和“游标</span><span lang="EN-US"><span style="font-family: Times New Roman;">Cursor</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">”模拟链表结点，以达到和链表类似的目的，这就是<strong style="mso-bidi-font-weight: normal;">静态链表</strong>。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">游标</span><span lang="EN-US"><span style="font-family: Times New Roman;">Cursor</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">通常为非负整数形式，它存放后继结点在结构数组中的数组下标值（并非绝对位置）。根据结点</span><span lang="EN-US"><span style="font-family: Times New Roman;">cursor</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">值可以轻松凭借</span><span lang="EN-US"><span style="font-family: Times New Roman;">StaticList[cursor].data</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">获得当前后继结点的值。而数组最后一个结点的</span><span lang="EN-US"><span style="font-family: Times New Roman;">cursor</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">值通常为</span><span lang="EN-US"><span style="font-family: Times New Roman;">-1</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">表示</span><span lang="EN-US"><span style="font-family: Times New Roman;">null</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">由于数组的特性，首先<strong style="mso-bidi-font-weight: normal;">静态链表的长度是固定的</strong>。因此在执行添加</span><span lang="EN-US"><span style="font-family: Times New Roman;">/</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">删除操作时并不能实际创建</span><span lang="EN-US"><span style="font-family: Times New Roman;">/</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">释放内存空间，而全部在原数组内部进行。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">在后插法添加结点操作中，新结点先存放在数组空闲空间中，然后使新结点的</span><span lang="EN-US"><span style="font-family: Times New Roman;">cursor</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">值等于要插入结点的</span><span lang="EN-US"><span style="font-family: Times New Roman;">cursor</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">，再将原结点的</span><span lang="EN-US"><span style="font-family: Times New Roman;">cursor</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">值等于新结点在结构体数组中的实际下标值。以上步骤可由以下语句实现：</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>StaticList[s].cursor=StaticList[p].cursor;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small;"><span style="font-family: Times New Roman;"><span style="mso-tab-count: 1;">       </span>StaticList[p].cursor=s;</span></span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">这说明尽管静态链表中的数据结点物理位置可能并不连续，但其逻辑次序并未发生变化，这就接近于链表的实际存储结构。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">执行静态链表的删除操作时，只需使要删除结点前驱的</span><span lang="EN-US"><span style="font-family: Times New Roman;">cursor</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">值等于要删除结点的</span><span lang="EN-US"><span style="font-family: Times New Roman;">cursor</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">值即可。实际上要删除的结点空间并未发生任何修改。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">由以上操作可知，当静态链表在经过数次插入</span><span lang="EN-US"><span style="font-family: Times New Roman;">/</span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">删除操作后，其总结点数其实只增未降，这就使得静态链表的运行效率大打折扣。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-size: small;"><span lang="EN-US"><span style="mso-tab-count: 1;"><span style="font-family: Times New Roman;">       </span></span></span><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';">为此，我们一般额外设置一个<strong style="mso-bidi-font-weight: normal;">备用静态链表</strong>，该表结点所存放的值是空闲空间以及因删除操作而回收的结点空间，实际运算时需要原链表和备用表的互相协作以达到相关目的。</span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span lang="EN-US"><span style="font-size: small; font-family: Times New Roman;"> </span></span></p>


<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="font-family: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman';"><span style="font-size: small;">（<strong style="mso-bidi-font-weight: normal;">未完待续</strong>）</span></span></p>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-01-26T19:31:32+08:00" pubdate data-updated="true">2009-01-26</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/shu-ju-jie-gou/'>数据结构</a>

</div>


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2009/01/26/ji-chou-ji-yu/">
		
			己丑寄语</a>
	</h2>
	<div class="entry-content">
		<p> 最近开始看《Friends》，曾经在网上听说了Ross的十年之痒，但苦于一直没有充足的时间领略这部长达238集并热播十年的情景剧。现在终于能开怀畅“品”了。</p>

<p> 更夸张的是，第一次接触Friends就一口气用一天多点的时间看完了第一季的完整内容&hellip;或许还真是闲得慌了。不可否认，Friends所能给人带来的轻松与愉悦的确名副其实，片中体现出的浓厚的美国文化则深深吸引了观众。这也使得我对情景剧一贯不以为然的态度发生了转变。</p>

<p> 除夕夜前半段和家人一起看电视，后半段就自己继续“品”着Friends。很快，六十年一回归的己丑年将拉开大幕，“努力奋斗”这份来自朋友的祝辞，也将成为这一年的永恒主题。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-01-26T00:44:14+08:00" pubdate data-updated="true">2009-01-26</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/tian-xuan-zhi-zuo/'>天选之作</a>

</div>


	
</div></article>

<nav id="pagenavi">
    
    	
        	<a href="/posts/13" class="prev">Prev</a>
        
    
    
        <a href="/posts/15" class="next">Next</a>
    
    <div class="center"><a href="/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    Han Yi

<br>
Powered by Octopress.
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>
