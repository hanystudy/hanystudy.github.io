
<!DOCTYPE HTML>
<html>
<head>
	<script data-cfasync="false" type="text/javascript" src="//use.typekit.net/axj3cfp.js"></script>
	<script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
	<meta charset="utf-8">
	<title>  | Wing of Dream 梦境之翼</title>

<meta name="author" content="Han Yi"> 

<meta name="description" content="  有朋友提出首页音乐不符合本站主题&hellip;我们将作更改，另外待开发内容也已提上日程。由于本学期突然有期中考，我们的更新可能会慢一些，但技术交流的频率不会降低。 2008-04-18 站点日志 Comments "> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Wing of Dream 梦境之翼" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el, 
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	
</head>



<body>
	<header id="header" class="inner"><h1><a href="/">Wing of Dream 梦境之翼</a></h1>
<h4></h4>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:www.hanyi.name">
			</form>
		</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/18/shou-ye-jian-she-ji-hua/">
		
			首页建设计划</a>
	</h2>
	<div class="entry-content">
		<p> 有朋友提出首页音乐不符合本站主题&hellip;我们将作更改，另外待开发内容也已提上日程。由于本学期突然有期中考，我们的更新可能会慢一些，但技术交流的频率不会降低。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-18T21:15:58+08:00" pubdate data-updated="true">2008-04-18</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhan-dian-ri-zhi/'>站点日志</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/18/shou-ye-jian-she-ji-hua//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/18/yue-zhong-zong-jie-di-1-qi/">
		
			月中总结（第1期）</a>
	</h2>
	<div class="entry-content">
		<p> 我们每月中旬将对blog内容作一合订总结，并提供连载文章的目录。</p>

<p> 1、好文推荐:《<span style="color: #000000;">Visual C++动态链接库编程》 作者:宋宝华</span></p>

<p>   简介:文章面向具有c++基础，并且对vc6.0环境有一定应用能力的读者。详细介绍了windows动态链接库的概念、编程方法和应用，是一份不可多得的技术参考类文章。</p>

<p>      <a href="http://www.hanyi.name/blog/?p=27" target="_blank">Visual C++动态链接库编程（一）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=28" target="_blank">Visual C++动态链接库编程（二）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=29" target="_blank">Visual C++动态链接库编程（三）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=30" target="_blank">Visual C++动态链接库编程（四）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=31" target="_blank">Visual C++动态链接库编程（五）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=32" target="_blank">Visual C++动态链接库编程（六）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=33" target="_blank">Visual C++动态链接库编程（七）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=34" target="_blank">Visual C++动态链接库编程（八）</a> （完结篇）</p>

<p> 2、语言学习:《C++学习笔记——重温计划》</p>

<p>   贴上博主原版C++学习笔记，由于是手工录入需要分期刊出。面向具有一定C语言基础的读者，无基础配合有关参考书籍亦可。</p>

<p>      <a href="http://www.hanyi.name/blog/?p=21" target="_blank">C++学习笔记(重温计划之一)</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=22" target="_blank">C++学习笔记(重温计划之二)</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=26" target="_blank">C++学习笔记(重温计划之三)</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=36" target="_blank">C++学习笔记(重温计划之四)</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=37" target="_blank">C++学习笔记(重温计划之五)</a> （待续）</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-18T20:36:43+08:00" pubdate data-updated="true">2008-04-18</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/tian-xuan-zhi-zuo/'>天选之作</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/18/yue-zhong-zong-jie-di-1-qi//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/18/xiao-yi-hui-bian/">
		
			小议汇编</a>
	</h2>
	<div class="entry-content">
		<p> 在绝大多数人眼中，汇编语言是一个低级的、面向机器硬件的程序设计语言。从第一颗微处理器诞生之日起，二进制代码形式的机器语言就被代替成了具有一定意义的特殊指令。指令的有序堆积即称为汇编语言。</p>

<p> 令人遗憾的是，中国人自计算机发明以来，几乎未在其硬件领域上取得过较大突破。微处理器技术也是如此。这也就能解释，为何若干套指令集中没有汉字的影子了。（无语。。。）其实，非但我国在这一领域起步较晚，当今技术水平与国外同类技术的差距也还是相当可观的。这样可能有人会说，经济全球化的今天，中国人为什么总要搞自己的一套东西！需知，信息产业在未来社会生活所占据的比重将十分庞大，而当今国际社会的政治形势变幻也从未停留过脚步，拥有民族化自主知识产权的技术也就成了重要一环。</p>

<p> 提前说了这么多废话，主要还是勉励当代微电子学专业的同学们奋发图强。我们从“软”的已经软到了火候，而该“硬”的却还没有硬得起来。</p>

<p> 目前高校的汇编语言教学主要是以8086/88指令系统为主要内容，事实上真正的汇编语言远不止这个概念。它的发展和CPU的发展几乎是同步进行的。我们知道，1971年intel公司推出了世界上第一台4位微处理器4004，1978年推出了16位微处理器i8086/87，并相应配套了x86指令集。随后的8088芯片用在了IBM-PC中，在1981年的首次PC机概念推广时广为人知。此后，x86指令集被多数微处理器厂商采用并集成到自主产品中。虽然后来的发展使cpu指令集不断更新扩充，但为了延续长期以往积攒的软件资源周期，都向上兼容了x86指令集。当然，不同的cpu大多数都有自己的扩展指令集，还有些并未沿用x86构架，但总的来说这些指令主要分两大构架:</p>

<p>   1、复杂指令系统计算机(CISC,Complex Instruction Set Computer):指令均处于平等地位的指令构架，有指令多且复杂，因为操作码扩展而增加寻址方式种类的特点。早期的x86指令集都属于cisc构架。</p>

<p>   2、精简指令系统计算机(RISC,Reduced Instruction Set Computer):指令有优先级之分，一般常用指令优先级较高，提升了运行效率，并且克服了cisc构架的上述若干缺点。当前除PC机以外的计算机系统基本上都采用RISC构架。</p>

<p> cisc虽然拥有众多缺点，但x86集基础上所建立的软件资源是它至今仍必须在pc机上存在的重要原因。目前看来，cisc和risc在pc机上的争夺最终将走向中间领域，两大厂商intel和amd也在上世纪90年代开始同时采用了两种技术。</p>

<p> 那么，汇编语言的具体优势又在哪里？</p>

<p> 高级语言如C/C++,JAVA,C#等，都具有直观，抽象化易于理解，应用范围广的特点。早期的汇编语言相对而言就不具备这些优势了。通常汇编用来进行底层开发，例如操作系统及其硬件驱动程序、端口程序,还包括当前愈为流行的嵌入式开发等等。有时程序员会使用汇编语言和高级语言相配合以进一步达到高效精确的目的。近一段时期以来，随着汇编语言自身的发展和翻译程序的开发，汇编已经能够做到完全独立编写win32程序,其在一些高级绘图程序、视频游戏程序中的应用也越来越多。</p>

<p> 我认为，针对计算机偏软件方向的专业来说，汇编语言提供了一个能近距离观察机器内部实现的窗口。另外，通过对汇编语言程序设计的掌握，将对上层软件系统原理拥有更为深刻的理解。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-18T19:40:03+08:00" pubdate data-updated="true">2008-04-18</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/assembly/'>assembly</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/18/xiao-yi-hui-bian//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/11/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-wu/">
		
			C++学习笔记(重温计划之五)</a>
	</h2>
	<div class="entry-content">
		<p>3、数据类型（下）</p>

<p> 1)向量(Vectors)</p>

<p>   Vector是C++标准模板类库的重要组成部分,使用时需要包含头文件vector.主要定义方式如下:</p>

<p>    vector &lt;int&gt; a(10);                     //定义了10个整数元素,但没有赋初值</p>

<p>    vector &lt;int&gt; b(10,1);                  //定义了10个整数元素,且每个元素的初值为1</p>

<p>    vector &lt;int&gt; c(b);                       //用一个现成的向量创建一个向量</p>

<p>    vector &lt;int&gt; d(b.begin(),b.begin()+3);             //定义了一个其值为向量b前3个值的向量</p>

<p> 我们知道,当输出一个数组时我们一般用循环实现.在vector中,有相应的遍历器函数,形式为vector&lt;int&gt;::iterator,例如:</p>

<p>   for(vector&lt;int&gt;::iterator it = a.begin(); it != a.end() ; ++it)</p>

<p>    cout &lt;&lt;*it &lt;&lt;&ldquo; &rdquo;;</p>

<p>   有关向量的其他操作如下:</p>

<p>a.assign(b.begin(),b.begin()+3);     //将b的0-2元素构成的向量赋给a
a.assign(4,2);                       //将a向量只含0-3元素,且赋为值2
int x = a.back();                    //将a的最后一个向量元素值赋给整数变量x
a.clear();                           //a向量元素清空
if(a.empty()) cout &lt;&lt; &ldquo;empty&rdquo;;       //a.empty()作为条件判断空或非空
int y = a.front();                   //将a的第一个向量元素赋给整数变量
ya.pop_back;                         //删除a向量的最后一个元素
a.push_back(5);                      //在a向量最后插入一个元素,其值为5
a.resize(10);                        //将向量元素个数调至10个,多则删,少则补,其值随机
a.resize(10,2);                      //将向量元素个数调至10个,多则删,少则补,其值为2
if(a==b) cout &lt;&lt; &ldquo;equal&rdquo;;            //向量的比较操作还有!=,&lt;,&lt;=,&gt;,&gt;=</p>

<p>   向量与数组相比的好处是,其空间大小不需要提前指定,可以不断添加新的元素.但是,向量初始化时会分配一定的预留空间,如果添加元素的个数超过了预留空间,则需要扩容.内存意义上的扩容需要删除原空间并添加新的空间,这就必然增加向量操作的负担,因此在预计添加元素个数较多的情况下,我们还是需要给定向量的初始化大小.</p>

<p>   和数组类似,向量也存在2维向量乃至多维向量.我们通常使用 vector&lt;vector&lt;int&gt;&gt; 的形式声明一个2维向量,其一般操作和1维向量的方法是一致的.</p>

<p> 2)指针与引用</p>

<p>   c++的指针应用几乎是必不可少,我们将用较大篇幅来研究指针的用法.</p>

<p> a.指针的定义</p>

<p>   如下的定义方式都是正确的</p>

<p>   int * p;</p>

<p>   char *cp;</p>

<p>   float* fp;</p>

<p>   double*dp;</p>

<p>   我们也可以定义一个二级指针</p>

<p>   int ** iip;</p>

<p>   但需要注意的是,一个*只能修饰一个指针,例如</p>

<p>   int* ip,iq;   //其中ip为指针变量,而iq为整形变量</p>

<p>   在指针初始化的过程中,有下面的形式:</p>

<p>   int* ip;</p>

<p>   int iCount = 18;</p>

<p>   int* iPtr = &amp;iCount;       //初始化,&amp;表示实体的地址,&amp;后可以是一个变量,但不能是具体数值</p>

<p>   ip = &amp;iCount;;              //赋值</p>

<p>   须注意,int<em> ip = &amp;iCount; 与 </em>ip = &amp;iCount; 并不相同,前者为初始化并赋值,后者本身形式错误.诸如 int<em> iPtr; </em>iPtr = 58;的语句也是毫无意义的.</p>

<p> b.指针类型</p>

<p>  指针是有类型的,其类型也必须是一致的.在c语言中,有强制类型转换(int *),但事实上,c++有自身的强制转换函数.例如:</p>

<p>   int<em> ip = reinterpret_cast&lt;int</em>&gt;(&amp;f);           //reinterpret的含义本身是&#8221; 重解释&#8221;,因而将float型指针无条件转换为整形指针.</p>

<p> c.指针运算</p>

<p>   #include&lt;iostream&gt;
   using namespace std;
   int main(void){
     int iArray[6];
     for(int i=0;i&lt;6;++i) iArray[i]= i<em>2;
     for(int</em> iP=iArray; iP&lt;iArray+6; iP+=1)
     cout&lt;&lt;iP&lt;&lt;&ldquo;: &rdquo;&lt;&lt;*iP&lt;&lt;endl;
   }</p>

<p>   上面的程序例中,指针运算在数组中的应用已有了初步展现.同时对于不同类型的指针,相应的运算操作也有不同的数据变化.但是,在指针进行超过数组范围的操作时是非常危险的.</p>

<p> d.指针限定</p>

<p>   我们知道,一个指针可以表示两个实体,即地址值和间仿值.因而,指针本身也分为指针常量和常量指针.</p>

<p>   const int a = 78;</p>

<p>   int b = 10;</p>

<p>   int c = 18;</p>

<p>   const int* ip = &amp;a;                  //const 修饰指向的实体类型 常量指针 无法修改数值</p>

<p>   int<em> const cp = &amp;b;                 //const 修饰指针</em>cp 指针常量 无法修改地址</p>

<p>   int const* dp = &amp;b;                 //同上</p>

<p>   const int *const icp = &amp;c;       //常量指针常量 均无法修改</p>

<p> e.引用</p>

<p>   引用定义为:</p>

<p>   int someInt = 5,anyInt = 8;</p>

<p>   int &amp; rInt = someIne;    //引用的作用类似别名,但值得注意的是, 如果重定义 rInt = anyInt,则rInt地址不变,值变为8,引用与指针的差别也就在于此了.即引用无法更改所引用的地址.通常我们也能使用const int &amp; rInt = someIne使上述语句无法运行.但实体本身的操作someInt = 8同样能达到目的.</p>

<p>   引用的主要作用是进行参数传递,这在后文中将有较为详细深入的介绍.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-11T11:44:32+08:00" pubdate data-updated="true">2008-04-11</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/11/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-wu//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/08/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-si/">
		
			C++学习笔记(重温计划之四)</a>
	</h2>
	<div class="entry-content">
		<p>3、数据类型（中）</p>

<p> 1）C-串与string</p>

<p>   c++的字符串分两类，一种是由c语言沿袭而来，称为c-串。例如，</p>

<p>   char buffer[7]=&ldquo;Hello!&rdquo;; //由于所有字符串必须以\0为结束符，则长度定义必须比实际元素个数多1</p>

<p>   事实上，字符数组的实际类型为char<em>，或const char</em>，称为字符型指针。实际应用中我们做如下定义:</p>

<p>   char<em> str=&ldquo;Hello!&rdquo;;//输出</em>str时为&#8221;H&#8221;，str则为&#8221;Hello&#8221;</p>

<p>   在c库函数中，又定义了字符串操作函数，例如strcmp(比较)、strcpy(复制)、strcat(连接)、strrev(倒置)、strset(设置)、strstr/strchr(查找串或字符)。通常我们需要指定头文件string.h，标准c++将其嵌套入iostream中，即省略了这一调用。</p>

<p>  其实，C++中提供了另一种高效可行的字符串类型，即string类型。string类是标准c++中的基础类，这在后文中我们会有详细解释。string的目的是使字符串操作更加方便安全。</p>

<h1>include&#8221;iostream&#8221;</h1>

<h1>include&#8221;algorithm&#8221;</h1>

<p>using namespace std;</p>

<p>int main(){</p>

<p>   string a,s1 = &ldquo;Hello!&rdquo;;</p>

<p>   string s2 = &ldquo;123&rdquo;;</p>

<p>   a=s1;                                                                                    //复制</p>

<p>   cout &lt;&lt; (a==s1 ? &ldquo; &rdquo; : &ldquo;not&rdquo;) &lt;&lt; &ldquo;equal\n&rdquo;;                          //比较</p>

<p>   cout &lt;&lt; a+s2 &lt;&lt;endl;                                                         //连接</p>

<p>   reverse(a.begin(),a.end());                                                     //倒置串</p>

<p>   cout &lt;&lt;a &lt;&lt; endl;</p>

<p>   cout &lt;&lt; a.replace(0,9,9,&lsquo;c&rsquo;)&lt;&lt;endl;                                     //设置</p>

<p>   cout &lt;&lt; (s1.find(&ldquo;ell&rdquo;)!= -1 ? &ldquo;&rdquo; : &ldquo;not&rdquo;) &lt;&lt; &ldquo;found\n&rdquo;;        //查找串</p>

<p>   cout &lt;&lt; (s1.find(&lsquo;c&rsquo;)!= -1 ? &ldquo;&rdquo; : &ldquo;not&rdquo;) &lt;&lt; &ldquo;found\n&rdquo;);          //查找字符</p>

<p>}</p>

<p>   由上基本可以看出，string在与c-串对比中是明显有优势的。而且，c-串可以随时赋值给string变量，具有相当的亲和程度.</p>

<p>  现在讨论string与c-串在输入输出中的c++用法.</p>

<p>   当输入时,我们以:</p>

<p>   fot(string s;cin &gt;&gt; s;)            //string s可以替换为char s[10]</p>

<p>   cout &lt;&lt; s &lt;&lt;&ldquo; &rdquo;;</p>

<p>   cout &lt;&lt; endl; </p>

<p>   cin &gt;&gt;在读入时一般过滤前导空格,包括空格、回车、水平/垂直制表符等等。</p>

<p>  我们同样可以采用非循环的方式。例如:</p>

<p>   string s;                           //在字符数组中，可以定义char s[10]</p>

<p>   getline(cin,s);                   //相应可以改为cin.getline(s,10)</p>

<p>   cout &lt;&lt; s &lt;&lt;endl;           //getline的好处是，在读入多行字符时，程序可以将内容逐行分解操作</p>

<p>  下面假设，存在一个文件aaa.txt,文件内有若干行整数，并且每行整数个数未知。这时求每行的整数和。</p>

<h1>include&lt;iostream&gt;                      //该程序已调试通过</h1>

<h1>include&lt;sstream&gt;</h1>

<h1>include&lt;fstream&gt;</h1>

<p>using namespace std;
int main(void){
 ifstream in(&ldquo;aaa.txt&rdquo;);
 for(string s;getline(in,s);){              //逐行读入的循环
  int a, sum = 0;
  for(istringstream sin(s);sin&gt;&gt;a;sum+=a);          //istringstream sin(s)意在创建输入string流sin()，sin&gt;&gt;即从string流中将整数输入到a中进行运算
  cout &lt;&lt; sum &lt;&lt; endl;
 }
 getchar();
 return 0;
}</p>

<p>  上面的程序体现了string流的概念，进一步体现了string字符串型的优势和特点。</p>

<p>  2）数组</p>

<p>   int a[5];   //即定义了一个数组，5代表了数组中元素个数。并且[ ]内必须为常量表达式，通常我们可以使用const int定义。</p>

<p>   数组的初始化过程中，有如下几种方式进行:</p>

<p>   int iArray[10] = {1,2,3,4,5,6,7,8,9,10};</p>

<p>   请注意，以上方式禁止的有:元素个数大于定义数、中途有元素定义为空、元素省略&hellip;不过实际操作中可以使元素个数少于定义数，比如  int iArray[10] = {1,2,3,4,5,6,7,8}; 这是允许的。</p>

<p>　int iArray[] = {1,2,3,4,5,6,7,8,9,10};  //虽然没有定义常量值，但初始化值的个数已经做出说明了。</p>

<p>　我们还能用到sizeof(a[n])来返回a[n]元素所占空间的字节数。</p>

<p>　下面来探测未初始化数组元素的默认值情况。计算机把这一类数组区分为全局数组或静态数组、局部数组。在全局数组和静态数组中，未定义情况下的元素值恒为０，而在局部数组中则变成不确定数。</p>

<p>　数组也有多位数组的形式，可定义为:</p>

<p>   int a[3][5];   //这是一个２维数组，其输入输出方式和１维数组是相同的</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-08T10:49:37+08:00" pubdate data-updated="true">2008-04-08</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/08/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-si//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/06/shou-ye-zheng-zai-geng-xin-flash-yuan-ma/">
		
			首页正在更新flash源码</a>
	</h2>
	<div class="entry-content">
		<p> 此次更新的主要目的是为接下来的内容扩展做好铺垫，另外也是为了增强网站的整体美观。晚上花了点时间只是整理出一个框架，未来具体情况目前还在构思中。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-06T01:20:53+08:00" pubdate data-updated="true">2008-04-06</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhan-dian-ri-zhi/'>站点日志</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/06/shou-ye-zheng-zai-geng-xin-flash-yuan-ma//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-ba-wan-jie-wan-jie-bao-hua-jie-yi/">
		
			Visual C++动态链接库编程（八）——完结篇——宋宝华解疑</a>
	</h2>
	<div class="entry-content">
		<p>　1.关于文章的获取</p>

<p>　　许多读者发来e-mail询问本系列文章的相关事宜，如：</p>

<p>　　（1） 是否已出版？</p>

<p>　　（2） 哪里可以<a target="_blank" href="http://www.mydown.com/" class="bluekey"><font color="#003399">下载</font></a>打包版？</p>

<p>　　（3） 哪里可以下载笔者的其它文章？</p>

<p class="guanggao">　　还有一些读者对日前笔者在天极网发表的《<a target="_blank" href="http://soft.yesky.com/lesson/188/2023188.shtml"><font color="#1111ee">C语言嵌入式系统编程修炼之道</font></a>》非常喜爱，给予了热情洋溢的赞扬，询问笔者能否继续创作嵌入式编程方面的文章。</p>


<p>　　对于这些问题，统一作答如下：</p>

<p>　　（1）本系列文章暂时尚未出版；</p>

<p>　　（2）您可以在天极网<a target="_blank" href="http://product.yesky.com/software/" class="bluekey"><font color="#003399">软件</font></a>频道下载笔者的多数拙作。另外，我也将不定期将这些文章上传到我的博客（ <a href="http://blog.donews.com/21cnbao/%EF%BC%89%E3%80%82%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E4%B8%AD%E7%9A%84%E4%BE%8B%E7%A8%8B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%9D%87%E7%BB%8F%E8%BF%87%E4%BA%B2%E6%89%8B%E8%B0%83%E8%AF%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%97%A0%E8%AF%AF%EF%BC%9B">http://blog.donews.com/21cnbao/%EF%BC%89%E3%80%82%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E4%B8%AD%E7%9A%84%E4%BE%8B%E7%A8%8B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%9D%87%E7%BB%8F%E8%BF%87%E4%BA%B2%E6%89%8B%E8%B0%83%E8%AF%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%97%A0%E8%AF%AF%EF%BC%9B</a></p>

<p>　　（3）就嵌入式系统开发，笔者将继续进行此方面的创作，新近将推出《基于嵌入式实时OS VxWorks的多任务<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>设计》及《领悟：从Windows多线程到VxWorks的多任务》。</p>

<p>　　非常感谢读者朋友对这些文章的喜爱，在下将竭尽所能地为您提供更多的好文章。</p>

<p>　　2.关于DLL的疑问</p>

<p>　　你好，看了你写的&#8221;VC++ DLL编程深入浅出&#8221;，特别有收获。 只是有个地方我老搞不明白，就是用DLL导出全局变量时，指定了.lib的路径（#pragma comment(lib,&ldquo;dllTest.lib&rdquo;)），那么.dll的文件的路径呢，我尝试着把.dll文件移到别的地方程序就无法正常运行了，请问.dll在这里怎么指定。</p>

<p>　　希望您能在百忙中抽空给我解答一下，不胜感激！</p>

<p>　　一位编程爱好者</p>

<p>　　回答：</p>

<p>　　Windows按下列顺序搜索DLL：</p>

<p>　　（1）当前进程的可执行模块所在的目录；</p>

<p>　　（2）当前目录；</p>

<p>　　（3）Windows 系统目录，通过GetSystemDirectory 函数可获得此目录的路径；</p>

<p>　　（4）Windows 目录，通过GetWindowsDirectory 函数可获得此目录的路径；</p>

<p>　　（5）PATH 环境变量中列出的目录。</p>

<p>　　因此，隐式链接时，DLL文件的路径不需要指定也不能指定，系统指定按照1～5的步骤寻找DLL，但是对应的.lib文件却需要指定路径；如果使用Windows API函数LoadLibrary动态加载DLL，则可以指定DLL的路径。</p>

<p>　　你好,我是一位C++初学者,我在PCONLINE看了教学之后,受益不浅。我想问一下能否在DLL里使用多线程?MSDN上用#using &lt;mscorlib.dll&gt;这个指令之后实现了多线程,不过好象不支持DLL..</p>

<p>　　请问有什么办法支持制作多线程DLL??能否给一个源码来?</p>

<p>　　回答：</p>

<p>　　在DLL中可以处理多线程，WIN32对于多线程的支持是<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>本身提供的一种能力，并不在于用户编写的是哪一类程序。即便是一个控制台程序，我们都可以使用多线程：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
void ThreadFun(void)
{
　while(1)
　{
　　printf( &#8220;this is new thread\n&#8221; );
　　Sleep( 1000 );
　}
}
int main()
{
　DWORD threadID;
　CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)ThreadFun, NULL, 0, &amp;threadID );
　while(1)
　{
　　printf( &#8220;this is main thread\n&#8221; );
　　Sleep( 1000 );
　}
}</td>
</tr>
</table>


<p>　　观察程序运行的结果为在控制台窗口上交替输出this is main thread、this is new thread。</p>

<p>　　我们来看下面的一个多线程DLL的例子。</p>

<p>　　DLL程序提供一个接口函数SendInit，在此接口中启动发送线程SendThreadFunc，在这个线程的对应工作函数中我们使用原始套接字socket发送报文。参考微软出版的经典书籍《Windows核心编程》，我们发现，不宜在DLL被加载的时候（即进程绑定时）启动一个新的线程。</p>

<p>　　这个线程等待一个CEvent事件（用于线程间通信），应用程序调用DLL中的接口函数SendMsg( InterDataPkt sendData )可以释放此事件。下面是相关的源代码：</p>

<p>　　（1）发送报文线程入口函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>///////////////////////////////////////////////////////////////////////////
//函数名：SendThreadFunc
//函数功能：发送报文工作线程入口函数，使用UDP协议
////////////////////////////////////////////////////////////////////////////
DWORD WINAPI SendThreadFunc( LPVOID lpvThreadParm )
//提示：对于线程函数应使用WINAPI声明，WINAPI被宏定义为__stdcall
{
　/* 创建socket */
　sendSock = socket ( AF_INET, SOCK_DGRAM, 0 );
　if ( sendSock == INVALID_SOCKET )
　{
　　AfxMessageBox ( &#8220;Socket创建失败&#8221; );
　　closesocket ( recvSock );
　}　/* 获得目标节点端口与地址 */
　struct sockaddr_in desAddr;
　desAddr.sin_family=AF_INET;
　desAddr.sin_port=htons( DES_RECV_PORT ); //目标节点接收端口
　desAddr.sin_addr.s_addr = inet_addr( DES_IP );

　/* 发送数据 */
　while(1)
　{
　　WaitForSingleObject( hSendEvent, 0xffffffffL );//无限等待事件发生
　　ResetEvent( hSendEvent );

　　sendto( sendSock, (char *)sendSockData.data, sendSockData.len, 0, (struct sockaddr*)&amp;desAddr, sizeof(desAddr) );
　}
　return -1;
}</td>
</tr>
</table>


<p>　　（2）MFC规则DLL的InitInstance函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/////////////////////////////////////////////////////////////////////////////
// CMultiThreadDllApp initialization
BOOL CMultiThreadDllApp::InitInstance()
{
　if ( !AfxSocketInit() ) //初始化socket
　{
　　AfxMessageBox( IDP_SOCKETS_INIT_FAILED );
　　return FALSE;
　}
　return TRUE;
}</td>
</tr>
</table>


<p>　　（3）启动发送线程</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>////////////////////////////////////////////////////////////////////////////////
//函数名：SendInit
//函数功能：DLL提供给应用程序调用接口，用于启动发送线程
/////////////////////////////////////////////////////////////////////////////
void SendInit(void)
{
　hSendThread = CreateThread( NULL, 1000, SendThreadFunc, this, 1, &amp;uSendThreadID );
}</td>
</tr>
</table>


<p>　　（4）SendMsg函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>////////////////////////////////////////////////////////////////////////////////
//函数名：SendMsg
//函数功能：DLL提供给应用程序调用接口，用于发送报文
/////////////////////////////////////////////////////////////////////////////
extern &#8220;C&#8221; void WINAPI SendMsg( InterDataPkt sendData )
{
　sendSockData = sendData;
　SetEvent( hSendEvent ); //释放发送事件
}</td>
</tr>
</table>


<p>　　以上程序仅仅是一个简单的例子，其实在许多工程应用中，我们经常看到这样的处理方式。这个DLL对用户而言仅仅使一个简单的接口函数SendMsg，对调用它的应用程序屏蔽了多线程的技术细节。与之类似，MFC提供的CSocket类在底层自己采用了多线程机制，所以使我们免去了对多线程的使用。</p>

<p>　　您好,看了您的DLL文章，发现导出函数可以直接用<em>declspec(dllexport)声明或在.def文件中定义，变量的导出也一样。我想知道类是否也可以在.def文件中导出？您的文章中只讲了在类前添加</em>declspec(dllexport)导出类的方法。请您指教！</p>

<p>　　回答：</p>

<p>　　一般我们不采用.def文件导出类，但是这并不意味着类不能用.def文件导出类。</p>

<p>　　使用Depends查看连载2的&#8221;导出类&#8221;例程生成的DLL，我们发现其导出了如图21的众多&#8221;怪&#8221;symbol，这些symbol都是经过编译器处理的。因此，为了以.def文件导出类，我们必须把这些&#8221;怪&#8221;symbol全部导出，实在是不划算啊！所以对于类，我们最好直接以_declspec(dllexport)导出。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="483" src="http://dev.yesky.com/imagelist/05/10/t5u84cjh02yz.jpg" height="160" /><img border="0" width="483" src="http://dev.yesky.com/imagelist/05/10/t5u84cjh02yz.jpg" height="160" />
图1 导出类时导出的symbol</td>
</tr>
</table>


<p>　　您好,看了您的DLL文章，知道怎么创建DLL了，但是面对一个具体的工程，我还是不知道究竟应该把什么做成DLL？您能给一些这方面的经验吗？</p>

<p>　　回答：</p>

<p>　　DLL一般用于软件模块中较固定、较通用的可以被复用的模块，这里有一个非常好的例子，就是豪杰超级解霸。梁肇新大师把处理视频和音频的算法模块专门做成了两个DLL，供超级解霸的用户界面GUI程序调用，实在是DLL<a target="_blank" href="http://design.yesky.com/" class="bluekey"><font color="#003399">设计</font></a>的模范教程。所谓&#8221;万变不离其宗&#8221;，超级解霸的界面再cool，用到的还是那几个DLL！具体请参考《编程高手箴言》一书。</p>

<p>　　您好,您的DLL文章讲的都是Windows的，请问Linux操作系统上可以制作DLL吗？如果能，和Windows有什么不一样？谢谢！</p>

<p>　　回答：</p>

<p>　　在Linux操作系统中，也可以采用动态链接技术进行软件设计，但与Windows下DLL的创建和调用方式有些不同。</p>

<p>　　Linux操作系统中的共享对象技术（Shared Object）与Windows里的DLL相对应，但名称不一样，其共享对象文件以.so作为后缀。与Linux共享对象技术相关的一些函数如下：</p>

<p>　　(1)打开共享对象，函数原型：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//打开名为filename共享对象，并返回操作句柄；
void *dlopen (const char *filename, int flag);</td>
</tr>
</table>


<p>　　(2)取函数地址，函数原型:</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//获得接口函数地址
void *dlsym(void *handle, char *symbol);</td>
</tr>
</table>


<p>　　(3)关闭共享对象，函数原型:</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//关闭指定句柄的共享对象
int dlclose (void *handle);</td>
</tr>
</table>


<p>　　(4)动态库错误函数，函数原型:</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//共享对象操作函数执行失败时，返回出错信息
const char *dlerror(void);</td>
</tr>
</table>


<p>　　从这里我们分明看到Windows API――LoadLibrary、FreeLibrary和GetProcAddress的影子！又一个&#8221;万变不离其宗&#8221;！</p>

<p>　　本系列文章的连载暂时告一段落，您可以继续给笔者发送email（mailto：21cnbao@21cn.com）讨论DLL的编程问题。对于文中的错误和纰漏，也热诚欢迎您指正。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:23:32+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-ba-wan-jie-wan-jie-bao-hua-jie-yi//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-qi/">
		
			Visual C++动态链接库编程（七）</a>
	</h2>
	<div class="entry-content">
		<p>　　从前文可知，DLL在<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>编制中可作出巨大贡献，它提供了具共性代码的复用能力。但是，正如一门高深的武学，若被掌握在正义之侠的手上，便可助其仗义江湖；但若被掌握在邪恶之徒的手上，则必然在江湖上掀起腥风血雨。DLL正是一种这样的武学。DLL一旦染上了魔性，就不再是正常的DLL程序，而是DLL木马，一种恶贯满盈的病毒，令特洛伊一夜之间国破家亡。</p>

<p>　　<strong>DLL木马的原理</strong></p>

<p>　　DLL木马的实现原理是编程者在DLL中包含木马程序代码，随后在目标主机中选择特定目标进程，以某种方式强行指定该进程调用包含木马程序的DLL，最终达到侵袭目标系统的目的。</p>

<p>　　正是DLL程序自身的特点决定了以这种形式加载木马不仅可行，而且具有良好的隐藏性：</p>

<p>　　（1）DLL程序被映射到宿主进程的地址空间中，它能够共享宿主进程的资源，并根据宿主进程在目标主机的级别非法访问相应的系统资源；</p>

<p>　　（2）DLL程序没有独立的进程地址空间，从而可以避免在目标主机中留下&#8221;蛛丝马迹&#8221;，达到隐蔽自身的目的。</p>

<p>　　DLL木马实现了&#8221;真隐藏&#8221;，我们在任务管理器中看不到木马&#8221;进程&#8221;，它完全溶进了系统的内核。与&#8221;真隐藏&#8221;对应的是&#8221;假隐藏&#8221;，&#8221;假隐藏&#8221;木马把自己注册成为一个服务。虽然在任务管理器中也看不到这个进程，但是&#8221;假隐藏&#8221;木马本质上还具备独立的进程空间。&#8221;假隐藏&#8221;只适用于Windows9x的系统，对于基于WINNT的<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>，通过服务管理器，我们可以发现系统中注册过的服务。</p>

<p>　　DLL木马注入其它进程的方法为远程线程插入。</p>

<p>　　远程线程插入技术指的是通过在另一个进程中创建远程线程的方法进入那个进程的内存地址空间。将木马程序以DLL的形式实现后，需要使用插入到目标进程中的远程线程将该木马DLL插入到目标进程的地址空间，即利用该线程通过调用Windows API LoadLibrary函数来加载木马DLL，从而实现木马对系统的侵害。</p>

<p>　　<strong>DLL木马注入程序</strong></p>

<p>　　这里涉及到一个非常重要的Windows API――CreateRemoteThread。与之相比，我们所习惯使用的CreateThread API函数只能在进程自身内部产生一个新的线程，而且被创建的新线程与主线程共享地址空间和其他资源。而CreateRemoteThread则不同，它可以在另外的进程中产生线程！CreateRemoteThread有如下特点：</p>

<p>　　（1）CreateRemoteThread较CreateThread多一个参数hProcess，该参数用于指定要创建线程的远程进程，其函数原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>HANDLE CreateRemoteThread(
　HANDLE hProcess, //远程进程句柄
　LPSECURITY_ATTRIBUTES lpThreadAttributes,
　SIZE_T dwStackSize,
　LPTHREAD_START_ROUTINE lpStartAddress,
　LPVOID lpParameter,
　DWORD dwCreationFlags,
　LPDWORD lpThreadId
);</td>
</tr>
</table>


<p>　　（2）线程函数的代码不能位于我们用来注入DLL木马的进程所在的地址空间中。也就是说，我们不能想当然地自己写一个函数，并把这个函数作为远程线程的入口函数；</p>

<p>　　（3）不能把本进程的指针作为CreateRemoteThread的参数，因为本进程的内存空间与远程进程的不一样。
　　以下<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>由作者Shotgun的DLL木马注入程序简化而得（<a target="_blank" href="http://www.mydown.com/code/245/245731.html"><font color="#1a1ae6">单击此处下载</font></a>，在经典书籍《Windows核心编程》中我们也可以看到类似的例子），它将d盘根目录下的troydll.dll插入到ID为4000的进程中：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;void CheckError ( int, int, char *); //出错处理函数

PDWORD pdwThreadId;
HANDLE hRemoteThread, hRemoteProcess;
DWORD fdwCreate, dwStackSize, dwRemoteProcessId;
PWSTR pszLibFileRemote=NULL;

void main(int argc,char **argv)
{
　int iReturnCode;
　char lpDllFullPathName[MAX_PATH];
　WCHAR pszLibFileName[MAX_PATH]={0};

　dwRemoteProcessId = 4000;
　strcpy(lpDllFullPathName, &#8220;d:&#92;troydll.dll&#8221;);
　//将DLL文件全路径的ANSI码转换成UNICODE码
　iReturnCode = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,
　　lpDllFullPathName, strlen(lpDllFullPathName),
　　pszLibFileName, MAX_PATH);
　CheckError(iReturnCode, 0, &#8220;MultByteToWideChar&#8221;);
　//打开远程进程
　hRemoteProcess = OpenProcess(PROCESS_CREATE_THREAD | //允许创建线程
　　PROCESS_VM_OPERATION | //允许VM操作
　　PROCESS_VM_WRITE, //允许VM写
　　FALSE, dwRemoteProcessId );
　CheckError( (int) hRemoteProcess, NULL, &#8220;Remote Process not Exist or Access Denied!&#8221;);
　//计算DLL路径名需要的内存空间
　int cb = (1 + lstrlenW(pszLibFileName)) * sizeof(WCHAR);
　pszLibFileRemote = (PWSTR) VirtualAllocEx( hRemoteProcess, NULL, cb, MEM_COMMIT, PAGE_READWRITE);
　CheckError((int)pszLibFileRemote, NULL, &#8220;VirtualAllocEx&#8221;);
　//将DLL的路径名复制到远程进程的内存空间
　iReturnCode = WriteProcessMemory(hRemoteProcess, pszLibFileRemote, (PVOID) pszLibFileName, cb, NULL);
　CheckError(iReturnCode, false, &#8220;WriteProcessMemory&#8221;);
　//计算LoadLibraryW的入口地址
　PTHREAD_START_ROUTINE pfnStartAddr = (PTHREAD_START_ROUTINE)
　　　GetProcAddress(GetModuleHandle(TEXT(&#8220;Kernel32&#8221;)), &#8220;LoadLibraryW&#8221;);
　CheckError((int)pfnStartAddr, NULL, &#8220;GetProcAddress&#8221;);
　//启动远程线程，通过远程线程调用用户的DLL文件
　hRemoteThread = CreateRemoteThread( hRemoteProcess, NULL, 0, pfnStartAddr, pszLibFileRemote, 0, NULL);
　CheckError((int)hRemoteThread, NULL, &#8220;Create Remote Thread&#8221;);
　//等待远程线程退出
　WaitForSingleObject(hRemoteThread, INFINITE);
　//清场处理
　if (pszLibFileRemote != NULL)
　{
　　VirtualFreeEx(hRemoteProcess, pszLibFileRemote, 0, MEM_RELEASE);
　}
　if (hRemoteThread != NULL)
　{
　　CloseHandle(hRemoteThread );
　}
　if (hRemoteProcess!= NULL)
　{
　　CloseHandle(hRemoteProcess);
　}
}

//错误处理函数CheckError()
void CheckError(int iReturnCode, int iErrorCode, char *pErrorMsg)
{
　if(iReturnCode==iErrorCode)
　{
　　printf(&#8220;%s Error:%d\n\n&#8221;, pErrorMsg, GetLastError());
　　//清场处理
　　if (pszLibFileRemote != NULL)
　　{
　　　VirtualFreeEx(hRemoteProcess, pszLibFileRemote, 0, MEM_RELEASE);
　　}
　　if (hRemoteThread != NULL)
　　{
　　　CloseHandle(hRemoteThread );
　　}
　　if (hRemoteProcess!= NULL)
　　{
　　　CloseHandle(hRemoteProcess);
　　}
　　exit(0);
　}
}</td>
</tr>
</table>


<p>　　从DLL木马注入程序的源代码中我们可以分析出DLL木马注入的一般步骤为：</p>

<p>　　（1）取得宿主进程（即要注入木马的进程）的进程ID dwRemoteProcessId；</p>

<p>　　（2）取得DLL的完全路径，并将其转换为宽字符模式pszLibFileName；</p>

<p>　　（3）利用Windows API OpenProcess打开宿主进程，应该开启下列选项：</p>

<p>　　a.PROCESS_CREATE_THREAD：允许在宿主进程中创建线程；</p>

<p>　　b.PROCESS_VM_OPERATION：允许对宿主进程中进行VM操作；</p>

<p>　　c.PROCESS_VM_WRITE：允许对宿主进程进行VM写。</p>

<p>　　（4）利用Windows API VirtualAllocEx函数在远程线程的VM中分配DLL完整路径宽字符所需的存储空间，并利用Windows API WriteProcessMemory函数将完整路径写入该存储空间；</p>

<p>　　（5）利用Windows API GetProcAddress取得Kernel32模块中LoadLibraryW函数的地址，这个函数将作为随后将启动的远程线程的入口函数；</p>

<p>　　（6）利用Windows API CreateRemoteThread启动远程线程，将LoadLibraryW的地址作为远程线程的入口函数地址，将宿主进程里被分配空间中存储的完整DLL路径作为线程入口函数的参数以另其启动指定的DLL；</p>

<p>　　（7）清理现场。</p>

<p>　　<strong>DLL木马的防治</strong></p>

<p>　　从DLL木马的原理和一个简单的DLL木马程序中我们学到了DLL木马的工作方式，这可以帮助我们更好地理解DLL木马病毒的防治手段。</p>

<p>　　一般的木马被植入后要打开一<a target="_blank" href="http://product.yesky.com/net/" class="bluekey"><font color="#003399">网络</font></a>端口与攻击程序通信，所以防火墙是抵御木马攻击的最好方法。防火墙可以进行数据包过滤检查，我们可以让防火墙对通讯端口进行限制，只允许系统接受几个特定端口的数据请求。这样，即使木马植入成功，攻击者也无法进入到受侵系统，防火墙把攻击者和木马分隔开来了。</p>

<p>　　对于DLL木马，一种简单的观察方法也许可以帮助用户发现之。我们查看运行进程所依赖的DLL，如果其中有一些莫名其妙的DLL，则可以断言这个进程是宿主进程，系统被植入了DLL木马。&#8221;道高一尺，魔高一丈&#8221;，现如今，DLL木马也发展到了更高的境界，它们看起来也不再&#8221;莫名其妙&#8221;。在最新的一些木马里面，开始采用了先进的DLL陷阱技术，编程者用特洛伊DLL替换已知的系统DLL。特洛伊DLL对所有的函数调用进行过滤，对于正常的调用，使用函数转发器直接转发给被替换的系统DLL；对于一些事先约定好的特殊情况，DLL会执行一些相应的操作。</p>

<p>　　本文给出的只是DLL木马最简单情况的介绍，读者若有兴趣深入研究，可以参考其它资料。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:21:07+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-qi//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-liu/">
		
			Visual C++动态链接库编程（六）</a>
	</h2>
	<div class="entry-content">
		<p>　　动态链接库DLL实现了库的共享，体现了代码重用的思想。我们可以把广泛的、具有共性的、能够多次被利用的函数和类定义在库中。这样，在再次使用这些函数和类的时候，就不再需要重新添加与这些函数和类相关的代码。具有共性的问题大致有哪些呢？笔者归纳如下：</p>

<p class="guanggao">　　（1）通用的算法</p>


<p>　　图像处理、视频音频解码、压缩与解压缩、加密与解密通常采用某些特定的算法，这些算法较固定且在这类<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>中往往经常被使用。</p>

<p>　　（2）纯资源DLL</p>

<p>　　我们可以从DLL中获取资源，对于一个支持多种语言的应用程序而言，我们可以判断<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>的语言，并自动为应用程序加载与OS对应的语言。这是多语言支持应用程序的一般做法。</p>

<p>　　（3）通信控制DLL</p>

<p>　　串口、网口的通信控制函数如果由DLL提供则可以使应用程序轻松不少。在工业控制、modem程序甚至socket通信中，经常使用通信控制DLL。</p>

<p>　　本节将给出DLL的三个典型应用实例。</p>

<p>　　<strong>7.1 算法DLL</strong></p>

<p>　　我们直接用读者的一个提问作为例子。</p>

<p>　　宋宝华先生，您好！</p>

<p>　　我在dev.yesky.com上看到你连载的《VC++动态链接库编程》，觉得非常好。我以前主要是用Delphi的，C/C++学过，对Win32和VCL比较熟悉，但是没有接触过VC++，对MFC很陌生。这段时间和一个同学合作做光学成像的计算机模拟，用到傅立叶变换，手里面有例程是VC++写的。我们的界面是用Delphi开发，需要将其傅立叶变换功能提出做一个DLL供Delphi调用。苦于不懂MFC，试了很多方法，都不成功，最后只得采用折衷方案，简单修改一下程序，传一个参数进去，当作exe来调用，才没有耽搁后续进程。</p>

<p>　　……</p>

<p>　　谢谢！</p>

<p>　　　　　　　　致</p>

<p>　　礼！</p>

<p>　　　　　　　　 某某</p>

<p>　　学习过较高级别数学（概率统计与随机过程）、信号与线性系统及数字信号处理的读者应该知道，傅立叶变换是一种在信号分析中常用的算法，用于时域和频域的相互转换。FFT变换算法通用而有共性，我们适宜把它集成在一个DLL中。</p>

<p>　　随后，这位读者提供了这样的一个函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/* 函数名称：FFT()
* 参数:
* complex&lt;double&gt; * TD - 指向时域数组的指针
* complex&lt;double&gt; * FD - 指向频域数组的指针
* r －2的幂数，即迭代次数
* 返回值: 无。
* 说明:该函数用来实现快速傅立叶变换
*/void FFT(complex&lt;double&gt; * TD, complex&lt;double&gt; * FD, int r)
{
　LONG count; // 傅立叶变换点数
　int i,j,k; // 循环变量
　int bfsize,p; // 中间变量
　double angle; // 角度
　complex&lt;double&gt; *W,*X1,*X2,*X;
　count = 1 &lt;&lt; r; //傅立叶变换点数

　// 分配运算所需存储器

　W = new complex&lt;double&gt;[count / 2];
　X1 = new complex&lt;double&gt;[count];
　X2 = new complex&lt;double&gt;[count];

　// 计算加权系数

　for(i = 0; i &lt; count / 2; i++)
　{
　　angle = -i * PI * 2 / count;
　　W[i] = complex&lt;double&gt; (<a target="_blank" href="http://gamepic.yesky.com/gamepic/colplay/" class="bluekey"><font color="#003399">cos</font></a>(angle), sin(angle));
　}

　// 将时域点写入X1

　memcpy(X1, TD, sizeof(complex&lt;double&gt;) * count);

　// 采用蝶形算法进行快速傅立叶变换

　for(k = 0; k &lt; r; k++)
　{
　　for(j = 0; j &lt; 1 &lt;&lt; k; j++)
　　{
　　　bfsize = 1 &lt;&lt; (r-k);
　　　for(i = 0; i &lt; bfsize / 2; i++)
　　　{
　　　　p = j * bfsize;
　　　　X2[i + p] = X1[i + p] + X1[i + p + bfsize / 2];
　　　　X2[i + p + bfsize / 2] = (X1[i + p] - X1[i + p + bfsize / 2]) * W[i * (1&lt;&lt;k)];
　　　}
　　}
　　X = X1;
　　X1 = X2;
　　X2 = X;
　}

　// 重新排序

　for(j = 0; j &lt; count; j++)
　{
　　p = 0;
　　for(i = 0; i &lt; r; i++)
　　{
　　　if (j&amp;(1&lt;&lt;i))
　　　{
　　　　p+=1&lt;&lt;(r-i-1);
　　　}
　　}
　　FD[j]=X1[p];
　}

　// 释放内存

　delete W;
　delete X1;
　delete X2;
}</td>
</tr>
</table>


<p class="guanggao">　　既然有了FFT这个函数，我们要把它做在DLL中，作为DLL的一个接口将是十分简单的，其步骤如下：</p>


<p>　　（1）利用MFC向导建立一个非MFC DLL；</p>

<p>　　（2）在工程中添加fft.h和fft.cpp两个文件；</p>

<p>　　fft.h的源代码为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#ifndef FFT_H
#define FFT_H#include &lt;complex&gt;

using namespace std;
extern &#8220;C&#8221; void __declspec(dllexport) __stdcall FFT(complex&lt;double&gt; * TD, complex&lt;double&gt; * FD, int r);

#define PI 3.1415926
#endif

fft.cpp的源代码为：

/* 文件名：fft.cpp　*/

#include &#8220;fft.h&#8221;
void __stdcall FFT(complex&lt;double&gt; * TD, complex&lt;double&gt; * FD, int r)
{
　…//读者提供的函数代码
}</td>
</tr>
</table>


<p class="guanggao">　　在任何编程语言中使用Win32 API LoadLibrary都可以加载这个DLL，而使用GetProcAddress(hDll, &#8220;FFT&#8221;)则可以获得函数FFT的地址，读者所提到的Delphi当然也不例外。</p>


<p>　　这个DLL中有两点需要注意：</p>

<p>　　（1）使用extern &ldquo;C&#8221;修饰函数声明，否则，生成的DLL只能供C++调用；</p>

<p>　　（2）使用<strong>stdcall修饰函数声明及定义，</strong>stdcall是Windows API的函数调用方式。</p>

<p class="guanggao">　　<strong>7.2纯资源DLL</strong></p>


<p>　　我们在应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>中产生如图18所示的资源（对话框），<a target="_blank" href="http://www.mydown.com/code/244/244785.html"><font color="#d52b2b">单击此处下载本工程</font></a>。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/76j85iz4679p.jpg" />
图18 中文对话框</td>
</tr>
</table>


<p>　　在与这个应用程序相同的工作区里利用MFC向导建立两个简单的DLL，把应用工程中的资源全选后分别拷贝到ChineseDll和EngLishDll，在EnglishDll工程的资源文件中搜索下面的语句：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/////////////////////////////////////////////////////////////////////////////// Chinese (P.R.C.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
#ifdef _WIN32
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED
#pragma code_page(936)
#endif //_WIN32</td>
</tr>
</table>


<p>　　将其改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32

LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#pragma code_page(1252)
#endif //_WIN32</td>
</tr>
</table>


<p>　　并将其中所有的中文翻译为英文。这个DLL为我们提供了如图19所示的对话框资源。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/53b44x05f4i0.jpg" />
图19英文对话框</td>
</tr>
</table>


<p>　　修改应用工程的InitInstance()函数，在</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>CResourceDllCallDlg dlg;
m_pMainWnd = &amp;dlg;
int nResponse = dlg.DoModal();</td>
</tr>
</table>


<p>　　之前（即对话框显示之前）添加如下代码：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//获取<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>的语言WORD wLangPID = PRIMARYLANGID( GetSystemDefaultLangID() );
if( LANG_CHINESE == wLangPID )
{
　hLanguageDll = LoadLibrary( &#8220;ChineseDll.dll&#8221; ); //加载中文资源
}
else
{
　hLanguageDll = LoadLibrary( &#8220;EnglishDll.dll&#8221; ); //加载英文资源
}

if( NULL == hLanguageDll )
{
　AfxMessageBox( &#8220;Load DLL failure&#8221; );
　return FALSE;
}
AfxSetResourceHandle( hLanguageDll ); //设置当前的资源句柄</td>
</tr>
</table>


<p>　　这样的应用程序将具有自适应性质，在中文OS中显示中文资源，在英文OS中则显示英文资源。
　　<strong>7.3通信控制DLL</strong></p>

<p>　　我们在这里举一个串口通信类的例子。</p>

<p>　　也许您需要了解一点串口通信的背景知识，其实串口到处都看得到，譬如PC机的COM口即为串行通讯口（简称串口）。如图20，打开Windows的设备管理器，我们看到了COM口。</p>

<p>　　在Windows系统，需通过DCB(Device Control Block)对串口进行配置。利用Windows API GetCommState函数可以获取串口当前配置；利用SetCommState函数则可以设置串口通讯的参数。</p>

<p>　　串行通信通常按以下四步进行：</p>

<p>　　(1)打开串口；</p>

<p>　　(2)配置串口；</p>

<p>　　(3)数据传送；</p>

<p>　　(4)关闭串口。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/2b6sfwuq08kz.jpg" />
图20 PC的串口</td>
</tr>
</table>


<p>　　由此可见，我们需要给串口控制DLL提供如下四个接口函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//打开指定的串口，其参数port为端口号BOOL ComOpen(int port); //在这个函数里使用默认的参数设置串口

//将打开的串口关闭

void ComClose(int port);

//将串口接收缓冲区中的数据放到buffer中

int GetComData(char *buf, int buf_len);

//将指定长度的数据发送到串口

int SendDataToCom(LPBYTE buf,int buf_Len);</td>
</tr>
</table>


<p>　　下面给出了DLL接口的主要源代码框架：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//com.h：com类通信接口class AFX_EXT_CLASS com
{
　public:
　　ComOpen(int port)
　　{
　　　…
　　}
　　int SendDataToCom(LPBYTE buf,int buf_Len)
　　{
　　　…
　　}
　　int GetComData(char *buf, int buf_len)
　　{
　　　…
　　}
　　void ComClose()
　　{
　　　…
　　}
　}</td>
</tr>
</table>


<p>　　我们编写一控制台<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>来演示DLL的调用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;iostream&gt;
#include &lt;exception&gt;using namespace std;

#include &lt;windows.h&gt;
#include &#8220;com.h&#8221; //包含DLL中导出类的头文件 int main(int argc, char *argv[])
{
　try
　{
　　char str[] = &#8220;com_class test&#8221;;
　　com com1;
　　com1.ComOpen (1);
　　for(int i=0; i&lt;100; i++) //以同步方式写com的buffer
　　{
　　　Sleep(500);
　　　com1.SendDataToCom (str,strlen(str));
　　}
　　com1.ComClose ();
　}
　catch(exception &amp;e)
　{
　　cout &lt;&lt; e.what() &lt;&lt; endl;
　}
　return 0;
}</td>
</tr>
</table>


<p>　　DLL的编写与调用方法及主要应用皆已讲完，在下一节里，我们将看到比较“高深”的主题――DLL木马。曾几何时，DLL木马成为了病毒的一种十分重要的形式，是DLL的什么特性使得它能够成为一种病毒？下一节我们将揭晓谜底。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:19:07+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-liu//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-wu/">
		
			Visual C++动态链接库编程（五）</a>
	</h2>
	<div class="entry-content">
		<p>　　前文我们对非MFC DLL和MFC规则DLL进行了介绍，现在开始详细分析DLL的最后一种类型――MFC扩展DLL。</p>

<p>　　<strong>6.1概论</strong></p>

<p>　　MFC扩展DLL与MFC规则DLL的相同点在于在两种DLL的内部都可以使用MFC类库，其不同点在于MFC扩展DLL与应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的接口可以是MFC的。MFC扩展DLL的含义在于它是MFC的扩展，其主要功能是实现从现有MFC库类中派生出可重用的类。MFC扩展DLL使用MFC 动态链接库版本，因此只有用共享MFC 版本生成的MFC 可执行文件（应用程序或规则DLL）才能使用MFC扩展DLL。</p>

<p class="guanggao">　　从前文可知，MFC规则DLL被MFC向导自动添加了一个CWinApp的对象，而MFC扩展DLL则不包含该对象，它只是被自动添加了DllMain 函数。对于MFC扩展DLL，开发人员必须在DLL的DllMain函数中添加初始化和结束代码。</p>


<p>　　从下表我们可以看出三种DLL对DllMain入口函数的不同处理方式：</p>

<p><p class="guanggao">
<table border="1" align="center" width="90%" cellPadding="2" cellSpacing="0">
<tr>
<td>DLL类型</td>
<td>入口函数</td>
</tr>
<tr>
<td>非 MFC DLL</td>
<td>编程者提供DllMain函数</td>
</tr>
<tr>
<td>MFC规则 DLL</td>
<td>CWinApp对象的InitInstance 和 ExitInstance</td>
</tr>
<tr>
<td>MFC扩展 DLL</td>
<td>MFC DLL向导生成DllMain 函数</td>
</tr>
</table>
<p class="guanggao">　　对于MFC扩展DLL，系统会自动在工程中添加如下表所示的宏，这些宏为DLL和应用程序的编写提供了方便。像AFX_EXT_CLASS、AFX_EXT_API、AFX_EXT_DATA这样的宏，在DLL和应用程序中将具有不同的定义，这取决于<em>AFXEXT宏是否被定义。这使得在DLL和应用程序中，使用统一的一个宏就可以表示出输出和输入的不同意思。在DLL中，表示输出（因为</em>AFXEXT被定义，通常是在编译器的标识参数中指定/D_AFXEXT）；在应用程序中，则表示输入（_AFXEXT没有定义）。</p></p>

<p><p class="guanggao">
<table border="1" align="center" width="90%" cellPadding="2" cellSpacing="0">
<tr>
<td>宏</td>
<td>定义</td>
</tr>
<tr>
<td>AFX_CLASS_IMPORT</td>
<td><strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_API_IMPORT</td>
<td></strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_DATA_IMPORT</td>
<td><strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_CLASS_EXPORT</td>
<td></strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_API_EXPORT</td>
<td><strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_DATA_EXPORT</td>
<td></strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_EXT_CLASS</td>
<td>#ifdef _AFXEXT
　AFX_CLASS_EXPORT</p>

<h1>else</h1>

<p>　AFX_CLASS_IMPORT</td>
</tr>
<tr>
<td>AFX_EXT_API</td>
<td>#ifdef _AFXEXT
　AFX_API_EXPORT</p>

<h1>else</h1>

<p>　AFX_API_IMPORT</td>
</tr>
<tr>
<td>AFX_EXT_DATA</td>
<td>#ifdef _AFXEXT
　AFX_DATA_EXPORT</p>

<h1>else</h1>

<p>　AFX_DATA_IMPORT</td>
</tr>
</table>
<p class="guanggao">　　<strong>6.2 MFC扩展DLL导出MFC派生类</strong></p>
　　在这个例子中，我们将产生一个名为“ExtDll”的MFC扩展DLL工程，在这个DLL中导出一个对话框类，这个对话框类派生自MFC类CDialog。</p>

<p>　　使用MFC向导生成MFC扩展DLL时，系统会自动添加如下代码：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>static AFX_EXTENSION_MODULE ExtDllDLL = { NULL, NULL };
extern &ldquo;C&rdquo; int APIENTRYDllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
　// Remove this if you use lpReserved</p>

<p>　UNREFERENCED_PARAMETER( lpReserved );</p>

<p>　//说明：lpReserved是一个被系统所保留的参数，对于隐式链接是一个非零值，对于显式链接值是零</p>

<p>　if (dwReason == DLL_PROCESS_ATTACH)
　{
　　TRACE0( &ldquo;EXTDLL.DLL Initializing!\n&rdquo; );
　　// Extension DLL one-time initialization
　　if ( !AfxInitExtensionModule( ExtDllDLL, hInstance ))
　　　return 0;
　　　// Insert this DLL into the resource chain
　　new CDynLinkLibrary( ExtDllDLL );
　}
　else if (dwReason == DLL_PROCESS_DETACH)
　{
　　TRACE0( &ldquo;EXTDLL.DLL Terminating!\n&rdquo; );
　　// Terminate the library before destructors are called
　　AfxTermExtensionModule( ExtDllDLL );
　}
　return 1; // ok
}</td>
</tr>
</table>
<p class="guanggao">　　这一段代码含义晦涩，我们需要对其进行解读：</p>
　　（1）上述代码完成MFC扩展DLL的初始化和终止处理；</p>

<p>　　（2）初始化期间所创建的 CDynLinkLibrary 对象使MFC扩展 DLL 可以将 DLL中的CRuntimeClass 对象或资源导出到应用程序；</p>

<p>　　（3）AfxInitExtensionModule函数捕获模块的CRuntimeClass 结构和在创建 CDynLinkLibrary 对象时使用的对象工厂（COleObjectFactory 对象）；</p>

<p>　　（4）AfxTermExtensionModule函数使 MFC 得以在每个进程与扩展 DLL 分离时（进程退出或使用AfxFreeLibrary卸载DLL时）清除扩展 DLL；</p>

<p>　　（5）第一条语句static AFX_EXTENSION_MODULE ExtDllDLL = { NULL, NULL };定义了一个AFX_EXTENSION_MODULE类的静态全局对象，AFX_EXTENSION_MODULE的定义如下：</p>

<p><p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>struct AFX_EXTENSION_MODULE
{
　BOOL bInitialized;
　HMODULE hModule;
　HMODULE hResource;
　CRuntimeClass<em> pFirstSharedClass;
　COleObjectFactory</em> pFirstSharedFactory;
};</td>
</tr>
</table>
<p class="guanggao">　　由AFX_EXTENSION_MODULE的定义我们可以更好的理解（2）、（3）、（4）点。</p>
　　在资源编辑器中添加一个如图15所示的对话框，并使用MFC类向导为其添加一个对应的类CExtDialog，系统自动添加了ExtDialog.h和ExtDialog.cpp两个头文件。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/z44bxd805tf3.jpg" height="219" /><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/z44bxd805tf3.jpg" height="219" />
图15 MFC扩展DLL中的对话框</td>
</tr>
</table>
<p class="guanggao">　　修改ExtDialog.h中CExtDialog类的声明为：</p></p>

<p><p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class AFX_EXT_CLASS CExtDialog : public CDialog
{
　public:
　　CExtDialog( CWnd<em> pParent = NULL );
　　enum { IDD = IDD_DLL_DIALOG };
　protected:
　　virtual void DoDataExchange( CDataExchange</em> pDX );
　　DECLARE_MESSAGE_MAP()
};</td>
</tr>
</table>
<p class="guanggao">　　这其中最主要的改变是我们在class AFX_EXT_CLASS CExtDialog语句中添加了“AFX_EXT_CLASS”宏，则使得DLL中的CExtDialog类被导出。</p>
<p class="guanggao">　　<strong>6.3 MFC扩展DLL的加载</strong></p>
　　6.3.1 隐式加载</p>

<p>　　我们在6.2工程所在的工作区中添加一个LoadExtDllDlg工程，用于演示MFC扩展DLL的加载。在LoadExtDllDlg工程中添加一个如图16所示的对话框，这个对话框上包括一个“调用DLL”按钮。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="394" src="http://dev.yesky.com/imagelist/05/10/4o3b052d7377.jpg" height="138" /><img border="0" width="394" src="http://dev.yesky.com/imagelist/05/10/4o3b052d7377.jpg" height="138" />
图16 MFC扩展DLL调用工程中的对话框</td>
</tr>
</table>
　　在与图16对应对话框类实现文件的头部添加：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// LoadExtDllDlg.cpp : implementation file
//#include &ldquo;..\ExtDialog.h&rdquo;</p>

<h1>pragma comment( lib, &ldquo;ExtDll.lib&rdquo; )</h1>

<p>而“调用DLL”按钮的单击事件的消息处理函数为：</p>

<p>void CLoadExtDllDlg::OnDllcallButton()
{
　CExtDialog extDialog;
　extDialog.DoModal();
}</td>
</tr>
</table>
　　当我们单击“调用DLL”的时候，弹出了如图15的对话框。</p>

<p>　　为提供给用户隐式加载（MFC扩展DLL一般使用隐式加载，具体原因见下节），MFC扩展DLL需要提供三个文件：</p>

<p>　　（1）描述DLL中扩展类的头文件；</p>

<p>　　（2）与动态链接库对应的.LIB文件；</p>

<p>　　（3）动态链接库.DLL文件本身。</p>

<p>　　有了这三个文件，应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的开发者才可充分利用MFC扩展DLL。</p>

<p>　　6.3.2 显示加载</p>

<p>　　显示加载MFC扩展DLL应使用MFC全局函数AfxLoadLibrary而不是WIN32 API中的LoadLibrary。AfxLoadLibrary 最终也调用了 LoadLibrary这个API，但是在调用之前进行了线程同步的处理。</p>

<p>　　AfxLoadLibrary 的函数原型与 LoadLibrary完全相同，为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>HINSTANCE AFXAPI AfxLoadLibrary( LPCTSTR lpszModuleName );</td>
</tr>
</table>
　　与之相对应的是，MFC 应用程序应使用AfxFreeLibrary 而非FreeLibrary 卸载MFC扩展DLL。AfxFreeLibrary的函数原型也与 FreeLibrary完全相同，为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BOOL AFXAPI AfxFreeLibrary( HINSTANCE hInstLib );</td>
</tr>
</table>
　　如果我们把上例中的“调用DLL”按钮单击事件的消息处理函数改为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CLoadExtDllDlg::OnDllcallButton()
{
　HINSTANCE hDll = AfxLoadLibrary( &ldquo;ExtDll.dll&rdquo; );
　if(NULL == hDll)
　{
　　AfxMessageBox( &ldquo;MFC扩展DLL动态加载失败&rdquo; );
　　return;
　}　CExtDialog extDialog;
　extDialog.DoModal();
　AfxFreeLibrary(hDll);
}</td>
</tr>
</table>
　　则工程会出现link错误：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>LoadExtDllDlg.obj : error LNK2001: unresolved external symbol &ldquo;<strong>declspec(dllimport) public: virtual </strong>thiscall CExtDialog::~CExtDialog(void)&rdquo; (<strong>imp_??1CExtDialog@@UAE@XZ)LoadExtDllDlg.obj : error LNK2001: unresolved external symbol &ldquo;</strong>declspec(dllimport) public: <strong>thiscall CExtDialog::CExtDialog(class CWnd *)&rdquo; (</strong>imp_??0CExtDialog@@QAE@PAVCWnd@@@Z)</td>
</tr>
</table>
　　提示CExtDialog的构造函数和析构函数均无法找到！是的，对于派生MFC类的MFC扩展DLL，当我们要在应用程序中使用DLL中定义的派生类时，我们不宜使用动态加载DLL的方法。</p>

<p>　　<strong>6.4 MFC扩展DLL加载MFC扩展DLL</strong></p>

<p>　　我们可以在MFC扩展DLL中再次使用MFC扩展DLL，但是，由于在两个DLL中对于AFX_EXT_CLASS、AFX_EXT_API、AFX_EXT_DATA宏的定义都是输出，这会导致调用的时候出现问题。</p>

<p>　　我们将会在调用MFC扩展DLL的DLL中看到link错误：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>error LNK2001: unresolved external symbol …&hellip;&hellip;.</td>
</tr>
</table>
　　因此，在调用MFC扩展DLL的MFC扩展DLL中，在包含被调用DLL的头文件之前，需要临时重新定义AFX_EXT_CLASS的值。下面的例子显示了如何实现：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//临时改变宏的含义“输出”为“输入”#undef AFX_EXT_CLASS</p>

<h1>undef AFX_EXT_API</h1>

<h1>undef AFX_EXT_DATA</h1>

<h1>define AFX_EXT_CLASS AFX_CLASS_IMPORT</h1>

<h1>define AFX_EXT_API AFX_API_IMPORT</h1>

<h1>define AFX_EXT_DATA AFX_DATA_IMPORT</h1>

<p>//包含被调用MFC扩展DLL的头文件</p>

<h1>include &ldquo;CalledDLL.h&rdquo;</h1>

<p>//恢复宏的含义为输出</p>

<h1>undef AFX_EXT_CLASS</h1>

<h1>undef AFX_EXT_API</h1>

<h1>undef AFX_EXT_DATA</h1>

<h1>define AFX_EXT_CLASS AFX_CLASS_EXPORT</h1>

<h1>define AFX_EXT_API AFX_API_EXPORT</h1>

<h1>define AFX_EXT_DATA AFX_DATA_EXPORT</td></h1>

<p></tr>
</table>
　　<strong>6.5 MFC扩展DLL导出函数和变量</strong></p>

<p>　　MFC扩展DLL导出函数和变量的方法也十分简单，下面我们给出一个简单的例子。</p>

<p>　　我们在MFC向导生成的MFC扩展DLL工程中添加gobal.h和global.cpp两个文件：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//global.h:MFC扩展DLL导出变量和函数的声明extern &ldquo;C&rdquo;
{
　int AFX_EXT_DATA total; //导出变量
　int AFX_EXT_API add( int x, int y ); //导出函数
}</p>

<p>//global.cpp:MFC扩展DLL导出变量和函数定义</p>

<h1>include &ldquo;StdAfx.h&rdquo;</h1>

<h1>include &ldquo;global.h&rdquo;</h1>

<p>extern &ldquo;C&rdquo; int total;
int add(int x,int y)
{
　total = x + y;
　return total;
}</td>
</tr>
</table>
　　编写一个简单的控制台<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>来调用这个MFC扩展DLL：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;iostream.h&gt;</p>

<h1>include &lt;afxver<em>.h&gt;//AFX_EXT_DATA、AFX_EXT_API宏的定义在afxver</em>.h头文件中</h1>

<h1>pragma comment ( lib, &ldquo;ExtDll.lib&rdquo; )</h1>

<h1>include &ldquo;..\global.h&rdquo;</h1>

<p>int main(int argc, char* argv[])
{
　cout &lt;&lt; add(2,3) &lt;&lt; endl;
　cout &lt;&lt; total;
　return 0;
}</td>
</tr>
</table>
　　运行程序，在控制台上看到：</p>

<p>　　5</p>

<p>　　5</p>

<p>　　另外，在Visual C++下建立MFC扩展DLL时，MFC DLL向导会自动生成.def文件。因此，对于函数和变量，我们除了可以利用AFX_EXT_DATA、AFX_EXT_API宏导出以外，在.def文件中定义导出也是一个很好的办法。与之相比，在.def文件中导出类却较麻烦。通常需要从工程生成的.map文件中获得类的所有成员函数被C++编译器更改过的标识符，并且在.def文件中导出这些“奇怪”的标识符。因此，MFC扩展DLL通常以AFX_EXT_CLASS宏直接声明导出类。</p>

<p>　　<strong>6.6 MFC扩展DLL的应用</strong></p>

<p>　　上述各小节所举MFC扩展DLL的例子均只是为了说明某方面的问题，没有真实地体现“MFC扩展” 的内涵，譬如6.2派生自CDialog的类也不具备比CDialog更强的功能。MFC扩展DLL的真实内涵体现在它提供的类虽然派生自MFC类，但是提供了比MFC类更强大的功能、更丰富的接口。下面我们来看一个具体的例子（<a target="_blank" href="http://www.mydown.com/code/244/244724.html"><font color="#dd2222">单击此处下载本工程</font></a>）。</p>

<p>　　我们知道static控件所对应的CStatic类不具备设置背景和文本颜色的接口，这使得我们不能在对话框或其它用户界面上自由灵活地修改static控件的颜色风格，因此我们需要一个提供了SetBackColor和SetTextColor接口的CStatic派生类CMultiColorStatic。
　
　　这个类的声明如下：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class AFX_EXT_CLASS CMultiColorStatic : public CStatic
{
　// Construction　public:
　　CMultiColorStatic();
　　virtual ~CMultiColorStatic();
　　// Attributes
　protected:
　　CString m_strCaption;
　　COLORREF m_BackColor;
　　COLORREF m_TextColor;
　　// Operations
　public:
　　void SetTextColor( COLORREF TextColor );
　　void SetBackColor( COLORREF BackColor );
　　void SetCaption( CString strCaption );</p>

<p>　　// Generated message map functions
　protected:
　　afx_msg void OnPaint();
　　DECLARE_MESSAGE_MAP()
};</td>
</tr>
</table>
　　在这个类的实现文件中，我们需要为它提供WM_PAINT消息的处理函数（这是因为颜色的设置依赖于WM_PAINT消息）：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BEGIN_MESSAGE_MAP(CMultiColorStatic, CStatic)//{ {AFX_MSG_MAP(CMultiColorStatic)
　ON_WM_PAINT() //为这个类定义WM_PAINT消息处理函数
//}}AFX_MSG_MAP
END_MESSAGE_MAP()</td>
</tr>
</table>
　　下面是这个类中的重要成员函数：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//为CMultiColorStatic类添加“设置文本颜色”接口void CMultiColorStatic::SetTextColor( COLORREF TextColor )
{
　m_TextColor = TextColor; //设置文字颜色
}</p>

<p>//为CMultiColorStatic类添加“设置背景颜色”接口</p>

<p>void CMultiColorStatic::SetBackColor( COLORREF BackColor )
{
　m_BackColor = BackColor; //设置背景颜色
}</p>

<p>//为CMultiColorStatic类添加“设置标题”接口</p>

<p>void CMultiColorStatic::SetCaption( CString strCaption )
{
　m_strCaption = strCaption;
}</p>

<p>//重画Static，颜色和标题的设置都依赖于这个函数</p>

<p>void CMultiColorStatic::OnPaint()
{
　CPaintDC dc(this); // device context for painting
　CRect rect;
　GetClientRect( &amp;rect );
　dc.SetBkColor( m_BackColor );
　dc.SetBkMode( TRANSPARENT );
　CFont <em>pFont = GetParent()-&gt;GetFont();//得到父窗体的字体
　CFont </em>pOldFont;
　pOldFont = dc.SelectObject( pFont );//选用父窗体的字体
　dc.SetTextColor( m_TextColor );//设置文本颜色
　dc.DrawText( m_strCaption, &amp;rect, DT_CENTER );//文本在Static中央
　dc.SelectObject( pOldFont );
}</td>
</tr>
</table>
　　为了验证CMultiColorStatic类，我们制作一个基于对话框的应用程序，它包含一个如图17所示的对话框。该对话框上包括一个static控件和三个按钮，这三个按钮可分别把static控件设置为“红色”、“蓝色”和“绿色”。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="333" src="http://dev.yesky.com/imagelist/05/10/ui4t07vro853.jpg" height="166" /><img border="0" width="333" src="http://dev.yesky.com/imagelist/05/10/ui4t07vro853.jpg" height="166" />
图17 扩展的CStatic类调用演示</td>
</tr>
</table>
　　下面看看应如何编写与这个对话框对应的类。</p>

<p>　　包含这种Static的对话框类的声明如下：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &ldquo;..\MultiColorStatic.h&rdquo;</p>

<h1>pragma comment ( lib, &ldquo;ColorStatic.lib&rdquo; )// CCallDllDlg dialog</h1>

<p>class CCallDllDlg : public CDialog
{
　public:
　　CCallDllDlg(CWnd<em> pParent = NULL); // standard constructor
　　enum { IDD = IDD_CALLDLL_DIALOG };
　　CMultiColorStatic m_colorstatic; //包含一个CMultiColorStatic的实例
　protected:
　　virtual void DoDataExchange(CDataExchange</em> pDX);//DDX/DDV support
　　HICON m_hIcon;</p>

<p>　// Generated message map functions
　//{ {AFX_MSG(CCallDllDlg)</p>

<p>　virtual BOOL OnInitDialog();
　afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
　afx_msg void OnPaint();
　afx_msg HCURSOR OnQueryDragIcon();
　afx_msg void OnRedButton();
　afx_msg void OnBlueButton();
　afx_msg void OnGreenButton();
//}}AFX_MSG
DECLARE_MESSAGE_MAP()
};</td>
</tr>
</table>
　　下面是这个类中与使用CMultiColorStatic相关的主要成员函数：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CCallDllDlg::DoDataExchange(CDataExchange* pDX)
{
　CDialog::DoDataExchange(pDX);
　//{ {AFX_DATA_MAP(CCallDllDlg)
　　DDX_Control(pDX, IDC_COLOR_STATIC, m_colorstatic);
　//使m_colorstatic与IDC_COLOR_STATIC控件关联
　//}}AFX_DATA_MAP
}BOOL CCallDllDlg::OnInitDialog()
{
　…
　// TODO: Add extra initialization here</p>

<p>　// 初始static控件的显示</p>

<p>　m_colorstatic.SetCaption(&ldquo;最开始为黑色&rdquo;);
　m_colorstatic.SetTextColor(RGB(0,0,0));
　return TRUE; // return TRUE unless you set the focus to a control
}</p>

<p>//设置static控件文本颜色为红色</p>

<p>void CCallDllDlg::OnRedButton()
{
　m_colorstatic.SetCaption( &ldquo;改变为红色&rdquo; );
　m_colorstatic.SetTextColor( RGB( 255, 0, 0 ) );
　Invalidate( TRUE ); //导致发出WM_PAINT消息
}</p>

<p>//设置static控件文本颜色为蓝色</p>

<p>void CCallDllDlg::OnBlueButton()
{
　m_colorstatic.SetCaption( &ldquo;改变为蓝色&rdquo; );
　m_colorstatic.SetTextColor( RGB( 0, 0, 255 ) );
　Invalidate( TRUE ); //导致发出WM_PAINT消息
}</p>

<p>//设置static控件文本颜色为绿色</p>

<p>void CCallDllDlg::OnGreenButton()
{
　m_colorstatic.SetCaption( &ldquo;改变为绿色&rdquo; );
　m_colorstatic.SetTextColor( RGB(0,255,0) );
　Invalidate( TRUE ); //导致发出WM_PAINT消息
}</td>
</tr>
</table>
　　至此，我们已经讲解完成了所有类型的动态链接库，即非MFC DLL、MFC规则DLL和MFC扩展DLL。下一节将给出DLL的三个工程实例，与读者朋友们共同体会DLL的应用范围和使用方法。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:14:54+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-wu//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>

<nav id="pagenavi">
    
    	
        	<a href="/posts/21" class="prev">Prev</a>
        
    
    
        <a href="/posts/23" class="next">Next</a>
    
    <div class="center"><a href="/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2018

    Han Yi

<br>
Powered by Octopress.
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'hanyi';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-49392954-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>
