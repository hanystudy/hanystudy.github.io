
<!DOCTYPE HTML>
<html>
<head>
	<script data-cfasync="false" type="text/javascript" src="//use.typekit.net/axj3cfp.js"></script>
	<script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
	<meta charset="utf-8">
	<title>  | Wing of Dream 梦境之翼</title>

<meta name="author" content="Han Yi"> 

<meta name="description" content=" 一年多前，我曾怀着鄙夷的心态去学习“倭语”。虽然直到现在我学习它的总课时还没超过两个月，但我决定称其为“日语”的时间据此也已一年有余了，尽管无论如何这也不像是所谓的尊敬的说法。  记得我们第一节课的时候，工大日语专业毕业的老师就问我们为何要学习日语。说实话，我参加类似成人社会的培训并不多， &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Wing of Dream 梦境之翼" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el, 
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	
</head>



<body>
	<header id="header" class="inner"><h1><a href="/">Wing of Dream 梦境之翼</a></h1>
<h4></h4>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/portfolio">Portfolio</a></li>
	<li><a href="/archives">Archive</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:www.hanyi.name">
			</form>
		</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/23/dong-jing-di-shi-qi-ge-ming-ri/">
		
			東京ラブストーリーの第十七個命日</a>
	</h2>
	<div class="entry-content">
		<p> 一年多前，我曾怀着鄙夷的心态去学习“倭语”。虽然直到现在我学习它的总课时还没超过两个月，但我决定称其为“日语”的时间据此也已一年有余了，尽管无论如何这也不像是所谓的尊敬的说法。</p>

<p> 记得我们第一节课的时候，工大日语专业毕业的老师就问我们为何要学习日语。说实话，我参加类似成人社会的培训并不多，同学们也并非都是学生，因而回答也是五花八门。我旁边的哥们说他喜欢日剧，故学之。我在一边琢磨着:“日剧”平时情节倒也单调，几个常用的口语恐怕自己母语都认不全的人也能学上两句了。谁知这一琢磨便跳了过去，我也就不清楚自己为何坐在此处了。</p>

<p> 另一方面，自从我坐在电脑前就基本上与电视决裂。多年来未能完整看过剧集，直到最后，连新闻报道都完全倚仗互联网。对我来说，二十年来所拥有的娱乐活动基本上就与电子产品有关，电脑游戏占据了一大部。用一句时令话说，我也算是季节性“宅男”快了。至于音像制品，除了一些广为人知的动漫以外，其它的就不甚了解。后来我又通过那“哥们”了解了些情况，得知他是地道的日剧迷，几乎差点就好言相劝之。在我看来，过度迷恋那种较为“畸形”的电视剧可能会影响一个人的价值观，所以我也是敬其而远之的。</p>

<p> 我开始决定鉴赏网络上传播形形色色的音像制品还只是在不久以前，当然这并不包括更早就已经赏玩过的，其实那些东西也并不存在什么可引起争议的地方。事实上就放在两三年以前，我还对这些所谓散发着“西方自由主义气息”的内容有些抵触，在学习如何解决问题的道路上，我们只需要唯物辩证法就足矣。后来慢慢发现，意识形态使得我们无法对问题作出合理的判断，缺少了独立思考我们也就无可奈何。于是我试图解放思想，乃至更进一步解放思想。</p>

<p> 我可以对一部刚刚欣赏完毕的东瀛剧集作出一些自己的评析。去欣赏的缘由成了很难解释清楚的话题，但我可以确定的是我下决心把它下载下来只是因为它只有十一集大小。尽管如此，这仍对我小小的160g硬盘产生了很大压力（这个原因在上一段第一句话）。</p>

<p>   剧集的名称叫做《東京ラブストーリー》。我用日语是因为这是它的本名，我们应当给予其尊重。此外，剧中细节处理方面十分到位，这也完全与“本剧凭借描写细腻著称”相吻合，这要归功于脚本制作，确实是有一定功力的。具体镜头分析我在网络上也看到一些，再结合到读者自己的观点，应当是足够应付的了。因此今天不谈细节。</p>

<p> 我试图从婚姻家庭学的观点解释这个问题，发现有点“神经”。因为リカ（请允许我这样称呼）在现实情况中是不存在的，她有点像是成人童话里的人物。退一步讲“她”即使真正存在，但毕竟ながお完治和関口里美都是凡人，产生与结局不一致的概率也将非常低。在这一点上脚本的思维是成熟的，但它却在实际情况中向人暗示着另一方面。众所周知，大部分的观众对这样的结局是比较惋惜的，这是因为，在十一集的剧情中，基本上90%以上都是在讲リカ和完治的故事。而对五年以前、完治和里美之间的笔墨却着落不多，有的也是以回忆性谈话为主，而类似的谈话又基本上都是和リカ分不开。这也就不难解释脚本在这类问题上的导向性了。但如果我站在执笔人的立场上，也会毫不犹豫地偏向（此处省略若干形容词）的リカ了吧？毕竟这只是一部电视剧。</p>

<p> 从剧中我们同样可以明确，完治对里美的感情起源于高中时代，而此时距离他们毕业分别亦有五年。以完治的个性来看，八年时间几乎不会冲淡这份情感。那么完治、三上和里美之间所建立的深厚感情基础，到成年后完治和里美走入婚礼殿堂，这不能不说是顺利成章的。只不过，即使在现实中，这种情况也无异于凤毛麟角，堪称几十年一遇了也说不定。 </p>

<p> 因而无论从何种角度，无论是剧中四角关系到后期的三角关系，都不能明确给观众一个可靠的方向。我想说脚本实在有点YY的意思，但最后竟形成了一个不悲不喜而又十分合理的结局，又不能不使人敬佩之。</p>

<p> 总而言之，本剧其实对我们所有人都留下了一个莫大的遗憾，这种遗憾恐怕是每个人都逃脱不掉的，那就是我们几乎不会拥有一个ラブストーリー，和它发生在東京一样，令人痛苦而幸福。</p>

<p> 题解：命日，中文作“忌日”。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-23T22:57:11+08:00" pubdate data-updated="true">2008-04-23</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/tian-xuan-zhi-zuo/'>天选之作</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/23/dong-jing-di-shi-qi-ge-ming-ri//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/20/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-liu/">
		
			C++学习笔记(重温计划之六)</a>
	</h2>
	<div class="entry-content">
		<p>4、函数性质</p>

<p> 1）函数形态</p>

<p>   C++中的函数分为“求值”和“返回值为空”两种类型。当函数有返回值时，须定义函数的返回值类型，为空时须定义为void。理论上说，函数只对输入参数和输出返回值负责，至于函数内部的细节程序本身并不干预。编程的原则是优先调用c++库函数，而后再进行手写，这有助于提升编程效率。</p>

<p> 2）传值参数</p>

<p>   参数通过传值机制进入函数内部。传值的具体方法是，在程序中遇到函数被调用时，实参被克隆为形参并参加函数运算。须注意的是，参数个数不宜过多。</p>

<p> 3）指针参数</p>

<p>   在面向对象编程中，我们通常使用指针参数的形式来进行传参。这样的好处是，指针参数其实赋予了函数操作异地数据的能力，使得函数不再需要返回具体值，而已经在函数运行中产生结果了。我们给出一个传递数组的方法:</p>

<p>   void mySort (int* b,int size);</p>

<p>   void f(){</p>

<p>    int a[]={3，4，5，1，7，2，9};</p>

<p>    mySort(a,sizeof(a)/sizeof(a[0]));</p>

<p>    //&hellip;</p>

<p>   }</p>

<p>   而事实上，数组也就只能使用传递地址一种方法来达到传递的目的。在实际编程中，传递指针和引用的特性广受欢迎。但是，传递指针和引用在一定程度上破坏了函数的黑盒性，不排除造成灾难性错误的可能，这就引起了一些麻烦。当然我们也可以利用一些手段来避免此类问题，例如:当传递引用时，使用const修饰符限制函数对参数的操作等等。</p>

<p> 4）函数的栈机制</p>

<p>   一般情况下，每当一个程序要运行时，操作系统会自动在内存中生成一个随时可以运行的进程空间。空间中分四个区域，分别是代码区、全局数据区、堆区和栈区。在栈区中，动态地存放了程序运行中的函数状态，利用这一点，我们可以进一步研究函数机制。</p>

<p>   平时在编写函数时，我们会给局部变量赋初值。这是因为c++的栈机制决定的。由于系统并不存在所谓的清理机制，每当运行一个新的程序时，旧的栈区中的数据将保留下来，而未得到初值的变量也就无可奈何了。</p>

<p>   以上也同样展现了指针的负面效应，甚至当我们知道数据确切地存放地址时，就可以任意而直接地改变地址中的数值了。</p>

<p> 5）函数指针</p>

<p>   函数指针主要有以下几种声明方法:</p>

<p>   int* f(int a);</p>

<p>   int *gp(int) ;</p>

<p>   int g(int);                  //这是另一种声明和定义区分开的例子</p>

<p>   int (<em>gp)(int) =g;       //我们可以写成 int (</em>gp)(int); int gp =g;</p>

<p> 需要注意，在声明或定义函数指针时，其参数的类型须为一致，否则编译不能通过。函数指针的主要作用是用来进行参数传递，且一般为bool(const T&amp;,const T&amp;)形式。在函数指针数组中，一些特定的操作将被简化和易于维护，例如:</p>

<p>  //&hellip; </p>

<p>  typedef void (*MenuFun)();</p>

<p>   MenuFun fun[] = {f1,f2,f3};</p>

<p>   cin&gt;&gt;choice;</p>

<p>   switch(choice){</p>

<p>   case 1:fun<a href="">0</a>;break;</p>

<p>   //&hellip;</p>

<p>   }//&hellip;</p>

<p>   函数指针还使得C++有了沟通其它语言编写程序的能力，同时作为面向对象编程机制中的重要手段，在高级编程诸如动态链接库编程中都有广泛应用。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-20T22:56:01+08:00" pubdate data-updated="true">2008-04-20</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/20/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-liu//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/19/zhao-dao-le-zhao-dao-le/">
		
			找到了~找到了</a>
	</h2>
	<div class="entry-content">
		<p>今天很激动，后果很严重。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-19T23:36:09+08:00" pubdate data-updated="true">2008-04-19</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/tian-xuan-zhi-zuo/'>天选之作</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/19/zhao-dao-le-zhao-dao-le//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/18/shou-ye-jian-she-ji-hua/">
		
			首页建设计划</a>
	</h2>
	<div class="entry-content">
		<p> 有朋友提出首页音乐不符合本站主题&hellip;我们将作更改，另外待开发内容也已提上日程。由于本学期突然有期中考，我们的更新可能会慢一些，但技术交流的频率不会降低。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-18T21:15:58+08:00" pubdate data-updated="true">2008-04-18</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhan-dian-ri-zhi/'>站点日志</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/18/shou-ye-jian-she-ji-hua//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/18/yue-zhong-zong-jie-di-1-qi/">
		
			月中总结（第1期）</a>
	</h2>
	<div class="entry-content">
		<p> 我们每月中旬将对blog内容作一合订总结，并提供连载文章的目录。</p>

<p> 1、好文推荐:《<span style="color: #000000;">Visual C++动态链接库编程》 作者:宋宝华</span></p>

<p>   简介:文章面向具有c++基础，并且对vc6.0环境有一定应用能力的读者。详细介绍了windows动态链接库的概念、编程方法和应用，是一份不可多得的技术参考类文章。</p>

<p>      <a href="http://www.hanyi.name/blog/?p=27" target="_blank">Visual C++动态链接库编程（一）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=28" target="_blank">Visual C++动态链接库编程（二）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=29" target="_blank">Visual C++动态链接库编程（三）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=30" target="_blank">Visual C++动态链接库编程（四）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=31" target="_blank">Visual C++动态链接库编程（五）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=32" target="_blank">Visual C++动态链接库编程（六）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=33" target="_blank">Visual C++动态链接库编程（七）</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=34" target="_blank">Visual C++动态链接库编程（八）</a> （完结篇）</p>

<p> 2、语言学习:《C++学习笔记——重温计划》</p>

<p>   贴上博主原版C++学习笔记，由于是手工录入需要分期刊出。面向具有一定C语言基础的读者，无基础配合有关参考书籍亦可。</p>

<p>      <a href="http://www.hanyi.name/blog/?p=21" target="_blank">C++学习笔记(重温计划之一)</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=22" target="_blank">C++学习笔记(重温计划之二)</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=26" target="_blank">C++学习笔记(重温计划之三)</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=36" target="_blank">C++学习笔记(重温计划之四)</a></p>

<p>      <a href="http://www.hanyi.name/blog/?p=37" target="_blank">C++学习笔记(重温计划之五)</a> （待续）</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-18T20:36:43+08:00" pubdate data-updated="true">2008-04-18</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/tian-xuan-zhi-zuo/'>天选之作</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/18/yue-zhong-zong-jie-di-1-qi//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/18/xiao-yi-hui-bian/">
		
			小议汇编</a>
	</h2>
	<div class="entry-content">
		<p> 在绝大多数人眼中，汇编语言是一个低级的、面向机器硬件的程序设计语言。从第一颗微处理器诞生之日起，二进制代码形式的机器语言就被代替成了具有一定意义的特殊指令。指令的有序堆积即称为汇编语言。</p>

<p> 令人遗憾的是，中国人自计算机发明以来，几乎未在其硬件领域上取得过较大突破。微处理器技术也是如此。这也就能解释，为何若干套指令集中没有汉字的影子了。（无语。。。）其实，非但我国在这一领域起步较晚，当今技术水平与国外同类技术的差距也还是相当可观的。这样可能有人会说，经济全球化的今天，中国人为什么总要搞自己的一套东西！需知，信息产业在未来社会生活所占据的比重将十分庞大，而当今国际社会的政治形势变幻也从未停留过脚步，拥有民族化自主知识产权的技术也就成了重要一环。</p>

<p> 提前说了这么多废话，主要还是勉励当代微电子学专业的同学们奋发图强。我们从“软”的已经软到了火候，而该“硬”的却还没有硬得起来。</p>

<p> 目前高校的汇编语言教学主要是以8086/88指令系统为主要内容，事实上真正的汇编语言远不止这个概念。它的发展和CPU的发展几乎是同步进行的。我们知道，1971年intel公司推出了世界上第一台4位微处理器4004，1978年推出了16位微处理器i8086/87，并相应配套了x86指令集。随后的8088芯片用在了IBM-PC中，在1981年的首次PC机概念推广时广为人知。此后，x86指令集被多数微处理器厂商采用并集成到自主产品中。虽然后来的发展使cpu指令集不断更新扩充，但为了延续长期以往积攒的软件资源周期，都向上兼容了x86指令集。当然，不同的cpu大多数都有自己的扩展指令集，还有些并未沿用x86构架，但总的来说这些指令主要分两大构架:</p>

<p>   1、复杂指令系统计算机(CISC,Complex Instruction Set Computer):指令均处于平等地位的指令构架，有指令多且复杂，因为操作码扩展而增加寻址方式种类的特点。早期的x86指令集都属于cisc构架。</p>

<p>   2、精简指令系统计算机(RISC,Reduced Instruction Set Computer):指令有优先级之分，一般常用指令优先级较高，提升了运行效率，并且克服了cisc构架的上述若干缺点。当前除PC机以外的计算机系统基本上都采用RISC构架。</p>

<p> cisc虽然拥有众多缺点，但x86集基础上所建立的软件资源是它至今仍必须在pc机上存在的重要原因。目前看来，cisc和risc在pc机上的争夺最终将走向中间领域，两大厂商intel和amd也在上世纪90年代开始同时采用了两种技术。</p>

<p> 那么，汇编语言的具体优势又在哪里？</p>

<p> 高级语言如C/C++,JAVA,C#等，都具有直观，抽象化易于理解，应用范围广的特点。早期的汇编语言相对而言就不具备这些优势了。通常汇编用来进行底层开发，例如操作系统及其硬件驱动程序、端口程序,还包括当前愈为流行的嵌入式开发等等。有时程序员会使用汇编语言和高级语言相配合以进一步达到高效精确的目的。近一段时期以来，随着汇编语言自身的发展和翻译程序的开发，汇编已经能够做到完全独立编写win32程序,其在一些高级绘图程序、视频游戏程序中的应用也越来越多。</p>

<p> 我认为，针对计算机偏软件方向的专业来说，汇编语言提供了一个能近距离观察机器内部实现的窗口。另外，通过对汇编语言程序设计的掌握，将对上层软件系统原理拥有更为深刻的理解。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-18T19:40:03+08:00" pubdate data-updated="true">2008-04-18</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/assembly/'>assembly</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/18/xiao-yi-hui-bian//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/11/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-wu/">
		
			C++学习笔记(重温计划之五)</a>
	</h2>
	<div class="entry-content">
		<p>3、数据类型（下）</p>

<p> 1)向量(Vectors)</p>

<p>   Vector是C++标准模板类库的重要组成部分,使用时需要包含头文件vector.主要定义方式如下:</p>

<p>    vector &lt;int&gt; a(10);                     //定义了10个整数元素,但没有赋初值</p>

<p>    vector &lt;int&gt; b(10,1);                  //定义了10个整数元素,且每个元素的初值为1</p>

<p>    vector &lt;int&gt; c(b);                       //用一个现成的向量创建一个向量</p>

<p>    vector &lt;int&gt; d(b.begin(),b.begin()+3);             //定义了一个其值为向量b前3个值的向量</p>

<p> 我们知道,当输出一个数组时我们一般用循环实现.在vector中,有相应的遍历器函数,形式为vector&lt;int&gt;::iterator,例如:</p>

<p>   for(vector&lt;int&gt;::iterator it = a.begin(); it != a.end() ; ++it)</p>

<p>    cout &lt;&lt;*it &lt;&lt;&ldquo; &rdquo;;</p>

<p>   有关向量的其他操作如下:</p>

<p>a.assign(b.begin(),b.begin()+3);     //将b的0-2元素构成的向量赋给a
a.assign(4,2);                       //将a向量只含0-3元素,且赋为值2
int x = a.back();                    //将a的最后一个向量元素值赋给整数变量x
a.clear();                           //a向量元素清空
if(a.empty()) cout &lt;&lt; &ldquo;empty&rdquo;;       //a.empty()作为条件判断空或非空
int y = a.front();                   //将a的第一个向量元素赋给整数变量
ya.pop_back;                         //删除a向量的最后一个元素
a.push_back(5);                      //在a向量最后插入一个元素,其值为5
a.resize(10);                        //将向量元素个数调至10个,多则删,少则补,其值随机
a.resize(10,2);                      //将向量元素个数调至10个,多则删,少则补,其值为2
if(a==b) cout &lt;&lt; &ldquo;equal&rdquo;;            //向量的比较操作还有!=,&lt;,&lt;=,&gt;,&gt;=</p>

<p>   向量与数组相比的好处是,其空间大小不需要提前指定,可以不断添加新的元素.但是,向量初始化时会分配一定的预留空间,如果添加元素的个数超过了预留空间,则需要扩容.内存意义上的扩容需要删除原空间并添加新的空间,这就必然增加向量操作的负担,因此在预计添加元素个数较多的情况下,我们还是需要给定向量的初始化大小.</p>

<p>   和数组类似,向量也存在2维向量乃至多维向量.我们通常使用 vector&lt;vector&lt;int&gt;&gt; 的形式声明一个2维向量,其一般操作和1维向量的方法是一致的.</p>

<p> 2)指针与引用</p>

<p>   c++的指针应用几乎是必不可少,我们将用较大篇幅来研究指针的用法.</p>

<p> a.指针的定义</p>

<p>   如下的定义方式都是正确的</p>

<p>   int * p;</p>

<p>   char *cp;</p>

<p>   float* fp;</p>

<p>   double*dp;</p>

<p>   我们也可以定义一个二级指针</p>

<p>   int ** iip;</p>

<p>   但需要注意的是,一个*只能修饰一个指针,例如</p>

<p>   int* ip,iq;   //其中ip为指针变量,而iq为整形变量</p>

<p>   在指针初始化的过程中,有下面的形式:</p>

<p>   int* ip;</p>

<p>   int iCount = 18;</p>

<p>   int* iPtr = &amp;iCount;       //初始化,&amp;表示实体的地址,&amp;后可以是一个变量,但不能是具体数值</p>

<p>   ip = &amp;iCount;;              //赋值</p>

<p>   须注意,int<em> ip = &amp;iCount; 与 </em>ip = &amp;iCount; 并不相同,前者为初始化并赋值,后者本身形式错误.诸如 int<em> iPtr; </em>iPtr = 58;的语句也是毫无意义的.</p>

<p> b.指针类型</p>

<p>  指针是有类型的,其类型也必须是一致的.在c语言中,有强制类型转换(int *),但事实上,c++有自身的强制转换函数.例如:</p>

<p>   int<em> ip = reinterpret_cast&lt;int</em>&gt;(&amp;f);           //reinterpret的含义本身是&#8221; 重解释&#8221;,因而将float型指针无条件转换为整形指针.</p>

<p> c.指针运算</p>

<p>   #include&lt;iostream&gt;
   using namespace std;
   int main(void){
     int iArray[6];
     for(int i=0;i&lt;6;++i) iArray[i]= i<em>2;
     for(int</em> iP=iArray; iP&lt;iArray+6; iP+=1)
     cout&lt;&lt;iP&lt;&lt;&ldquo;: &rdquo;&lt;&lt;*iP&lt;&lt;endl;
   }</p>

<p>   上面的程序例中,指针运算在数组中的应用已有了初步展现.同时对于不同类型的指针,相应的运算操作也有不同的数据变化.但是,在指针进行超过数组范围的操作时是非常危险的.</p>

<p> d.指针限定</p>

<p>   我们知道,一个指针可以表示两个实体,即地址值和间仿值.因而,指针本身也分为指针常量和常量指针.</p>

<p>   const int a = 78;</p>

<p>   int b = 10;</p>

<p>   int c = 18;</p>

<p>   const int* ip = &amp;a;                  //const 修饰指向的实体类型 常量指针 无法修改数值</p>

<p>   int<em> const cp = &amp;b;                 //const 修饰指针</em>cp 指针常量 无法修改地址</p>

<p>   int const* dp = &amp;b;                 //同上</p>

<p>   const int *const icp = &amp;c;       //常量指针常量 均无法修改</p>

<p> e.引用</p>

<p>   引用定义为:</p>

<p>   int someInt = 5,anyInt = 8;</p>

<p>   int &amp; rInt = someIne;    //引用的作用类似别名,但值得注意的是, 如果重定义 rInt = anyInt,则rInt地址不变,值变为8,引用与指针的差别也就在于此了.即引用无法更改所引用的地址.通常我们也能使用const int &amp; rInt = someIne使上述语句无法运行.但实体本身的操作someInt = 8同样能达到目的.</p>

<p>   引用的主要作用是进行参数传递,这在后文中将有较为详细深入的介绍.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-11T11:44:32+08:00" pubdate data-updated="true">2008-04-11</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/11/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-wu//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/08/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-si/">
		
			C++学习笔记(重温计划之四)</a>
	</h2>
	<div class="entry-content">
		<p>3、数据类型（中）</p>

<p> 1）C-串与string</p>

<p>   c++的字符串分两类，一种是由c语言沿袭而来，称为c-串。例如，</p>

<p>   char buffer[7]=&ldquo;Hello!&rdquo;; //由于所有字符串必须以\0为结束符，则长度定义必须比实际元素个数多1</p>

<p>   事实上，字符数组的实际类型为char<em>，或const char</em>，称为字符型指针。实际应用中我们做如下定义:</p>

<p>   char<em> str=&ldquo;Hello!&rdquo;;//输出</em>str时为&#8221;H&#8221;，str则为&#8221;Hello&#8221;</p>

<p>   在c库函数中，又定义了字符串操作函数，例如strcmp(比较)、strcpy(复制)、strcat(连接)、strrev(倒置)、strset(设置)、strstr/strchr(查找串或字符)。通常我们需要指定头文件string.h，标准c++将其嵌套入iostream中，即省略了这一调用。</p>

<p>  其实，C++中提供了另一种高效可行的字符串类型，即string类型。string类是标准c++中的基础类，这在后文中我们会有详细解释。string的目的是使字符串操作更加方便安全。</p>

<h1>include&#8221;iostream&#8221;</h1>

<h1>include&#8221;algorithm&#8221;</h1>

<p>using namespace std;</p>

<p>int main(){</p>

<p>   string a,s1 = &ldquo;Hello!&rdquo;;</p>

<p>   string s2 = &ldquo;123&rdquo;;</p>

<p>   a=s1;                                                                                    //复制</p>

<p>   cout &lt;&lt; (a==s1 ? &ldquo; &rdquo; : &ldquo;not&rdquo;) &lt;&lt; &ldquo;equal\n&rdquo;;                          //比较</p>

<p>   cout &lt;&lt; a+s2 &lt;&lt;endl;                                                         //连接</p>

<p>   reverse(a.begin(),a.end());                                                     //倒置串</p>

<p>   cout &lt;&lt;a &lt;&lt; endl;</p>

<p>   cout &lt;&lt; a.replace(0,9,9,&lsquo;c&rsquo;)&lt;&lt;endl;                                     //设置</p>

<p>   cout &lt;&lt; (s1.find(&ldquo;ell&rdquo;)!= -1 ? &ldquo;&rdquo; : &ldquo;not&rdquo;) &lt;&lt; &ldquo;found\n&rdquo;;        //查找串</p>

<p>   cout &lt;&lt; (s1.find(&lsquo;c&rsquo;)!= -1 ? &ldquo;&rdquo; : &ldquo;not&rdquo;) &lt;&lt; &ldquo;found\n&rdquo;);          //查找字符</p>

<p>}</p>

<p>   由上基本可以看出，string在与c-串对比中是明显有优势的。而且，c-串可以随时赋值给string变量，具有相当的亲和程度.</p>

<p>  现在讨论string与c-串在输入输出中的c++用法.</p>

<p>   当输入时,我们以:</p>

<p>   fot(string s;cin &gt;&gt; s;)            //string s可以替换为char s[10]</p>

<p>   cout &lt;&lt; s &lt;&lt;&ldquo; &rdquo;;</p>

<p>   cout &lt;&lt; endl; </p>

<p>   cin &gt;&gt;在读入时一般过滤前导空格,包括空格、回车、水平/垂直制表符等等。</p>

<p>  我们同样可以采用非循环的方式。例如:</p>

<p>   string s;                           //在字符数组中，可以定义char s[10]</p>

<p>   getline(cin,s);                   //相应可以改为cin.getline(s,10)</p>

<p>   cout &lt;&lt; s &lt;&lt;endl;           //getline的好处是，在读入多行字符时，程序可以将内容逐行分解操作</p>

<p>  下面假设，存在一个文件aaa.txt,文件内有若干行整数，并且每行整数个数未知。这时求每行的整数和。</p>

<h1>include&lt;iostream&gt;                      //该程序已调试通过</h1>

<h1>include&lt;sstream&gt;</h1>

<h1>include&lt;fstream&gt;</h1>

<p>using namespace std;
int main(void){
 ifstream in(&ldquo;aaa.txt&rdquo;);
 for(string s;getline(in,s);){              //逐行读入的循环
  int a, sum = 0;
  for(istringstream sin(s);sin&gt;&gt;a;sum+=a);          //istringstream sin(s)意在创建输入string流sin()，sin&gt;&gt;即从string流中将整数输入到a中进行运算
  cout &lt;&lt; sum &lt;&lt; endl;
 }
 getchar();
 return 0;
}</p>

<p>  上面的程序体现了string流的概念，进一步体现了string字符串型的优势和特点。</p>

<p>  2）数组</p>

<p>   int a[5];   //即定义了一个数组，5代表了数组中元素个数。并且[ ]内必须为常量表达式，通常我们可以使用const int定义。</p>

<p>   数组的初始化过程中，有如下几种方式进行:</p>

<p>   int iArray[10] = {1,2,3,4,5,6,7,8,9,10};</p>

<p>   请注意，以上方式禁止的有:元素个数大于定义数、中途有元素定义为空、元素省略&hellip;不过实际操作中可以使元素个数少于定义数，比如  int iArray[10] = {1,2,3,4,5,6,7,8}; 这是允许的。</p>

<p>　int iArray[] = {1,2,3,4,5,6,7,8,9,10};  //虽然没有定义常量值，但初始化值的个数已经做出说明了。</p>

<p>　我们还能用到sizeof(a[n])来返回a[n]元素所占空间的字节数。</p>

<p>　下面来探测未初始化数组元素的默认值情况。计算机把这一类数组区分为全局数组或静态数组、局部数组。在全局数组和静态数组中，未定义情况下的元素值恒为０，而在局部数组中则变成不确定数。</p>

<p>　数组也有多位数组的形式，可定义为:</p>

<p>   int a[3][5];   //这是一个２维数组，其输入输出方式和１维数组是相同的</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-08T10:49:37+08:00" pubdate data-updated="true">2008-04-08</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/c-plus-plus-slash-c/'>c++/c</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/08/C-xue-xi-bi-ji-chong-wen-ji-hua-zhi-si//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/06/shou-ye-zheng-zai-geng-xin-flash-yuan-ma/">
		
			首页正在更新flash源码</a>
	</h2>
	<div class="entry-content">
		<p> 此次更新的主要目的是为接下来的内容扩展做好铺垫，另外也是为了增强网站的整体美观。晚上花了点时间只是整理出一个框架，未来具体情况目前还在构思中。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-06T01:20:53+08:00" pubdate data-updated="true">2008-04-06</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhan-dian-ri-zhi/'>站点日志</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/06/shou-ye-zheng-zai-geng-xin-flash-yuan-ma//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-ba-wan-jie-wan-jie-bao-hua-jie-yi/">
		
			Visual C++动态链接库编程（八）——完结篇——宋宝华解疑</a>
	</h2>
	<div class="entry-content">
		<p>　1.关于文章的获取</p>

<p>　　许多读者发来e-mail询问本系列文章的相关事宜，如：</p>

<p>　　（1） 是否已出版？</p>

<p>　　（2） 哪里可以<a target="_blank" href="http://www.mydown.com/" class="bluekey"><font color="#003399">下载</font></a>打包版？</p>

<p>　　（3） 哪里可以下载笔者的其它文章？</p>

<p class="guanggao">　　还有一些读者对日前笔者在天极网发表的《<a target="_blank" href="http://soft.yesky.com/lesson/188/2023188.shtml"><font color="#1111ee">C语言嵌入式系统编程修炼之道</font></a>》非常喜爱，给予了热情洋溢的赞扬，询问笔者能否继续创作嵌入式编程方面的文章。</p>


<p>　　对于这些问题，统一作答如下：</p>

<p>　　（1）本系列文章暂时尚未出版；</p>

<p>　　（2）您可以在天极网<a target="_blank" href="http://product.yesky.com/software/" class="bluekey"><font color="#003399">软件</font></a>频道下载笔者的多数拙作。另外，我也将不定期将这些文章上传到我的博客（ <a href="http://blog.donews.com/21cnbao/%EF%BC%89%E3%80%82%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E4%B8%AD%E7%9A%84%E4%BE%8B%E7%A8%8B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%9D%87%E7%BB%8F%E8%BF%87%E4%BA%B2%E6%89%8B%E8%B0%83%E8%AF%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%97%A0%E8%AF%AF%EF%BC%9B">http://blog.donews.com/21cnbao/%EF%BC%89%E3%80%82%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E4%B8%AD%E7%9A%84%E4%BE%8B%E7%A8%8B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%9D%87%E7%BB%8F%E8%BF%87%E4%BA%B2%E6%89%8B%E8%B0%83%E8%AF%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E6%97%A0%E8%AF%AF%EF%BC%9B</a></p>

<p>　　（3）就嵌入式系统开发，笔者将继续进行此方面的创作，新近将推出《基于嵌入式实时OS VxWorks的多任务<a target="_blank" href="http://dev.yesky.com/" class="bluekey"><font color="#003399">程序</font></a>设计》及《领悟：从Windows多线程到VxWorks的多任务》。</p>

<p>　　非常感谢读者朋友对这些文章的喜爱，在下将竭尽所能地为您提供更多的好文章。</p>

<p>　　2.关于DLL的疑问</p>

<p>　　你好，看了你写的&#8221;VC++ DLL编程深入浅出&#8221;，特别有收获。 只是有个地方我老搞不明白，就是用DLL导出全局变量时，指定了.lib的路径（#pragma comment(lib,&ldquo;dllTest.lib&rdquo;)），那么.dll的文件的路径呢，我尝试着把.dll文件移到别的地方程序就无法正常运行了，请问.dll在这里怎么指定。</p>

<p>　　希望您能在百忙中抽空给我解答一下，不胜感激！</p>

<p>　　一位编程爱好者</p>

<p>　　回答：</p>

<p>　　Windows按下列顺序搜索DLL：</p>

<p>　　（1）当前进程的可执行模块所在的目录；</p>

<p>　　（2）当前目录；</p>

<p>　　（3）Windows 系统目录，通过GetSystemDirectory 函数可获得此目录的路径；</p>

<p>　　（4）Windows 目录，通过GetWindowsDirectory 函数可获得此目录的路径；</p>

<p>　　（5）PATH 环境变量中列出的目录。</p>

<p>　　因此，隐式链接时，DLL文件的路径不需要指定也不能指定，系统指定按照1～5的步骤寻找DLL，但是对应的.lib文件却需要指定路径；如果使用Windows API函数LoadLibrary动态加载DLL，则可以指定DLL的路径。</p>

<p>　　你好,我是一位C++初学者,我在PCONLINE看了教学之后,受益不浅。我想问一下能否在DLL里使用多线程?MSDN上用#using &lt;mscorlib.dll&gt;这个指令之后实现了多线程,不过好象不支持DLL..</p>

<p>　　请问有什么办法支持制作多线程DLL??能否给一个源码来?</p>

<p>　　回答：</p>

<p>　　在DLL中可以处理多线程，WIN32对于多线程的支持是<a target="_blank" href="http://os.yesky.com/" class="bluekey"><font color="#003399">操作系统</font></a>本身提供的一种能力，并不在于用户编写的是哪一类程序。即便是一个控制台程序，我们都可以使用多线程：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
void ThreadFun(void)
{
　while(1)
　{
　　printf( &#8220;this is new thread\n&#8221; );
　　Sleep( 1000 );
　}
}
int main()
{
　DWORD threadID;
　CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)ThreadFun, NULL, 0, &amp;threadID );
　while(1)
　{
　　printf( &#8220;this is main thread\n&#8221; );
　　Sleep( 1000 );
　}
}</td>
</tr>
</table>


<p>　　观察程序运行的结果为在控制台窗口上交替输出this is main thread、this is new thread。</p>

<p>　　我们来看下面的一个多线程DLL的例子。</p>

<p>　　DLL程序提供一个接口函数SendInit，在此接口中启动发送线程SendThreadFunc，在这个线程的对应工作函数中我们使用原始套接字socket发送报文。参考微软出版的经典书籍《Windows核心编程》，我们发现，不宜在DLL被加载的时候（即进程绑定时）启动一个新的线程。</p>

<p>　　这个线程等待一个CEvent事件（用于线程间通信），应用程序调用DLL中的接口函数SendMsg( InterDataPkt sendData )可以释放此事件。下面是相关的源代码：</p>

<p>　　（1）发送报文线程入口函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>///////////////////////////////////////////////////////////////////////////
//函数名：SendThreadFunc
//函数功能：发送报文工作线程入口函数，使用UDP协议
////////////////////////////////////////////////////////////////////////////
DWORD WINAPI SendThreadFunc( LPVOID lpvThreadParm )
//提示：对于线程函数应使用WINAPI声明，WINAPI被宏定义为__stdcall
{
　/* 创建socket */
　sendSock = socket ( AF_INET, SOCK_DGRAM, 0 );
　if ( sendSock == INVALID_SOCKET )
　{
　　AfxMessageBox ( &#8220;Socket创建失败&#8221; );
　　closesocket ( recvSock );
　}　/* 获得目标节点端口与地址 */
　struct sockaddr_in desAddr;
　desAddr.sin_family=AF_INET;
　desAddr.sin_port=htons( DES_RECV_PORT ); //目标节点接收端口
　desAddr.sin_addr.s_addr = inet_addr( DES_IP );

　/* 发送数据 */
　while(1)
　{
　　WaitForSingleObject( hSendEvent, 0xffffffffL );//无限等待事件发生
　　ResetEvent( hSendEvent );

　　sendto( sendSock, (char *)sendSockData.data, sendSockData.len, 0, (struct sockaddr*)&amp;desAddr, sizeof(desAddr) );
　}
　return -1;
}</td>
</tr>
</table>


<p>　　（2）MFC规则DLL的InitInstance函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>/////////////////////////////////////////////////////////////////////////////
// CMultiThreadDllApp initialization
BOOL CMultiThreadDllApp::InitInstance()
{
　if ( !AfxSocketInit() ) //初始化socket
　{
　　AfxMessageBox( IDP_SOCKETS_INIT_FAILED );
　　return FALSE;
　}
　return TRUE;
}</td>
</tr>
</table>


<p>　　（3）启动发送线程</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>////////////////////////////////////////////////////////////////////////////////
//函数名：SendInit
//函数功能：DLL提供给应用程序调用接口，用于启动发送线程
/////////////////////////////////////////////////////////////////////////////
void SendInit(void)
{
　hSendThread = CreateThread( NULL, 1000, SendThreadFunc, this, 1, &amp;uSendThreadID );
}</td>
</tr>
</table>


<p>　　（4）SendMsg函数</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>////////////////////////////////////////////////////////////////////////////////
//函数名：SendMsg
//函数功能：DLL提供给应用程序调用接口，用于发送报文
/////////////////////////////////////////////////////////////////////////////
extern &#8220;C&#8221; void WINAPI SendMsg( InterDataPkt sendData )
{
　sendSockData = sendData;
　SetEvent( hSendEvent ); //释放发送事件
}</td>
</tr>
</table>


<p>　　以上程序仅仅是一个简单的例子，其实在许多工程应用中，我们经常看到这样的处理方式。这个DLL对用户而言仅仅使一个简单的接口函数SendMsg，对调用它的应用程序屏蔽了多线程的技术细节。与之类似，MFC提供的CSocket类在底层自己采用了多线程机制，所以使我们免去了对多线程的使用。</p>

<p>　　您好,看了您的DLL文章，发现导出函数可以直接用<em>declspec(dllexport)声明或在.def文件中定义，变量的导出也一样。我想知道类是否也可以在.def文件中导出？您的文章中只讲了在类前添加</em>declspec(dllexport)导出类的方法。请您指教！</p>

<p>　　回答：</p>

<p>　　一般我们不采用.def文件导出类，但是这并不意味着类不能用.def文件导出类。</p>

<p>　　使用Depends查看连载2的&#8221;导出类&#8221;例程生成的DLL，我们发现其导出了如图21的众多&#8221;怪&#8221;symbol，这些symbol都是经过编译器处理的。因此，为了以.def文件导出类，我们必须把这些&#8221;怪&#8221;symbol全部导出，实在是不划算啊！所以对于类，我们最好直接以_declspec(dllexport)导出。</p>

<table border="0" align="center" width="90%">
<tr>
<td>
<p align="center"><img border="0" width="483" src="http://dev.yesky.com/imagelist/05/10/t5u84cjh02yz.jpg" height="160" /><img border="0" width="483" src="http://dev.yesky.com/imagelist/05/10/t5u84cjh02yz.jpg" height="160" />
图1 导出类时导出的symbol</td>
</tr>
</table>


<p>　　您好,看了您的DLL文章，知道怎么创建DLL了，但是面对一个具体的工程，我还是不知道究竟应该把什么做成DLL？您能给一些这方面的经验吗？</p>

<p>　　回答：</p>

<p>　　DLL一般用于软件模块中较固定、较通用的可以被复用的模块，这里有一个非常好的例子，就是豪杰超级解霸。梁肇新大师把处理视频和音频的算法模块专门做成了两个DLL，供超级解霸的用户界面GUI程序调用，实在是DLL<a target="_blank" href="http://design.yesky.com/" class="bluekey"><font color="#003399">设计</font></a>的模范教程。所谓&#8221;万变不离其宗&#8221;，超级解霸的界面再cool，用到的还是那几个DLL！具体请参考《编程高手箴言》一书。</p>

<p>　　您好,您的DLL文章讲的都是Windows的，请问Linux操作系统上可以制作DLL吗？如果能，和Windows有什么不一样？谢谢！</p>

<p>　　回答：</p>

<p>　　在Linux操作系统中，也可以采用动态链接技术进行软件设计，但与Windows下DLL的创建和调用方式有些不同。</p>

<p>　　Linux操作系统中的共享对象技术（Shared Object）与Windows里的DLL相对应，但名称不一样，其共享对象文件以.so作为后缀。与Linux共享对象技术相关的一些函数如下：</p>

<p>　　(1)打开共享对象，函数原型：</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//打开名为filename共享对象，并返回操作句柄；
void *dlopen (const char *filename, int flag);</td>
</tr>
</table>


<p>　　(2)取函数地址，函数原型:</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//获得接口函数地址
void *dlsym(void *handle, char *symbol);</td>
</tr>
</table>


<p>　　(3)关闭共享对象，函数原型:</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//关闭指定句柄的共享对象
int dlclose (void *handle);</td>
</tr>
</table>


<p>　　(4)动态库错误函数，函数原型:</p>

<table border="1" bgColor="#e3e3e3" align="center" width="90%" borderColor="#cccccc">
<tr>
<td>//共享对象操作函数执行失败时，返回出错信息
const char *dlerror(void);</td>
</tr>
</table>


<p>　　从这里我们分明看到Windows API――LoadLibrary、FreeLibrary和GetProcAddress的影子！又一个&#8221;万变不离其宗&#8221;！</p>

<p>　　本系列文章的连载暂时告一段落，您可以继续给笔者发送email（mailto：21cnbao@21cn.com）讨论DLL的编程问题。对于文中的错误和纰漏，也热诚欢迎您指正。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2008-04-05T15:23:32+08:00" pubdate data-updated="true">2008-04-05</time></div>
	

<div class="tags">

	<a class='category' href='/blog/categories/zhuan-zai/'>转载</a>

</div>


	
		<span class="comments"><a href="/blog/2008/04/05/visual-Visual-C-dong-tai-lian-jie-ku-bian-cheng-ba-wan-jie-wan-jie-bao-hua-jie-yi//posts/22/index.html#disqus_thread">Comments</a></span>
	
</div></article>

<nav id="pagenavi">
    
    	
        	<a href="/posts/21" class="prev">Prev</a>
        
    
    
        <a href="/posts/23" class="next">Next</a>
    
    <div class="center"><a href="/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2019

    Han Yi

<br>
Powered by Octopress.
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'hanyi';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-49392954-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>
