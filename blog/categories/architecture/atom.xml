<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Wing of Dream 梦境之翼]]></title>
  <link href="http://www.hanyi.name/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://www.hanyi.name/"/>
  <updated>2020-06-29T16:19:33+08:00</updated>
  <id>http://www.hanyi.name/</id>
  <author>
    <name><![CDATA[Han Yi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(16): 架构风格——反应式架构]]></title>
    <link href="http://www.hanyi.name/blog/2020/06/29/software-design-and-architecture-notes-16/"/>
    <updated>2020-06-29T15:20:02+08:00</updated>
    <id>http://www.hanyi.name/blog/2020/06/29/software-design-and-architecture-notes-16</id>
    <content type="html"><![CDATA[<h2>架构风格——反应式架构</h2>

<p>在过去10年，多核、云计算、移动/IOT、用户体验等相关领域的发展使传统上以可维护性为核心的软件架构面临着新的挑战，这主要体现在软件系统的<strong>即时响应性</strong>(Responsiveness)、<strong>回弹性</strong>(Resilience)以及<strong>弹性</strong>(Elasticity)等架构质量属性[JDRM14]。</p>

<p>即时响应性旨在合理成本范围内提供低延迟的用户体验。显然这并非是全新的质量属性，传统上围绕它的解决方案包括算法优化、摩尔定律等。然而，随着系统复杂性不断上升，即时响应性不可避免地受到损害，业界发明了许多技术解决这一问题。从架构角度看，这些技术可以被划分为<strong>纵向</strong>(Scale up/down)和<strong>横向</strong>(Scale out/in)两种基本的扩展方案。其中，前者以多核技术为代表，后者则依赖分布式技术，两者在架构方面互为补充。由此衍生的细分领域包括但不限于并发编程、分布式通信、数据一致性、节点协调、错误处理、职责分离等，这些技术在实践中形成了一系列设计原则和模式。<strong>反应式架构</strong>(Reactive architecture)就是以这些原则和模式为基础、进而发展为一种面向现代高即时响应性的软件系统的架构风格。</p>

<h3>多核与反应式编程</h3>

<p>多核技术提供了纵向的单机扩展能力，但要利用这种底层能力离不开上层并发编程的支持。经典的并发编程框架如Java Concurrency[BG99]，提供了最接近底层且功能强大的并发编程API，例如下列一个爬虫的代码片段(例子来源于互联网):</p>

<pre><code>public class Crawler {
   private ConcurrentHashMap&lt;String, Boolean&gt; seen = new ConcurrentHashMap&lt;String, Boolean&gt;();
   private AtomicInteger pending = new AtomicInteger(0);

   public Crawler(String baseUrl, int numOfThreads) {
       this.client = HttpClientBuilder.create().build();
       this.baseUrl = baseUrl;
       this.executorService = Executors.newFixedThreadPool(numOfThreads, new ThreadFactory() {
          public Thread newThread(Runnable r) {
              return new Thread(r, "Crawler-Worker");
           }
       });
   }

   public void start() {
       handle(baseUrl);
   }

   private void handle(final String link) {        
      if (seen.containsKey(link))
          return;
      seen.put(link, true);
      pending.incrementAndGet();
      executorService.execute(new Runnable() {
          public void run() {
              List&lt;String&gt; links = getLinksFromUrl(link);
              for (String link : links) {
                  handle(link);
              }
              pending.decrementAndGet();
              if (pending.get() == 0) {
                  synchronized (lock) {
                      lock.notify();
                  }
              }
          }
      });
   }
}
</code></pre>

<p>客户端代码如下:</p>

<pre><code>public class Main{
    public static void main(String[] args) throws InterruptedException {
        if (args.length != 2) {
            System.err.println("Invalid syntax: &lt;baseUrl&gt; &lt;numOfThreads&gt;");
            System.exit(1);
        }
        String baseUrl = args[0];
        int numOfThreads = Integer.parseInt(args[1]);
        Crawler crawler = new Crawler(baseUrl, numOfThreads);
        crawler.start();
        crawler.join();
        crawler.shutdown();
    }
}
</code></pre>

<p>该例中的爬虫实现基于Java Concurrency的ExecutorService API，一种共享状态并发式编程模型。为了保证线程安全，代码中采用了ConcurrentHashMap、AtomicInteger、Lock和Synchronized等Java特有的并发编程技术，存在复杂度较高、易理解性差、共享状态维护难度高、易出错等缺点。</p>

<p><strong>反应式编程</strong>(Reactive programming)是一种具有异步编程风格的编程框架，其衍生自基于数据流的并发声明式编程模型，采用事件驱动和非阻塞线程技术，从而降低因为资源等待导致的并发性能瓶颈。首先来看一个基于RxJava[RXJ14]的爬虫代码片段(例子来源于互联网):</p>

<pre><code>public class ObservableCrawler {
  private Subscriber&lt;? super String&gt; subscriber;

  public static Observable&lt;String&gt; create(Crawler crawler, String url, int numOfThreads) {
      ObservableCrawler o = new ObservableCrawler(crawler, numOfThreads);
      return Observable.create(subscriber -&gt; {
          o.subscriber = subscriber;
          if (o.executorService == null) {
              o.process(url);
              subscriber.onCompleted();
          } else {
              o.processAsync(url);
          }
      });
  }
  private ObservableCrawler(Crawler crawler, int numOfThreads) {
      this.crawler = crawler;
      this.executorService = numOfThreads &gt; 0 ?
              Executors.newFixedThreadPool(numOfThreads, r -&gt; new Thread(r, "Crawler-" + threadIdGenerator.incrementAndGet()))
              : null;
  }

  private void processAsync(String url) {
         pendingTasks.incrementAndGet();
         executorService.submit(() -&gt; {
             // If item is not unique, skip processing
             boolean isFirstTime =  results.add(url);
             if (isFirstTime) {
                 subscriber.onNext(url);
                 crawler.crawl(url, this::processAsync);
             }
             if (pendingTasks.decrementAndGet() == 0) {
                 subscriber.onCompleted();
                 executorService.shutdown();
             }
         });
  }
}
</code></pre>

<p>其客户端代码如下:</p>

<pre><code>public class CrawlerClient {
  public CrawlerClient(Crawler crawler, String url, int numOfThreads) {
      this.observable = ObservableCrawler.create(crawler, url, numOfThreads);
      observable.subscribe(this::onNext, this::onError, this::onCompleted);
  }

  public void waitForCompletion() throws InterruptedException {
      completionLatch.await();
  }
}
</code></pre>

<p>与前面直接基于Java Concurrency的例子类似，该例同样采用了ExecutorService实现爬虫的并发执行，其中waitForCompletion也提供了阻塞客户端的能力。两者的区别在于，RxJava的版本采用观察者模式对爬虫类进行了封装，客户端不再需要等待代码执行结束后再执行后续指令。其中的一部分技术细节，例如线程安全代码被封装在API中，再通过回调函数接口提供给客户端，后者只需要关心onNext、onError和onCompleted的线程安全实现，这在一定程度上降低了Java并发编程的复杂度。</p>

<p>除了上例介绍中朴素的回调函数API之外，反应式编程通常还可能提供多种异步编程风格API，包括但不限于:</p>

<ul>
<li><p>Futures/Promises，一种单赋值容器，支持针对单写/多读场景的、自上而下的异步编程风格，能够有效解决回调地狱(Callback hell)的问题。</p></li>
<li><p>流(Streams)，一种无界限的数据处理流，支持多个源点、汇点间的异步、非阻塞、背压(Backpressure)的数据变换管道。例如函数组合(Functional composition)提供的map、filter、fold等流式操作。这里的背压是指当异步执行管道中的消费端计算能力不足，上游仍然持续生产事件，从而导致系统过载的问题。反应式编程API一般通过配置不同策略以防止潜在的系统灾难。</p></li>
<li><p>数据流变量(Dataflow variables)，一种单赋值变量，能够基于输入、过程和其它变量实现自动更新。</p></li>
</ul>


<p>前述例子中采用的RxJava遵循了ReactiveX标准——一套反应式编程的技术规范[REX]，类似的反应式编程扩展(Rx)支持已被添加至许多编程语言中，如RxJS、Rx.NET、RxScala等。此外，RxJava还支持JVM平台的反应式流规范(Reactive Streams Specification)[RSS]，从而具备与其它反应式编程API之间的互操作性。与传统编程模型相比，反应式编程在多核利用率、并发编程、系统模块性、工作流组装方面相较于传统编程模型具有优势。但其同样可能会损害代码的易理解性，并且通常只局限于单机计算，虽然有助于加强即时响应性，但并不能满足反应式架构要求的另外两个核心质量属性:</p>

<ul>
<li><p>回弹性，指系统在出错时能够自动恢复并保持正常的即时响应性目标。</p></li>
<li><p>弹性，是指系统在异常工作负载下，能够自适应调整自身容量从而维持其正常的即时响应性目标。</p></li>
</ul>


<p>这正是分布式系统成为云计算、移动/IOT领域核心技术的重要原因。</p>

<h3>分布式与异步消息传递</h3>

<p>分布式技术的目标是为系统提供横向扩展能力。通过负载监控和自动化伸缩技术，实现系统容量的自适应调节，从而满足弹性需求。另外，通过隔离组件控制系统错误/灾难的级联传递，再将错误提交至安全上下文中即时处理，从而满足回弹性需求。</p>

<p>反应式架构使用<strong>异步消息传递</strong>作为组件间的通信模式，通过在组件间建立临时边界，实现组件间的松耦合、隔离与地址透明化，达到时间、空间二重解耦的目的。值得注意的是，这里的空间解耦既可以指单机中的线程/进程，也可以指分布式系统的组件。“消息传递”意味着组件通常是长期存活且可被调用者直接定位、实现定向通信的方式，这与另一种流行的分布式系统通信模式——“事件传递”有着重要区别。因为“事件传递”是通过事件源的状态变化引发相应事件，再通过观察者模式通知“订阅”的组件，因此其关注点在于<strong>可定位事件源</strong>。而在“消息传递”中则相反，调用者需要明确知道被调用者的位置信息，即更加关注<strong>可定位接收者</strong>——这是反应式架构实现回弹性和弹性的重要基础。因为后者具有更强的控制力:负载管理、错误检测、消息丢弃/复制/排序、通过监控和调整消息队列实现流量控制以及背压等。</p>

<p>以应对回弹性为例，为了使系统在出错时仍然保持正常的即时响应性，需要实现调用者和被调用者的完全隔离，使后者发生的错误不被传递至前者，同时应支持消息被传递到多个复制组件中，即便错误发生时系统仍能正常提供服务。虽然容错性也是受到普遍重视的质量属性之一，但是传统上强耦合、深度嵌套的同步调用链代码缺少一致的容错方案。反应式架构明确要求把错误信息封装在消息中传递至其它组件，并使其在出错组件外部的一个安全上下文中得到有效处理(代理模式)。这里体现的基本思想是把错误处理从原有调用链中解耦，即移除客户端中针对服务端错误进行处理的职责。</p>

<p>再以弹性计算为例，系统被要求能够根据实际负载需求自动增加或减少所占用资源，从而动态调整吞吐量。这种自适应性意味着无介入实现系统伸缩、状态/行为冗余、负载均衡、失效备援和系统升级等能力。其基本思想是在编程抽象和语义层面实现组件空间位置的透明化，使系统更易于伸缩，且这种可伸缩性无需局限于CPU核甚至数据中心。</p>

<h3>消息传递并发式模型及其应用</h3>

<p>消息传递并发式模型是一种通过异步通信信道实现组件间通信的编程模型，目前被广泛应用于实现反应式架构中的“异步消息传递”模式，例如经典的Actor模型[CPR73]。</p>

<p>Actor是一种相比基于线程的并发编程更高级的抽象模型，其旨在解决如下问题:</p>

<ul>
<li><p>伸缩性，指包括单机和分布式环境下的系统扩容能力，即隐藏系统横向、纵向扩展的底层技术差异。</p></li>
<li><p>透明性，指同时适应单机和分布式环境下的定位能力，例如在单机环境下采用并发编程语言，在分布式环境下采用网络通信，这些完全不同的资源定位方式导致系统难以从单机向分布式演化。</p></li>
<li><p>不一致性，这里的不一致性是指在许多超大型系统中，面向人的信息系统交互存在不一致的问题，例如文档、标准等。</p></li>
</ul>


<p>在Actor模型中，最基本的并发计算元素被称作actor。actor之间可以发送和接收消息，并且各自维护一个内部状态。当actor接收到消息时，可以并行执行下列响应方法:</p>

<ul>
<li><p>创建有限数量的新actor。</p></li>
<li><p>发送有限数量的消息给其它actor。</p></li>
<li><p>定义下一次接收消息时触发的行为。</p></li>
</ul>


<p>Actor模型无论在计算理论还是在实际应用中都产生了重要影响，特别是可以被用于描述一些流行的并发编程框架，例如下面要介绍的Erlang/OTP Processes[EOP]和Akka Actors[AA]。</p>

<h4>Erlang/OTP Processes</h4>

<p>Erlang是一种声明式编程语言，除了基本的语法规则外，Erlang在其内核语言的基础上还提供了一套专有运行时系统和库——OTP(Open Telecom Platform)，后者是Erlang实现分布式、软实时、高容错、高可用、热部署的基础[OTP]。其中，<strong>进程</strong>(Processes，注意这里不是操作系统进程)是Erlang并发编程的基本计算元素，类似actor。如下列代码所示(例子来源于互联网):</p>

<pre><code>-module(counter).
-export([run/0, counter/1]).

run() -&gt;
    S = spawn(counter, counter, [0]),
    send_msgs(S, 100000),
    S.

counter(Sum) -&gt;
    receive
        value -&gt; io:fwrite("Value is ~w~n", [Sum]);
        {inc, Amount} -&gt; counter(Sum+Amount)
    end.

send_msgs(_, 0) -&gt; true;
send_msgs(S, Count) -&gt;
    S ! {inc, 1},
    send_msgs(S, Count-1).

% Usage:
%    1&gt; c(counter).
%    2&gt; S = counter:run().
%       ... Wait a bit until all children have run ...
%    3&gt; S ! value.
%    Value is 100000
</code></pre>

<p>上例中实现了一个并发计数器counter，并向外部提供两个函数run和counter。其中run函数的作用是创建一个新的counter进程，然后向其发送倒计时时间消息。counter定义了消息接收行为，包括打印和增数。send_msgs通过!向S进程发送消息，然后通过递归实现倒数。与actor概念类似，Erlang的进程相互之间完全隔离，并通过消息传递相互通信。由于进程的创建和销毁十分轻量化，从而允许系统中容纳数量非常可观的进程(在普通PC中即可实现千万级进程数)，这些进程可以在运行时系统中存在很长时间，如果没有消息接收或者运行了太长时间，进程就会被重新放入调度队列，避免影响其它正常运行进程。</p>

<h4>Akka Actors</h4>

<p>Akka是一个基于JVM的并发编程框架，其中的核心模块Akka Actors的Scala语法部分借鉴自Erlang，例如:</p>

<pre><code>object HelloWorld {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String, from: ActorRef[Greet])

  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =&gt;
    context.log.info("Hello {}!", message.whom)
    message.replyTo ! Greeted(message.whom, context.self)
    Behaviors.same
  }
}
</code></pre>

<p>与此相比Java版本就显得较为繁琐一些，但也很容易理解:</p>

<pre><code>public class HelloWorld extends AbstractBehavior&lt;HelloWorld.Greet&gt; {

  public static final class Greet {
    public final String whom;
    public final ActorRef&lt;Greeted&gt; replyTo;

    public Greet(String whom, ActorRef&lt;Greeted&gt; replyTo) {
      this.whom = whom;
      this.replyTo = replyTo;
    }
  }

  public static final class Greeted {
    public final String whom;
    public final ActorRef&lt;Greet&gt; from;

    public Greeted(String whom, ActorRef&lt;Greet&gt; from) {
      this.whom = whom;
      this.from = from;
    }
  }

  public static Behavior&lt;Greet&gt; create() {
    return Behaviors.setup(HelloWorld::new);
  }

  private HelloWorld(ActorContext&lt;Greet&gt; context) {
    super(context);
  }

  @Override
  public Receive&lt;Greet&gt; createReceive() {
    return newReceiveBuilder().onMessage(Greet.class, this::onGreet).build();
  }

  private Behavior&lt;Greet&gt; onGreet(Greet command) {
    getContext().getLog().info("Hello {}!", command.whom);
    command.replyTo.tell(new Greeted(command.whom, getContext().getSelf()));
    return this;
  }
}
</code></pre>

<p>从编程模型的角度看，Akka Actors与Erlang Processes本质上是一致的，然而其底层系统存在巨大差别——更多是JVM与OTP的差别。两者如今也都形成了各自庞大的生态系统，成为设计反应式架构的重要参考，并且在通信、数字金融、在线游戏、在线交易、统计、社交媒体、移动应用等领域得到了广泛应用。</p>

<h2>结论</h2>

<p>本文介绍了一种流行的架构风格——反应式架构，详细讨论了即时响应性、回弹性和弹性等质量属性以及异步消息传递模式。在具体实践层面，首先讨论了事件驱动模式的反应式编程及其在多核环境中的应用，进一步介绍了消息传递模式的Actor模型及相关的流行编程框架——Erlang Processes和Akka Actors。由此可见，<strong>参考架构风格的关键在于理解其要解决的核心问题，即要满足的特定的功能或非功能需求是否符合期望。一旦确定架构风格，其特定的设计原则就应尽量被作为软件开发的通用设计原则。而针对架构风格中包含的多种模式、框架和系统，就需要依据具体上下文灵活做出选择。</strong></p>

<h2>引用</h2>

<p>JDRM14, <a href="https://www.reactivemanifesto.org/">https://www.reactivemanifesto.org/</a></p>

<p>BG99, <a href="https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">Java Concurrency in Practice</a></p>

<p>RXJ14, <a href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a></p>

<p>REX, <a href="http://reactivex.io/">http://reactivex.io/</a></p>

<p>RSS, <a href="http://www.reactive-streams.org/">http://www.reactive-streams.org/</a></p>

<p>CPR73, <a href="https://dl.acm.org/doi/10.5555/1624775.1624804">A universal modular ACTOR formalism for artificial intelligence</a></p>

<p>EOP, <a href="https://erlang.org/doc/reference_manual/processes.html">https://erlang.org/doc/reference_manual/processes.html</a></p>

<p>AA, <a href="https://doc.akka.io/docs/akka/current/typed/index.html">https://doc.akka.io/docs/akka/current/typed/index.html</a></p>

<p>OTP, <a href="https://erlang.org/doc/">https://erlang.org/doc/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(15)]]></title>
    <link href="http://www.hanyi.name/blog/2019/06/08/software-design-and-architecture-notes-15/"/>
    <updated>2019-06-08T13:14:00-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/06/08/software-design-and-architecture-notes-15</id>
    <content type="html"><![CDATA[<h2>软件架构说什么？</h2>

<p><strong>架构</strong>(Architecture)一词源自建筑领域，尽管看起来与软件设计毫无关联，但人们从上世纪60年代起就注意到两者的相似性[PHJ06]，并从结构和工程等方面大量借鉴了这个古老的学科，软件设计也因此获益匪浅[GHJV95]。当然不仅是软件，这个词也被其它领域广泛借鉴，例如作为计算机基础的<strong>体系结构</strong>(Computer architecture)，后者主要指计算机的物理结构或者CPU指令集。又比如<strong>企业架构</strong>(Enterprise architecture)、<strong>解决方案架构</strong>(Solution architecture)或者<strong>信息架构</strong>(Information architecture)等，则是表示针对各自问题域的专业性实践集合。</p>

<p>虽然架构与<strong>设计</strong>同属于本系列的主题之一，但迄今为止我们都很少提及。一方面是因为，作为诞生于上世纪90年代的buzz word，软件架构是在软件设计的基础上发展而来的，前者继承了后者的许多核心思想，例如模块化、原则、模式等，逐渐形成了更加庞大的体系。另一方面，架构一词如今具有极其丰富的含义，以至于可能达到阻碍交流的地步，因此确有必要首先对部分概念予以澄清。此外，除非特别说明，本系列文章中的架构均指软件架构。</p>

<h3>定义和解释</h3>

<p><em>架构是指一个系统在其所在环境中的基本概念和属性，这体现为系统的元素、关系及其设计和演进的原则。</em></p>

<p>虽然这是ISO/IEC 42010对架构的正式定义，另一种USP(Unique selling proposition)定义则更详细地解释了这一点:</p>

<p><em>架构是一系列重要的决策，涉及描述软件系统的组织、确定结构化元素及其接口、确定元素在协作中的特定行为、指导结构和行为元素通过组合逐渐形成较大子系统的风格(涉及元素、接口、协作和组织等)。此外还要考虑用途、功能、性能、适应力、可重用性、可理解性、经济性、技术限制及其权衡、美学等因素。</em></p>

<p>以上定义明确指出了架构的<strong>表示</strong>(Representation)、<strong>质量属性</strong>(Quality attribute)以及<strong>风格</strong>(Style)等核心内容。此外，针对已有的架构方案，有时需要进行专门的<strong>架构评估</strong>(Architecture evaluation)，从而提前发现问题并控制潜在风险。本文剩余部分将作进一步讨论。</p>

<h3>架构表示</h3>

<p>由于架构本身的丰富性，采用适当方法描述架构就变得非常重要，一种基本的架构描述工具是<strong>架构视图</strong>(Architecture view)，其被用于表示架构在解决特定问题时所体现的结构化信息。由于完整的架构一般会涉及众多干系人，在单一视图中无法清楚表示所有信息，因此为了进一步在视图中区分来自不同干系人的诉求，采用<strong>架构视点</strong>(Architecture viewpoint)聚焦于某一类架构决策，并采用特定的标记和建模技术建立对应的架构视图。常见的架构视点有功能、逻辑、数据、模块、组件-连接器、需求、实现、并发、性能、安全、部署、用户使用及反馈等，由此可见其对应的架构视图也就非常丰富。</p>

<p>以组件-连接器类型的架构视图为例，该架构视图定义了系统中的可计算组件及其交互方式，其中组件是指可独立运行、且支持交互或存储数据的软件单元，连接器则被用于描述组件之间的交互机制。在构建组件-连接器视图的过程中，组件可以根据承担功能、可重用性、硬件单元，甚至团队的技术背景、康威定律以及产品演化路径等方式定义。同时，组件还需要描述其对外提供交互的接口(API)，包括访问端口、参数以及参数类型。然后根据组件间交互的需求，如同步、异步、延迟、吞吐量等确定连接器的类型和通信协议。连接器两端的组件分别被称为调用者和被调用者，组件与连接器之间通常需要相关配置以确定关联信息。</p>

<h4>架构描述语言</h4>

<p>通常，架构视图是采用<strong>架构描述语言</strong>(Architecture description languages，ADL)具体实现的，如AADL、Wright、ACME、xADL等专门面向软件架构的语言。同时也可以采用通用的建模语言，例如UML，实际上后者在工业界更加流行。架构视图和ADL共同组成了架构表示的基本方法，但仍不足以有效应对架构的复杂性。这是因为在真实场景中架构视点可能是非常多的，架构需要从核心视点出发逐步完善，因此需要进一步参考适当的<strong>架构框架</strong>(Architecture framework)。</p>

<h4>架构框架</h4>

<p>架构框架是指在特定应用领域或干系人社区中，创建、解释、分析和使用架构表示的通用实践集合。一种经典的架构框架是“4+1架构视图模型”[PK95]，其基本思想是需要采用若干个相互平行、且具有不同架构视点的架构视图，具体来说就是<strong>逻辑视图</strong>、<strong>进程视图</strong>、<strong>开发视图</strong>和<strong>物理视图</strong>等四种主要架构视图，以及相应的<strong>用例和场景</strong>说明，从而达到表示完整架构的目的。</p>

<ul>
<li><p>逻辑视图，即把系统按照功能、通信、行为等进行结构化分解的结果，描述系统的静态信息。具体可以采用UML中的类图或状态图实现。</p></li>
<li><p>进程视图，即对系统中进程和线程的通信、执行过程进行描述，即系统的动态运行信息。具体可以采用UML中的部署图和活动图实现。</p></li>
<li><p>开发视图，也称作<strong>实现视图</strong>，用于描述软件开发过程中的软件结构，例如组件、包、类、子系统、代码库、文件等。具体可采用UML的组件图或包图实现。</p></li>
<li><p>物理视图，描述系统运行的硬件资源结构，及其与系统进程之间的映射关系。具体可采用UML中的部署图、时序图或协作图实现。</p></li>
<li><p>用例和场景，也称作<strong>用例视图</strong>，即从少量核心用例出发，描述系统中对象间、进程间的交互顺序。该视图主要用于构建可验证的架构原型，从而对当前架构进行测试。</p></li>
</ul>


<p>根据上述5种架构视图，4+1架构视图模型能够建立一个核心的软件架构表示。然而从架构对整个软件工程的影响角度来说，架构框架作为架构表示的核心，往往还需要更多架构视点的支持，这与具体上下文密切相关，特别是接下来要讨论的质量属性。</p>

<h3>质量属性</h3>

<p>除了满足功能需求，架构还需要考虑系统的非功能需求(二者相互正交)，后者也被称作系统的质量属性，例如性能、可靠性、资源利用率、可用性、精确性等。与功能需求最显著的不同在于，质量属性往往是相对概念，一般表现为某种程度，且具备多种领域背景。正因为如此，质量属性大大提升了架构的复杂性，也是除了功能需求变化外另一个可能引起架构变化的重要原因。</p>

<p>ISO/IEC 25010对软件质量进行了明确定义，其中功能性表示系统功能的完整性、正确性、适当性与合规性，此外还包含7种非功能属性以及对应的子属性:</p>

<ul>
<li><p>可靠性，指系统在特定时间和条件下维持当前性能的能力，包括成熟度、容错性、可恢复下、可用性等指标。</p></li>
<li><p>易用性，指个体或群体在使用系统时的难易程度。包括易理解性、易学习性、易操作性、界面美观性、操作错误保护以及可访问性。</p></li>
<li><p>高效性，指系统在特定条件下，资源使用量与软件性能之间的关系。包括耗时、资源利用率、容量等指标。</p></li>
<li><p>兼容性，指系统在特定的软、硬件环境中能够正常运行的能力。包括共存性、互操作性等指标。</p></li>
<li><p>安全性，指系统保护数据和执行正当行为的能力。包括保密性、完整性、非拒绝性、可审计性以及可验证性。</p></li>
<li><p>可维护性，指系统在需要做出特定修改时所花费的成本大小。包括可分析性、可改变性、稳定性、可测试性、模块性、可重用性以及可修改性。</p></li>
<li><p>可移植性，指系统迁移到其它环境的能力。包括可适应性、可安装性、可替换性等。</p></li>
</ul>


<p>值得一提的是，经验研究表明并非所有的非功能需求都有同等机会引发架构变化[JAD16]，尽管它们可能拥有相同的重要性。但在进行架构相关决策时，依然不可避免地要考虑功能以及多种质量属性，这就导致从零开始设计架构具有极高的成本和风险。因此绝大多数架构设计活动实际上是遵循着经受实践检验的经验，即下面要讨论的<strong>架构风格</strong>。</p>

<h3>架构风格</h3>

<p>架构风格是指一系列满足功能和特定质量属性的设计决策与约束子集[RNE09]，其意义在于:</p>

<ul>
<li><p>提供可重用的领域和工程知识，特别是相同领域或产品族中与应用无关的设计规则和决策，避免重新发明轮子。</p></li>
<li><p>阻止架构腐化和偏离，帮助未来开发人员在不损害基本架构原则的基础上扩展系统。</p></li>
<li><p>根据质量需求指导设计。</p></li>
</ul>


<p>以经典的<strong>管道-过滤器</strong>架构为例，在该架构风格中，所有的过滤器都通过两个字节流“输入”和“输出”进行通信，这样就保证了任何过滤器都能够互相连接——即满足兼容性。另外，过滤器之间可以一次只传递部分数据，这样就能够尽可能提高过滤器之间并行计算的能力，从而提高系统效率。除此之外，应用中常见的架构风格还包括但不限于:</p>

<ul>
<li><p>客户端-服务器(C/S)架构。</p></li>
<li><p>分层(三层或N层)架构。</p></li>
<li><p>点对点(Peer-to-peer)架构。</p></li>
<li><p>事件驱动(Event-driven)架构，也称隐式调用架构。</p></li>
<li><p>表述性状态转移(REST)架构。</p></li>
<li><p>面向服务架构(SOA)。</p></li>
<li><p>领域驱动设计(DDD)。</p></li>
</ul>


<p>限于篇幅本文无法详细讨论每种架构风格。而事实上，在实际软件开发过程中架构风格往往是在最初就确定的，因此可被视为架构设计的设计规则。另外，大部分情况下整个系统会拥有多种架构风格，从而满足各种质量属性需求。</p>

<h3>架构评估</h3>

<p>由于架构的重要性，团队通常需要对已有的架构方案进行评估。架构权衡分析(Architecture tradeoff analysis method)是一种架构评估方法，采用该方法首先需要建立一个专门的架构评审小组，该小组应至少包含所有的干系人。启动评估后，首先应确保所有参与者熟悉评估流程以及业务背景。向所有评估者展示更高层次的系统架构，包括所采用的架构风格。然后通过<strong>质量属性树</strong>描述系统所要特别关注的质量属性，并且为每个所要满足的属性提供一个具体场景。一个质量属性树的例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/architecture/quality_tree.png" alt="Quality attribute tree" /></p>

<p>把所有场景按照优先级进行排序，然后逐一分析当前架构对该场景的适用性，根据相关反馈进行调整。最后在更大范围的干系人组织中分享当前架构知识。</p>

<h2>结论</h2>

<p>软件架构包含三个核心问题，分别是架构表示、质量属性和架构风格。架构表示是架构得以沟通并完善的重要途径，在架构设计的过程中不仅要考虑功能需求，还要考虑非功能需求(质量属性)，不同的架构风格在应对特定质量属性方面具有优势，因此真实场景中需要组合架构风格以满足来自不同干系人的需求。</p>

<h2>引用</h2>

<p>PHJ06, <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1605175">The Past, Present, and Future of Software Architecture</a></p>

<p>GHJV95, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/DSBP-2018-01/recursos/Erich%20Gamma,%20Richard%20Helm,%20Ralph%20Johnson,%20John%20M.%20Vlissides-Design%20Patterns_%20Elements%20of%20Reusable%20Object-Oriented%20Software%20%20-Addison-Wesley%20Professional%20%281994%29.pdf">Design Patterns: Elements of Reusable Object-Oriented Software</a></p>

<p>PK95, <a href="https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf">Architectural Blueprints—The “4+1” View
Model of Software Architecture</a></p>

<p>RNE09, <a href="https://www.softwarearchitecturebook.com/">Software Architecture: Foundations, Theory, and Practice</a></p>

<p>JAD16, <a href="http://www.aset.tu-berlin.de/fileadmin/fg331/Publications/ICSE16.pdf">Are “Non-functional” Requirements really Non-functional?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(14)]]></title>
    <link href="http://www.hanyi.name/blog/2019/06/01/software-design-and-architecture-notes-14/"/>
    <updated>2019-06-01T23:31:49-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/06/01/software-design-and-architecture-notes-14</id>
    <content type="html"><![CDATA[<h2>敏捷软件设计</h2>

<p>早期的软件开发方法源自传统制造业和建筑业，即按照需求、分析、设计、开发、测试、运营等阶段顺序执行。这种线性的软件开发过程被称作<strong>瀑布模型</strong>(Waterfall)。瀑布模型在上世纪70年代逐渐发展成熟，成为软件开发方法的事实标准。随着互联网的出现，软件工业迈入飞速发展，频繁变更的需求和快速更替的技术使瀑布模型遭遇了空前挑战。于是，通过从先进制造业汲取经验，行业一线的职业程序员们开始调整原有方法，90年代先后诞生了<strong>统一过程</strong>(Unified process)、<strong>Scrum</strong>、<strong>极限编程</strong>(Extreme programming)等轻量级软件开发方法。2001年，程序员们从这些方法的核心思想中提炼出了著名的<strong>敏捷宣言</strong>，由此敏捷成为前述一系列软件开发方法的代名词。时至今日，对于需求明确并且依赖成熟技术的软件开发活动来说，严谨且可靠的瀑布模型仍然占有一席之地。敏捷思想则在自互联网时代开启的一系列新兴领域中更受欢迎，也更具备发展空间。</p>

<p>敏捷对软件设计产生了重大影响，正如Martin Fowler所指出的，极限编程不仅宣告了Big Design Up Front的终结，还严重影响了一批热门的技术实践例如UML、框架构建、设计模式[MFL00]。然而软件设计并未因敏捷而消失，敏捷也不意味着无设计或设计灾难，为了与传统瀑布模型的<strong>计划设计</strong>(Planned design)进行区别，敏捷设计被描述为<strong>演进式设计</strong>(Evolutionary design)、<strong>持续设计</strong>(Continuous design)或<strong>浮现式设计</strong>(Emergent design)，或许这些名词有时夹带了浓厚的宣传意味，但是不可否认分析与设计、原则与模式依然是敏捷软件设计的核心，后者的主要特点在于更加强调轻量化的敏捷设计实践。这往往意味着:</p>

<ul>
<li><p>强调价值交付，交付价值是推动整个软件工业发展的重要经济基础，因此价值应当始终是软件开发的优先选项。</p></li>
<li><p>强调团队责任，而不是把职责局限于分析师、设计师、XX师等不同工种，从而减少<strong>单点失败</strong>(Single point failure)。</p></li>
<li><p>强调快速反馈，无论是测试驱动开发还是持续集成，通过尽可能的自动化实现软件设计质量的实时监控，且应保证快速响应。</p></li>
</ul>


<p>具备代表性的实践有面向设计一致性的<a href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/"><strong>代码味道</strong></a>和<strong>重构</strong>、面向功能一致性的<strong>测试驱动开发</strong>(Test driven development)以及面向团队一致性的<strong>结对编程</strong>(Pair programming)、<strong>代码评审</strong>(Code review)和<strong>持续集成</strong>(Continuous integration)等。敏捷正是通过前述一系列实践，从而避免从BDUF走向另一个设计熵增的极端。本文剩余部分将进一步讨论价值交付、团队责任和快速反馈在敏捷软件设计活动中的具体体现。</p>

<h3>价值交付：扩展—收缩模式(Expand-Contract Pattern)</h3>

<p>应对变化是敏捷软件设计的永恒主题。当现有设计发生变化时，这种变化可能通过接口向模块外传递，从而影响更多其它模块。特别对于<a href="https://martinfowler.com/bliki/PublishedInterface.html">公共接口</a>来说，变更现有设计会产生较高成本，进而影响交付的价值。[MFL14]讨论了一种扩展—收缩模式，其核心思想是在变更设计的同时保持向后兼容，当新设计产生的价值得到验证后再移除旧设计。例如下列代码:</p>

<pre><code>class WindowFactory {

    public Window createWindow(String title, int x, int y, int width, int height) {
        ...
    }
}
</code></pre>

<p>该例中的抽象工厂类WindowFactory能够创建不同类型的Window，参数列表接受窗口名、位置和尺寸等信息，其中位置和尺寸能够使用Rect对象代替，从而有:</p>

<pre><code>class WindowFactory {

    public Window createWindow(String title, Rect rect) {
        ...
    }
}
</code></pre>

<p>如果该接口属于公共接口，那么所有客户端组件都必须被动修改，否则将无法正常工作。更加合理的做法是首先保留原接口(<strong>扩展</strong>):</p>

<pre><code>class WindowFactory {

    public Window createWindow(String title, int x, int y, int width, int height) {
        ...
    }

    public Window createWindow(String title, Rect rect) {
        ...
    }
}
</code></pre>

<p>当客户端组件迁移完成后，再移除失效的接口(<strong>收缩</strong>)。通过采用扩展—收缩模式，能够有效控制设计变更对交付价值的影响，这也是敏捷软件设计的核心目标之一。</p>

<p>同样的模式还被应用于演进式数据库设计[MFL16]，特别是当数据模式发生破坏性修改时(修改表名、列名等操作)，需要保证在迁移阶段同时支持新旧两种数据访问模式。例如当修改表名时，可以通过创建与旧表名相同的视图提供向后支持。当设计需要修改列名时，可以先创建新的列，然后通过触发器实现新旧两列的同步，直至迁移阶段结束再清理旧模式。在真实场景中应根据数据库类型、应用类型等相关上下文决定具体实现，但设计思想仍然遵循扩展—收缩模式。</p>

<h3>团队责任：模型风暴(Model Storming)</h3>

<p>模型风暴是一种即时建模活动，其目的是把设计责任赋予团队而非个人。理论上说模型风暴可以发生在敏捷软件开发过程的任何时间，但通常是由一名用户故事的所有者(Story owner)在进入开发阶段前发起。首先由所有者确保理解所要解决的问题，然后集合若干团队成员(通常是2~3人)进行站立会议(Stand session)。在所有者介绍完背景并确保所有人理解上下文后，团队开始在一个共享建模工具上探索设计方案，直至大家充分理解并达成一致，会议结束(通常是5~10分钟)。</p>

<p>模型风暴有两种应用场景——分析和设计。分析模型风暴主要是帮助团队理解需求，这时应尽可能集合相关干系人(产品负责人、业务分析师、设计师、质量分析师和开发等)，然后通过绘制草图帮助所有人理解原始需求，并澄清相关问题。这一阶段的关键在于鼓励各种干系人参与建模过程，于是应尽量采用包容性建模(Inclusive modeling)及相关工具，避免过度专业和复杂的工具应用，从而促进沟通。常见的包容性工具有白板、索引卡、便利贴、白板纸等。</p>

<p>设计模型风暴是在编写代码前由若干开发人员共同完成的设计活动。根据开发人员的技术背景，建模过程可以采用<a href="http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8/">UML</a>、<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">类职责协作卡</a>(CRC)、<a href="http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5/">数据流程图</a>或一般流程图等包容性工具。具体过程可以参考<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">前文</a>介绍的CRC及其在协作式OOD中的应用。</p>

<p>模型风暴能够促进设计知识在团队中进行传递，从而有效控制软件设计的单点失败风险。</p>

<h3>快速反馈：设计监测(Design Monitoring)</h3>

<p>快速反馈主要是指能够快速验证当前设计的完整性，并在发现设计缺陷时提供警报，这往往需要依赖专业面向软件设计的静态代码分析工具来完成。通常的做法是把相关工具集成进现有的持续集成过程，并作为某种质量检测报告输出，从而实现设计监测。设计监测工具主要通过分析软件结构中的依赖热点(Hotspot)进行，一般有两种途径分析这些热点——<strong>度量</strong>和<strong>模式</strong>。</p>

<p>度量是通过对软件结构中的实体及其依赖关系进行量化分析，从而反映软件模块化的程度。一种可量化的设计原则是<a href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/">包依赖原则</a>，在此基础上的经典Java开源实现即JDepend(现基本停止维护)，该工具以Java语言的包为单位，分别计算每个包的类数量(TC)、具体类数量(CC)、抽象类数量(AC)、传入耦合(Ca)、传出耦合(Ce)、抽象系数(A)、不稳定性(I)、偏离距离(D)，每种度量的具体定义本文不再赘述。</p>

<p>模式主要是指检测依赖中的反模式，后者主要是违反设计原则的实际情况，例如违反包间无环依赖，接口隔离、Liskov替换、依赖倒置等。具体做法是把软件设计中的依赖关系用图表示，然后检测图中存在的违反设计原则的特定模式(Motif)，经典开源实现即Google的<a href="https://code.google.com/archive/p/gueryframework/">GUERY</a>(停止维护)。该工具能够根据图中的顶点、关系及其路径长度等条件识别特定模式，并且根据Tarjan算法计算强联通子图进而生成凝聚图。</p>

<p>免费工具除前述外，还有针对Java程序的依赖抽取和可视化工具<a href="http://www.dependency-analyzer.org/">Class Dependency Analyzer(CDA)</a>，CDA能够把相关依赖以UML的形式进行可视化，帮助用户理解并管理复杂软件结构。专业用于依赖分析的商业工具有<a href="http://www.lattix.com/">Lattix</a>、<a href="http://www.hello2morrow.com/products/sonargraph">SonarGraph</a>、<a href="http://www.headwaysoftware.com/products/?code=Structure101">Structure 101</a>、<a href="https://www.jarchitect.com/">JArchitect</a>/<a href="https://www.ndepend.com/">NDepend</a>/<a href="https://www.cppdepend.com/">CppDepend</a>等，本文不再赘述。</p>

<p>值得一提的是，面向软件设计领域无论是免费还是商业工具，尽管其内置的设计规则具有普遍性，同时也支持自定义规则，但通常都存在较高的学习、维护和实施成本，实际上并不能真正达到快速反馈的目的。对处于一线的中小型敏捷团队来说过重，更适用于一些已经具备较高价值的商业软件开发和大型软件组织的架构看护活动。</p>

<p><a href="https://www.archunit.org">ArchUnit</a>是一个基于Java语言的开源依赖检查框架，用户通过编写测试断言的形式约束软件结构依赖，并且通过现有单元测试框架如Junit实现自动运行。与前面提到的主流第三方工具相比，该工具也定义了一些具有普遍意义的依赖规则，同时还具有如下优势:</p>

<ul>
<li><p>直接采用原生语言并作为宿主的测试实现，支持包、类、注解、分层、分片等多种概念实体，使定义复杂的Java代码依赖规则更加容易。</p></li>
<li><p>采用单元测试的思路，使依赖规则能够更快响应软件结构变化，降低规则维护的成本，真正实现快速反馈。</p></li>
<li><p>允许开发人员结合价值交付、团队责任等灵活定制依赖规则，特别适用于敏捷软件设计的场景。</p></li>
</ul>


<p>该工具的缺点是无法向多数GUI工具那样支持依赖分析，内置规则也不如成熟商业工具丰富，因此要求开发人员深入理解设计原则，并能够结合上下文定制恰当的规则。</p>

<h2>结论</h2>

<p>在一般的敏捷宣传语言中，诸如<strong>大道至简</strong>(You Aren&rsquo;t Gonna Need It，YAGNI)和<strong>恰如其分</strong>(Just enough)等词汇往往被使用且被轻易误解。原因在于脱离了具体的实践，敏捷就只剩下一个以人为本的空壳，并不能反映出源自核心的根本经济动力。因此无论是从软件匠艺(Craftsmanship)还是专业主义(Professionalism)来看，敏捷对开发人员的要求都要更高。反映在软件设计领域，具体就是除了基本的分析和设计方法、原则和模式等知识外，进一步注重软件设计中的价值交付、团队责任以及快速反馈等实践。</p>

<h2>引用</h2>

<p>MFL00, <a href="https://martinfowler.com/articles/designDead.html">Is Design Dead?
</a></p>

<p>MFL14, <a href="https://martinfowler.com/bliki/ParallelChange.html">Parallel Change</a></p>

<p>MFL16, <a href="https://martinfowler.com/articles/evodb.html">Evolutionary Database Design</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(13)]]></title>
    <link href="http://www.hanyi.name/blog/2019/05/14/software-design-and-architecture-notes-13/"/>
    <updated>2019-05-14T11:14:51-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/05/14/software-design-and-architecture-notes-13</id>
    <content type="html"><![CDATA[<h2>设计诊断</h2>

<p><strong>设计诊断</strong>(Design diagnosis)是指获取、分析、检测软件设计及其质量的活动。经济利益是驱动软件设计诊断的重要原因之一，特别是对于具有重要价值的软件设施来说，尽早发现并解决设计中存在的问题是十分必要的。然而一直以来软件设计都被认为是难以度量和评价。一方面是因为设计中包含的决策通常是涉及对领域、技术或其它上下文因素的权衡，这是任何客观标准都难以做到完全覆盖的，因此始终无法100%消除对主观参与的依赖，导致设计诊断的权威性受到限制。另一方面，已有的设计验证方法普遍落后于软件开发技术的创造和更替。尽管<a href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/">设计原则与代码味道</a>具有一定的普适性，但是大部分原则本身缺少明确的定量或定性规则(即使存在这类规则一般也很难适用于新的开发技术)，少量有明确的规则通常被归为静态代码分析和风格检查，尚不足以达到设计诊断的目的。</p>

<p>因此为了实现设计诊断，一方面需要对软件设计进行统一的形式化表示，避免对具体的软件开发技术产生依赖。在前者的基础上进一步分析当前软件设计，帮助分析人员理解现有设计、发现设计中的潜在缺陷、甚至模拟历史和未来的设计演化，从而为工程进度和技术债管理提供依据。本文的剩余部分将详细讨论这些主题。</p>

<h3>设计分析(Design analysis)</h3>

<p>设计分析的目标是研究设计本身，后者通常表示解决问题的方案，也可以指构建解决方案的过程。[BC00]认为，理想的解决方案可被视作具有一系列特性的集合，其中的每种特性都可以被归纳为某个维度，即<strong>设计参数</strong>(Design parameters)。不同的设计参数之间存在一定的依赖关系，即<strong>设计结构</strong>(Design structure)。设计参数的所有可能值的集合被称作<strong>设计空间</strong>(Design space)。在整个设计过程中，每个设计参数由对应的<strong>设计任务</strong>(Design tasks)决定，后者相互之间的依赖关系被称为<strong>任务结构</strong>(Task structure)。例如要设计一个马克杯，“是否包含杯盖”是一个设计参数，而“杯盖直径”则是依赖于前者的另一个设计参数，而对于“容器直径”来说，“杯盖直径”与其存在相互依赖的关系。相应地，分别负责杯盖和容器的设计任务之间也就存在依赖，因此设计结构和任务结构具有一致性。前述这些结构可以用一种邻接方阵进行表示，即接下来要讨论的<strong>设计/任务结构矩阵</strong>(Design/Task structure matrix，DSM/TSM)。</p>

<h4>设计结构矩阵</h4>

<p>在DSM(TSM)中，每个结点表示设计参数(或设计任务)，两个设计参数之间的依赖用符号x进行表示，一个马克杯的设计结构例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/full_dsm.png" alt="Full DSM" /></p>

<p>虽然该DSM只有10x10，但每个结点间依赖都可能包含了丰富的物理和工程属性，真实场景中也许会非常复杂。根据设计参数之间的依赖关系类型，在DSM中可以进一步发掘出一些微结构，例如:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/dsm.png" alt="Micro DSM" /></p>

<p>上图描述了两种微观的设计结构，(a)表示层次结构，(b)表示无层次的相互依赖结构，这两种设计结构实质上体现了不同的关系强度，显然(b)体现了更强的相互关系。</p>

<p>另外，真实案例中的矩阵规模通常要比马克杯大得多，例如一个设计笔记本电脑的TSM如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/computer_tsm.png" alt="A laptop computer TSM" /></p>

<p>上图中的TSM相比于马克杯的例子有几个新的元素。首先矩阵中的设计任务呈现出特定排序(或呈现为下三角矩阵)，即相互之间存在强关联的设计任务被放置的更近，越接近对角线的依赖密度就越高。其次整个矩阵上产生了若干相互关联的区块，这些区块直接反映了系统中的独立组件，例如驱动系统、主板等，被称作<strong>原型模块</strong>(Protomodules)。原型模块通常是由领域知识或者组织结构等上下文决定，但是并非真正意义上的模块，因为其本身不具有接下来要讨论的<strong>模块性</strong>(Modularity)。</p>

<h4>模块性与设计规则</h4>

<p>一般而言，高复杂度的问题会导致同样高复杂度的设计，而一个“好”的设计能够有效地管理其自身复杂性。[BC00]认为，<strong>模块化</strong>(Modularization)是系统管理自身复杂性的核心，也是二十世纪以来计算机乃至更多其它领域得以飞速发展的重要原因。系统的模块化程度体现为<strong>模块性</strong>(Modularity)，其中包含两个重要概念:</p>

<p><strong>模块</strong>，即内部元素间的关系比与外部元素间更强的系统单元，这些关系的相对强弱决定了模块的粒度。</p>

<p><strong>抽象</strong>、<strong>信息隐藏</strong>和<strong>接口</strong>，即当一个系统达到一定复杂度时，需要将其拆分成不同部分，抽象的目的在于隐藏其内部复杂性，且通过接口与系统的其它部分进行交互。</p>

<p>在设计笔记本电脑的TSM中，我们知道主板和显示屏之间的设计任务多存在循环依赖，一个例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/design_rule_tsm.png" alt="Cycling in a laptop computer TSM" /></p>

<p>该例中的多个设计任务因为相应设计参数而存在互相依赖，例如主板要决定CPU的规格和所采用的中断协议，而显示屏需要确定详细规格。当主板中具有独立的图形控制器时，显示屏的规格就会发生改变。否则CPU就要根据显示屏的规格提供更多的计算能力，并且采用不同的中断协议。由此可见，“主板是否包含独立的图形控制器”就成为其它设计参数的关键依赖参数。从系统的角度看，其整体复杂性通常是由一系列关键依赖参数决定的，一旦其中某个设计参数确定，则许多依赖的设计参数也就相应确定。这些关键依赖参数被称作<strong>设计规则</strong>(Design rule)。一个完整的系统设计规则集合应至少包含如下信息:</p>

<ul>
<li><p>模块及其在系统中扮演的角色。</p></li>
<li><p>模块间通信的接口。</p></li>
<li><p>系统集成协议以及测试某个模块是否遵循设计规则。</p></li>
</ul>


<p>通过抽取设计规则可以消除原型模块间的相互依赖，从而形成真正意义的模块。其中，设计规则被称为<strong>显性模块</strong>(Explicit modules)，而其他相互独立的部分被称为<strong>隐性模块</strong>(Implicit modules)。一个模块化后拥有完整设计规则集合的DSM/TSM所下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/modularization.png" alt="Modularization" /></p>

<p>DSM/TSM对于计划设计过程同样具有意义，在上例中，首先进行的是设计规则阶段，然后进入可并行进行的隐性模块设计阶段，最后是系统集成和测试阶段。其中，设计规则作为所有阶段的输入，隐性模块则作为集成和测试阶段的输入。</p>

<h4>模块演化及其模拟</h4>

<p>模块性反映了系统的结构状况。如果一个系统具有嵌套层级结构，每个结构单元对内强关联，对外则相互独立，并且具有良好的功能角色定义——那么该系统就被称作<strong>模块化系统</strong>。值得注意的是，系统结构并非一成不变，一方面是因为某些设计参数间的依赖并不容易在初期就显现出来，另一方面，由于复杂的结构往往导致更高的经济成本，因此在真实场景中更加倾向于寻求结构和经济之间的平衡。为了描述模块的动态特征，可以采用<strong>模块操作符</strong>(Modular operators)，[BC00]提出了六种最基本的模块操作符，后者能够用于表示动态结构的所有可能演化路径:</p>

<ul>
<li><strong>分解</strong>(Splitting)，把现有设计或任务划分成多个模块，在层次结构中这往往意味着产生了新层，例如以下模块化层级设计:</li>
</ul>


<p><img src="http://content.hanyi.name/images/design_diagnosis/dsm_splitting_before.png" alt="Two-level modular design hierarchy" /></p>

<p>上例中描述了A~D四个隐性模块以及一个集成和测试阶段，从模块化的角度来看它们都属于相同层级。当更多设计参数及其依赖显现，并且上下文满足模块化设计需求时，新的设计规则以及相应的接口、测试就会出现，于是就诞生了新的层级，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/dsm_splitting_after.png" alt="Three-level modular design hierarchy" /></p>

<p>在进行分解操作后，新的层级应当只对其所依赖的设计规则负责，而对全局设计规则以及上层的集成和测试部分保持透明，这对设计任务和阶段执行具有重要意义。</p>

<ul>
<li><p><strong>替换</strong>(Substituting)，指替换现有模块设计。替换通常是因为多种设计路径之间存在竞争关系，于是更多受到经济系统因素的驱动。模块的可替换性通常是由分解所决定的，因此分解在此扮演了非常重要的角色。</p></li>
<li><p><strong>增强</strong>(Augmenting)和<strong>排除</strong>(Excluding)，即添加或删除模块，与分解与替换不同的是，增强和排除是针对已经模块化的系统来说的。排除体现了模块化设计的可配置性，也就是说用户可以按需选择模块，这与替换的特性是相当的。增强通常是由于系统中需要引入新特性，为了保证可增强性，需要在设计规则阶段就要考虑这种能力。</p></li>
<li><p><strong>反转</strong>(Inverting)，指创建新的设计规则。我们知道设计规则来自于设计参数，后者广泛存在于隐性模块中。因此有时需要把隐性模块从当前的设计层级中“拉取”上来，使其对更多模块保持可见。</p></li>
<li><p><strong>移植</strong>(Porting)，即把当前模块移植到新系统。某些隐性模块支持从当前系统移植到新系统，那么该模块至少应满足以下条件之一:</p>

<ul>
<li><p>所依赖的设计规则在新系统中存在且不变。</p></li>
<li><p>模块本身不受设计规则的影响。</p></li>
</ul>
</li>
</ul>


<p>采用上述模块操作符可以模拟任何过去、现在和未来所发生的设计变化。例如可以抽取设计演化历史中的连续片段，然后用模块操作符描述每一步的变化。对于进行中乃至未来的设计来说，模块演化则是非确定的，采用公式(j6 X 2) - 1即可计算模块演化的所有可能路径，例如当系统中包含6个模块时，就有93311种演化可能。</p>

<h4>应用DSM分析软件设计</h4>

<p>[NEVD05]首次把DSM用于管理复杂软件系统的<strong>依赖模型</strong>(Dependency model)，具体方法是通过静态分析提取代码的依赖关系，然后在DSM中进行层次结构展示，支持人工选取设计规则，并且检测出违反相关规则的依赖关系。</p>

<p>通过静态分析提取到的大多属于语法依赖，即字面引用所体现的依赖关系。不同编程语言的语法依赖类型存在一定区别，并且语言自身的模块化特性也不尽相同，因此存在多种表示软件依赖模型的方式。一种简单的做法是忽略依赖类型间的差异，选择统一的模块化元素作为DSM的设计参数，例如Java中的类，并且按照元素间存在的引用数量定义依赖强度。下例展示了jEdit v4.2的DSM:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/jedit_dsm.png" alt="DSM for jEdit v4.2" /></p>

<p>当DSM规模较大时，需要支持进一步显示矩阵中的层次结构。尽管许多现代编程语言都在语法上提供了层次化结构的特性(例如包、类、方法等)，这些信息可被直接用于DSM分层。但是，多数情况下软件的层次结构无法满足[BC00]的模块性标准，这种在实际中十分普遍的情况被称作软件结构的<strong>技术债</strong>。为了方便理解和改进现有系统的模块性，业界开发了许多针对DSM的聚类算法，即从DSM中的元素及其依赖出发，通过重新排列元素顺序实现自动聚类，其中有代表性的方法有:</p>

<ul>
<li><p>[JNW73]采用<strong>矩阵分区算法</strong>把初始矩阵划分成若干子矩阵，使后者满足下三角矩阵的特征，从而消除循环依赖。</p>

<p>该算法的基本思路是针对每个元素，首先构建可达性(Reachability)集合R(s)与先导(Antecedent)集合A(s)，前者指从该元素出发能到达的所有元素集合，后者指从非当前元素出发能到达或经过该元素的路径的所有元素集合，以及两者交集R(s)A(s)。算法每次迭代选择满足R(s)A(s) = R(s)的元素集合作为当前矩阵的top-levels，然后将其从剩余元素的集合中删除并重复这一过程，直到剩余元素个数为0。矩阵分区算法的优点是实现简单，能够快速筛选出不存在循环依赖的子矩阵，对DSM分层具有一定意义。但是该方法无法满足更多的模块化特性，例如[BC00]中指出的隐性模块间的相互独立性。</p></li>
<li><p>聚类分析中常用的<strong>启发式算法</strong>同样被用于构建DSM的元素聚类。如果某个系统内存在一系列规模合理且相互独立的子模块，那么这些子模块内的依赖关系一定趋近于DSM对角线，以此推论为基础设计距离惩罚函数作为启发式算法的目标函数[TS94]。与分区算法相比，启发式算法能够实现模块间独立条件下的更优结果，而且实现也比较简单，例如聚类部分采用现有的遗传算法框架[RAC08]。但是，设计软件模块性的目标函数是一项挑战。另外，软件的模块性往往还体现在层次结构方面，这是一般的聚类方法难以同时考虑的。</p></li>
<li><p>由于DSM本质上是有向图，因此可以采用图算法进行DSM分层。[SYG09]是一种基于图算法的DSM层次聚类方法，首先计算DSM的凝聚图(Condensation graph)，然后找出所有出度为0的结点的所有依赖关系路径，再从拥有最长路径的结点出发构建DSM的层次结构。该方法构建出的层次结构一定满足下三角矩阵，同一层的模块间保持相互独立且允许并行开发。其优点在于使用DSM实际反映出软件的层次结构，从而能够进一步诊断软件的设计问题[RYR15]。</p>

<p>如果要根据DSM中依赖关系的强弱寻找更优化的层次结构，则可以采用<strong>图聚类</strong>方法[SS07]，特别是针对有向图聚类[FM13]。[SA14]采用<strong>谱聚类</strong>方法对DSM进行重新聚类，该方法建立在DSM中具有较大特征值的特征向量、特征值、模块层次数以及每层模块数等数量之间的相关性基础上，通过对原始DSM进行奇异值分解、分析和降维，计算每个结点在k维空间的线性表示，最后以结点在k维空间中的距离进行聚类。尽管该方法需要指定k值，但是聚类结果依然能正确反映DSM的层次结构。例如:</p></li>
</ul>


<p><img src="http://content.hanyi.name/images/design_diagnosis/spectral_clustering.png" alt="Spectral clustering" /></p>

<p>其中(a)是原始DSM，(b)&copy;(d)分别表示k=2，k=4，k=8时的谱聚类结果，可以看到随着k值的变化，聚类结果始终能表现出实际DSM的层次结构。</p>

<h3>设计度量(Design metrics)</h3>

<p>设计度量涉及一系列面向软件设计的度量指标，包括针对整体模块性的度量、接口强度和优先级、扇入/扇出、联通度以及可见度等等。值得注意的是，设计的度量结果并不能直接等价于设计质量，通常可以作为支持设计分析结果的辅助证据，帮助定位具体问题并结合具体上下文制定改进计划。</p>

<p><strong>模块度</strong>是一种度量整体模块性的指标。[MAC06]认为可以通过计算DSM中元素间的依赖成本，例如依赖的数量和分布模式等，从而实现模块度的间接计算，并且其中存在两种可能的应用场景:</p>

<ul>
<li><p>比较软件A和软件B的模块性。</p></li>
<li><p>比较软件A在T时刻和T + N时刻的模块性。</p></li>
</ul>


<p>假设DSM的元素数量为n，其中<strong>传播成本</strong>(Propagation cost，Pc)忽略元素所在的位置，假设直接依赖和间接依赖具有同等成本，然后计算所有元素的扇入或扇出数M，则Pc = M / n2。对于整个系统而言，扇入和扇出数是相等的，因此M可以任选其中一种进行计算。<strong>聚集成本</strong>(Clustered cost)把模块内和模块间的依赖进行区别计算，首先指定一个依赖阈值(通常是10%~100%间的数)，并将DSM中被依赖次数超过该阈值的元素计入主控元素，然后根据以下条件计算每项依赖所包含的成本:</p>

<ul>
<li>DependencyCost(i -> j | j is a vertical bus) = d</li>
<li>DependencyCost(i -> j | in same cluster) = d * n^λ</li>
<li>DependencyCost(i -> j | not in same cluster) = d * N^λ
其中d是表示是否存在i -> j依赖的二进制值，n指模块规模，N指DSM规模。λ是自定义参数。</li>
</ul>


<p>除了通过依赖成本计算模块度，另一类方法是直接计算模块度。根据模块从内及外且依赖由强变弱的定义，[GG04]提出了一种通用的模块度计算方法，该方法的前提是DSM中已经包含了精确的模块化信息。当DSM中不包含模块化信息，或者需要直接计算系统的实际依赖复杂度时，可采用<strong>奇异值模块度指数</strong>(Singular Value Modularity Index，SMI)[KO11]。该方法通过对DSM进行奇异值分解，然后计算奇异值的下降率从而表示系统模块度。以下面三种典型的结构模式为例:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/different_patterns.png" alt="Typical structural patterns" /></p>

<p>从模块性来看，单块(Integral)系统的模块性较差，总线(Bus-modular)系统也比较差，模块化系统则相对较好。对这些模式对应的DSM进行奇异值分解，从而得到上面三种结构的奇异值下降模式:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/singular_value_decay_pattern.png" alt="Singular value decay pattern" /></p>

<p>可以看出，单块系统的下降趋势非常陡峭，总线型系统比较陡峭，而模块化系统的下降趋势则相对平滑。基于上述关联关系，可以认为当系统的模块性较差时，奇异值会出现迅速下降的情况(SMI较低)，而模块性较好的系统，奇异值下降则通常比较缓慢(SMI较高)，这种相关性也是上文讨论的谱聚类方法的基本假设。</p>

<h2>结论</h2>

<p>设计诊断包括分析和度量两个方面，其中设计分析主要负责设计的形式化表示，例如本文讨论的DSM工具。在DSM的基础上可以进一步分析和模拟设计演化过程，发现设计缺陷以及优化系统模块性。DSM同样可以用于设计度量，设计度量指标不直接等价于设计质量，但可以指导设计及其改进。除了基本的度量指标外，模块度是度量系统整体模块性的核心，可以用于不同软件之间和相同软件的不同版本之间的模块性评价。</p>

<h2>引用</h2>

<p>BC00, <a href="https://mitpress.mit.edu/books/design-rules-volume-1">Design Rules, Vol. 1: The Power of Modularity</a></p>

<p>NEVD05, <a href="https://lattix.com/dev/files/wp/oopsla05.pdf">Using Dependency Models to Manage Complex Software Architecture</a></p>

<p>JNW73, <a href="https://systemsconcept.org/html/Content/BM_1973%20.pdf">Binary Matrices in System Modeling</a></p>

<p>TS94, <a href="http://web.mit.edu/eppinger/www/pdf/Pimmler_DTM1994.pdf">Integration analysis of product decompositions</a></p>

<p>RAC08, <a href="https://www.tandfonline.com/doi/abs/10.1080/09544820802563226">Systematic module and interface definition using component design structure matrix</a></p>

<p>SS07, <a href="http://www.leonidzhukov.net/hse/2018/sna/papers/GraphClustering_Schaeffer07.pdf">Graph clustering</a></p>

<p>FM13, <a href="https://arxiv.org/pdf/1308.0971.pdf">Clustering and Community Detection in Directed Networks: A Survey</a></p>

<p>SYG09, <a href="https://www.cs.drexel.edu/~yfcai/papers/2009/ASE2009_drh.pdf">Design Rule Hierarchies and Parallelism in Software Development Tasks</a></p>

<p>RYR15, <a href="https://apps.dtic.mil/dtic/tr/fulltext/u2/a621415.pdf">Hotspot Patterns: The Formal Definition and Automatic Detection of Architecture Smells</a></p>

<p>SA14, <a href="https://www.researchgate.net/profile/Andy_Dong/publication/269279676_A_spectral_analysis_software_to_detect_modules_in_a_DSM_Risk_and_change_management_in_complex_systems/links/54dc1a540cf28d3de65ea241.pdf">A Spectral Analysis Software to Detect Modules in a DSM</a></p>

<p>MAC06, <a href="https://pdfs.semanticscholar.org/cbfe/a3d346938dba911239502cc97b282668af71.pdf">Exploring the Structure of Complex Software Designs: An Empirical Study of Open Source and Proprietary Code</a></p>

<p>GG04, <a href="https://proceedings.asmedigitalcollection.asme.org/proceeding.aspx?articleid=1651497">A Comparison of Modular Product Design Methods on Improvement and Iteration</a></p>

<p>KO11, <a href="https://hal.archives-ouvertes.fr/hal-00571207/document">Degree of Modularity in Engineering Systems and Products with Technical and Business Constraints</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(12)]]></title>
    <link href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/"/>
    <updated>2019-04-23T15:59:14-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12</id>
    <content type="html"><![CDATA[<h2>设计原则与代码味道</h2>

<p>在此之前我们已经讨论了<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">面向对象分析与设计</a>、<a href="http://www.hanyi.name/blog/2019/03/10/software-design-and-architecture-notes-10/">领域分析及其模式</a>以及<a href="http://www.hanyi.name/blog/2019/03/29/software-design-and-architecture-notes-11/">设计模式</a>。其中朴素的分析和设计方法具有通用性，但需要长期的实际经验积累，在这一过程中不可避免会付出一定代价。虽然模式提供了可复用的设计元素，但基本都存在特定上下文的限制。尽管仍有新的模式不断被提出，但并不意味着其适用性和局限性已被明确认识。同样是来源于经验，有一些设计知识能适用于绝大多数场景，从而具备更广泛的适用性，这就是本文首先要讨论的<strong>设计原则</strong>。设计原则是来源于实际经验且能够指导一般软件设计的法则，其根本动机是发现并解决软件设计问题。</p>

<p>一般而言，发现软件设计问题的终极方法是以真实需求为基础构建软件，然后收集并分析该软件的开发和运行反馈——显然这种方式的代价过于昂贵。一种退而求其次的办法是构建原型系统，在原型阶段只考虑待验证的核心功能，尽早交付给用户使用并收集相关反馈，该方法使软件设计能够更快响应变化。但是我们知道设计复杂度与问题的复杂度是正相关的，而<strong>易变性</strong>又是软件设计的一个重要特征，因此从原型获得一次反馈的效用会随着时间推移和问题复杂度的增加而逐步降低，于是需要缩短反馈周期以实现频繁反馈。高反馈频率意味着更高的交付效率，然而交付效率的提升又有赖于恰当的工程方法和可扩展的设计。因此，“黑盒”式的问题反馈方法虽然为设计问题发现提供了事实依据，但其效率受软件自身设计问题所制约。另一方面，从最初采集得到反馈到定位具体设计问题，对问题根因可能存在不同解读方式，导致最终结论的有效性也可能面临挑战。</p>

<p>幸运的是软件开发并非孤立问题，软件设计实践中遇到的问题及其解决方案往往具有普遍性。在这些知识的基础上诞生了一系列被普遍认可的、“白盒”式的设计原则，使软件设计中的潜在问题能够被更早发现和解决。应注意，某些设计原则是针对特定上下文，例如Liscov替换原则之于OO，更多则适用于广泛的上下文。本文剩余部分首先介绍设计原则背后的核心设计属性，然后按所适应的场景分组并讨论经典的设计原则，最后讨论相比于设计原则更轻量、更贴近日常编程活动、且涵盖更广泛的经验知识——代码味道及其与设计原则之间由表及里的内在联系。</p>

<h3>设计属性和通用设计原则</h3>

<p>每提起设计原则就会出现许多经典的名字和概念，但诸多原则都表现了相对稳定的设计属性，这些属性往往也是软件设计领域中的核心概念，且在前文大多已经讨论过：</p>

<ul>
<li><p><strong>耦合性</strong>(Coupling)，即模块间依赖的程度，耦合越高则意味着该模块将难以被维护，详见<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">结构化设计方法</a>。</p></li>
<li><p><strong>内聚性</strong>(Cohesion)，即模块具有单一目的性的程度，内聚越高则意味着更好的可理解性和可重用性，详见<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">结构化设计方法</a>。</p></li>
<li><p><strong>正交性</strong>(Orthogonality)，即模块能够独立发生变化的程度，具有正交性的模块意味着更容易应对变化。正交性最初被用于描述一种针对关系数据库的设计原则[DC93]，即对于任意两个相互独立的表，其无损分解后的子集不存在相互重叠的情况，该原则能够帮助发现关系数据库设计存在的数据冗余问题。[AD00]详细解释了正交性在更广泛的软件设计问题中的意义，特别是其在模块化、组件化、分层设计等不同设计方法中的一致性体现。</p></li>
<li><p><strong>信息隐藏性</strong>(Information hiding)，即模块尽力隐藏其实现细节的程度，具有信息隐藏的模块通常意味着更低的耦合性，详见<a href="http://www.hanyi.name/blog/2018/10/03/software-design-and-architecture-notes-3/">模块化编程</a>。</p></li>
</ul>


<p>设计属性为评估设计质量建立了基础，但由于更加强调概念完整性，使其在形式上很难直接与具体的设计问题相关联，于是就出现了数量更多且更具实践意义的设计原则。对于早期提出的、通用的设计原则来说，其可能借鉴自其它领域，例如:</p>

<ul>
<li><p><strong>关注点分离</strong>(Separation of concerns, SoC)，即把注意力集中在某个方面，而非与其它无关方面相混淆。该原则最初来源于Dijkstra对计算领域中科学性思维属性的探索[EWD74]，后来被引入软件设计领域，用于强调软件模块之间应具有尽可能少的特性重叠。</p></li>
<li><p><strong>一次且仅一次</strong>(Once and only once)，也称Don&rsquo;t repeat yourself，DRY。指任何知识都应在系统中有唯一、清晰和权威的表示。该原则适用于许多软件设计领域。例如<strong>单一数据源</strong>(Single source of truth, SSOT)，指系统中的任何数据元素都只有一份，任何其它具有相同定义的数据都是该唯一元素的引用，目的是保证数据的完整性和规范性。</p></li>
<li><p><strong>保持简洁</strong>(Keep it simple stupid, KISS)，简洁意味着易于理解、维护和扩展。KISS旨在强调简洁性对于系统设计的重要性。实际上简洁性还普遍适用于设计、建筑和哲学等其它领域，例如Simplicity is the ultimate sophistication，Brevity is the soul of wit，Less is more，Make simple tasks simple以及Simplify, then add lightness等。</p></li>
</ul>


<h3>实体设计原则</h3>

<p>实体通常指软件中表示模块的单位，例如存在于许多编程范式中的类、模块等元素。针对实体的代表性设计原则如下:</p>

<ul>
<li><p><strong>单一职责</strong>(Single responsibility)，指任意实体应只有一个使其产生变更的原因。这里“产生变更的原因”等价于实体的职责，即要求实体具有尽可能少的变化维度。单一职责原则是表述最简单的设计原则之一，也是最难被遵循的原则。这是因为职责的定位和分离会随着上下文变化而不同，这需要一定的实践经验和分析过程，且缺少直观的量化手段。尽管如此，单一职责原则仍有可能通过遵循其它设计原则而间接实现。</p></li>
<li><p><strong>开放-封闭</strong>(Open closed)，指任意实体应对扩展开放，对修改封闭[BM88]。当程序需要发生变更时，应尽可能通过添加新的代码而非修改已有代码来完成，即增量扩展。频繁发生修改的实体通常是难以被预测和重用的。值得注意的是，对大多数软件设计来说，保证100%对修改封闭是难以实现的。因此实际中通常采用一些策略性封闭方法，例如:</p>

<ul>
<li><p>采用抽象加强显式封闭。如果新的需求导致无法满足对修改封闭，首先应考虑当前的抽象设计，是否需要调整或引入新的抽象从而加强显式封闭特性。</p></li>
<li><p>采用数据驱动实现封闭。当修改可能影响同一抽象层级下的许多实体时，可以考虑采用配置数据驱动代码的方式限制修改的影响范围。该方法能够避免引入额外依赖，同时把修改封闭在尽可能小的范围。</p></li>
</ul>


<p>无论是采用抽象还是数据驱动方法，都有可能引入新的封闭性问题。因此实践中往往需要不断考虑并扩展实体对修改的封闭性。</p></li>
<li><p><strong>Liskov替换</strong>(Liskov substitution)，如果S是T的子类型，那么对T的任意对象的引用可以被直接替换为S的对象，且毋须修改已有代码。Liskov原则中的“替换”不仅是指语法上父子类型相互兼容，进一步子类型应当保留父类型中的不变量(见<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">设计契约</a>)，从而实现在语义层面的兼容。在类型系统中，前述这种更趋严格的子类型定义被称作<strong>行为子类型</strong>(Behavior subtyping)[LB87]。</p></li>
<li><p><strong>接口隔离</strong>(Interface segregation)，指客户端不应被强迫依赖于它们不用的接口。当实体中需要引入一个新的公共方法时，一般会在其接口中声明具有相同签名的方法。如果该抽象层级下对应了多个子类型，但并非所有子类型都需要新声明的方法时，就意味着发生了<strong>接口污染</strong>，这种接口也被称作”胖接口”。依赖于胖接口的客户端代码被迫依赖于许多对它们来说无意义的接口，从而大幅增加了级联变更发生的概率。</p></li>
</ul>


<h3>实体依赖原则</h3>

<p>软件的不同实体之间通常存在着依赖关系，针对实体间依赖的代表性设计原则如下:</p>

<ul>
<li><p><strong>依赖倒置</strong>(Dependency inversion)，指高层实体不应依赖低层实体，两者都应该依赖于抽象;抽象不应依赖细节，细节应依赖抽象。当发生直接依赖的实体之间同时存在层级关系时，应当使其依赖共同的抽象。</p></li>
<li><p><strong>控制反转</strong>(Inversion of control)，指通过框架实现程序的控制流，从而操作客户端代码以实现自定义扩展[MFR05]。传统上软件由客户端代码和所依赖的代码库组成，其中客户端代码扮演了负责控制流的角色。为了实现可扩展性，需要首先建立抽象，框架就是集合了众多抽象设计的代码骨架，其中提供了客户端代码的接口，但控制流就从客户端移交到框架端。该原则也被称作<strong>好莱坞原则</strong>(Hollywood principle)，即<strong>Don&rsquo;t call us, we&rsquo;ll call you</strong>。</p></li>
<li><p><strong>最少知识</strong>(Least knowledge)，也称<strong>迪米特法则</strong>(Law of demeter)[LHR88]。对于任何类C以及C中的方法M，M中发生直接调用的对象的类应符合以下两种情形之一:</p>

<ul>
<li><p>方法M的参数对象所属的类(参数对象可以是M中创建的对象、M中发生的函数调用所创建的对象、或者是M中引用的全局变量对象，包括C)。</p></li>
<li><p>类C中任何实例变量对象所属的类。</p></li>
</ul>


<p>应用最少知识原则能够降低系统本身和对其修改的复杂度。该原则的另一个名字“迪米特”是最初应用该项原则所设计的OO系统[LHR88]。</p></li>
</ul>


<h3>包设计原则</h3>

<p>与Java的package和C++的namespace等关键字不同，包在设计原则的上下文中是指独立的可交付物(有时也被称作<strong>组件</strong>)，例如jar包和dll文件。包是常见于大规模的软件系统中的概念，这里的“规模”没有具体的量化指标，可能是指代码行数、团队大小以及系统复杂度等。针对包的代表性设计原则如下:</p>

<ul>
<li><p><strong>重用-发布等价</strong>(Reuse-Release equivalency)，指可重用代码的粒度不应小于代码的可发布粒度。我们知道可重用性是OOD的一个重要属性，可重用的代码应遵循如下原则:</p>

<ul>
<li><p>可以被独立开发、维护、测试、分发。</p></li>
<li><p>具体实现对外部隐藏，只通过<strong>发布接口</strong>(Published Interface)对外公开[MFR02]。</p></li>
</ul>


<p>违反上述原则的代码重用通常都具有副作用，例如<strong>代码复制</strong>(Code clone)、破坏代码封装导致的<strong>强耦合</strong>等。针对这些问题，在可发布粒度上实现代码重用是一种有效的解决办法，该方法通过封装和可追踪使代码具有更好的可重用性，包就是实现这种可发布粒度的有效途径。</p></li>
<li><p><strong>共同封闭</strong>(Common closure)，指包中的不同实体应当封闭于相似的修改原因。根据前文对开放-封闭原则的讨论，实际中始终存在无法令实体对其封闭的修改。而如果不同实体具有共同的修改，那么应使它们属于同一个包。也就是说，同类型的修改应尽可能被限制于最少数量的包中。</p></li>
<li><p><strong>共同重用</strong>(Common reuse)，指包中的不同实体应当具有被共同使用的倾向。一般情况下，如果某些实体之间存在抽象层级的协作关系，那么它们应属于同一个包。否则，仅针对个别实体的修改可能引起跨包修改，从而存在较高风险。与共同封闭原则类似，该原则有利于加强包的可维护性，这在大多数上下文中比可重用性更加重要。</p></li>
</ul>


<h3>包依赖原则</h3>

<p>与实体间存在依赖关系类似，包之间也存在依赖关系，针对包之间依赖的代表性设计原则如下:</p>

<ul>
<li><p><strong>无环依赖</strong>(Acyclic dependencies)，指包之间的依赖关系图应是一个有向无环图(DAG)。作为可发布的软件单元，不同包之间不可避免着存在着依赖关系。如果软件系统中存在包的循环依赖关系，即环形依赖，则可能导致以下问题:</p>

<ul>
<li><p>依赖环中的所有包存在共同修改的可能，破坏了可独立发布的属性。</p></li>
<li><p>包可能间接依赖于大量其它包，从而降低可维护性。</p></li>
</ul>


<p>一种解决循环依赖的方法是应用依赖倒置原则，提取依赖的共同抽象。另一种方法是把现有包中被依赖的部分抽取出来组成新的包。</p></li>
<li><p><strong>稳定依赖</strong>(Stable dependencies)，指包之间应遵循更加稳定的依赖方向。如果一个模块是易变的，那么对该模块的依赖在很大程度上也是易变的，这种<strong>易变性</strong>(Volatility)会沿着依赖的方向传递，从而影响整个系统的可维护性。然而由于软件的易变性可能存在许多影响因子，不同影响因子所导致的后果也不尽相同。其中<strong>稳定性</strong>(Stability)被用于描述模块修改的难易程度，即当模块越难以被修改即越稳定。Uncle Bob提出了一种稳定性的度量指标，可以用如下形式计算:</p>

<p>Ca: 传入耦合(Afferent coupling)，依赖于当前包内实体的外部实体数量。</p>

<p>Ce: 传出耦合(Efferent coupling)，依赖于外部实体的包内实体数量。</p>

<p>I: 不稳定系数(Instability)，且I = Ce ÷ (Ca + Ce)，则I范围是[0,1]，当I=0时当前包最稳定，I=1时则最不稳定。</p>

<p>因此，被依赖的包应具有比依赖包更大的I值，即满足稳定依赖原则。</p></li>
<li><p><strong>稳定抽象</strong>(Stable abstractions)，指稳定性越高的包也应越抽象，反之则越具体。由于高度稳定的包往往难以被修改，因此其应尽可能抽象，从而使系统的易变部分始终保持在不稳定包的具体实现中。包的抽象程度被称作<strong>抽象性</strong>，与稳定性相同，Uncle Bob提出了抽象性A的计算方式:</p>

<p>A = 抽象实体数 ÷ 实体总数。</p></li>
</ul>


<p>根据稳定性和抽象性的定义，理想情况下的软件系统应呈现类似如下线性关系:</p>

<p><img src="http://content.hanyi.name/images/design_principles/abstraction_instability.png" alt="Abstraction-Instability graph" /></p>

<p>也就是说，当已知某个包的稳定性和抽象性度量时，我们就可以进一步计算它们在上述坐标中偏离理想值的程度，用距离D表示这种程度，从而有:</p>

<p>D = |(A + I - 1) ÷ √2|</p>

<p>在实际中能够通过计算包的D值，从而决定包的设计合理性，D值越大的包应优先被关注和改进。</p>

<h3>代码味道</h3>

<p>相比于设计原则，代码味道是一种更加轻量的、被用于识别设计问题的方法。如果把具有良好设计的代码视作是干净无味的话，那么代码味道则可被用于发现那些“显而易见”的“异常”代码。“味道”一词并不是一个正式的概念，Martin Fowler认为代码味道应具备三个基本特征[MFR06]:</p>

<ul>
<li><p>代码味道应是易于被察觉的。</p></li>
<li><p>代码味道不一定表示代码中存在设计问题，即使存在“问题”，也有可能是因为设计权衡的结果。</p></li>
<li><p>代码味道非常易于被程序员理解和掌握，基于代码异味的重构使新手程序员也有机会持续改进设计，即使在缺少对深层次设计原则理解和相关经验的情况下。</p></li>
</ul>


<p>与设计原则类似，按照作用层级可以把代码异味划分为方法、实体(类和模块)以及通用三个类别。</p>

<ul>
<li><p>具有代表性的方法级代码味道包括:</p>

<ul>
<li><strong>长方法</strong>(Long function)和<strong>长参数列表</strong>(Long parameter list)，不仅导致代码难于理解，还可能违反单一职责原则。</li>
<li><strong>重复switch</strong>(Repeated switches)，尽管switch语句具有易于理解的结构，但可能违反开放-封闭原则，特别是当相似结构的switch语句重复出现时，会相应存在多处需要同时被修改的代码。</li>
<li><strong>循环</strong>(Loops)，随着内循环和管道式编程的普及，常规的外循环语句由于相对复杂的结构已经成为循环计算的备选方案。</li>
<li><strong>特性依恋</strong>(Feature envy)，指实体中的某个方法过度依赖了其它实体中的数据或方法，进而可能违反了关注点分离原则。</li>
</ul>
</li>
<li><p>具有代表性的实体级代码味道包括:</p>

<ul>
<li><strong>临时值域</strong>(Temporary field)，指实体中仅在部分情况下有效的属性，这可能违反单一职责原则和关注点分离原则。</li>
<li><strong>消息链</strong>(Message chains)，如果存在对象的方法的链式调用，且每个阶段的调用都作用于不同对象，这种消息链可能违反了最少知识原则。</li>
<li><strong>中间人</strong>(Middle man)，指缺少实际意义的代理方法。尽管封装被作为是OO的重要特征，但某些时候存在不合理的封装，例如一些实体中存在的代理方法，其作用仅是分离了真正的调用对象和被调用对象，这可能违反了单一职责原则和关注点分离原则。</li>
<li><strong>内幕交易</strong>(Insider trading)，指实体间发生数据处理和相互传递的现象。数据交易可能会引起过度耦合，但有时很难完全避免，因此需要尽可能减少此类现象出现的频率。</li>
<li><strong>过大的类</strong>(Large class)，指一些包含了大量属性的类。这可能违反了单一职责原则和关注点分离原则。</li>
<li><strong>异曲同工的类</strong>(Alternative classes with different interfaces)，指某些具有相同类型特性的类，因其具有不同接口而无法利用OO的多态性。</li>
<li><strong>数据类</strong>(Data class)，指只包含可被外部读写的属性的类，导致有关该类的操作散布在不同的类中，这可能违反单一职责原则。</li>
<li><strong>被拒绝的馈赠</strong>(Refused bequest)，指在继承关系中，子类拒绝或忽略了父类中的某些方法或数据，这可能违反接口隔离原则。一种解决办法是创建父类的兄弟类，使方法和数据相分离——这只在具有良好抽象意义的情况下有效，否则可能会引入更多复杂度，反而得不偿失。如果现有抽象更加稳定，而“被拒绝”的元素又足以影响可维护性，更有效的办法是抽取新的类，并采用对象代理关系替换原有继承关系。</li>
</ul>
</li>
<li><p>具有代表性的通用代码味道包括:</p>

<ul>
<li><strong>数据泥团</strong>(Data clumps)，指某些经常同时出现的数据组合，其出现场景可能包括不同类中的属性、许多方法签名的参数等。通常可以采用创建新的类表示这些数据组合。</li>
<li><strong>重复代码</strong>(Duplicated code)，指相同或相似的代码结构在程序中多次出现的现象。最易被识别的重复代码通常发生在同一个类或拥有继承关系的多个类中，也比较容易被消除。除此之外，对重复代码的识别和解决都可能需要进一步的设计权衡。</li>
<li><strong>全局数据</strong>(Global data)，特别是可变的全局数据，即全局变量。我们已经多次强调了这种共享可变状态的代码可能导致潜在的质量和可维护性问题。实际上，即使是非共享状态的<strong>可变数据</strong>(Mutable data)，依然可能导致代码质量问题。</li>
<li><strong>发散式变化</strong>(Divergent change)，即某个模块可能会由于不同原因而导致不同方式的修改，违反了单一职责原则。如果修改原因只有一种，但引起了其它模块发生多次级联修改，则称作<strong>霰弹式修改</strong>(Shotgun surgery)。</li>
<li><strong>基本类型偏执</strong>(Primitive obsession)，指采用基本类型表示某些复杂数据类型，而非创建独立的类，这可能导致大量的重复代码。</li>
<li><strong>懒元素</strong>(Lazy element)，指某些设计元素(例如类、实体)只有非常简单的功能，甚至使用一、两行代码就能清楚表现该元素的特性，那么他们就没有单独存在的必要。与之表现形式相反，但具有统一思想的<strong>夸夸其谈未来性</strong>(Speculative generality)，或者称作<strong>大设计先行</strong>(Big design up front, BDUF)，则表示发生了过度设计。</li>
<li><strong>过高的圈复杂度</strong>(High cyclomatic complexity)，指代码中存在过度复杂的控制流图。圈复杂度通常用代码中的线性逻辑路径数进行表示。假设用N表示代码中的基本区块(指不包含任何控制分支的连续代码片段)数，E表示连接基本区块的边数，P表示连通子图数，那么圈复杂度M可用公式M = E - N + 2P进行计算。过高的圈复杂度可能意味着过度复杂的逻辑或缺少结构性的代码。</li>
<li><strong>神秘命名</strong>(Mysterious name)和<strong>注释</strong>(Comments)，这两种代码味道经常同时出现，因为合理的命名更加表意，也就降低了额外注释的必要性。当然在某些时候再合理的命名也无法表达某些上下文时，注释则是必要的补充。</li>
</ul>
</li>
</ul>


<p>尽管前述大部分的代码味道都有“程度”的概念，使其具体的应用仍然依赖实际经验，但仍然有一些可以遵循的规则。例如，针对重复代码的<strong>事不过三规则</strong>(Rule of Three)，这里虽然中文成语中的数量是虚指，但具体应用时可以作为实际阈值，也就是说当重复代码出现三次时，就应考虑采取相应解决方案了。当然这种规则只能作为初步判断条件，进一步仍然需要结合设计原则进行恰当分析。</p>

<h2>结论</h2>

<p>为了发现和定位软件设计中存在的问题，人们在实践中总结出了一系列具有普遍意义的设计原则。看似纷繁复杂的设计原则其实体现了一致的设计属性，并在长期的设计分析和验证过程中不断得到认可。为了进一步缩短软件设计的反馈周期，在代码编写活动中就可以通过识别代码味道尽早发现潜在的设计问题，并通过持续重构保证软件的设计质量。</p>

<h2>引用</h2>

<p>DC93, <a href="http://web.archive.org/web/20100224075429/http://www.dbdebunk.com/page/page/622331.htm">The Principle of Orthogonal Design</a></p>

<p>AD00, <a href="https://www.nceclusters.no/globalassets/filer/nce/diverse/the-pragmatic-programmer.pdf">The Pragmatic Programmer: From Journeyman to Master</a></p>

<p>EWD74, <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html">On the role of scientific thought</a></p>

<p>BM88, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/POO-2016-01/documentos/Object%20Oriented%20Software%20Construction-Meyer.pdf">Object Oriented Software Construction</a></p>

<p>LB87, <a href="https://klevas.mif.vu.lt/~plukas/resources/OODPrinciples/Liskov1987.pdf">Data Abstraction and Hierarchy</a></p>

<p>LHR88, <a href="https://www2.ccs.neu.edu/research/demeter/papers/law-of-demeter/oopsla88-law-of-demeter.pdf">Object-Oriented Programming: An Objective Sense of Style</a></p>

<p>MFR00, <a href="https://martinfowler.com/books/refactoring.html">Refactoring: Improving the Design of Existing Code</a></p>

<p>MFR02, <a href="https://martinfowler.com/bliki/PublishedInterface.html">Published Interface</a></p>

<p>MFR05, <a href="https://martinfowler.com/bliki/InversionOfControl.html">Inversion Of Control</a></p>

<p>MFR06, <a href="https://martinfowler.com/bliki/CodeSmell.html">CodeSmell</a></p>
]]></content>
  </entry>
  
</feed>
