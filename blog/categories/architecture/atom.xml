<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Wing of Dream 梦境之翼]]></title>
  <link href="http://www.hanyi.name/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://www.hanyi.name/"/>
  <updated>2019-06-08T13:16:02-04:00</updated>
  <id>http://www.hanyi.name/</id>
  <author>
    <name><![CDATA[Han Yi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(15)]]></title>
    <link href="http://www.hanyi.name/blog/2019/06/08/software-design-and-architecture-notes-15/"/>
    <updated>2019-06-08T13:14:00-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/06/08/software-design-and-architecture-notes-15</id>
    <content type="html"><![CDATA[<h2>软件架构说什么？</h2>

<p><strong>架构</strong>(Architecture)一词源自建筑领域，尽管看起来与软件设计毫无关联，但人们从上世纪60年代起就注意到两者的相似性[PHJ06]，并从结构和工程等方面大量借鉴了这个古老的学科，软件设计也因此获益匪浅[GHJV95]。当然不仅是软件，这个词也被其它领域广泛借鉴，例如作为计算机基础的<strong>体系结构</strong>(Computer architecture)，后者主要指计算机的物理结构或者CPU指令集。又比如<strong>企业架构</strong>(Enterprise architecture)、<strong>解决方案架构</strong>(Solution architecture)或者<strong>信息架构</strong>(Information architecture)等，则是表示针对各自问题域的专业性实践集合。</p>

<p>虽然架构与<strong>设计</strong>同属于本系列的主题之一，但迄今为止我们都很少提及。一方面是因为，作为诞生于上世纪90年代的buzz word，软件架构是在软件设计的基础上发展而来的，前者继承了后者的许多核心思想，例如模块化、原则、模式等，逐渐形成了更加庞大的体系。另一方面，架构一词如今具有极其丰富的含义，以至于可能达到阻碍交流的地步，因此确有必要首先对部分概念予以澄清。此外，除非特别说明，本系列文章中的架构均指软件架构。</p>

<h3>定义和解释</h3>

<p><em>架构是指一个系统在其所在环境中的基本概念和属性，这体现为系统的元素、关系及其设计和演进的原则。</em></p>

<p>虽然这是ISO/IEC 42010对架构的正式定义，另一种USP(Unique selling proposition)定义则更详细地解释了这一点:</p>

<p><em>架构是一系列重要的决策，涉及描述软件系统的组织、确定结构化元素及其接口、确定元素在协作中的特定行为、指导结构和行为元素通过组合逐渐形成较大子系统的风格(涉及元素、接口、协作和组织等)。此外还要考虑用途、功能、性能、适应力、可重用性、可理解性、经济性、技术限制及其权衡、美学等因素。</em></p>

<p>以上定义明确指出了架构的<strong>表示</strong>(Representation)、<strong>质量属性</strong>(Quality attribute)以及<strong>风格</strong>(Style)等核心内容。此外，针对已有的架构方案，有时需要进行专门的<strong>架构评估</strong>(Architecture evaluation)，从而提前发现问题并控制潜在风险。本文剩余部分将作进一步讨论。</p>

<h3>架构表示</h3>

<p>由于架构本身的丰富性，采用适当方法描述架构就变得非常重要，一种基本的架构描述工具是<strong>架构视图</strong>(Architecture view)，其被用于表示架构在解决特定问题时所体现的结构化信息。由于完整的架构一般会涉及众多干系人，在单一视图中无法清楚表示所有信息，因此为了进一步在视图中区分来自不同干系人的诉求，采用<strong>架构视点</strong>(Architecture viewpoint)聚焦于某一类架构决策，并采用特定的标记和建模技术建立对应的架构视图。常见的架构视点有功能、逻辑、数据、模块、组件-连接器、需求、实现、并发、性能、安全、部署、用户使用及反馈等，由此可见其对应的架构视图也就非常丰富。</p>

<p>以组件-连接器类型的架构视图为例，该架构视图定义了系统中的可计算组件及其交互方式，其中组件是指可独立运行、且支持交互或存储数据的软件单元，连接器则被用于描述组件之间的交互机制。在构建组件-连接器视图的过程中，组件可以根据承担功能、可重用性、硬件单元，甚至团队的技术背景、康威定律以及产品演化路径等方式定义。同时，组件还需要描述其对外提供交互的接口(API)，包括访问端口、参数以及参数类型。然后根据组件间交互的需求，如同步、异步、延迟、吞吐量等确定连接器的类型和通信协议。连接器两端的组件分别被称为调用者和被调用者，组件与连接器之间通常需要相关配置以确定关联信息。</p>

<h4>架构描述语言</h4>

<p>通常，架构视图是采用<strong>架构描述语言</strong>(Architecture description languages，ADL)具体实现的，如AADL、Wright、ACME、xADL等专门面向软件架构的语言。同时也可以采用通用的建模语言，例如UML，实际上后者在工业界更加流行。架构视图和ADL共同组成了架构表示的基本方法，但仍不足以有效应对架构的复杂性。这是因为在真实场景中架构视点可能是非常多的，架构需要从核心视点出发逐步完善，因此需要进一步参考适当的<strong>架构框架</strong>(Architecture framework)。</p>

<h4>架构框架</h4>

<p>架构框架是指在特定应用领域或干系人社区中，创建、解释、分析和使用架构表示的通用实践集合。一种经典的架构框架是“4+1架构视图模型”[PK95]，其基本思想是需要采用若干个相互平行、且具有不同架构视点的架构视图，具体来说就是<strong>逻辑视图</strong>、<strong>进程视图</strong>、<strong>开发视图</strong>和<strong>物理视图</strong>等四种主要架构视图，以及相应的<strong>用例和场景</strong>说明，从而达到表示完整架构的目的。</p>

<ul>
<li><p>逻辑视图，即把系统按照功能、通信、行为等进行结构化分解的结果，描述系统的静态信息。具体可以采用UML中的类图或状态图实现。</p></li>
<li><p>进程视图，即对系统中进程和线程的通信、执行过程进行描述，即系统的动态运行信息。具体可以采用UML中的部署图和活动图实现。</p></li>
<li><p>开发视图，也称作<strong>实现视图</strong>，用于描述软件开发过程中的软件结构，例如组件、包、类、子系统、代码库、文件等。具体可采用UML的组件图或包图实现。</p></li>
<li><p>物理视图，描述系统运行的硬件资源结构，及其与系统进程之间的映射关系。具体可采用UML中的部署图、时序图或协作图实现。</p></li>
<li><p>用例和场景，也称作<strong>用例视图</strong>，即从少量核心用例出发，描述系统中对象间、进程间的交互顺序。该视图主要用于构建可验证的架构原型，从而对当前架构进行测试。</p></li>
</ul>


<p>根据上述5种架构视图，4+1架构视图模型能够建立一个核心的软件架构表示。然而从架构对整个软件工程的影响角度来说，架构框架作为架构表示的核心，往往还需要更多架构视点的支持，这与具体上下文密切相关，特别是接下来要讨论的质量属性。</p>

<h3>质量属性</h3>

<p>除了满足功能需求，架构还需要考虑系统的非功能需求(二者相互正交)，后者也被称作系统的质量属性，例如性能、可靠性、资源利用率、可用性、精确性等。与功能需求最显著的不同在于，质量属性往往是相对概念，一般表现为某种程度，且具备多种领域背景。正因为如此，质量属性大大提升了架构的复杂性，也是除了功能需求变化外另一个可能引起架构变化的重要原因。</p>

<p>ISO/IEC 25010对软件质量进行了明确定义，其中功能性表示系统功能的完整性、正确性、适当性与合规性，此外还包含7种非功能属性以及对应的子属性:</p>

<ul>
<li><p>可靠性，指系统在特定时间和条件下维持当前性能的能力，包括成熟度、容错性、可恢复下、可用性等指标。</p></li>
<li><p>易用性，指个体或群体在使用系统时的难易程度。包括易理解性、易学习性、易操作性、界面美观性、操作错误保护以及可访问性。</p></li>
<li><p>高效性，指系统在特定条件下，资源使用量与软件性能之间的关系。包括耗时、资源利用率、容量等指标。</p></li>
<li><p>兼容性，指系统在特定的软、硬件环境中能够正常运行的能力。包括共存性、互操作性等指标。</p></li>
<li><p>安全性，指系统保护数据和执行正当行为的能力。包括保密性、完整性、非拒绝性、可审计性以及可验证性。</p></li>
<li><p>可维护性，指系统在需要做出特定修改时所花费的成本大小。包括可分析性、可改变性、稳定性、可测试性、模块性、可重用性以及可修改性。</p></li>
<li><p>可移植性，指系统迁移到其它环境的能力。包括可适应性、可安装性、可替换性等。</p></li>
</ul>


<p>值得一提的是，经验研究表明并非所有的非功能需求都有同等机会引发架构变化[JAD16]，尽管它们可能拥有相同的重要性。但在进行架构相关决策时，依然不可避免地要考虑功能以及多种质量属性，这就导致从零开始设计架构具有极高的成本和风险。因此绝大多数架构设计活动实际上是遵循着经受实践检验的经验，即下面要讨论的<strong>架构风格</strong>。</p>

<h3>架构风格</h3>

<p>架构风格是指一系列满足功能和特定质量属性的设计决策与约束子集[RNE09]，其意义在于:</p>

<ul>
<li><p>提供可重用的领域和工程知识，特别是相同领域或产品族中与应用无关的设计规则和决策，避免重新发明轮子。</p></li>
<li><p>阻止架构腐化和偏离，帮助未来开发人员在不损害基本架构原则的基础上扩展系统。</p></li>
<li><p>根据质量需求指导设计。</p></li>
</ul>


<p>以经典的<strong>管道-过滤器</strong>架构为例，在该架构风格中，所有的过滤器都通过两个字节流“输入”和“输出”进行通信，这样就保证了任何过滤器都能够互相连接——即满足兼容性。另外，过滤器之间可以一次只传递部分数据，这样就能够尽可能提高过滤器之间并行计算的能力，从而提高系统效率。除此之外，应用中常见的架构风格还包括但不限于:</p>

<ul>
<li><p>客户端-服务器(C/S)架构。</p></li>
<li><p>分层(三层或N层)架构。</p></li>
<li><p>点对点(Peer-to-peer)架构。</p></li>
<li><p>事件驱动(Event-driven)架构，也称隐式调用架构。</p></li>
<li><p>表述性状态转移(REST)架构。</p></li>
<li><p>面向服务架构(SOA)。</p></li>
<li><p>领域驱动设计(DDD)。</p></li>
</ul>


<p>限于篇幅本文无法详细讨论每种架构风格。而事实上，在实际软件开发过程中架构风格往往是在最初就确定的，因此可被视为架构设计的设计规则。另外，大部分情况下整个系统会拥有多种架构风格，从而满足各种质量属性需求。</p>

<h3>架构评估</h3>

<p>由于架构的重要性，团队通常需要对已有的架构方案进行评估。架构权衡分析(Architecture tradeoff analysis method)是一种架构评估方法，采用该方法首先需要建立一个专门的架构评审小组，该小组应至少包含所有的干系人。启动评估后，首先应确保所有参与者熟悉评估流程以及业务背景。向所有评估者展示更高层次的系统架构，包括所采用的架构风格。然后通过<strong>质量属性树</strong>描述系统所要特别关注的质量属性，并且为每个所要满足的属性提供一个具体场景。一个质量属性树的例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/architecture/quality_tree.png" alt="Quality attribute tree" /></p>

<p>把所有场景按照优先级进行排序，然后逐一分析当前架构对该场景的适用性，根据相关反馈进行调整。最后在更大范围的干系人组织中分享当前架构知识。</p>

<h2>结论</h2>

<p>软件架构包含三个核心问题，分别是架构表示、质量属性和架构风格。架构表示是架构得以沟通并完善的重要途径，在架构设计的过程中不仅要考虑功能需求，还要考虑非功能需求(质量属性)，不同的架构风格在应对特定质量属性方面具有优势，因此真实场景中需要组合架构风格以满足来自不同干系人的需求。</p>

<h2>引用</h2>

<p>PHJ06, <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1605175">The Past, Present, and Future of Software Architecture</a></p>

<p>GHJV95, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/DSBP-2018-01/recursos/Erich%20Gamma,%20Richard%20Helm,%20Ralph%20Johnson,%20John%20M.%20Vlissides-Design%20Patterns_%20Elements%20of%20Reusable%20Object-Oriented%20Software%20%20-Addison-Wesley%20Professional%20%281994%29.pdf">Design Patterns: Elements of Reusable Object-Oriented Software</a></p>

<p>PK95, <a href="https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf">Architectural Blueprints—The “4+1” View
Model of Software Architecture</a></p>

<p>RNE09, <a href="https://www.softwarearchitecturebook.com/">Software Architecture: Foundations, Theory, and Practice</a></p>

<p>JAD16, <a href="http://www.aset.tu-berlin.de/fileadmin/fg331/Publications/ICSE16.pdf">Are “Non-functional” Requirements really Non-functional?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(14)]]></title>
    <link href="http://www.hanyi.name/blog/2019/06/01/software-design-and-architecture-notes-14/"/>
    <updated>2019-06-01T23:31:49-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/06/01/software-design-and-architecture-notes-14</id>
    <content type="html"><![CDATA[<h2>敏捷软件设计</h2>

<p>早期的软件开发方法源自传统制造业和建筑业，即按照需求、分析、设计、开发、测试、运营等阶段顺序执行。这种线性的软件开发过程被称作<strong>瀑布模型</strong>(Waterfall)。瀑布模型在上世纪70年代逐渐发展成熟，成为软件开发方法的事实标准。随着互联网的出现，软件工业迈入飞速发展，频繁变更的需求和快速更替的技术使瀑布模型遭遇了空前挑战。于是，通过从先进制造业汲取经验，行业一线的职业程序员们开始调整原有方法，90年代先后诞生了<strong>统一过程</strong>(Unified process)、<strong>Scrum</strong>、<strong>极限编程</strong>(Extreme programming)等轻量级软件开发方法。2001年，程序员们从这些方法的核心思想中提炼出了著名的<strong>敏捷宣言</strong>，由此敏捷成为前述一系列软件开发方法的代名词。时至今日，对于需求明确并且依赖成熟技术的软件开发活动来说，严谨且可靠的瀑布模型仍然占有一席之地。敏捷思想则在自互联网时代开启的一系列新兴领域中更受欢迎，也更具备发展空间。</p>

<p>敏捷对软件设计产生了重大影响，正如Martin Fowler所指出的，极限编程不仅宣告了Big Design Up Front的终结，还严重影响了一批热门的技术实践例如UML、框架构建、设计模式[MFL00]。然而软件设计并未因敏捷而消失，敏捷也不意味着无设计或设计灾难，为了与传统瀑布模型的<strong>计划设计</strong>(Planned design)进行区别，敏捷设计被描述为<strong>演进式设计</strong>(Evolutionary design)、<strong>持续设计</strong>(Continuous design)或<strong>浮现式设计</strong>(Emergent design)，或许这些名词有时夹带了浓厚的宣传意味，但是不可否认分析与设计、原则与模式依然是敏捷软件设计的核心，后者的主要特点在于更加强调轻量化的敏捷设计实践。这往往意味着:</p>

<ul>
<li><p>强调价值交付，交付价值是推动整个软件工业发展的重要经济基础，因此价值应当始终是软件开发的优先选项。</p></li>
<li><p>强调团队责任，而不是把职责局限于分析师、设计师、XX师等不同工种，从而减少<strong>单点失败</strong>(Single point failure)。</p></li>
<li><p>强调快速反馈，无论是测试驱动开发还是持续集成，通过尽可能的自动化实现软件设计质量的实时监控，且应保证快速响应。</p></li>
</ul>


<p>具备代表性的实践有面向设计一致性的<a href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/"><strong>代码味道</strong></a>和<strong>重构</strong>、面向功能一致性的<strong>测试驱动开发</strong>(Test driven development)以及面向团队一致性的<strong>结对编程</strong>(Pair programming)、<strong>代码评审</strong>(Code review)和<strong>持续集成</strong>(Continuous integration)等。敏捷正是通过前述一系列实践，从而避免从BDUF走向另一个设计熵增的极端。本文剩余部分将进一步讨论价值交付、团队责任和快速反馈在敏捷软件设计活动中的具体体现。</p>

<h3>价值交付：扩展—收缩模式(Expand-Contract Pattern)</h3>

<p>应对变化是敏捷软件设计的永恒主题。当现有设计发生变化时，这种变化可能通过接口向模块外传递，从而影响更多其它模块。特别对于<a href="https://martinfowler.com/bliki/PublishedInterface.html">公共接口</a>来说，变更现有设计会产生较高成本，进而影响交付的价值。[MFL14]讨论了一种扩展—收缩模式，其核心思想是在变更设计的同时保持向后兼容，当新设计产生的价值得到验证后再移除旧设计。例如下列代码:</p>

<pre><code>class WindowFactory {

    public Window createWindow(String title, int x, int y, int width, int height) {
        ...
    }
}
</code></pre>

<p>该例中的抽象工厂类WindowFactory能够创建不同类型的Window，参数列表接受窗口名、位置和尺寸等信息，其中位置和尺寸能够使用Rect对象代替，从而有:</p>

<pre><code>class WindowFactory {

    public Window createWindow(String title, Rect rect) {
        ...
    }
}
</code></pre>

<p>如果该接口属于公共接口，那么所有客户端组件都必须被动修改，否则将无法正常工作。更加合理的做法是首先保留原接口(<strong>扩展</strong>):</p>

<pre><code>class WindowFactory {

    public Window createWindow(String title, int x, int y, int width, int height) {
        ...
    }

    public Window createWindow(String title, Rect rect) {
        ...
    }
}
</code></pre>

<p>当客户端组件迁移完成后，再移除失效的接口(<strong>收缩</strong>)。通过采用扩展—收缩模式，能够有效控制设计变更对交付价值的影响，这也是敏捷软件设计的核心目标之一。</p>

<p>同样的模式还被应用于演进式数据库设计[MFL16]，特别是当数据模式发生破坏性修改时(修改表名、列名等操作)，需要保证在迁移阶段同时支持新旧两种数据访问模式。例如当修改表名时，可以通过创建与旧表名相同的视图提供向后支持。当设计需要修改列名时，可以先创建新的列，然后通过触发器实现新旧两列的同步，直至迁移阶段结束再清理旧模式。在真实场景中应根据数据库类型、应用类型等相关上下文决定具体实现，但设计思想仍然遵循扩展—收缩模式。</p>

<h3>团队责任：模型风暴(Model Storming)</h3>

<p>模型风暴是一种即时建模活动，其目的是把设计责任赋予团队而非个人。理论上说模型风暴可以发生在敏捷软件开发过程的任何时间，但通常是由一名用户故事的所有者(Story owner)在进入开发阶段前发起。首先由所有者确保理解所要解决的问题，然后集合若干团队成员(通常是2~3人)进行站立会议(Stand session)。在所有者介绍完背景并确保所有人理解上下文后，团队开始在一个共享建模工具上探索设计方案，直至大家充分理解并达成一致，会议结束(通常是5~10分钟)。</p>

<p>模型风暴有两种应用场景——分析和设计。分析模型风暴主要是帮助团队理解需求，这时应尽可能集合相关干系人(产品负责人、业务分析师、设计师、质量分析师和开发等)，然后通过绘制草图帮助所有人理解原始需求，并澄清相关问题。这一阶段的关键在于鼓励各种干系人参与建模过程，于是应尽量采用包容性建模(Inclusive modeling)及相关工具，避免过度专业和复杂的工具应用，从而促进沟通。常见的包容性工具有白板、索引卡、便利贴、白板纸等。</p>

<p>设计模型风暴是在编写代码前由若干开发人员共同完成的设计活动。根据开发人员的技术背景，建模过程可以采用<a href="http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8/">UML</a>、<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">类职责协作卡</a>(CRC)、<a href="http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5/">数据流程图</a>或一般流程图等包容性工具。具体过程可以参考<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">前文</a>介绍的CRC及其在协作式OOD中的应用。</p>

<p>模型风暴能够促进设计知识在团队中进行传递，从而有效控制软件设计的单点失败风险。</p>

<h3>快速反馈：设计监测(Design Monitoring)</h3>

<p>快速反馈主要是指能够快速验证当前设计的完整性，并在发现设计缺陷时提供警报，这往往需要依赖专业面向软件设计的静态代码分析工具来完成。通常的做法是把相关工具集成进现有的持续集成过程，并作为某种质量检测报告输出，从而实现设计监测。设计监测工具主要通过分析软件结构中的依赖热点(Hotspot)进行，一般有两种途径分析这些热点——<strong>度量</strong>和<strong>模式</strong>。</p>

<p>度量是通过对软件结构中的实体及其依赖关系进行量化分析，从而反映软件模块化的程度。一种可量化的设计原则是<a href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/">包依赖原则</a>，在此基础上的经典Java开源实现即JDepend(现基本停止维护)，该工具以Java语言的包为单位，分别计算每个包的类数量(TC)、具体类数量(CC)、抽象类数量(AC)、传入耦合(Ca)、传出耦合(Ce)、抽象系数(A)、不稳定性(I)、偏离距离(D)，每种度量的具体定义本文不再赘述。</p>

<p>模式主要是指检测依赖中的反模式，后者主要是违反设计原则的实际情况，例如违反包间无环依赖，接口隔离、Liskov替换、依赖倒置等。具体做法是把软件设计中的依赖关系用图表示，然后检测图中存在的违反设计原则的特定模式(Motif)，经典开源实现即Google的<a href="https://code.google.com/archive/p/gueryframework/">GUERY</a>(停止维护)。该工具能够根据图中的顶点、关系及其路径长度等条件识别特定模式，并且根据Tarjan算法计算强联通子图进而生成凝聚图。</p>

<p>免费工具除前述外，还有针对Java程序的依赖抽取和可视化工具<a href="http://www.dependency-analyzer.org/">Class Dependency Analyzer(CDA)</a>，CDA能够把相关依赖以UML的形式进行可视化，帮助用户理解并管理复杂软件结构。专业用于依赖分析的商业工具有<a href="http://www.lattix.com/">Lattix</a>、<a href="http://www.hello2morrow.com/products/sonargraph">SonarGraph</a>、<a href="http://www.headwaysoftware.com/products/?code=Structure101">Structure 101</a>、<a href="https://www.jarchitect.com/">JArchitect</a>/<a href="https://www.ndepend.com/">NDepend</a>/<a href="https://www.cppdepend.com/">CppDepend</a>等，本文不再赘述。</p>

<p>值得一提的是，面向软件设计领域无论是免费还是商业工具，尽管其内置的设计规则具有普遍性，同时也支持自定义规则，但通常都存在较高的学习、维护和实施成本，实际上并不能真正达到快速反馈的目的。对处于一线的中小型敏捷团队来说过重，更适用于一些已经具备较高价值的商业软件开发和大型软件组织的架构看护活动。</p>

<p><a href="https://www.archunit.org">ArchUnit</a>是一个基于Java语言的开源依赖检查框架，用户通过编写测试断言的形式约束软件结构依赖，并且通过现有单元测试框架如Junit实现自动运行。与前面提到的主流第三方工具相比，该工具也定义了一些具有普遍意义的依赖规则，同时还具有如下优势:</p>

<ul>
<li><p>直接采用原生语言并作为宿主的测试实现，支持包、类、注解、分层、分片等多种概念实体，使定义复杂的Java代码依赖规则更加容易。</p></li>
<li><p>采用单元测试的思路，使依赖规则能够更快响应软件结构变化，降低规则维护的成本，真正实现快速反馈。</p></li>
<li><p>允许开发人员结合价值交付、团队责任等灵活定制依赖规则，特别适用于敏捷软件设计的场景。</p></li>
</ul>


<p>该工具的缺点是无法向多数GUI工具那样支持依赖分析，内置规则也不如成熟商业工具丰富，因此要求开发人员深入理解设计原则，并能够结合上下文定制恰当的规则。</p>

<h2>结论</h2>

<p>在一般的敏捷宣传语言中，诸如<strong>大道至简</strong>(You Aren&rsquo;t Gonna Need It，YAGNI)和<strong>恰如其分</strong>(Just enough)等词汇往往被使用且被轻易误解。原因在于脱离了具体的实践，敏捷就只剩下一个以人为本的空壳，并不能反映出源自核心的根本经济动力。因此无论是从软件匠艺(Craftsmanship)还是专业主义(Professionalism)来看，敏捷对开发人员的要求都要更高。反映在软件设计领域，具体就是除了基本的分析和设计方法、原则和模式等知识外，进一步注重软件设计中的价值交付、团队责任以及快速反馈等实践。</p>

<h2>引用</h2>

<p>MFL00, <a href="https://martinfowler.com/articles/designDead.html">Is Design Dead?
</a></p>

<p>MFL14, <a href="https://martinfowler.com/bliki/ParallelChange.html">Parallel Change</a></p>

<p>MFL16, <a href="https://martinfowler.com/articles/evodb.html">Evolutionary Database Design</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(13)]]></title>
    <link href="http://www.hanyi.name/blog/2019/05/14/software-design-and-architecture-notes-13/"/>
    <updated>2019-05-14T11:14:51-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/05/14/software-design-and-architecture-notes-13</id>
    <content type="html"><![CDATA[<h2>设计诊断</h2>

<p><strong>设计诊断</strong>(Design diagnosis)是指获取、分析、检测软件设计及其质量的活动。经济利益是驱动软件设计诊断的重要原因之一，特别是对于具有重要价值的软件设施来说，尽早发现并解决设计中存在的问题是十分必要的。然而一直以来软件设计都被认为是难以度量和评价。一方面是因为设计中包含的决策通常是涉及对领域、技术或其它上下文因素的权衡，这是任何客观标准都难以做到完全覆盖的，因此始终无法100%消除对主观参与的依赖，导致设计诊断的权威性受到限制。另一方面，已有的设计验证方法普遍落后于软件开发技术的创造和更替。尽管<a href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/">设计原则与代码味道</a>具有一定的普适性，但是大部分原则本身缺少明确的定量或定性规则(即使存在这类规则一般也很难适用于新的开发技术)，少量有明确的规则通常被归为静态代码分析和风格检查，尚不足以达到设计诊断的目的。</p>

<p>因此为了实现设计诊断，一方面需要对软件设计进行统一的形式化表示，避免对具体的软件开发技术产生依赖。在前者的基础上进一步分析当前软件设计，帮助分析人员理解现有设计、发现设计中的潜在缺陷、甚至模拟历史和未来的设计演化，从而为工程进度和技术债管理提供依据。本文的剩余部分将详细讨论这些主题。</p>

<h3>设计分析(Design analysis)</h3>

<p>设计分析的目标是研究设计本身，后者通常表示解决问题的方案，也可以指构建解决方案的过程。[BC00]认为，理想的解决方案可被视作具有一系列特性的集合，其中的每种特性都可以被归纳为某个维度，即<strong>设计参数</strong>(Design parameters)。不同的设计参数之间存在一定的依赖关系，即<strong>设计结构</strong>(Design structure)。设计参数的所有可能值的集合被称作<strong>设计空间</strong>(Design space)。在整个设计过程中，每个设计参数由对应的<strong>设计任务</strong>(Design tasks)决定，后者相互之间的依赖关系被称为<strong>任务结构</strong>(Task structure)。例如要设计一个马克杯，“是否包含杯盖”是一个设计参数，而“杯盖直径”则是依赖于前者的另一个设计参数，而对于“容器直径”来说，“杯盖直径”与其存在相互依赖的关系。相应地，分别负责杯盖和容器的设计任务之间也就存在依赖，因此设计结构和任务结构具有一致性。前述这些结构可以用一种邻接方阵进行表示，即接下来要讨论的<strong>设计/任务结构矩阵</strong>(Design/Task structure matrix，DSM/TSM)。</p>

<h4>设计结构矩阵</h4>

<p>在DSM(TSM)中，每个结点表示设计参数(或设计任务)，两个设计参数之间的依赖用符号x进行表示，一个马克杯的设计结构例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/full_dsm.png" alt="Full DSM" /></p>

<p>虽然该DSM只有10x10，但每个结点间依赖都可能包含了丰富的物理和工程属性，真实场景中也许会非常复杂。根据设计参数之间的依赖关系类型，在DSM中可以进一步发掘出一些微结构，例如:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/dsm.png" alt="Micro DSM" /></p>

<p>上图描述了两种微观的设计结构，(a)表示层次结构，(b)表示无层次的相互依赖结构，这两种设计结构实质上体现了不同的关系强度，显然(b)体现了更强的相互关系。</p>

<p>另外，真实案例中的矩阵规模通常要比马克杯大得多，例如一个设计笔记本电脑的TSM如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/computer_tsm.png" alt="A laptop computer TSM" /></p>

<p>上图中的TSM相比于马克杯的例子有几个新的元素。首先矩阵中的设计任务呈现出特定排序(或呈现为下三角矩阵)，即相互之间存在强关联的设计任务被放置的更近，越接近对角线的依赖密度就越高。其次整个矩阵上产生了若干相互关联的区块，这些区块直接反映了系统中的独立组件，例如驱动系统、主板等，被称作<strong>原型模块</strong>(Protomodules)。原型模块通常是由领域知识或者组织结构等上下文决定，但是并非真正意义上的模块，因为其本身不具有接下来要讨论的<strong>模块性</strong>(Modularity)。</p>

<h4>模块性与设计规则</h4>

<p>一般而言，高复杂度的问题会导致同样高复杂度的设计，而一个“好”的设计能够有效地管理其自身复杂性。[BC00]认为，<strong>模块化</strong>(Modularization)是系统管理自身复杂性的核心，也是二十世纪以来计算机乃至更多其它领域得以飞速发展的重要原因。系统的模块化程度体现为<strong>模块性</strong>(Modularity)，其中包含两个重要概念:</p>

<p><strong>模块</strong>，即内部元素间的关系比与外部元素间更强的系统单元，这些关系的相对强弱决定了模块的粒度。</p>

<p><strong>抽象</strong>、<strong>信息隐藏</strong>和<strong>接口</strong>，即当一个系统达到一定复杂度时，需要将其拆分成不同部分，抽象的目的在于隐藏其内部复杂性，且通过接口与系统的其它部分进行交互。</p>

<p>在设计笔记本电脑的TSM中，我们知道主板和显示屏之间的设计任务多存在循环依赖，一个例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/design_rule_tsm.png" alt="Cycling in a laptop computer TSM" /></p>

<p>该例中的多个设计任务因为相应设计参数而存在互相依赖，例如主板要决定CPU的规格和所采用的中断协议，而显示屏需要确定详细规格。当主板中具有独立的图形控制器时，显示屏的规格就会发生改变。否则CPU就要根据显示屏的规格提供更多的计算能力，并且采用不同的中断协议。由此可见，“主板是否包含独立的图形控制器”就成为其它设计参数的关键依赖参数。从系统的角度看，其整体复杂性通常是由一系列关键依赖参数决定的，一旦其中某个设计参数确定，则许多依赖的设计参数也就相应确定。这些关键依赖参数被称作<strong>设计规则</strong>(Design rule)。一个完整的系统设计规则集合应至少包含如下信息:</p>

<ul>
<li><p>模块及其在系统中扮演的角色。</p></li>
<li><p>模块间通信的接口。</p></li>
<li><p>系统集成协议以及测试某个模块是否遵循设计规则。</p></li>
</ul>


<p>通过抽取设计规则可以消除原型模块间的相互依赖，从而形成真正意义的模块。其中，设计规则被称为<strong>显性模块</strong>(Explicit modules)，而其他相互独立的部分被称为<strong>隐性模块</strong>(Implicit modules)。一个模块化后拥有完整设计规则集合的DSM/TSM所下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/modularization.png" alt="Modularization" /></p>

<p>DSM/TSM对于计划设计过程同样具有意义，在上例中，首先进行的是设计规则阶段，然后进入可并行进行的隐性模块设计阶段，最后是系统集成和测试阶段。其中，设计规则作为所有阶段的输入，隐性模块则作为集成和测试阶段的输入。</p>

<h4>模块演化及其模拟</h4>

<p>模块性反映了系统的结构状况。如果一个系统具有嵌套层级结构，每个结构单元对内强关联，对外则相互独立，并且具有良好的功能角色定义——那么该系统就被称作<strong>模块化系统</strong>。值得注意的是，系统结构并非一成不变，一方面是因为某些设计参数间的依赖并不容易在初期就显现出来，另一方面，由于复杂的结构往往导致更高的经济成本，因此在真实场景中更加倾向于寻求结构和经济之间的平衡。为了描述模块的动态特征，可以采用<strong>模块操作符</strong>(Modular operators)，[BC00]提出了六种最基本的模块操作符，后者能够用于表示动态结构的所有可能演化路径:</p>

<ul>
<li><strong>分解</strong>(Splitting)，把现有设计或任务划分成多个模块，在层次结构中这往往意味着产生了新层，例如以下模块化层级设计:</li>
</ul>


<p><img src="http://content.hanyi.name/images/design_diagnosis/dsm_splitting_before.png" alt="Two-level modular design hierarchy" /></p>

<p>上例中描述了A~D四个隐性模块以及一个集成和测试阶段，从模块化的角度来看它们都属于相同层级。当更多设计参数及其依赖显现，并且上下文满足模块化设计需求时，新的设计规则以及相应的接口、测试就会出现，于是就诞生了新的层级，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/dsm_splitting_after.png" alt="Three-level modular design hierarchy" /></p>

<p>在进行分解操作后，新的层级应当只对其所依赖的设计规则负责，而对全局设计规则以及上层的集成和测试部分保持透明，这对设计任务和阶段执行具有重要意义。</p>

<ul>
<li><p><strong>替换</strong>(Substituting)，指替换现有模块设计。替换通常是因为多种设计路径之间存在竞争关系，于是更多受到经济系统因素的驱动。模块的可替换性通常是由分解所决定的，因此分解在此扮演了非常重要的角色。</p></li>
<li><p><strong>增强</strong>(Augmenting)和<strong>排除</strong>(Excluding)，即添加或删除模块，与分解与替换不同的是，增强和排除是针对已经模块化的系统来说的。排除体现了模块化设计的可配置性，也就是说用户可以按需选择模块，这与替换的特性是相当的。增强通常是由于系统中需要引入新特性，为了保证可增强性，需要在设计规则阶段就要考虑这种能力。</p></li>
<li><p><strong>反转</strong>(Inverting)，指创建新的设计规则。我们知道设计规则来自于设计参数，后者广泛存在于隐性模块中。因此有时需要把隐性模块从当前的设计层级中“拉取”上来，使其对更多模块保持可见。</p></li>
<li><p><strong>移植</strong>(Porting)，即把当前模块移植到新系统。某些隐性模块支持从当前系统移植到新系统，那么该模块至少应满足以下条件之一:</p>

<ul>
<li><p>所依赖的设计规则在新系统中存在且不变。</p></li>
<li><p>模块本身不受设计规则的影响。</p></li>
</ul>
</li>
</ul>


<p>采用上述模块操作符可以模拟任何过去、现在和未来所发生的设计变化。例如可以抽取设计演化历史中的连续片段，然后用模块操作符描述每一步的变化。对于进行中乃至未来的设计来说，模块演化则是非确定的，采用公式(j6 X 2) - 1即可计算模块演化的所有可能路径，例如当系统中包含6个模块时，就有93311种演化可能。</p>

<h4>应用DSM分析软件设计</h4>

<p>[NEVD05]首次把DSM用于管理复杂软件系统的<strong>依赖模型</strong>(Dependency model)，具体方法是通过静态分析提取代码的依赖关系，然后在DSM中进行层次结构展示，支持人工选取设计规则，并且检测出违反相关规则的依赖关系。</p>

<p>通过静态分析提取到的大多属于语法依赖，即字面引用所体现的依赖关系。不同编程语言的语法依赖类型存在一定区别，并且语言自身的模块化特性也不尽相同，因此存在多种表示软件依赖模型的方式。一种简单的做法是忽略依赖类型间的差异，选择统一的模块化元素作为DSM的设计参数，例如Java中的类，并且按照元素间存在的引用数量定义依赖强度。下例展示了jEdit v4.2的DSM:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/jedit_dsm.png" alt="DSM for jEdit v4.2" /></p>

<p>当DSM规模较大时，需要支持进一步显示矩阵中的层次结构。尽管许多现代编程语言都在语法上提供了层次化结构的特性(例如包、类、方法等)，这些信息可被直接用于DSM分层。但是，多数情况下软件的层次结构无法满足[BC00]的模块性标准，这种在实际中十分普遍的情况被称作软件结构的<strong>技术债</strong>。为了方便理解和改进现有系统的模块性，业界开发了许多针对DSM的聚类算法，即从DSM中的元素及其依赖出发，通过重新排列元素顺序实现自动聚类，其中有代表性的方法有:</p>

<ul>
<li><p>[JNW73]采用<strong>矩阵分区算法</strong>把初始矩阵划分成若干子矩阵，使后者满足下三角矩阵的特征，从而消除循环依赖。</p>

<p>该算法的基本思路是针对每个元素，首先构建可达性(Reachability)集合R(s)与先导(Antecedent)集合A(s)，前者指从该元素出发能到达的所有元素集合，后者指从非当前元素出发能到达或经过该元素的路径的所有元素集合，以及两者交集R(s)A(s)。算法每次迭代选择满足R(s)A(s) = R(s)的元素集合作为当前矩阵的top-levels，然后将其从剩余元素的集合中删除并重复这一过程，直到剩余元素个数为0。矩阵分区算法的优点是实现简单，能够快速筛选出不存在循环依赖的子矩阵，对DSM分层具有一定意义。但是该方法无法满足更多的模块化特性，例如[BC00]中指出的隐性模块间的相互独立性。</p></li>
<li><p>聚类分析中常用的<strong>启发式算法</strong>同样被用于构建DSM的元素聚类。如果某个系统内存在一系列规模合理且相互独立的子模块，那么这些子模块内的依赖关系一定趋近于DSM对角线，以此推论为基础设计距离惩罚函数作为启发式算法的目标函数[TS94]。与分区算法相比，启发式算法能够实现模块间独立条件下的更优结果，而且实现也比较简单，例如聚类部分采用现有的遗传算法框架[RAC08]。但是，设计软件模块性的目标函数是一项挑战。另外，软件的模块性往往还体现在层次结构方面，这是一般的聚类方法难以同时考虑的。</p></li>
<li><p>由于DSM本质上是有向图，因此可以采用图算法进行DSM分层。[SYG09]是一种基于图算法的DSM层次聚类方法，首先计算DSM的凝聚图(Condensation graph)，然后找出所有出度为0的结点的所有依赖关系路径，再从拥有最长路径的结点出发构建DSM的层次结构。该方法构建出的层次结构一定满足下三角矩阵，同一层的模块间保持相互独立且允许并行开发。其优点在于使用DSM实际反映出软件的层次结构，从而能够进一步诊断软件的设计问题[RYR15]。</p>

<p>如果要根据DSM中依赖关系的强弱寻找更优化的层次结构，则可以采用<strong>图聚类</strong>方法[SS07]，特别是针对有向图聚类[FM13]。[SA14]采用<strong>谱聚类</strong>方法对DSM进行重新聚类，该方法建立在DSM中具有较大特征值的特征向量、特征值、模块层次数以及每层模块数等数量之间的相关性基础上，通过对原始DSM进行奇异值分解、分析和降维，计算每个结点在k维空间的线性表示，最后以结点在k维空间中的距离进行聚类。尽管该方法需要指定k值，但是聚类结果依然能正确反映DSM的层次结构。例如:</p></li>
</ul>


<p><img src="http://content.hanyi.name/images/design_diagnosis/spectral_clustering.png" alt="Spectral clustering" /></p>

<p>其中(a)是原始DSM，(b)&copy;(d)分别表示k=2，k=4，k=8时的谱聚类结果，可以看到随着k值的变化，聚类结果始终能表现出实际DSM的层次结构。</p>

<h3>设计度量(Design metrics)</h3>

<p>设计度量涉及一系列面向软件设计的度量指标，包括针对整体模块性的度量、接口强度和优先级、扇入/扇出、联通度以及可见度等等。值得注意的是，设计的度量结果并不能直接等价于设计质量，通常可以作为支持设计分析结果的辅助证据，帮助定位具体问题并结合具体上下文制定改进计划。</p>

<p><strong>模块度</strong>是一种度量整体模块性的指标。[MAC06]认为可以通过计算DSM中元素间的依赖成本，例如依赖的数量和分布模式等，从而实现模块度的间接计算，并且其中存在两种可能的应用场景:</p>

<ul>
<li><p>比较软件A和软件B的模块性。</p></li>
<li><p>比较软件A在T时刻和T + N时刻的模块性。</p></li>
</ul>


<p>假设DSM的元素数量为n，其中<strong>传播成本</strong>(Propagation cost，Pc)忽略元素所在的位置，假设直接依赖和间接依赖具有同等成本，然后计算所有元素的扇入或扇出数M，则Pc = M / n2。对于整个系统而言，扇入和扇出数是相等的，因此M可以任选其中一种进行计算。<strong>聚集成本</strong>(Clustered cost)把模块内和模块间的依赖进行区别计算，首先指定一个依赖阈值(通常是10%~100%间的数)，并将DSM中被依赖次数超过该阈值的元素计入主控元素，然后根据以下条件计算每项依赖所包含的成本:</p>

<ul>
<li>DependencyCost(i -> j | j is a vertical bus) = d</li>
<li>DependencyCost(i -> j | in same cluster) = d * n^λ</li>
<li>DependencyCost(i -> j | not in same cluster) = d * N^λ
其中d是表示是否存在i -> j依赖的二进制值，n指模块规模，N指DSM规模。λ是自定义参数。</li>
</ul>


<p>除了通过依赖成本计算模块度，另一类方法是直接计算模块度。根据模块从内及外且依赖由强变弱的定义，[GG04]提出了一种通用的模块度计算方法，该方法的前提是DSM中已经包含了精确的模块化信息。当DSM中不包含模块化信息，或者需要直接计算系统的实际依赖复杂度时，可采用<strong>奇异值模块度指数</strong>(Singular Value Modularity Index，SMI)[KO11]。该方法通过对DSM进行奇异值分解，然后计算奇异值的下降率从而表示系统模块度。以下面三种典型的结构模式为例:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/different_patterns.png" alt="Typical structural patterns" /></p>

<p>从模块性来看，单块(Integral)系统的模块性较差，总线(Bus-modular)系统也比较差，模块化系统则相对较好。对这些模式对应的DSM进行奇异值分解，从而得到上面三种结构的奇异值下降模式:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/singular_value_decay_pattern.png" alt="Singular value decay pattern" /></p>

<p>可以看出，单块系统的下降趋势非常陡峭，总线型系统比较陡峭，而模块化系统的下降趋势则相对平滑。基于上述关联关系，可以认为当系统的模块性较差时，奇异值会出现迅速下降的情况(SMI较低)，而模块性较好的系统，奇异值下降则通常比较缓慢(SMI较高)，这种相关性也是上文讨论的谱聚类方法的基本假设。</p>

<h2>结论</h2>

<p>设计诊断包括分析和度量两个方面，其中设计分析主要负责设计的形式化表示，例如本文讨论的DSM工具。在DSM的基础上可以进一步分析和模拟设计演化过程，发现设计缺陷以及优化系统模块性。DSM同样可以用于设计度量，设计度量指标不直接等价于设计质量，但可以指导设计及其改进。除了基本的度量指标外，模块度是度量系统整体模块性的核心，可以用于不同软件之间和相同软件的不同版本之间的模块性评价。</p>

<h2>引用</h2>

<p>BC00, <a href="https://mitpress.mit.edu/books/design-rules-volume-1">Design Rules, Vol. 1: The Power of Modularity</a></p>

<p>NEVD05, <a href="https://lattix.com/dev/files/wp/oopsla05.pdf">Using Dependency Models to Manage Complex Software Architecture</a></p>

<p>JNW73, <a href="https://systemsconcept.org/html/Content/BM_1973%20.pdf">Binary Matrices in System Modeling</a></p>

<p>TS94, <a href="http://web.mit.edu/eppinger/www/pdf/Pimmler_DTM1994.pdf">Integration analysis of product decompositions</a></p>

<p>RAC08, <a href="https://www.tandfonline.com/doi/abs/10.1080/09544820802563226">Systematic module and interface definition using component design structure matrix</a></p>

<p>SS07, <a href="http://www.leonidzhukov.net/hse/2018/sna/papers/GraphClustering_Schaeffer07.pdf">Graph clustering</a></p>

<p>FM13, <a href="https://arxiv.org/pdf/1308.0971.pdf">Clustering and Community Detection in Directed Networks: A Survey</a></p>

<p>SYG09, <a href="https://www.cs.drexel.edu/~yfcai/papers/2009/ASE2009_drh.pdf">Design Rule Hierarchies and Parallelism in Software Development Tasks</a></p>

<p>RYR15, <a href="https://apps.dtic.mil/dtic/tr/fulltext/u2/a621415.pdf">Hotspot Patterns: The Formal Definition and Automatic Detection of Architecture Smells</a></p>

<p>SA14, <a href="https://www.researchgate.net/profile/Andy_Dong/publication/269279676_A_spectral_analysis_software_to_detect_modules_in_a_DSM_Risk_and_change_management_in_complex_systems/links/54dc1a540cf28d3de65ea241.pdf">A Spectral Analysis Software to Detect Modules in a DSM</a></p>

<p>MAC06, <a href="https://pdfs.semanticscholar.org/cbfe/a3d346938dba911239502cc97b282668af71.pdf">Exploring the Structure of Complex Software Designs: An Empirical Study of Open Source and Proprietary Code</a></p>

<p>GG04, <a href="https://proceedings.asmedigitalcollection.asme.org/proceeding.aspx?articleid=1651497">A Comparison of Modular Product Design Methods on Improvement and Iteration</a></p>

<p>KO11, <a href="https://hal.archives-ouvertes.fr/hal-00571207/document">Degree of Modularity in Engineering Systems and Products with Technical and Business Constraints</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(12)]]></title>
    <link href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/"/>
    <updated>2019-04-23T15:59:14-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12</id>
    <content type="html"><![CDATA[<h2>设计原则与代码味道</h2>

<p>在此之前我们已经讨论了<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">面向对象分析与设计</a>、<a href="http://www.hanyi.name/blog/2019/03/10/software-design-and-architecture-notes-10/">领域分析及其模式</a>以及<a href="http://www.hanyi.name/blog/2019/03/29/software-design-and-architecture-notes-11/">设计模式</a>。其中朴素的分析和设计方法具有通用性，但需要长期的实际经验积累，在这一过程中不可避免会付出一定代价。虽然模式提供了可复用的设计元素，但基本都存在特定上下文的限制。尽管仍有新的模式不断被提出，但并不意味着其适用性和局限性已被明确认识。同样是来源于经验，有一些设计知识能适用于绝大多数场景，从而具备更广泛的适用性，这就是本文首先要讨论的<strong>设计原则</strong>。设计原则是来源于实际经验且能够指导一般软件设计的法则，其根本动机是发现并解决软件设计问题。</p>

<p>一般而言，发现软件设计问题的终极方法是以真实需求为基础构建软件，然后收集并分析该软件的开发和运行反馈——显然这种方式的代价过于昂贵。一种退而求其次的办法是构建原型系统，在原型阶段只考虑待验证的核心功能，尽早交付给用户使用并收集相关反馈，该方法使软件设计能够更快响应变化。但是我们知道设计复杂度与问题的复杂度是正相关的，而<strong>易变性</strong>又是软件设计的一个重要特征，因此从原型获得一次反馈的效用会随着时间推移和问题复杂度的增加而逐步降低，于是需要缩短反馈周期以实现频繁反馈。高反馈频率意味着更高的交付效率，然而交付效率的提升又有赖于恰当的工程方法和可扩展的设计。因此，“黑盒”式的问题反馈方法虽然为设计问题发现提供了事实依据，但其效率受软件自身设计问题所制约。另一方面，从最初采集得到反馈到定位具体设计问题，对问题根因可能存在不同解读方式，导致最终结论的有效性也可能面临挑战。</p>

<p>幸运的是软件开发并非孤立问题，软件设计实践中遇到的问题及其解决方案往往具有普遍性。在这些知识的基础上诞生了一系列被普遍认可的、“白盒”式的设计原则，使软件设计中的潜在问题能够被更早发现和解决。应注意，某些设计原则是针对特定上下文，例如Liscov替换原则之于OO，更多则适用于广泛的上下文。本文剩余部分首先介绍设计原则背后的核心设计属性，然后按所适应的场景分组并讨论经典的设计原则，最后讨论相比于设计原则更轻量、更贴近日常编程活动、且涵盖更广泛的经验知识——代码味道及其与设计原则之间由表及里的内在联系。</p>

<h3>设计属性和通用设计原则</h3>

<p>每提起设计原则就会出现许多经典的名字和概念，但诸多原则都表现了相对稳定的设计属性，这些属性往往也是软件设计领域中的核心概念，且在前文大多已经讨论过：</p>

<ul>
<li><p><strong>耦合性</strong>(Coupling)，即模块间依赖的程度，耦合越高则意味着该模块将难以被维护，详见<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">结构化设计方法</a>。</p></li>
<li><p><strong>内聚性</strong>(Cohesion)，即模块具有单一目的性的程度，内聚越高则意味着更好的可理解性和可重用性，详见<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">结构化设计方法</a>。</p></li>
<li><p><strong>正交性</strong>(Orthogonality)，即模块能够独立发生变化的程度，具有正交性的模块意味着更容易应对变化。正交性最初被用于描述一种针对关系数据库的设计原则[DC93]，即对于任意两个相互独立的表，其无损分解后的子集不存在相互重叠的情况，该原则能够帮助发现关系数据库设计存在的数据冗余问题。[AD00]详细解释了正交性在更广泛的软件设计问题中的意义，特别是其在模块化、组件化、分层设计等不同设计方法中的一致性体现。</p></li>
<li><p><strong>信息隐藏性</strong>(Information hiding)，即模块尽力隐藏其实现细节的程度，具有信息隐藏的模块通常意味着更低的耦合性，详见<a href="http://www.hanyi.name/blog/2018/10/03/software-design-and-architecture-notes-3/">模块化编程</a>。</p></li>
</ul>


<p>设计属性为评估设计质量建立了基础，但由于更加强调概念完整性，使其在形式上很难直接与具体的设计问题相关联，于是就出现了数量更多且更具实践意义的设计原则。对于早期提出的、通用的设计原则来说，其可能借鉴自其它领域，例如:</p>

<ul>
<li><p><strong>关注点分离</strong>(Separation of concerns, SoC)，即把注意力集中在某个方面，而非与其它无关方面相混淆。该原则最初来源于Dijkstra对计算领域中科学性思维属性的探索[EWD74]，后来被引入软件设计领域，用于强调软件模块之间应具有尽可能少的特性重叠。</p></li>
<li><p><strong>一次且仅一次</strong>(Once and only once)，也称Don&rsquo;t repeat yourself，DRY。指任何知识都应在系统中有唯一、清晰和权威的表示。该原则适用于许多软件设计领域。例如<strong>单一数据源</strong>(Single source of truth, SSOT)，指系统中的任何数据元素都只有一份，任何其它具有相同定义的数据都是该唯一元素的引用，目的是保证数据的完整性和规范性。</p></li>
<li><p><strong>保持简洁</strong>(Keep it simple stupid, KISS)，简洁意味着易于理解、维护和扩展。KISS旨在强调简洁性对于系统设计的重要性。实际上简洁性还普遍适用于设计、建筑和哲学等其它领域，例如Simplicity is the ultimate sophistication，Brevity is the soul of wit，Less is more，Make simple tasks simple以及Simplify, then add lightness等。</p></li>
</ul>


<h3>实体设计原则</h3>

<p>实体通常指软件中表示模块的单位，例如存在于许多编程范式中的类、模块等元素。针对实体的代表性设计原则如下:</p>

<ul>
<li><p><strong>单一职责</strong>(Single responsibility)，指任意实体应只有一个使其产生变更的原因。这里“产生变更的原因”等价于实体的职责，即要求实体具有尽可能少的变化维度。单一职责原则是表述最简单的设计原则之一，也是最难被遵循的原则。这是因为职责的定位和分离会随着上下文变化而不同，这需要一定的实践经验和分析过程，且缺少直观的量化手段。尽管如此，单一职责原则仍有可能通过遵循其它设计原则而间接实现。</p></li>
<li><p><strong>开放-封闭</strong>(Open closed)，指任意实体应对扩展开放，对修改封闭[BM88]。当程序需要发生变更时，应尽可能通过添加新的代码而非修改已有代码来完成，即增量扩展。频繁发生修改的实体通常是难以被预测和重用的。值得注意的是，对大多数软件设计来说，保证100%对修改封闭是难以实现的。因此实际中通常采用一些策略性封闭方法，例如:</p>

<ul>
<li><p>采用抽象加强显式封闭。如果新的需求导致无法满足对修改封闭，首先应考虑当前的抽象设计，是否需要调整或引入新的抽象从而加强显式封闭特性。</p></li>
<li><p>采用数据驱动实现封闭。当修改可能影响同一抽象层级下的许多实体时，可以考虑采用配置数据驱动代码的方式限制修改的影响范围。该方法能够避免引入额外依赖，同时把修改封闭在尽可能小的范围。</p></li>
</ul>


<p>无论是采用抽象还是数据驱动方法，都有可能引入新的封闭性问题。因此实践中往往需要不断考虑并扩展实体对修改的封闭性。</p></li>
<li><p><strong>Liskov替换</strong>(Liskov substitution)，如果S是T的子类型，那么对T的任意对象的引用可以被直接替换为S的对象，且毋须修改已有代码。Liskov原则中的“替换”不仅是指语法上父子类型相互兼容，进一步子类型应当保留父类型中的不变量(见<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">设计契约</a>)，从而实现在语义层面的兼容。在类型系统中，前述这种更趋严格的子类型定义被称作<strong>行为子类型</strong>(Behavior subtyping)[LB87]。</p></li>
<li><p><strong>接口隔离</strong>(Interface segregation)，指客户端不应被强迫依赖于它们不用的接口。当实体中需要引入一个新的公共方法时，一般会在其接口中声明具有相同签名的方法。如果该抽象层级下对应了多个子类型，但并非所有子类型都需要新声明的方法时，就意味着发生了<strong>接口污染</strong>，这种接口也被称作”胖接口”。依赖于胖接口的客户端代码被迫依赖于许多对它们来说无意义的接口，从而大幅增加了级联变更发生的概率。</p></li>
</ul>


<h3>实体依赖原则</h3>

<p>软件的不同实体之间通常存在着依赖关系，针对实体间依赖的代表性设计原则如下:</p>

<ul>
<li><p><strong>依赖倒置</strong>(Dependency inversion)，指高层实体不应依赖低层实体，两者都应该依赖于抽象;抽象不应依赖细节，细节应依赖抽象。当发生直接依赖的实体之间同时存在层级关系时，应当使其依赖共同的抽象。</p></li>
<li><p><strong>控制反转</strong>(Inversion of control)，指通过框架实现程序的控制流，从而操作客户端代码以实现自定义扩展[MFR05]。传统上软件由客户端代码和所依赖的代码库组成，其中客户端代码扮演了负责控制流的角色。为了实现可扩展性，需要首先建立抽象，框架就是集合了众多抽象设计的代码骨架，其中提供了客户端代码的接口，但控制流就从客户端移交到框架端。该原则也被称作<strong>好莱坞原则</strong>(Hollywood principle)，即<strong>Don&rsquo;t call us, we&rsquo;ll call you</strong>。</p></li>
<li><p><strong>最少知识</strong>(Least knowledge)，也称<strong>迪米特法则</strong>(Law of demeter)[LHR88]。对于任何类C以及C中的方法M，M中发生直接调用的对象的类应符合以下两种情形之一:</p>

<ul>
<li><p>方法M的参数对象所属的类(参数对象可以是M中创建的对象、M中发生的函数调用所创建的对象、或者是M中引用的全局变量对象，包括C)。</p></li>
<li><p>类C中任何实例变量对象所属的类。</p></li>
</ul>


<p>应用最少知识原则能够降低系统本身和对其修改的复杂度。该原则的另一个名字“迪米特”是最初应用该项原则所设计的OO系统[LHR88]。</p></li>
</ul>


<h3>包设计原则</h3>

<p>与Java的package和C++的namespace等关键字不同，包在设计原则的上下文中是指独立的可交付物(有时也被称作<strong>组件</strong>)，例如jar包和dll文件。包是常见于大规模的软件系统中的概念，这里的“规模”没有具体的量化指标，可能是指代码行数、团队大小以及系统复杂度等。针对包的代表性设计原则如下:</p>

<ul>
<li><p><strong>重用-发布等价</strong>(Reuse-Release equivalency)，指可重用代码的粒度不应小于代码的可发布粒度。我们知道可重用性是OOD的一个重要属性，可重用的代码应遵循如下原则:</p>

<ul>
<li><p>可以被独立开发、维护、测试、分发。</p></li>
<li><p>具体实现对外部隐藏，只通过<strong>发布接口</strong>(Published Interface)对外公开[MFR02]。</p></li>
</ul>


<p>违反上述原则的代码重用通常都具有副作用，例如<strong>代码复制</strong>(Code clone)、破坏代码封装导致的<strong>强耦合</strong>等。针对这些问题，在可发布粒度上实现代码重用是一种有效的解决办法，该方法通过封装和可追踪使代码具有更好的可重用性，包就是实现这种可发布粒度的有效途径。</p></li>
<li><p><strong>共同封闭</strong>(Common closure)，指包中的不同实体应当封闭于相似的修改原因。根据前文对开放-封闭原则的讨论，实际中始终存在无法令实体对其封闭的修改。而如果不同实体具有共同的修改，那么应使它们属于同一个包。也就是说，同类型的修改应尽可能被限制于最少数量的包中。</p></li>
<li><p><strong>共同重用</strong>(Common reuse)，指包中的不同实体应当具有被共同使用的倾向。一般情况下，如果某些实体之间存在抽象层级的协作关系，那么它们应属于同一个包。否则，仅针对个别实体的修改可能引起跨包修改，从而存在较高风险。与共同封闭原则类似，该原则有利于加强包的可维护性，这在大多数上下文中比可重用性更加重要。</p></li>
</ul>


<h3>包依赖原则</h3>

<p>与实体间存在依赖关系类似，包之间也存在依赖关系，针对包之间依赖的代表性设计原则如下:</p>

<ul>
<li><p><strong>无环依赖</strong>(Acyclic dependencies)，指包之间的依赖关系图应是一个有向无环图(DAG)。作为可发布的软件单元，不同包之间不可避免着存在着依赖关系。如果软件系统中存在包的循环依赖关系，即环形依赖，则可能导致以下问题:</p>

<ul>
<li><p>依赖环中的所有包存在共同修改的可能，破坏了可独立发布的属性。</p></li>
<li><p>包可能间接依赖于大量其它包，从而降低可维护性。</p></li>
</ul>


<p>一种解决循环依赖的方法是应用依赖倒置原则，提取依赖的共同抽象。另一种方法是把现有包中被依赖的部分抽取出来组成新的包。</p></li>
<li><p><strong>稳定依赖</strong>(Stable dependencies)，指包之间应遵循更加稳定的依赖方向。如果一个模块是易变的，那么对该模块的依赖在很大程度上也是易变的，这种<strong>易变性</strong>(Volatility)会沿着依赖的方向传递，从而影响整个系统的可维护性。然而由于软件的易变性可能存在许多影响因子，不同影响因子所导致的后果也不尽相同。其中<strong>稳定性</strong>(Stability)被用于描述模块修改的难易程度，即当模块越难以被修改即越稳定。Uncle Bob提出了一种稳定性的度量指标，可以用如下形式计算:</p>

<p>Ca: 传入耦合(Afferent coupling)，依赖于当前包内实体的外部实体数量。</p>

<p>Ce: 传出耦合(Efferent coupling)，依赖于外部实体的包内实体数量。</p>

<p>I: 不稳定系数(Instability)，且I = Ce ÷ (Ca + Ce)，则I范围是[0,1]，当I=0时当前包最稳定，I=1时则最不稳定。</p>

<p>因此，被依赖的包应具有比依赖包更大的I值，即满足稳定依赖原则。</p></li>
<li><p><strong>稳定抽象</strong>(Stable abstractions)，指稳定性越高的包也应越抽象，反之则越具体。由于高度稳定的包往往难以被修改，因此其应尽可能抽象，从而使系统的易变部分始终保持在不稳定包的具体实现中。包的抽象程度被称作<strong>抽象性</strong>，与稳定性相同，Uncle Bob提出了抽象性A的计算方式:</p>

<p>A = 抽象实体数 ÷ 实体总数。</p></li>
</ul>


<p>根据稳定性和抽象性的定义，理想情况下的软件系统应呈现类似如下线性关系:</p>

<p><img src="http://content.hanyi.name/images/design_principles/abstraction_instability.png" alt="Abstraction-Instability graph" /></p>

<p>也就是说，当已知某个包的稳定性和抽象性度量时，我们就可以进一步计算它们在上述坐标中偏离理想值的程度，用距离D表示这种程度，从而有:</p>

<p>D = |(A + I - 1) ÷ √2|</p>

<p>在实际中能够通过计算包的D值，从而决定包的设计合理性，D值越大的包应优先被关注和改进。</p>

<h3>代码味道</h3>

<p>相比于设计原则，代码味道是一种更加轻量的、被用于识别设计问题的方法。如果把具有良好设计的代码视作是干净无味的话，那么代码味道则可被用于发现那些“显而易见”的“异常”代码。“味道”一词并不是一个正式的概念，Martin Fowler认为代码味道应具备三个基本特征[MFR06]:</p>

<ul>
<li><p>代码味道应是易于被察觉的。</p></li>
<li><p>代码味道不一定表示代码中存在设计问题，即使存在“问题”，也有可能是因为设计权衡的结果。</p></li>
<li><p>代码味道非常易于被程序员理解和掌握，基于代码异味的重构使新手程序员也有机会持续改进设计，即使在缺少对深层次设计原则理解和相关经验的情况下。</p></li>
</ul>


<p>与设计原则类似，按照作用层级可以把代码异味划分为方法、实体(类和模块)以及通用三个类别。</p>

<ul>
<li><p>具有代表性的方法级代码味道包括:</p>

<ul>
<li><strong>长方法</strong>(Long function)和<strong>长参数列表</strong>(Long parameter list)，不仅导致代码难于理解，还可能违反单一职责原则。</li>
<li><strong>重复switch</strong>(Repeated switches)，尽管switch语句具有易于理解的结构，但可能违反开放-封闭原则，特别是当相似结构的switch语句重复出现时，会相应存在多处需要同时被修改的代码。</li>
<li><strong>循环</strong>(Loops)，随着内循环和管道式编程的普及，常规的外循环语句由于相对复杂的结构已经成为循环计算的备选方案。</li>
<li><strong>特性依恋</strong>(Feature envy)，指实体中的某个方法过度依赖了其它实体中的数据或方法，进而可能违反了关注点分离原则。</li>
</ul>
</li>
<li><p>具有代表性的实体级代码味道包括:</p>

<ul>
<li><strong>临时值域</strong>(Temporary field)，指实体中仅在部分情况下有效的属性，这可能违反单一职责原则和关注点分离原则。</li>
<li><strong>消息链</strong>(Message chains)，如果存在对象的方法的链式调用，且每个阶段的调用都作用于不同对象，这种消息链可能违反了最少知识原则。</li>
<li><strong>中间人</strong>(Middle man)，指缺少实际意义的代理方法。尽管封装被作为是OO的重要特征，但某些时候存在不合理的封装，例如一些实体中存在的代理方法，其作用仅是分离了真正的调用对象和被调用对象，这可能违反了单一职责原则和关注点分离原则。</li>
<li><strong>内幕交易</strong>(Insider trading)，指实体间发生数据处理和相互传递的现象。数据交易可能会引起过度耦合，但有时很难完全避免，因此需要尽可能减少此类现象出现的频率。</li>
<li><strong>过大的类</strong>(Large class)，指一些包含了大量属性的类。这可能违反了单一职责原则和关注点分离原则。</li>
<li><strong>异曲同工的类</strong>(Alternative classes with different interfaces)，指某些具有相同类型特性的类，因其具有不同接口而无法利用OO的多态性。</li>
<li><strong>数据类</strong>(Data class)，指只包含可被外部读写的属性的类，导致有关该类的操作散布在不同的类中，这可能违反单一职责原则。</li>
<li><strong>被拒绝的馈赠</strong>(Refused bequest)，指在继承关系中，子类拒绝或忽略了父类中的某些方法或数据，这可能违反接口隔离原则。一种解决办法是创建父类的兄弟类，使方法和数据相分离——这只在具有良好抽象意义的情况下有效，否则可能会引入更多复杂度，反而得不偿失。如果现有抽象更加稳定，而“被拒绝”的元素又足以影响可维护性，更有效的办法是抽取新的类，并采用对象代理关系替换原有继承关系。</li>
</ul>
</li>
<li><p>具有代表性的通用代码味道包括:</p>

<ul>
<li><strong>数据泥团</strong>(Data clumps)，指某些经常同时出现的数据组合，其出现场景可能包括不同类中的属性、许多方法签名的参数等。通常可以采用创建新的类表示这些数据组合。</li>
<li><strong>重复代码</strong>(Duplicated code)，指相同或相似的代码结构在程序中多次出现的现象。最易被识别的重复代码通常发生在同一个类或拥有继承关系的多个类中，也比较容易被消除。除此之外，对重复代码的识别和解决都可能需要进一步的设计权衡。</li>
<li><strong>全局数据</strong>(Global data)，特别是可变的全局数据，即全局变量。我们已经多次强调了这种共享可变状态的代码可能导致潜在的质量和可维护性问题。实际上，即使是非共享状态的<strong>可变数据</strong>(Mutable data)，依然可能导致代码质量问题。</li>
<li><strong>发散式变化</strong>(Divergent change)，即某个模块可能会由于不同原因而导致不同方式的修改，违反了单一职责原则。如果修改原因只有一种，但引起了其它模块发生多次级联修改，则称作<strong>霰弹式修改</strong>(Shotgun surgery)。</li>
<li><strong>基本类型偏执</strong>(Primitive obsession)，指采用基本类型表示某些复杂数据类型，而非创建独立的类，这可能导致大量的重复代码。</li>
<li><strong>懒元素</strong>(Lazy element)，指某些设计元素(例如类、实体)只有非常简单的功能，甚至使用一、两行代码就能清楚表现该元素的特性，那么他们就没有单独存在的必要。与之表现形式相反，但具有统一思想的<strong>夸夸其谈未来性</strong>(Speculative generality)，或者称作<strong>大设计先行</strong>(Big design up front, BDUF)，则表示发生了过度设计。</li>
<li><strong>过高的圈复杂度</strong>(High cyclomatic complexity)，指代码中存在过度复杂的控制流图。圈复杂度通常用代码中的线性逻辑路径数进行表示。假设用N表示代码中的基本区块(指不包含任何控制分支的连续代码片段)数，E表示连接基本区块的边数，P表示连通子图数，那么圈复杂度M可用公式M = E - N + 2P进行计算。过高的圈复杂度可能意味着过度复杂的逻辑或缺少结构性的代码。</li>
<li><strong>神秘命名</strong>(Mysterious name)和<strong>注释</strong>(Comments)，这两种代码味道经常同时出现，因为合理的命名更加表意，也就降低了额外注释的必要性。当然在某些时候再合理的命名也无法表达某些上下文时，注释则是必要的补充。</li>
</ul>
</li>
</ul>


<p>尽管前述大部分的代码味道都有“程度”的概念，使其具体的应用仍然依赖实际经验，但仍然有一些可以遵循的规则。例如，针对重复代码的<strong>事不过三规则</strong>(Rule of Three)，这里虽然中文成语中的数量是虚指，但具体应用时可以作为实际阈值，也就是说当重复代码出现三次时，就应考虑采取相应解决方案了。当然这种规则只能作为初步判断条件，进一步仍然需要结合设计原则进行恰当分析。</p>

<h2>结论</h2>

<p>为了发现和定位软件设计中存在的问题，人们在实践中总结出了一系列具有普遍意义的设计原则。看似纷繁复杂的设计原则其实体现了一致的设计属性，并在长期的设计分析和验证过程中不断得到认可。为了进一步缩短软件设计的反馈周期，在代码编写活动中就可以通过识别代码味道尽早发现潜在的设计问题，并通过持续重构保证软件的设计质量。</p>

<h2>引用</h2>

<p>DC93, <a href="http://web.archive.org/web/20100224075429/http://www.dbdebunk.com/page/page/622331.htm">The Principle of Orthogonal Design</a></p>

<p>AD00, <a href="https://www.nceclusters.no/globalassets/filer/nce/diverse/the-pragmatic-programmer.pdf">The Pragmatic Programmer: From Journeyman to Master</a></p>

<p>EWD74, <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html">On the role of scientific thought</a></p>

<p>BM88, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/POO-2016-01/documentos/Object%20Oriented%20Software%20Construction-Meyer.pdf">Object Oriented Software Construction</a></p>

<p>LB87, <a href="https://klevas.mif.vu.lt/~plukas/resources/OODPrinciples/Liskov1987.pdf">Data Abstraction and Hierarchy</a></p>

<p>LHR88, <a href="https://www2.ccs.neu.edu/research/demeter/papers/law-of-demeter/oopsla88-law-of-demeter.pdf">Object-Oriented Programming: An Objective Sense of Style</a></p>

<p>MFR00, <a href="https://martinfowler.com/books/refactoring.html">Refactoring: Improving the Design of Existing Code</a></p>

<p>MFR02, <a href="https://martinfowler.com/bliki/PublishedInterface.html">Published Interface</a></p>

<p>MFR05, <a href="https://martinfowler.com/bliki/InversionOfControl.html">Inversion Of Control</a></p>

<p>MFR06, <a href="https://martinfowler.com/bliki/CodeSmell.html">CodeSmell</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(11)]]></title>
    <link href="http://www.hanyi.name/blog/2019/03/29/software-design-and-architecture-notes-11/"/>
    <updated>2019-03-29T15:50:14-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/03/29/software-design-and-architecture-notes-11</id>
    <content type="html"><![CDATA[<h2>设计模式——动机与陷阱</h2>

<p>作为软件设计领域在过去三十多年里最重要的议题之一，时至今日，新的设计模式仍不断被提出和采用。软件设计模式的根本目的是为特定上下文提供经受验证的、可复用的元素，从而提高软件工业的生产效率。该领域在早期是伴随着OO的流行逐渐发展起来的[GHJV95]，前文所讨论的<a href="http://www.hanyi.name/blog/2019/03/10/software-design-and-architecture-notes-10/">领域分析模式</a>就是OOA相关的模式，此类模式侧重分析和描述问题域本身。OOD/OOP等活动中存在的模式被称为<strong>设计模式</strong>，后者用于描述通用代码设计过程中经常重现的组件结构。</p>

<p>为了便于交流和传播，每种设计模式最为人所知的部分就是名字和典型结构。实际上这是一把双刃剑。一方面它确实促进了模式在业界的普及，起到了良好的教育作用；另一方面，对设计模式的描述往往只表现出其中一面，背后其实隐藏了的许多问题，例如:</p>

<ul>
<li><p>根本动机，即模式要解决的原始问题，这对于理解模式的适用性非常重要。在不适用场景中应用模式实际上破坏了模式原本的经济效益。</p></li>
<li><p>复杂性，例如具有较高的实现复杂性，带缺陷的模式实现会引入更加隐蔽的问题。有时候这种复杂性与具体语言相关，因此语言特定的<strong>惯用法</strong>(idioms)也成为一种较底层的模式[BMRSS96]。</p></li>
<li><p>非适用场景，例如缺少明确的非适用场景的描述，而这部分信息有助于快速排除候选模式。</p></li>
<li><p>替代方案，例如缺少对已知的非适用场景的替代解决方案。</p></li>
</ul>


<p>上述问题的存在使应用设计模式面临许多挑战。对于这些经典设计模式的“动机与陷阱”，本文将在剩余部分逐一展开讨论。</p>

<h3>单例模式(Singleton Pattern)</h3>

<p>在OOD中经常会遇到整个系统要求某个类只产生唯一实例的情况，例如Printer spooler、A/D converter等。单例模式通过限制访问构造方法，并向全局提供统一的实例获取接口，从而保证所生产实例的唯一性，如下图所示：</p>

<p><img src="http://content.hanyi.name/images/design_patterns/singleton_pattern.png" alt="Singleton pattern" /></p>

<p>系统也可能允许某个类创建特定数量的实例，此时可以用Map结构的instances存储对应多组实例，即<strong>多例</strong>(Multiton)模式。虽然单例模式利用OO语言的特性实现了对任意创建实例的限制，但实际上可能引入更多问题。以基于Java语言的单例模式实现为例：</p>

<pre><code>public final class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
</code></pre>

<p>与上述采用普通类的实现相比，Java的<strong>单元素枚举</strong>模式具有更加简洁的实现，例如:</p>

<pre><code>public enum Singleton {
    INSTANCE;

    Singleton();
}
</code></pre>

<p>依据JVM规范中的类加载机制，作为静态常量的INSTANCE初始化会在Singleton类初始化过程中进行，而后者的发生需要满足且不限于以下条件之一：通过new运算符初始化实例;对类的非常静态变量进行读写操作;调用类的静态方法;通过反射调用类;类包含main函数。可见，由于类初始化条件的复杂性，INSTANCE初始化时机是无法得到有效控制的。一种结合懒求值模式的实现能够把INSTANCE初始化从类初始化的过程中分离出来:</p>

<pre><code>public final class Singleton {
    private static Singleton instance = null;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>

<p>在多线程场景下，上述实现无法保证Singleton只初始化一次。一种解决办法是把getInstance方法声明为synchronized，但会显著影响程序运行效率。另一种办法是采用<strong>双重检查锁</strong>(Double-checked locking)模式，这时需要把instance变量声明为volatile以保证可见性:</p>

<pre><code>public final class Singleton {
    private static volatile Singleton instance = null;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
</code></pre>

<p>事实上，如果充分利用Java的类初始化的原理，则可以借助<strong>按需初始化持有者</strong>(Initialization-on-demand holder)模式实现更高效的懒求值单例模式:</p>

<pre><code>public final class Singleton {
    private Singleton() {}

    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
</code></pre>

<p>上述结合多种模式的实现，看似解决了单例模式在Java并发程序中存在的问题，但因其较复杂的代码实现而影响了程序的可理解性。</p>

<p>单例模式的另一个复杂性在于其向系统中引入了全局状态特性，后者被公认为是影响软件质量和可维护性的重要反模式之一。因此，具有可变特性的单例模式实现应受到特别关注。而如果单例模式具有不可变特性，那么可以考虑采用无状态的<strong>工具类</strong>(Utility class)模式，即其携带的所有方法均为静态方法，且无法被用于创建任何实例，例如经典的工具类java.lang.Math。与单例类模式通常会引入额外复杂性相反，工具类模式有时会存在过度简化的问题，因为后者消除了抽象层级存在的可能，使得每次对工具类的引用都造成强依赖关系，即“不够OO”。因此，在采用工具类模式前，应充分理解所在领域与系统核心领域之间的关系及其作用。此外，无论是单例模式还是工具类模式，都可能会影响具体实现代码的可测试性，这点对于Java语言尤为如此。</p>

<p>虽然单例模式使OO在行为上更加接近真实世界，但其可能会引入一系列负面影响。尽管有针对性的模式试图消除这些影响，但始终难以避免引发新的问题，最终仍有可能得不偿失。因此，采用普通类始终是解决前述问题的首选替代方案。</p>

<h3>工厂模式(Factory Patterns)</h3>

<p>工厂模式是指一系列模式，这些模式被用于把实例的创建过程从现有应用逻辑中分离出来，从而更好地管理复杂性。例如，一个Color类可能包含如下构造函数:</p>

<pre><code>Color(String rgb) {//...}
Color(int red, int green, int blue) {//...}
Color(int hex) {//...}
</code></pre>

<p>注意上述构造函数的参数其实相当于Color的不同表示形式，这种构造过程更像是在进行类型转换，采用<strong>静态工厂方法</strong>(Static factory method)可以令其更加表意:</p>

<pre><code>static from(String rgb) {//...}
static from(int red, int green, int blue) {//...}
static from(int hex) {//...}
</code></pre>

<p>上述类型转换也可以支持聚合类型，例如java.util.EnumSet的of方法:</p>

<pre><code>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E first, E... rest) {//...}
</code></pre>

<p>静态工厂方法也支持创建不属于当前类的实例，例如java.util.Arrays和java.nio.Files等工具类:</p>

<pre><code>static &lt;T&gt; List&lt;T&gt; asList(T... a) {//...}
static BufferedReader newBufferedReader(Path path) {//...}
</code></pre>

<p>除了上述语法糖特性外，静态工厂方法还允许对实例进行缓存，从而控制新实例创建，例如单例模式中的静态方法getInstance。另外，还可以通过设置输入参数返回不同子类型的实例，例如java.util.EnumSet，该抽象类并不提供公共构造函数，而是通过静态工厂方法对输入数据进行分类，按照输入的元素数量自动选择RegularEnumSet或是JumboEnumSet的子类实现。</p>

<p>静态工厂方法是对Java语言中new运算符的替代方案，由于其更好的表意性，该方法通常被用于为编程框架提供统一界面。但是如果某个类只提供静态工厂方法，也就意味着该类无法被正确继承，从而限制OO的抽象类型特性。Java语言中采用静态方法也会影响代码的可测试性。</p>

<p>基于OO的代码框架设计通常采用抽象类或接口表示对象及其相互关系，有时需要负责提供对象创建的功能，但在抽象层级无法确定具体类型。因此先定义抽象的对象创建方法，然后在子类中进行具体实现，该模式被称作<strong>工厂方法</strong>(Factory method):</p>

<p><img src="http://content.hanyi.name/images/design_patterns/factory_method.png" alt="Factory method pattern" /></p>

<p>虽然工厂方法通过采用抽象类型延后了对象的具体类型确定。但是这也意味着始终要配合ConcreteProduct衍生出对应的ConcreteCreator，这种<strong>平行类层级结构</strong>能起到分离职责的作用，但也可能会引入过多的复杂性。</p>

<p>当相关的对象属性或行为随上下文变化时，Client需要根据条件创建不同的对象，于是就产生了对所有相关对象所属类的依赖。这时Client的复杂性会同时受到两个维度的影响：</p>

<ul>
<li><p>对象创建过程的复杂性。</p></li>
<li><p>对象所属的抽象类型数量。</p></li>
</ul>


<p>通过独立的工厂类对相关对象的创建过程进行封装，并从中抽取统一的抽象接口，这就是<strong>抽象工厂</strong>(Abstract factory)模式。其基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/abstract_factory.png" alt="Abstract factory pattern" /></p>

<p>借助抽象工厂模式，Client只需要依赖于Product和Factory的抽象类型，从而具有更好的可扩展性。当面临更复杂的场景时，抽象工厂模式就显得不够灵活，这里所说的复杂性具体存在两种情况:</p>

<ul>
<li><p>创建Product依赖于复杂的初始化参数列表，且具有复杂的实现过程。</p></li>
<li><p>Product具有很多类别且经常发生变化，那么AbstractFactory及其子类也会相应增多且面临频繁修改。</p></li>
</ul>


<p>一种能够避免创建工厂类且同样能够分离对象创建过程的途径是采用<strong>原型</strong>(Prototype)模式，后者允许通过复制一个已存在的对象从而快速创建新对象。原型模式的基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/prototype.png" alt="Prototype pattern" /></p>

<p>当已经存在一个原型对象时，Client就能通过调用原型对象的clone方法快速创建新对象。这里的原型对象可以采用任意方式创建，例如new运算符或者其它工厂模式。原型模式主要解决以下两个问题:</p>

<ul>
<li><p>要创建的对象具有复杂的初始化参数列表。</p></li>
<li><p>在运行时才能确定要创建的对象所属类型。</p></li>
</ul>


<p>Java语言中的Object类提供了默认的clone方法(浅拷贝)，但对象所属的类需要包含Cloneable标记接口才能调用和覆盖Object中的clone方法(例如实现深拷贝)。然而无论是实现浅拷贝还是深拷贝，clone方法都会为对象实现引入额外的复杂度，特别是当对象拥有较深的类层级结构或嵌套引用时，如何保证clone方法的正确性和一致性会遭遇挑战。</p>

<p>原型模式可以看作是对其它工厂模式的补充，其有效性依赖于已经存在的原型对象，因此存在较严格的适用场景。相比之下，<strong>建造者</strong>(Builder)模式则是一种通用性更强、更加灵活的对象创建模式。与抽象工厂通过实例方法直接创建对象不同，建造者模式把复杂对象的创建过程划分为相互独立的子过程，最后通过调用build方法生成所需的完整对象。该模式具有如下结构:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/builder.png" alt="Builder pattern" /></p>

<p>建造者模式允许更加可控的对象创建过程，而非传统上通过构造函数或setter方法准备对象所需的输入，因此具有更加表意、灵活且一致的优点。然而与抽象工厂类似，当具有许多不同类型的Product时，就需要创建对应的ConcreteBuilder，从而可能引入额外的复杂性。</p>

<h3>依赖注入模式(Dependency Injection Pattern)</h3>

<p>借助工厂模式，Client能够方便地创建所需的对象。但无论是工厂方法还是抽象工厂，目标对象始终是由Client通过直接或间接方法调用而创建的，因此两者之间依然存在较强的依赖关系。而在多数情况下，Client只关心依赖对象所提供的相关特性，而非对象的创建过程。另一方面，由于语言自身条件的制约(例如Java)，单元测试难以利用stub/mock技术隔离目标代码内部动态创建的对象，导致单元测试的高实现成本和低运行效率。为了解决前述问题，可以把创建对象的职责从Client彻底分离出来，即在外部完成对象创建，然后依照Client的实际需求“注入”相关依赖，从而使Client能够更聚焦于自身功能特性，这种模式被称作<strong>依赖注入</strong>(DI)。下图进一步解释了该模式的结构和原理:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/dependency_injection.jpg" alt="Dependency injection pattern" /></p>

<p>构建依赖对象的过程被称作<strong>装配</strong>(Assembling)，通常是由<strong>注入器</strong>(Injector)负责装配过程，其中包括向Client注入依赖。一种注入器的实现模式是<strong>服务定位器</strong>(Service locator)，在该模式中Client获取任何外部依赖都需要通过服务定位器进行查询，后者相当于保存相关依赖的注册表服务。其基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/service_locator.png" alt="Service locator pattern" /></p>

<p>虽然采用服务定位器的Client不再关心依赖对象的创建，但前两者之间仍存在强依赖关系，同时由于服务定位器的实现通常是基于单例和静态工厂方法，因此可能成为并发条件下的系统瓶颈，也欠缺可测试性。彻底实现Client与依赖获取分离的方式是<strong>依赖注入容器</strong>模式，该方法通过Client无关的代码或配置文件实现对象装配，然后将其与Client中声明的依赖相互关联以便注入。Client声明所需依赖和实现注入点的方式有三种:</p>

<ul>
<li><p>构造函数注入，即在Client进行初始化的过程中注入依赖。该方法有助于维护Client内部状态的一致性，也让Client的依赖项更易于被理解，这是最常见的一种DI实现方式。</p></li>
<li><p>setter注入，即当Client完成初始化后，通过其提供的setter方法注入依赖。当Client存在很多依赖项时，单纯依赖构造函数注入会面临长参数列表的问题，同时如果Client存在多种依赖组合状态，就需要相应数量的构造函数，相比之下setter注入就更加灵活。</p></li>
<li><p>接口注入，与setter注入类似，区别在于setter方法来自于独立的接口，并由Client实现相关接口的方法。该方法的优势在于外部的注入代码可以完全忽略Client的具体类型，仅通过相关接口类型的引用向其注入所需依赖。</p></li>
</ul>


<p>DI能够最大化分离依赖的创建和实际应用，从而实现显著的模块解耦。由于对象装配完全由注入器提供的机制负责，因此这里往往是DI最核心和最复杂的部分。许多基于动态特性的DI实现也使静态对象追踪更加困难，进而可能增加软件的维护成本。</p>

<h3>组件依赖模式(Component Dependency Patterns)</h3>

<p>软件开发的过程中经常存在独立的软件单元，例如被独立开发的类(如类库)，或是包含一组类的子系统，亦或是相互独立的对象。组件通常具有独立的设计和演化规则，因此不同组件对外提供的接口也不尽相同。实现组件间依赖的一般做法是引用目标组件的原始接口，但这会造成组件间的强耦合，当需要替换某些组件、或者对依赖过程实现扩展时会产生较高代价。组件依赖模式就是为了解决此类问题的一组设计模式。</p>

<p>一种解决组件间依赖的模式是<strong>适配器</strong>(Adapter)，也称<strong>包装</strong>(Wrapper)。该模式会额外创建一个Wrapper类包装目标组件，同时遵循面向Client的一致性接口。具体的包装手段有类适配器和对象适配器两种，其基本结构分别如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/adapter.png" alt="Adapter pattern" /></p>

<p>类适配器具有更加简洁和OO的外观，但也存在一些潜在的限制。首先类适配器只能包装具体类而非接口，因为后者没有可供复用的具体实现。其次继承通常具有侵入性，仅以代码复用为目的的继承可能会破坏原有类的封装能力，从而损害了OO的内核。对象适配器则与之相反，虽然可能需要额外的对象创建和连接操作，但不存在类适配器的问题，因此更容易应对复杂性。</p>

<p>适配器模式主要解决依赖已有类的问题，但类似的结构也可被用于正在开发的类，有时因为希望保持接口和实现相对独立。传统上接口是作为与Client间的契约先于实现而确定的，但是当接口本身也具有一定复杂性时，就可能需要接口和实现分别独立演化，以便必要时还能切换其它替代实现，这种模式被称作<strong>桥接</strong>(Bridge)。其基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/bridge.jpg" alt="Bridge pattern" /></p>

<p>桥接模式具有和对象适配器相似的结构，但要注意其根本动机的不同。桥接模式支持从原有具体类中分离出承担接口职责的部分，从而应对接口和实现同时可能发生快速变更的情况。而适配器是在目标类稳定的情况下利用额外的接口包装以实现代码快速复用。</p>

<p>当目标类的接口满足Client需求，但在具体应用时需要引入额外的<strong>面向切面</strong>(Aspect oriented)功能时(例如访问控制、日志记录等)，可以创建与其拥有相同接口的代理类，通过类似对象适配器的结构对目标类的对象进行包装，这就是<strong>代理</strong>(Proxy)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/proxy.png" alt="Proxy pattern" /></p>

<p>如果一个已有的子系统由若干接口和类组成，且其内部具有复杂的结构关系。为了提高子系统的易用性，可以额外维护一个统一的对外接口类，将系统特性通过简单的接口定义向外部发布，即<strong>外观</strong>(Facade)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/facade.png" alt="Facade pattern" /></p>

<p>与其它模式关注类之间的依赖问题不同，外观模式主要解决子系统间的依赖问题，但其解决问题的基本思路是一致的。有时对象间的依赖也会存在问题，例如可能会生成庞大数量的目标对象，使系统资源过度消耗。当大量目标对象中包含许多重复信息时，一种解决方法是通过创建共享对象以减少资源总消耗，这种模式称作<strong>享元</strong>(Flyweight)。享元模式具有如下基本结构:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/flyweight.png" alt="Flyweight pattern" /></p>

<p>为了实现目标对象共享，可以采用抽象工厂或工厂方法生产被Client依赖的享元对象，当已有的享元对象满足共享条件时，系统会直接返回该对象而非重新创建。享元对象相当于对目标对象的重新包装，但这并不意味着享元对象是一定可以被复用的，例如当目标对象包含特定的外部状态信息时，就需要专门再创建一个非共享享元对象保存这些外部状态信息，并且在对应的共享享元对象中保存对其引用。</p>

<h3>增量扩展模式(Incremental Extension Patterns)</h3>

<p>OO的重要特性之一是通过继承实现增量式扩展，这种特性能帮助我们有效管理系统复杂性。但是正如<a href="http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8/">面向对象——概念与建模</a>一文中提到的，继承除了提供模块能力外还兼有类型概念，这种概念兼有利弊，特别是令继承的适用场景受到一定限制，不合适的继承非但不能有效管理复杂性，反而会带来更多问题，此时就需要考虑用组合替代继承实现模块扩展，这就是<strong>组合优于继承</strong>(Composition over inheritance)长期占据主流观点的原因。接下来要讨论的设计模式或采用继承或采用组合的方法来解决增量扩展的问题。</p>

<p>当系统需要同时维护很多对象时，维护增量式扩展的核心问题之一是如何管理每个对象的定义及其相互间的关系。当所有对象间关系呈现为树形或层级结构、并且Client与这些对象交互存在趋向一致的外部接口时，可以采用<strong>组合</strong>(Composite)模式。该模式为系统中的对象提供了统一的外部接口，作为非叶节点的对象可以包含并将同类型的对象作为其子节点。组合模式的基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/composite.png" alt="Composite pattern" /></p>

<p>组合模式所提供的增量扩展能力在于可以通过实现Component接口任意添加新的节点类型，虽然是等同于继承的扩展方式，但除了具有树形或层级结构这种特殊的对象间关系外，多数时候组合模式并不能适用。相比之下，聚合是一种更加普遍的对象间关系，其中聚合对象可以包含若干个不同类型的局部对象，在实践中聚合关系往往是通过对象间的组合实现的，这被称作<strong>整体和局部</strong>(Whole-Part)模式。下图给出了该模式的基本结构:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/whole_part.png" alt="Whole-part pattern" /></p>

<p>与组合模式最大的区别在于，该模式并不要求“整体”和“局部”对象具有统一的访问接口，通常只有整体对象对外提供服务，而局部对象具有多种类型且一般不会向外界暴露。类似的结构也存在于<strong>主从</strong>(Master-slave)模式，该模式描述的对象间关系一般只有两层——主对象和从对象，其基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/master_slave.png" alt="Master-slave pattern" /></p>

<p>其中主对象可以按需把接收到的工作分解并指派给若干从对象，最终再汇总从对象的计算结果并产生最终结果，主从模式有助于提高系统容错性、并行性和计算准确性。</p>

<p>有时需要实现对象的动态扩展，为了保持扩展对Client透明，需要同时借助继承的抽象类型特性保证扩展结果具有与原对象一致的接口，这就是<strong>装饰器</strong>(Decorator)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/decorator.png" alt="Decorator pattern" /></p>

<p>为了描述具体的扩展内容，首先需要创建与目标对象相同接口的装饰器对象，后者只需关心各自要扩展的功能；在对象创建阶段，用装饰器对象包装目标对象，如果存在多个装饰器对象，则继续用其包装装饰后的对象；最终生成的装饰后对象具有与目标对象完全一致的对外接口，因此装饰器模式能够最大限度地保持Client不变。</p>

<p>如果一个上下文需要在不同状态中表现出不同行为，可以把这些状态对应的行为单独抽取出来，利用组合关系使其行为能够被动态替换，这就是<strong>状态</strong>(State)模式。与装饰器模式类似，状态模式也是一种同时结合了继承和组合的增量扩展模式，该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/state.png" alt="State pattern" /></p>

<p>除了内部状态发生改变之外，上下文行为还可能会因为其它因素产生变化，例如需要选择不同的算法策略，此时可以采用与状态模式具有几乎相同结构的<strong>策略</strong>(Strategy)模式:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/strategy.png" alt="Strategy pattern" /></p>

<p>状态模式和策略模式都属于纵向增量扩展模式，即每次扩展相当于对原有功能进行完整替换，这种扩展方式具有较高的灵活度。在某些场景中，上下文行为存在相对固定的套路，延续这种套路虽然可能会引入某些限制，但使后续扩展的关注点更加明确，从而提高增量式扩展的效率。<strong>模板方法</strong>(Template method)模式就是这类横向增量扩展模式的典型代表，其基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/template_method.png" alt="Template method pattern" /></p>

<p>该模式中提供的模板方法就是一个预置的算法框架，任何扩展只需替换其中预设的子步骤。另一种预置了算法框架的模式是<strong>迭代器</strong>(Iterator)，该模式封装了数据结构的基本操作，从而令Client更加关注在具体元素的操作。其基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/iterator.png" alt="Iterator pattern" /></p>

<p>在前述模式的基础上，可以进一步抽象出元素操作，从而满足数据结构及其算法、数据结构中的元素、元素对应的操作的独立扩展，这就是<strong>访问者</strong>(Visitor)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/visitor.png" alt="Visitor pattern" /></p>

<p>由于实现了最大限度的抽象化，访问者模式同时在上述三个维度上提供了增量扩展能力，但同时也引入了较高的复杂度，特别是当元素及其操作分别属于不同的类层级结构，但其相互之间仍然存在着强耦合关系，导致代码的可维护性受到损害。</p>

<h3>消息模式(Messaging Patterns)</h3>

<p>OO中的对象间通信主要通过消息传递进行，最直接的消息传递方式就是调用目标对象的方法。消息模式主要用于解决下述几个方面的复杂性:</p>

<ul>
<li><p>消息的发送者和接收者。</p></li>
<li><p>消息的表示和传递。</p></li>
<li><p>消息的存储和管理。</p></li>
</ul>


<p>当接收者的消息处理过程比较复杂，例如具有层次式的处理结构时(类似多层嵌套的条件分支)，可以把其中每一层的处理逻辑抽取出来构建独立对象，然后将原始的消息接收者替换为一组对象链，即<strong>责任链</strong>(Chain of responsibility)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/chain.png" alt="Chain of responsibility pattern" /></p>

<p>在责任链模式中，原来的消息接收者被划分成多个职责独立的对象，消息由一次处理变为沿着责任链进行传递并被多个对象分别处理。这种变化降低了原始代码的圈复杂度，而且方便复用现有对象组建新的责任链。</p>

<p>对于作为消息发送者的对象，把待发送的消息和接收者从中抽取出来构建独立对象，一方面可以降低发送者的复杂度，满足消息类型的增量扩展；另一方面可以灵活控制消息的发送时机。这种模式被称作<strong>命令</strong>(Command)模式。其基本结构如下所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/command.png" alt="Command pattern" /></p>

<p>上图中的Invoker扮演消息发送者的角色，Receiver则是消息的接收者，Client负责创建命令对象并将其和接收者关联。命令模式中的命令对象是不可变的，这种特性使命令对象能够被重复使用，但无法保存状态。另一种相似的模式——<strong>命令处理器</strong>(Command processor)允许创建具有可变状态的命令对象，其代价是扮演Invoker的命令处理器需要每次从Client获取新建的命令对象，其基本结构如下所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/command_processor.png" alt="Command processor pattern" /></p>

<p>如果一次消息发送对应了多个接收者，并且接收者还可能会发生动态增加或减少，那么在每个接收者上实现观察者接口，然后将其动态注册至消息的发送者上，当消息发送时会依次发送至每个已注册的接收者。这就是<strong>观察者</strong>(Observer)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/observer.png" alt="Observer pattern" /></p>

<p>观察者是一种消息传递模式，特别是当存在一对多的消息传递关系时，应用观察者模式能够实现消息发送者和接收者的解耦，并且支持动态的接收者增加和减少特性。观察者模式有时也被称作<strong>发布者-订阅者</strong>(Publisher-subscriber)模式，但后者有时存在更多变种。例如传统的观察者模式主要依赖消息推送(Push)，所有观察者都被动接收消息。但是发布者-订阅者模式中还支持消息拉取(Pull)，这时发布者只会发送很简单的变更通知，由订阅者决定是否读取该消息。消息拉取是一种更加灵活的消息传递方式，特别是当消息量可能超出了接收者的承受能力时，拉取实际上对接收者起到了保护作用。如果不存在消息过载的情况，那么采用推送则更加简单且实时。</p>

<p>如果系统中存在许多对象，并且这些对象间大都存在着某种消息传递关系时，可以创建一个中介对象负责接收并转发对象发送的消息，即<strong>中介者</strong>(Mediator)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/mediator.png" alt="Mediator pattern" /></p>

<p>与观察者模式类似，中介者模式能够解决多对多的对象间消息传递和动态增减问题。但是该模式会增加获取消息传递路径和参与双方信息的难度，使某些重要的领域逻辑无法在代码中得到清晰呈现，进而间接提高维护成本。因此当消息传递包含关键领域逻辑时，应避免采用中介者模式，当然最终的设计和实现可能会更加复杂，以<strong>视图处理器</strong>(View handler)模式为例:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/view_handler.jpg" alt="View handler pattern" /></p>

<p>该模式用于解决多文档窗口管理的问题。多文档窗口通常存在于Word等文本编辑工具，其特点是系统可以同时打开多个窗口，而且每个窗口可以指向任意文档的内容。该问题的复杂性在于每个窗口中的操作可能会影响其它窗口的显示结果，同时当用户点击退出时系统需要针对每个打开的文档向其询问是否要保存已修改的内容。视图处理器模式定义了系统中存在的三种对象:</p>

<ul>
<li><p>视图处理器，负责管理所有视图，以及对外提供针对视图的操作。</p></li>
<li><p>视图，负责保存当前视图的内部状态，向视图处理器提供基本操作。</p></li>
<li><p>供应者，负责保存数据，并且向其观察者发送数据更新消息。</p></li>
</ul>


<p>该模式的对象间的消息传递存在两种情况:</p>

<ul>
<li><p>当视图内的数据发生修改，该修改被反馈给供应者，然后把更新后的状态通过观察者模式发送给视图处理器和其它相关视图。</p></li>
<li><p>外部触发系统调用视图控制器提供的接口，然后把相关更新依次传递到每个视图。</p></li>
</ul>


<p>当多个对象间消息传递发生在跨进程的对等网络中时，消息传递需要先后经过序列化和反序列化，这时可以采用<strong>转发者-接收者</strong>(Forwarder-receiver)模式。</p>

<p><img src="http://content.hanyi.name/images/design_patterns/forwarder-receiver.png" alt="Forwarder-receiver pattern" /></p>

<p>在该模式下，消息发送者需要首先把消息传递给转发者；后者进行序列化和寻址，然后把消息传递至接收者；接收者接到消息后先进行反序列化，然后把消息返回给接收对象。有时需要保持网络地址对消息双方透明，从而实现信道自动调度，此时可以采用<strong>客户端-调度器-服务器</strong>模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/client_dispatcher_server.png" alt="Client dispatcher server pattern" /></p>

<p>在处理相关消息时，有时会导致接收者的内部状态发生改变，但消息的发送者可能要求撤销某些消息处理，其实质是恢复消息接收者的状态到历史的某个时刻。一种简单的做法是由消息接收者返回当前内部状态，以备忘录对象的形式在外部进行保存。当回退需求发生时，发送者向接收者发送备忘录对象并要求恢复至指定状态。这种模式被称为<strong>备忘录</strong>(Memento)，其基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/memento.png" alt="Memento pattern" /></p>

<h2>结论</h2>

<p>作为软件设计的最佳实践，设计模式从诞生之初就受到了工业界和学术界的热捧，并把OO进一步推向了金字塔顶端。近年来随着软件开发框架和工具链的日益完善，设计模式在日常应用开发中逐渐退居幕后，成为新技术背后的驱动力。但是，作为软件工业化的必经之路，新模式的发现及传播不可能由此中断。对于任何一种模式，了解其场景和结构固然重要，但深入理解模式的动机和陷阱才意味着做到了正确理解，才能真正将其作为软件设计的最佳实践。</p>

<h2>引用</h2>

<p>GHJV95, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/DSBP-2018-01/recursos/Erich%20Gamma,%20Richard%20Helm,%20Ralph%20Johnson,%20John%20M.%20Vlissides-Design%20Patterns_%20Elements%20of%20Reusable%20Object-Oriented%20Software%20%20-Addison-Wesley%20Professional%20%281994%29.pdf">Design Patterns: Elements of Reusable Object-Oriented Software</a></p>

<p>BMRSS96, <a href="https://github.com/ppizarro/coursera/blob/master/POSA/Books/Pattern-Oriented%20Software%20Architecture/Pattern-Oriented%20Software%20Architecture%2C%20Volume%201%20-%20A%20System%20Of%20Patterns.pdf">Pattern-Oriented Software Architecture Volume 1: A System of Patterns</a></p>
]]></content>
  </entry>
  
</feed>
