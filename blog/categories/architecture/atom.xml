<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Wing of Dream 梦境之翼]]></title>
  <link href="http://www.hanyi.name/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://www.hanyi.name/"/>
  <updated>2019-02-10T23:57:34-05:00</updated>
  <id>http://www.hanyi.name/</id>
  <author>
    <name><![CDATA[Han Yi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(8)]]></title>
    <link href="http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8/"/>
    <updated>2019-02-06T16:23:31-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8</id>
    <content type="html"><![CDATA[<h2>面向对象——概念与建模</h2>

<p>由前文<a href="blog/2019/01/24/software-design-and-architecture-notes-7/">编程范式</a>我们知道，对象作为最基础的编程概念广泛存在于各类编程范式中，采用这种范式的语言被称为基于对象语言(Object based language)。本文讨论的<strong>面向对象</strong>(Object oriented)的概念则首次出现在1967年诞生的Simula 67，其中除了对象概念本身外，还进一步提出了<strong>继承</strong>和<strong>多态</strong>这两个重要特性，成为此后长期影响学术界的语言之一。而面向对象在工业界的兴起则始于上世纪80年代，以Smalltalk和C++的相继发明为标志，深刻影响了此后近四十年的软件工程。</p>

<h3>基本概念</h3>

<p>继承是区分面向对象和基于对象的重要特征，大部分面向对象语言的继承是采用<strong>类</strong>(Class)实现的(注意“类”和“对象”是完全不同的编程概念)。我们知道类可被看作是能够创建对象的工厂对象，继承则允许增量式地进行对象扩展。因此，类作为数据抽象的核心，在其基础上实现继承就自然地支持增量式的数据抽象。除了类之外，面向对象还支持一种基于<strong>原型</strong>(Prototype)的特殊实现，后者通常并不包含类定义，任何对象都能够唯一地指定另一个对象作为其原型，其中对象的属性和事件沿原型链传递查找，从而实现继承。从支持增量式对象扩展的角度看，类继承和原型继承没有本质区别。下面讨论在面向对象语境下的一些重要概念。</p>

<ul>
<li>类。类是一个可能同时包含部分具体实现的抽象数据类型[BMR97]，其被用于描述一组存在于内存中且可直接被用于计算的实例。类的特点在于其同时扮演了<strong>模块</strong>和<strong>类型</strong>两种角色。其中模块作为一种语法概念，通常被用于表示软件分解单元，而类型则被用于动态对象的静态描述，相当于一种语义概念。在非面向对象模式中，上述两种概念通常是被分开表示的。</li>
</ul>


<p>在某些面向对象系统中(例如Smalltalk和Ruby)，类自身也可能是通过对象实现的，这种实例依然是其本身的类被称作<strong>元类</strong>(Metaclass)，面向对象语言或编程环境的作者可以利用元类方便地实现某些动态扩展特性，例如Ruby的<a href="http://www.hanyi.name/blog/2015/08/29/metaprogramming-ruby-core-concepts-object-oriented-hierarchies/">单例类</a>。</p>

<ul>
<li>对象。对象是指某个类的运行时实例[BMR97]。</li>
</ul>


<p>虽然“对象”一词最初来源于对真实世界物体的描述，但在实际编程场景中对象已经不仅仅被用于描述真实物体，例如用于描述一组配置属性等因技术需求而诞生的对象。对象是通过<strong>引用</strong>(Reference)进行表示的，并且可以被自身或其它对象引用。一个对象引用唯一地指向了该对象唯一且不变的<strong>标识</strong>(Identity)。对象标识是用于区分不同对象的唯一凭证。</p>

<p>对象的创建过程通常是在面向对象系统中默认定义的，一般包括分配内存空间和初始化两个步骤，前者由系统自身负责，后者允许在程序中自定义初始化过程。以Java的面向对象系统为例，类支持以构造函数(Constructor)定义初始化过程，如果某个类没有包含显式的构造函数，编译器会自动加入一个默认的无参构造函数并在其中调用父类的无参构造函数。</p>

<ul>
<li>组合与聚合。如果采用引用表示对象，那么对象之间就可以通过引用产生<strong>关联</strong>(Association)。但是仅使用引用不足以描述对象间真实的关系特征，从而无法满足<strong>忠实建模</strong>(Faithful modeling)。<strong>组合</strong>(Composition)关系是指一个对象包含了另一个对象的值，这种关系超过了一般引用的定义，特别是指被包含对象的生命周期被限制在其父对象内。<strong>聚合</strong>(Aggregation)关系指一个对象由另外多个对象组成，其组成关系通过引用实现。与组合的区别在于，聚合中被包含对象的生命周期不受父对象限制。</li>
</ul>


<p>从面向对象中对关系分类的角度看，组合与聚合可以统一被看作<strong>客户</strong>(Client)关系，其实质是对对象间关系的描述。</p>

<ul>
<li><p>继承。继承描述了一种类之间的扩展关系。在面向对象中，类本身具备良好的模块化特性，从而能够满足信息隐藏的原则，但模块化并不直接提供增量式设计和开发的途径。继承支持了类之间的扩展、特化和组成关系，显著增强了面向对象的可重用性和可扩展性。其中包括四个重要的衍生概念:</p>

<ul>
<li>重定义(Redefinition)，指子类能够重新实现父类中定义的过程，有时也称作<strong>覆盖</strong>(Override)。</li>
<li>多态(Polymorphism)，指一个变量实体或数据结构元素，在具备可控静态声明的前提下能够在运行时阶段绑定至不同类型的对象。例如当类A继承类B，那么类A的对象a，可以被赋于类型为B的变量b，且并不违反类型检查。</li>
<li>静态类型(Static typing)，前面提到多态的前提是具备“可控静态声明”，具体是指对于一个变量的声明类型(也称变量的静态类型)，尽管允许其被赋予不同类型(也称变量的动态类型)，但其动态类型必须是静态类型的后代(后代定义包含其自身)。</li>
<li>动态绑定(Dynamic binding)，是指变量所指向对象的动态类型决定被调用操作的具体位置。</li>
</ul>
</li>
</ul>


<p>本质上，继承同时包含了两个角色且互有重叠:模块和类型。从模块的角度看，继承提供了一种有效的可重用特性。这里提到的有效是指当类A继承类B时，A就立即拥有了B的全部特性，且无须进行任何改动。从类型的角度看，继承同时增强了可重用性和可扩展性，这主要体现在: 1.对于类Rectangle继承类Polygon，即Rectangle的全部实例同时也是Polygon全部实例的子集。2.对于类A继承类B，那么B的任意实例所具有的操作也同时存在于A。在许多文献中，继承也被称作is-a关系。</p>

<ul>
<li>多重继承。在真实世界中，对象可能同时包含了不同领域的抽象，对应在面向对象中就是多重继承，即一个类可以同时拥有多个父类。例如，类Teacher和类Student都继承了类UniversityPerson，这时需要一个类TeachingAssistant且同时继承自类Teacher和类Student，也就是说通过两个父类间接继承了类UniversityPerson，即<strong>重复继承</strong>。重复继承可能会造成一定的函数访问冲突，特别是当调用类TeachingAssistant的对象的name函数，而其实际上位于类UniversityPerson时，系统就面临多重函数查找路径的问题。而由此引发的复杂性使得多重继承在许多现代面向对象实践中被认为弊大于利，且不被推荐使用。但不可否认，多重继承实际上体现了真实世界原本的复杂性。</li>
</ul>


<p>在支持多重继承的面向对象系统中，通常采用<strong>复制</strong>(Replication)和<strong>共享</strong>(Sharing)两个策略解决前述重复继承问题。复制是指当遇到重复继承时，子类实际上包含了所有继承路径上属性和函数的副本，程序这时需要具体指定被调用副本的名称。共享是指程序可以指定在子类中只保留一份来自祖先的副本，这样就避免了名字冲突的问题，例如C++的<strong>虚继承</strong>(Virtual inheritance)。</p>

<p>许多现代面向对象语言不支持多重继承，但同时为了保留一定的设计能力大多采用了折衷方案，例如Java的<strong>接口</strong>(Interface)、Ruby的<strong>混入</strong>(Mixin)等。</p>

<ul>
<li>泛型。继承本质上体现了一种纵向的层级扩展关系，由上至下可以被看作是面向对象从抽象化到特化。而<strong>泛型</strong>(Genericity)则支持横向的同级扩展关系，即类型参数化。</li>
</ul>


<p>泛型最经典的案例就是编程语言标准库中常见的容器类，例如Set、List、Map等，这些容器类实际上是参数化的抽象数据类型，其本身包含了抽象数据类型中的具体操作，并藉由客户代码通过指定参数决定具体的元素类型。由于历史的原因，许多现代编程语言中虽然提供了泛型特性，但其实现原理差别巨大。例如C++的模板能完整地重新编译目标代码，最终根据模板参数生成不同的函数和类；而Java的泛型实际上是一种为了增强代码类型安全的语法特性，编译器对泛型语法进行类型检查，并最终通过<strong>类型擦除</strong>(Type erasure)生成无类型参数的目标代码；C#的泛型实现则介于C++的灵活和Java的简易之间，通过运行时<strong>实化</strong>(Reification)进行类型检查和具体操作，从而避免了类型擦除的缺点(例如无法实现泛型数组)，同时把类型参数保留在运行时，从而满足在泛型条件下支持反射。</p>

<h3>面向对象建模(Object Oriented Modeling)</h3>

<p>从上世纪80年代起，随着工业界对面向对象语言从逐渐认识到深入实践，面向对象开始代替传统的结构化方法成为主宰范式。但是，基于面向对象的软件开发很快就面临了更多数量的对象以及更加复杂的关系，实现系统设计也变得空前复杂。作为OO的早期布道者之一，Grady Booch等分别在面向对象的基本概念基础上发展出了一系列全新的建模方法，被统称为<strong>面向对象建模</strong>。</p>

<h4>统一建模语言(Unified Modeling Language, UML)</h4>

<p>1997年，Three amigos在Grady Booch的Booch method、James Rumbaugh的Object modeling technique(OMT)以及Ivar Jacobson的Object oriented software engineering(OOSE)的基础上，正式发布了UML 1.1。UML是一种编程语言无关的通用建模技术，旨在采用统一语言对复杂问题的不同关注点进行建模。</p>

<p>UML由<strong>图形标记</strong>(Graphical notations)和<strong>元模型</strong>(Meta-model)组成。其中图形标记定义了相关概念的图形表示法，也是UML建模的主要工具。元模型是一种对UML模型的形式化表示方法，用于对UML规格说明的精确表达。后者常被用于构建基于UML的计算机辅助软件工程(Computer Aided Software Engineering, CASE)系统。这里只讨论UML的图形标记方法。</p>

<p>下图展示了UML 2.5.1的图形标记分类[UML17]。其中<strong>结构图</strong>(Structure diagrams)用于代表系统中对象的静态结构，通常能够表示系统的核心概念及行为定义，但并不包括行为的动态细节。<strong>行为图</strong>(Behavior diagrams)表示系统中的动态行为，包括方法、协作、活动和状态历史记录等。</p>

<p><img src="http://content.hanyi.name/images/object_oriented/uml_diagrams_overview.png" alt="The taxonomy of UML diagrams" /></p>

<p>随着UML被纳入国际标准，其复杂度不断增加，即使由对象管理组织(Object Management Group, OMG)定义的狭义UML规范也已经十分臃肿，使其逐渐脱离了日常的软件设计实践。但不可否认，UML的核心内容依然在面向对象建模中占据权威地位。为了保证UML的实用性，本文接下来只讨论核心的图形标记[MFR03]。</p>

<ul>
<li>类图(Class diagrams)，表示系统中的对象类型及其相互之间的静态关系。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/class_diagrams_overview.png" alt="Class diagram" /></p>

<p>在上图中，每个方框表示类的属性和操作，方框间的实线表示类的相互关系，在每种关系上还标记了两个类之间的<strong>多重关系</strong>(Multiplicity)。关系是UML中最复杂的概念之一，甚至允许通过构造型(Stereotype)对关系进一步扩充。UML的基本关系种类包括：1. 关联(Association)，指类之间的持续性关系，例如类的属性类型，关联采用实线表示，并且可以是无向、单向和双向，带方向的关联进一步揭示了源类中包含以目标类作为类型的属性；2. 依赖(Dependency)，指一个元素(Supplier)的变更可能引起另一个元素(Client)的变更，依赖采用单向的虚线表示；3. 泛化(Generalization)，表示类之间的类型层级关系，例如继承采用带三角箭头的实线表示，如果目标类是接口类，那么采用带三角箭头的虚线表示，抽象类需要额外使用斜体表示。</p>

<p>从上述关系的定义来看，依赖是含义最广泛的关系，也是面向对象建模中需要仔细考虑的问题。过多的依赖路径会导致修改时发生涟漪效应(Ripple effect)，从而降低系统的可维护性。关联进一步包含了前文讨论的组合和聚合关系，其中组合使用一端实心菱形和单向箭头的实线表示，聚合采用一端空心菱形和单向箭头的实线表示，分别如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/aggregation.png" alt="Aggregation" /></p>

<p><img src="http://content.hanyi.name/images/object_oriented/composition.png" alt="Composition" /></p>

<p>UML中的大部分工具实质上都是为了设置约束，但仅通过图形标记无法表示所有类型的约束，因此UML支持使用{}表示自定义的约束。自定义约束的具体形式没有严格限定，可以是自然语言、伪代码，也可以采用对象约束语言(Object constraint language, OCL)。</p>

<ul>
<li>对象图(Object diagrams)，是指系统在某个时间点的对象快照，也被称作实例图。虽然类图能够完整表达对象的结构信息，但有时候并不容易理解，对象图能够以某个真实案例对前者进行补充。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/object_diagram.png" alt="Object diagram" /></p>

<ul>
<li>包图(Package diagrams)，指一组类或嵌套包的集合。包也被称作命名空间(Namespace)，其作用是定义比类层次更高的系统结构。包图在UML中使用带标签名的方框表示，包之间也可以定义类似类图中关系。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/package_diagram.png" alt="Package diagrams" /></p>

<ul>
<li>部署图(Deployment diagrams)，指系统的物理结构，特别是软件及其所运行的硬件框架。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/deployment_diagram.png" alt="Deployment diagram" /></p>

<ul>
<li>组合结构图(Composite diagrams)，指对一个类的内部结构进行层级表示，从而使其更容易被理解。以类TV Viewer为例，下面是TV Viewer的类图:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/composite_structure_1.png" alt="Class diagram of TV Viewer" /></p>

<p>如果用组合结构图进一步描述TV Viewer，则如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/composite_structure_2.png" alt="Composite structure diagram of TV Viewer" /></p>

<ul>
<li>组件图(Component diagrams)。在UML中，组件是一种从功能角度上看可以独立分发和升级的模块。组件图用于表示组件之间的交互关系，如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/component_diagram.png" alt="Component diagram" /></p>

<ul>
<li>时序图(Sequence diagrams)，表示一组对象及其之间的协作关系。具体来说，时序图通常限定在一个单独的场景下，包含了一组对象以及依据用例而发生的对象间消息传递，特别是展示了消息发生的顺序信息。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/sequence_diagram.png" alt="Sequence diagram" /></p>

<p>在时序图中，由于第一个消息通常不在参与者(Participants)中，因此也被称作<strong>创始消息</strong>(Found message)。另外，时序图中的参与者是可以被动态创建和销毁的。同时消息传递过程也支持循环、分支以及异步等特性。</p>

<ul>
<li>状态机图(State machine diagrams)，也称作状态图，表示单个对象的整个生命周期行为。在面向对象中状态具体包括了对象中所有属性值的集合，而状态图则侧重于抽象的状态定义，即提供不同的事件响应方式。一个简单的状态图例子如下:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/state_machine_diagram.png" alt="State machine diagram" /></p>

<p>该状态图表示了一座城堡中的安全机关。图中方框表示一个状态，除了状态名之外，还可以填入状态的内部活动，包括状态事件(Event)、看守(Guard)和活动(Activity)，当某个事件发生时，可根据当前状态选择迁移(Transition)或保持状态不变。更进一步，状态既可以是静止的也可以是活动的，例如当前对象某个正在发生的动作。状态也可以被分组，其作用是表示组内所有子状态的同一个向外部某个超状态(Superstate)迁移的路径。</p>

<p>在并发场景中，单个状态可以被分割成几个正交的子状态图，一个闹钟的例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/concurrent_state_diagram.png" alt="Concurrent state diagram" /></p>

<p>该图中用一个历史伪状态标记代替了初始状态标记，意味着当开关打开时，初始状态应为上一次开关关闭时所处的状态。</p>

<p>值得注意的是，状态图对应着两种可能的实现，一种是采用控制流代码或面向对象实现，另一种是基于状态表的解析和查询。前者具有更加复杂的代码结构，且需要持续维护相关代码；后者需要在初期实现一个较复杂的状态表解析和查询特性，后期则主要集中于状态表的数据维护。无论采用哪一种实现，其最终代码都具有一定的样板特征，因此结合代码生成技术都是更好的选择。</p>

<ul>
<li>活动图(Activity diagrams)，表示过程逻辑的业务流程的行为，且通常是跨多个用例或线程的行为。先看一个活动图的例子:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram.png" alt="Activity diagram" /></p>

<p>从上例可以看出，该活动图与传统的流程图十分类似，最主要的区别在于前者支持并发活动，例如<strong>分叉</strong>(fork)操作可以产生并发的子活动，所有子活动的同步操作通过<strong>结合</strong>(join)进行。活动图中的动作(Action)之间使用流(Flow)或者边(Edge)进行连接，且可以被进一步分解成更多子活动，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_2.png" alt="Action decomposition" /></p>

<p>一般而言，活动图更多聚焦于描述业务过程而非实现，但通过分区(Partition)可以进一步表示不同动作的负责对象，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_3.png" alt="Partition" /></p>

<p>活动图支持基于信号的动作触发场景，信号可以被直接触发并接收，也可以通过定时器触发，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_4.png" alt="Signal" /></p>

<p>活动图还进一步支持采用动作方框下放置别针(Pin)表示该动作的输入和输出参数，如果某个动作的输出与下一个动作的输入参数不同，还需要使用参数变换(Transformation)使其一致。当一个动作会导致下一个动作触发多次时，可以采用扩展区域(Expansion regions)标记需要响应多次的动作集合，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_5.png" alt="Expansion regions" /></p>

<p>在该例中，扩展区域中的动作流程可能会部分导致终止，因此采用终止流(Flow final)进行标记。</p>

<ul>
<li>通信图(Communication diagrams)，在UML 1.x中被称作协作图(Collaboration diagram)，用于表示对象交互过程中的数据连接，如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/communication_diagram.png" alt="Communication diagram" /></p>

<p>通信图所表达的信息与时序图类似，形式相对灵活但不如后者规整，因此其受欢迎程度也不如后者。</p>

<ul>
<li>交互概述图(Interaction overview diagrams)，指结合了活动图和时序图的概述表示。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/interaction_overview_diagram.png" alt="Interaction overview diagram" /></p>

<p>交互概述图实际上是一种针对对象交互行为的整体表现方案的总结。</p>

<ul>
<li>时间图(Timing diagrams)，表示单个或一组对象交互的时间约束。特别是当对象的某个状态存在一定时间约束时，如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/timing_diagram.png" alt="Timing diagram" /></p>

<ul>
<li>用例图(Use case diagrams)，表示系统的功能需求。用例(Use case)是一种对用户与系统或系统自身交互的描述。用例更注重用户的一般目标，与用户场景(User scenario)不同，后者详细描述了用户与系统的每一步交互(这里的用户不仅指人类)，如果交互过程中发生分支则产生新的场景。也就是说，一个用例包含了许多用户场景。下图是一个用例图的例子:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/use_case_diagram.png" alt="Use case diagram" /></p>

<p>用例是对系统功能的更高级描述，与极限编程中的用户故事(User stories)相比，后者侧重于表示系统特性，且可以用于安排迭代计划，而用例则是单纯的系统功能性描述。在具体实践中，一个特性可能直接对应用例，或者用例中的一个步骤，也可能对应于其中一个场景。而大多数情况下用例要比特性具有更粗的粒度。</p>

<h2>结论</h2>

<p>本文首先讨论了面向对象的核心概念；随着面向对象编程的流行，开发中面临的问题复杂度不断提升，由此催生了面向对象建模技术。UML旨在实现语言无关的通用建模语言，被广泛用于面向对象分析(OOA)和设计(OOD)等活动。另一方面，随着相关国际标准的建立，UML也逐渐变得更加臃肿，因此实践中，视实际情况选择性地对工具进行裁剪就变得尤为重要。</p>

<h2>引用</h2>

<p>BMR97, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/POO-2016-01/documentos/Object%20Oriented%20Software%20Construction-Meyer.pdf">Object-Oriented Software Construction</a></p>

<p>UML17, <a href="https://www.omg.org/spec/UML/">The unified modeling language specification</a></p>

<p>MFR03, <a href="https://martinfowler.com/books/uml.html">UML Distilled</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(7)]]></title>
    <link href="http://www.hanyi.name/blog/2019/01/24/software-design-and-architecture-notes-7/"/>
    <updated>2019-01-24T14:29:52-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/01/24/software-design-and-architecture-notes-7</id>
    <content type="html"><![CDATA[<h2>编程范式(Programming Paradigms)</h2>

<p><em>作为专业程序员，对方法论的持续抽象绝对是一项明智的长期投资。</em></p>

<p>Robert W. Floyd在1978年图灵奖颁奖礼上如是说[RWF79]，这里所说的“方法论”即<strong>编程范式</strong>(Programming Paradigms)。<strong>范式</strong>一词源自Thomas S. Kuhn的《科学革命的结构》，Kuhn认为过去数个世纪的科学变革，实质上是主宰范式的更替，而这些范式却都曾在一段时期内常自认为能够独立揭示科学的内涵[TSK62]。具体到程序设计领域，范式表示为编程活动中存在的公共风格或方法论。例如，结构化编程可看作是上世纪70年代的主宰范式，但并非唯一。即使是忠实的拥趸也必须承认，结构化编程在解决某些问题时并不理想，于是持续有诸如分支限定(branch-and-bound)、分治(divide-and-conquer)、状态机(state machine)等其他更高层级范式的提出。或许有人认为使用较为底层的编程范式照样可以完成绝大部分任务，但却低估了软件的运行效率和经济效益等重要因素。因此Floyd认为，编程技术得以持续进步的重要前提即是新范式的发明、阐释和交流。</p>

<h3>编程范式的概念组成(Conceptual Composition of Programming Paradigms)</h3>

<p>任何一种编程范式都可以被看作是由一组编程概念(Programming concepts)，通过组装内核语言(Kernel language)而形成[PVR04]。从数量上看，编程语言要比编程范式种类更多，编程概念则较少，假设存在n种概念，则理论上可以有2<sup>n</sup>种范式。下面以一些重要的编程概念为例：</p>

<ul>
<li><strong>变量</strong>(Variables)，通常由标识符(Identifier)和存储变量(Store variable)组成，前者相当于变量的名字，后者则是变量在内存中的实际位置。一个变量需要使用声明语句加以创建，例如：</li>
</ul>


<pre><code>declare
V=9999*9999
</code></pre>

<p>这里declare语句的作用相当于执行创建标识符和存储变量两个任务。</p>

<ul>
<li><strong>函数</strong>(Functions)。函数由标识符、参数列表和函数体组成，标识符的作用与变量一致，参数列表规定函数的输入，而函数体用于容纳一段程序代码，例如：</li>
</ul>


<pre><code>declare
fun {Fact N}
if N==0 then 1 else N*{Fact N-1} end
end
</code></pre>

<p>在该例中，Fact函数接受参数N，并且计算并返回N的阶乘。值得注意的是，函数体中的代码包含了条件表达式，以及对应于阶乘数学定义的<strong>递归</strong>表达式。递归使函数具有相对复杂的数学表达能力，例如求解组合数函数：</p>

<pre><code>declare
fun {Comb N K}
{Fact N} div ({Fact K}*{Fact N-K})
end
</code></pre>

<p>尽管该函数体只有一条语句，但精确反映了组合数的数学定义。但需要注意，Comb函数本身需要依赖之前定义的Fact函数，这种使用已有函数组成新函数的形式，被称作<strong>函数抽象</strong>(Functional abstraction)。</p>

<ul>
<li><strong>表</strong>(Lists)。当参与计算的数达到一定数量，就需要一个方便的方式表示数的集合了。例如计算杨辉三角( Pascal’s triangle)，其实质是对组合数在自然数序列上的枚举，即“从n中取k个数”，其中n为自然数序列，k则是从0到n范围内的自然数，在杨辉三角中n表示三角形的行数，而k表示为列数。那么为了保存该问题中的数列，就需要引出表的定义：</li>
</ul>


<pre><code>T=[5, 6, 7, 8]
</code></pre>

<p>表实际上是一条由连接构成的链，其中每个连接由两部分组成：表元素和剩余链部分的引用。Lisp语言使用cons函数动态地在表中创建新的连接，类似地这里用H|T表示cons，例如：</p>

<pre><code>H=4
T=[5, 6, 7, 8]
M=H|T
</code></pre>

<p>该例中M的值为[4, 5, 6, 7, 8]。反过来，也可以在一个表中实现逆cons操作，例如：</p>

<pre><code>L=[5 6 7 8]
{Browse L.1}
{Browse L.2}
</code></pre>

<p>这里L.1输出5，L.2输出为6, 7, 8。</p>

<p>表通常支持<strong>模式匹配</strong>(Pattern matching)操作，目的是更方便对表进行分解，例如该例中的case指令：</p>

<pre><code>declare
L=[5 6 7 8]
case L of H|T then {Browse H} {Browse T} end
</code></pre>

<p>这里case通过指定一种cons模式对表L进行分解，并使用H和T两个局部变量保存分解后的值，该局部变量的作用域仅限于case语句的then..end代码块内。</p>

<ul>
<li><strong>基于表的函数应用</strong>(Functions over lists)</li>
</ul>


<p>现在设计函数计算杨辉三角，计算原理是，对于第n行数列，分别将其左移一位和右移一位生成两个新的数列(末端补0)，然后将两列相加，即得到第n+1行数列。下面用自上而下法编程解决该问题。</p>

<pre><code>declare Pascal AddList ShiftLeft ShiftRight
fun {Pascal N}
    if N==1 then [1]
    else
        {AddList {ShiftLeft {Pascal N-1}} {ShiftRight {Pascal N-1}}}
    end
end
</code></pre>

<p>该函数在最顶端模拟了前述文字描述的算法，其余函数可分别表示为：</p>

<pre><code>fun {ShiftLeft L}
    case L of H|T then
    H|{ShiftLeft T}
    else [0] end
end
</code></pre>

<pre><code>fun {ShiftRight L} 0|L end
</code></pre>

<pre><code>fun {AddList L1 L2}
    case L1 of H1|T1 then
        case L2 of H2|T2 then
            H1+H2|{AddList T1 T2}
        end
    else nil end
end
</code></pre>

<p>可以看出，当程序引入了函数和表操作时，其复杂度也相应增加。那么应如何判别该程序的正确性呢？</p>

<ul>
<li><p><strong>正确性</strong>(Correctness)。程序的正确性验证是一个非常复杂的问题，因为它不仅涉及编写的程序本身，还依赖对编译器、运行时系统、操作系统、硬件环境乃至其它物理因素的正确性验证。因此对程序的正确性验证首先要确定一个合理范围，并假设范围之外的部分是可信的，例如要验证前面计算阶乘的代码片段，通常需要经过以下步骤：1. 建立对应编程语言中各种操作的数学模型，称作语义模型。2. 定义程序的行为，通常是对程序输入和输出的数学定义，称作程序的规格说明。3. 基于1的语义模型，借助数学方法推导程序的运行结果，从而证明程序符合2定义的规格说明。</p></li>
<li><p><strong>复杂度</strong>(Complexity)。这里主要指时间复杂度。观察前面给出的Pascal函数，{Pascal N-1}在函数体中出现了两次，由于其递归的特性，最终计算量将正比于2<sup>n</sup>，从而当输入稍大时就会导致很长的运行时间。为了提高程序运行效率，可以消除一次{Pascal N-1}的计算，所以有：</p></li>
</ul>


<pre><code>fun {FastPascal N}
    if N==1 then [1]
    else L in
        L={FastPascal N-1}
        {AddList {ShiftLeft L} {ShiftRight L}}
    end
end
</code></pre>

<p>改进后的程序时间复杂度达到了n<sup>2</sup>的多项式时间，从而远好于之前的指数时间。理想状态的时间复杂度应尽量满足低阶多项式时间。</p>

<ul>
<li><strong>懒求值</strong>(Lazy evaluation)。一般而言被直接调用的函数会立即被计算，这种模式被称作及早求值(Eager evaluation)，与之相反则被称作懒求值。在懒求值下，计算只会在其结果被需要时发生。懒求值对于程序代码的优化有一定意义，如下例：</li>
</ul>


<pre><code>fun lazy {Ints N}
    N|{Ints N+1}
end
</code></pre>

<p>如果Ints函数是及早求值，那么调用该函数会直接进入死循环，直到调用栈溢出，但懒求值则不会。例如：</p>

<pre><code>L={Ints 0}
case L of A|B|C|_ then {Browse A+B+C} end
</code></pre>

<p>该例只会导致Ints被执行三次，模式匹配中抽出的A、B、C将等于列表中的前三个数。与及早求值相比，懒求值其实意味了对程序的更多控制权，避免像普通的递归函数一样过早进行了大量计算。</p>

<ul>
<li><strong>高阶编程</strong>(Higher-order programming)。如果需要计算一个杨辉三角的变种，例如每行数列的获取不是通过对上一行的数做加法，而是改用减法、异或等算术表达式，那么最直观的方法就是对Pascal程序进行改造，特别是替换FastPascal函数中的AddList为新的函数调用。这就导致FastPascal函数可能需要频繁修改，甚至重复才能满足不同类型的计算需求。高阶编程允许将函数作为另一个函数调用的参数，从而满足统一的代码实现：</li>
</ul>


<pre><code>fun {GenericPascal Op N}
    if N==1 then [1]
    else L in
        L={GenericPascal Op N-1}
        {OpList Op {ShiftLeft L} {ShiftRight L}}
    end
end
</code></pre>

<p>GenericPascal就是理想的统一代码实现，允许通过Op传递所需的计算函数，避免了计算功能需要扩展时再次发生修改的可能。</p>

<ul>
<li><strong>并发</strong>(Concurrency)。真实世界中存在大量相互独立、且根据自身情况决定执行节奏的活动，这被称为“并发”。除非程序建立了通信机制，否则并发的活动相互间不会发生干涉。程序中的并发通常借助线程实现，如下例所示：</li>
</ul>


<pre><code>thread P in
    P={Pascal 30}
    {Browse P}
end
</code></pre>

<p>当线程代码开始运行时，尽管Pascal函数的执行需要较长时间，但程序本身依然会继续向下执行。</p>

<ul>
<li><strong>数据流</strong>(Dataflow)。如果某个操作引用了一个尚无法被绑定的变量，例如在并发编程中，该变量正在被另一个线程所绑定，那么理想的行为是请求绑定的一方陷入阻塞，直到获得该变量的绑定，这被称为数据流。例如：</li>
</ul>


<pre><code>declare X in
thread {Delay 10000} X=99 end
{Browse start} {Browse X*X}
</code></pre>

<p>上例中X*X会发生阻塞，直到X被主线程绑定。</p>

<ul>
<li><strong>显式状态</strong>(Explicit state)。与并发类似，真实世界中也会存在某种行为依赖于历史记录的情况，这就需要程序语言的函数具有维持内部状态的能力，大多数情况下我们把这种状态保存在变量中，这里使用<strong>内存单元</strong>(Memory cell)表示，以便和前文同样提到的变量概念进行区分。下例显示了如何在FastPascal中引入显式状态：</li>
</ul>


<pre><code>declare
C={NewCell 0}
fun {FastPascal N}
C:=@C+1
{GenericPascal Add N}
end
</code></pre>

<ul>
<li><strong>对象</strong>(Objects)。对象即带有内部状态的函数，一个包含多个函数的对象例子如下：</li>
</ul>


<pre><code>declare
  local C in
  C={NewCell 0}
  fun {Bump}
    C:=@C+1
    @C
  end
  fun {Read}
    @C
  end
end
</code></pre>

<p>本例中local..end定义了变量C的作用域范围，也就是说C对local..end定义的代码范围之外的部分不可见，即<strong>封装</strong>(Encapsulation)。封装意味着隔离了对象状态与程序的其它部分，从而具有了信息隐藏的特性。此外，该对象还包含两个方法：Bump和Read实现对其状态的操作，即对象的<strong>接口</strong>(Interface)。一旦对象的接口能维持一致，那么客户程序就无需了解对象具体的方法实现，并能够直接调用任何具有相同接口的对象方法，这种特性即多态(Polymorphism)。在封装和多态背后，针对接口与其实现的分离即<strong>数据抽象</strong>(Data abstraction)的实质。</p>

<ul>
<li><strong>类</strong>(Classes)。对象极大提升了程序的可复用性和可维护性，那么如果程序中需要超过一个对象呢？一种解决办法就是创建一个“工厂对象”，将其用于生产更多的对象，这个工厂对象即<strong>类</strong>(Class)。下例演示了如何利用函数创建类：</li>
</ul>


<pre><code>declare
fun {NewCounter}
C Bump Read in
  C={NewCell 0}
  fun {Bump}
    C:=@C+1
    @C
  end
  fun {Read}
      @C
  end
  counter(bump:Bump read:Read)
end
</code></pre>

<p>该例中NewCounter函数每次调用都能返回一个具有独立内部状态以及Bump和Read函数的新函数(对象)，即利用了前文提到的高阶编程的概念。对类的使用如下所示：</p>

<pre><code>declare
Ctr1={NewCounter}
Ctr2={NewCounter}
</code></pre>

<p>其中Ctr1和Ctr2相当于独立的对象，程序进而可以通过.操作符调用其中的方法，例如：</p>

<pre><code>{Browse {Ctr1.bump}}
</code></pre>

<p>值得注意的是，截至目前我们介绍了类和对象的概念，但这并非<strong>面向对象编程</strong>(Object oriented programming)的全部，也不意味着使用类和对象的编程概念就可以被称为“面向对象语言”。</p>

<ul>
<li><strong>非确定性和时间</strong>(Nondeterminism and time)。当程序具有并发和状态等概念时，问题就会变得更加复杂，这是因为并发所引起的线程时序是非确定的，而状态的改变也会因此变得不稳定。这里需要强调，非确定性本身不会带来问题，只有当程序中的非确定性具有可观测性时，进而引发的竞争条件才会导致潜在问题。</li>
</ul>


<pre><code>declare
C={NewCell 0}
thread
  C:=1
end
thread
  C:=2
end
</code></pre>

<p>在本例中，从字面上无法判断出在某个时刻变量C的值，即所谓的可观测非确定性。在这种情况下，程序的线程之间会因为<strong>交叉存取</strong>(Interleaving)问题而变得极不稳定，因此避免和限制交叉存取是保证高质量程序的重要经验之一。</p>

<ul>
<li><strong>原子性</strong>(Atomicity)。解决交叉存取问题的途径之一就是引入原子操作(Atomic operation)。原子性意味着任何中间状态都无法被观测，即从初始态直接跳跃至最终态。原子操作的实现方法之一即引入锁(Lock)对象，锁保证了在任何时刻只有一个线程在其中执行，此时其它线程只能在锁外等待。例如：</li>
</ul>


<pre><code>declare
C={NewCell 0}
L={NewLock}
thread
  lock L then I in
    I=@C
    C:=I+1
  end
end
thread
  lock L then J in
    J=@C
    C:=J+1
  end
end
</code></pre>

<p>锁的使用一般包含两步操作：1.创建锁对象；2.使用锁对象加锁并执行目标代码。代码运行结束后锁对象被立即释放，后续线程可以继续对该对象加锁。</p>

<h3>编程范式的分类(Taxonomy of Programming Paradigms)</h3>

<p>由于概念——范式——语言之间的组合构成关系，理论上说出于更上层次范式和语言的数量相比较于编程概念而言是十分巨大的。然而在多数情况下，实用的范式应当是图灵完备的。例如函数式编程，基于头等函数(First-class function)或闭包(Clusure)的概念，因此其相当于和λ算子等价，从而可以被证明图灵完备。下面讨论由基本编程概念组合而成的编程范式类别，这种分类法覆盖了绝大多数的实用编程范式(在[PVR04]中也被称作计算模型)。</p>

<h4>声明式模型(Declarative model)</h4>

<p>作为最早出现也是最简单的编程范式类别，声明式是指通过定义数学函数实现编程，从而使其最易被推导和测试，也是所有其它类别的编程范式的基础。</p>

<p>声明式编程首先定义了语法(Syntax)和语义(Semantics)的概念，其中语法用于规定合法的语言形式，由于编程不可能像自然语言完全一样灵活自由，因此通常具有极为限定的语法形式和约束。一种常用的语法标记即扩展巴科斯范式(Extended Backus-Naur Form, EBNF)，其基本形式是从非终结符开始，由左向右列出记号(Token)序列，其中任何遇到的终结符可以被直接加入序列，而非终结符则需要被它的展开式替换，并在选择项(Choice)前任选一个作为替换。上述这种语法定义形式被称为上下文无关文法(Context-free grammars)，因为其非终结符在任何情况下的展开都是唯一确定的。须知上下文无关文法是可能会存在歧义的，例如：</p>

<pre><code>&lt;exp&gt; ::= &lt;int&gt;|&lt;exp&gt; &lt;op&gt; &lt;exp&gt;
&lt;op&gt; ::= + | *
</code></pre>

<p>对于表达式2 * 3 + 4来说，其解析树存在两种可能，一种的叶结点是2 * 3和4，另一种的叶结点是2和3 + 4。为了消除这种歧义性，编程语言层面会定义更多约束以保证确定性：例如确定运算符优先级或者定义计算表达式的默认方向。</p>

<p>在语义方面，无论现代编程语言被设计得多复杂，其底层一定是基于一个纯数学的、易于推导的模型，这种模型被称作内核语言。实际上，本文所讨论的编程范式，就是通过定义内核语言形成对编程语言的语义化翻译，进而更容易被机器或操作系统所识别。</p>

<p>声明式编程有时也被称为无状态式编程，也即以下两种编程范式的核心思想——<strong>函数式编程</strong>(Functional programming，例如Scheme和Standard ML)和<strong>逻辑式编程</strong>(Logic programming，例如Prolog)。以该范式为基础为编程语言构建了庞大的特性集合，例如大部分常用的语法规则、编译技术、内存管理技术和异常管理技术等，都超出了本文的主题。</p>

<h4>并发声明式模型(Concurrent declarative model)</h4>

<p>该范式在声明式编程的基础上引入并发的概念。在本文的编程概念部分就已经讨论过，并发本身并不显著提高复杂度，只有并发和状态同时存在时问题才可能会出现，即前文提到的可观测非确定性问题。并发声明式的主要特点在于数据流概念的引入，既保留了声明式编程的基本特征，也允许更加灵活的增量执行属性，且避免引入可观测非确定性。</p>

<p>一般的声明式编程都是按照语句的出现顺序、由左至右依次执行，这种执行方式即所谓的及早求值或数据驱动求值(Data driven evaluation)。在某些应用场景中，及早求值并非最佳方案。例如在同时包含生产者和消费者的程序中，传统的及早求值要求生产者确定是否已经发送了完整的数据，而如果由消费者来负责就能进一步保证处理后的数据完整性，后者就采用了懒求值的思想，也被称作需求驱动求值(Demand driven evaluation)。在声明式编程中引入懒求值的特性，即<strong>懒声明式模型</strong>(Lazy declarative model)。该范式允许在某些潜在的无限制数据结构基础上实现编程，更有利于资源管理和程序结构的模块化。</p>

<p>懒求值最早是在函数式编程中被发现，最初仅被视为声明式编程的一种执行策略，可用于帮助设计具有良好平摊性或最坏时间上界的算法；后来被进一步应用于包含声明式子集且更具表达性的范式中，强化其模块化特性。采用懒求值的例子包括Haskell和Miranda。</p>

<h4>消息传递并发式模型(Message-passing concurrent model)</h4>

<p>由于前文所描述的并发声明式编程不具备可观测非确定性，使其在描述能力上有所限制。例如经典的C/S系统，任何时刻服务器都无法预知客户端发来的下一条消息，而这在并发声明式编程中就无法实现。而消息传递并发式编程则在前者的基础上引入了一个异步通信信道，任何程序中的实体都能从该信道中写入和读取消息，从而满足了可观测非确定性编程的需求。该范式创建了一个具有关联流的信道——<strong>端口</strong>(Port)。任何实体可以向该端口发送消息，一个具体的作法是创建一个流对象并将其和对应端口相关联，这里称其为端口对象。于是，实体就可以通过该端口对象对其它端口对象发送和接收消息。一个端口对象通常是一个声明式的递归过程，从而使其拥有声明式编程的一部分特性。</p>

<p>采用消息传递并发式的例子包括Actor模型和Erlang。</p>

<h4>状态式模型(Stateful model)</h4>

<p>状态式编程，也称命令式编程(Imperative programming)。本质上状态式相当于声明式+显式状态的组合，这里的显式状态是指某个过程调用依赖于超出该过程生命周期的状态，且该状态没有出现在过程的调用参数列表中。状态式编程增强了范式的抽象能力，这种能力被视为构建复杂系统的关键。以传统的无状态编程为例，尽管程序中的一个过程可以根据外界传递的参数做出对应的行为，但这始终是针对特定输入而产生确定性结果。而对于状态式编程而言，其自身拥有了更多能力从而变得相对较“智能”，这也更接近对真实世界活动的模拟。</p>

<p>范式的抽象能力可以通过以下特性衡量：1.封装性；2.组合性；3.可实例化和可调用性。其中，封装性的意义在于，我们知道程序的可推导性能够保证其正确性，但显式状态的引入会使得程序推导变得十分困难，一个例子是带有<strong>边际效应</strong>(Side effect)的函数。而封装性的提高可以降低状态带来的不利影响，特别是维持不变量(Invariant)，这在一定程度上提高可推导性。</p>

<p>状态式编程能够描述出行为依据状态而发生变化的程序，从而进一步有利于模块化程序，且如果封装和不变量使用得当，则其会拥有与声明式编程相当的可推导能力。</p>

<p>在状态式编程的基础上，采用一组交互式数据抽象的集合描述最终程序，即<strong>面向对象式模型</strong>(Object oriented model)。这里的数据抽象具有状态化和对象化二元特性。状态化意味着模块化能力，而对象化则进一步启发了多态和继承——这就是面向对象编程的基本原理。多态允许更细粒度的模块化，在合理的职责划分下依旧能保证统一接口；而继承则开辟了增量式的抽象构建，使程序模块易于复用，从而降低潜在的开发成本。</p>

<p>在最近40年里，面向对象编程在工业界和学术界都得到了深入研究和广泛应用，并且在绝大多数现代编程语言中都得到了支持。</p>

<h4>共享状态并发式模型(Shared-state concurrent model)</h4>

<p>与消息传递并发式类似，共享状态并发式也提供了可观测非确定性编程的能力，区别在于后者借助了共享且可变的显式状态（这里称作单元）而非异步通信信道来实现。尽管实质上都是状态化，但共享状态并发式编程较前者具有更加复杂的实现。</p>

<p>前文已经提到，并发声明式编程不具备可观测非确定性，这点其实兼有利弊，特别是无法实现完全独立的并发线程，或是超过两条线程以上的通信，这也是状态化并发编程的主要目的。但是为了应对随之而来的即交叉存取问题，除了异步消息信道外，还可以通过引入锁、监控和事务等实现针对共享状态单元的原子操作，这些解决方案适用于不同的问题。</p>

<p>事实上，共享状态并发式编程在绝大多数语言中都得到了支持，这主要得益于状态式编程（特别是面向对象编程）的广泛应用。颇为讽刺的是，尽管这种范式可能受到了更加彻底的研究，但建立在其基础上的应用程序至今仍面临复杂且严峻的挑战。</p>

<h4>关系式模型(Relational model)</h4>

<p>声明式编程的基本特性源于数学计算，包括过程、输入参数、输出参数等概念。当一个给定输入参数集合仅有一组输出参数集合时，同样可以用关系式编程实现。后者比声明式具有更高的灵活性：1.允许有0至多个结果；2.输入参数和输入参数可以在每次调用时都不同。从而令关系式编程在数据库、歧义性语法解析和复杂组合问题的枚举实现等领域具有一定优势。</p>

<p>具体实现上，关系式在声明式基础上引入了<strong>选择</strong>(Choice)语句，这种选择语句能够通过搜索自由抽取出一个结果集，虽然算法是确定的，但最终结果仍然是非确定。Prolog的search特性就是基于这种范式的逻辑式编程语言。</p>

<h3>编程范式的比较(Comparison of Programming Paradigms)</h3>

<p>编程范式对软件工程的意义在于满足<strong>天然性</strong>(Natural)和<strong>高效性</strong>(Efficient)。天然性意味着相关程序使用了尽可能少的、与问题本身不相干的代码，例如某些纯技术原因导致的代码。一般采用<strong>模块化</strong>、<strong>非确定性</strong>和<strong>对接真实世界</strong>来衡量范式的天然性。高效性则意味着程序与解决同一问题的嵌入式编程只存在常数级差别。由于通常无法同时兼顾这两种属性，于是它们就成为衡量编程范式的重要工具。</p>

<p>声明式编程的简洁和可推导性，使得程序较易于保证正确性，尽管多数时候由于不可变(Immutable)数据类型而需要为计算结果开辟新空间，但这引来的性能损耗在真实场景中几乎可以忽略不计，因此总体上说声明式编程具有高效性。但在满足天然性方面，朴素的声明式编程首先并不具备模块化特性，除非向其注入显式状态；其次，虽然声明式编程支持并发，但由于本身不支持状态，从而不具备可观测非确定性；由于前两者不满足，声明式编程也就不具备对接真实世界的特性。因此可以认为声明式编程并不具备良好的天然性。</p>

<p>状态式编程一般要求程序采用顺序执行，但真实世界的实体通常既是状态的也是平行的，这就需要引入并发来解决这一问题，即增加可观测非确定性。另一方面，在分布式环境中，状态的存储也面临一致性和效率问题，于是导致了一套复杂的一致性等级和协调算法解决方案，极大提升了状态式编程在解决分布式问题中的复杂度。这些问题对面向对象编程同样适用，而对后者而言，其相较于其它范式显然更符合天然性要求，这也是其流行至今的原因之一。</p>

<p>在并发编程方面，并发声明式作为基于数据流的、最简单的并发编程范式，无疑是实现确定性并发编程的最佳工具；真实世界中更多时候面临着可观测非确定性问题的挑战，于是推动了消息传递和共享状态两种应对方案的出现。对于消息传递并发式来说，程序描述了一批相互协调的活动实体，更加适用于多代理场景，例如通信；而对于共享状态并发式来说，程序描述了一批实现一致性修改的数据仓库，适用于以数据为中心的计算场景。而事实上，这两种范式在真实的软件工程实践中是可以并存使用的。</p>

<h2>结论</h2>

<p>编程范式用于描述编程活动中的风格和方法论，该问题是软件设计和实现的共同基础。本文首先介绍了编程范式的基本组成和重要的编程概念，并在此基础上进一步介绍了一种编程范式分类法[PVR04]，并在此基础上对不同类型的编程范式进行了比较。了解这种分类法能够便于理解编程语言的动机和设计原理，并且掌握语言发展的历史、现状和趋势，从而为进一步构建得以实用的软件设计提供更好的理论和技术储备。</p>

<h2>引用</h2>

<p>[RWF79], <a href="https://dl.acm.org/citation.cfm?id=359140">The Paradigms of Programming</a></p>

<p>[TSK62], <a href="https://projektintegracija.pravo.hr/_download/repository/Kuhn_Structure_of_Scientific_Revolutions.pdf">The Structure of Scientific Revolutions</a></p>

<p>[PVR04], <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.7366&amp;rep=rep1&amp;type=pdf">Concepts, Techniques, and Models of Computer Programming</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(6)]]></title>
    <link href="http://www.hanyi.name/blog/2018/12/09/software-design-and-architecture-notes-6/"/>
    <updated>2018-12-09T10:53:07-05:00</updated>
    <id>http://www.hanyi.name/blog/2018/12/09/software-design-and-architecture-notes-6</id>
    <content type="html"><![CDATA[<h2>数据模型与数据建模(Data Model and Data Modeling)</h2>

<p><strong>信息系统</strong>(Information Systems)是人类社会重要的基础应用之一，也是计算机自诞生起最重要的应用领域。在计算机信息系统中，<strong>数据</strong>(Data)作为信息的主要载体，也是沟通人与硬件系统的桥梁，其复杂性不言而喻。可以说，本文涉及的数据模型与数据建模技术的发展，始终是以弥补人机之间的鸿沟为目标的。</p>

<h3>数据模型</h3>

<p>在设计信息系统时，为了应对信息的复杂性，人们利用<strong>数据模型</strong>描述数据元素、元素间关系及其与真实世界实体的映射，从而达成抽象且一致的信息表示。初期的数据模型包括<strong>文件系统模型</strong>(File System Model)、<strong>层级模型</strong>(Hierarchical Model)和<strong>网络模型</strong>(Network Model)等。</p>

<p>文件系统模型利用计算机文件系统模拟制表(Tabulation)，包含一般表格中的字段、记录等概念、且具备顺序和随机访问文件的能力，数据可按文本或二进制类型进行存储。这是一种非常简洁的数据模型，诸如csv、dsv等标准格式至今仍被广泛使用。</p>

<p>层级模型与文件系统模型拥有类似的字段和记录等概念，所不同的是记录之间可以按树形结构进行关联，从而表示记录之间的关系。相比较于文件系统模型，层级模型能够显式表达记录间的连接关系，并允许按照标准的树遍历算法进行数据遍历；缺点在于子记录只能拥有唯一的父记录，反过来则没有限制。发布于1966年的IBM Information Management System(IMS)就是基于层级模型构建。</p>

<p>网络模型旨在克服层级模型对关系限制的缺陷，允许每条记录拥有多个父记录和子记录。从<strong>数据模式</strong>(Data Schema)的描述上来看，网络模型的对象关系呈现出一个通用的网状结构，从而具有较层级模型更好的表达能力。1969年，数据系统语言委员会(CODASYL)下属的数据仓库任务小组(DBTG)发布了网络模型规范，该规范包括了一种用于定义数据模式的<strong>数据定义语言</strong>(DDL)，以及能够被嵌入宿主语言的<strong>数据操纵语言</strong>(DML)，首次提出了独立于宿主语言的数据语言的概念，并且通过国际标准化组织制定了多项标准。但是自诞生后，网络模型并未被工业界和学术界广泛接纳，并在此后十年的竞争中败给更具形式化能力的<strong>关系模型</strong>(Relational Model)和后续模型。</p>

<p>Edgar F. Codd在1970年提出了关系模型[EFC70]，其包含两个主要内容：</p>

<ol>
<li><p>对应于N个数据集合，使用N元关系组表达集合间的关系，使模型具备更精确的数学表达能力。</p></li>
<li><p>一种具有强描述能力的全局数据子语言，该语言基于结构化一阶谓词逻辑算子，能够用于表达基于关系模型的数据操作。</p></li>
</ol>


<p>关系模型为设计人员提供了统一抽象的界面，很好地隐藏了数据操作与底层系统交互的实现细节。但是也存在一些不足：</p>

<ol>
<li><p>根据关系模型的数学定义，集合之间的关系通过维护单独的N元关系组实现，其实质是集合间的笛卡尔积。但是通过这种形式化表示无法进一步揭示笛卡尔积的基数信息，而实践证明这种数量关系在描述数据模型时非常重要。</p></li>
<li><p>与问题1类似，关系模型的形式化表达缺乏一定的语义信息，无法进一步揭露关系的实质。尽管这种针对关系的语义信息不是始终必要的，但实践证明语义对数据模型的可表达能力具有重要意义。</p></li>
</ol>


<p>为了解决上述问题，Peter Chen进一步发展出了<strong>实体-关系模型</strong>(ER模型)，后者成为当前数据模型的重要描述工具和行业标准[PPC76]。ER模型包含四个主要概念：<strong>实体</strong>(Entity)，即现实世界的实例，通常是名词形式；<strong>关系</strong>(Relationship)，实体间的关联方式，通常是动词形式；<strong>类型</strong>(Type)，对实体的类别定义，通常是名词形式；<strong>角色</strong>(Role)，对实体在某个关系下的特殊定义，通常也是名词形式[PPC02]。</p>

<p>ER模型的一个重要技术是<strong>实体-关系图</strong>(ER Diagram，ER图)，即用图展示前述的概念及其联系，其中方框表示实体的类型；菱形表示关系；圆圈表示实体或关系类型的属性；实体类型关系和实体属性关系上还标注了数量关系。一个典型的ER图如下图所示。</p>

<p><img src="http://content.hanyi.name/images/data_model_and_data_modeling/er_diagram.png" alt="er diagram" /></p>

<p>尽管本节介绍的数据模型为数据表达提供了形式化工具，但是在面对复杂系统时，设计人员不可能凭空得出系统终极的数据表示，于是<strong>数据建模</strong>就成为支撑构建数据模型的重要方法论。</p>

<h3>数据建模</h3>

<p>实践表明，在软件需求分析起初就需要开始构建数据模型，数据建模应关注数据的需求和实现等特定方面。一般的数据建模过程依次产生下列三种数据模型：</p>

<ol>
<li><p>概念数据模型(Conceptual Data Model)，从高层角度描述系统的信息需求，具体包括主要的信息概念及其相互关系。1969年，网络模型之父Charles W. Bachman提出了数据结构图(Data Structure Diagram)[CWB69]，并将其用于描述概念数据模型。
<img src="http://content.hanyi.name/images/data_model_and_data_modeling/data_structure_diagram.png" alt="data structure diagram" /></p></li>
<li><p>逻辑数据模型(Logical Data Model)，描述信息中领域的具体结构，例如表、列及其关系等。在复杂度较低时，设计人员往往可以跳过概念数据模型，从而直接得出逻辑数据模型。该模型与概念数据模型都是独立于具体的持久化技术（例如通用的数据库管理系统）。</p></li>
<li><p>物理数据模型(Physical Data Model)，满足非功能需求的且可立即被实现的数据模型。该模型与存储技术、维护技术和更新/查询场景等因素密切相关。</p></li>
</ol>


<h4>数据分类</h4>

<p>在开始构建数据模型之前，需要首先识别系统需求中的数据分类，从而确定相应的问题范围，并使用相应的数据模型进行建模。实践中存在多种逻辑思维实践以实现前期的数据分析，[DMG08]描述了一种被广泛认可的数据分类方式，把数据按照特性划分为下列六类：</p>

<p><strong>主数据</strong>(Master Data)，表示业务需求中出现的人物、地点、事物等信息。</p>

<p><strong>事务性数据</strong>(Transactional Data)，表示业务发生时伴随的内部或外部事件或事务，例如发起订单、创建发票、支付等活动。</p>

<p><strong>引用数据</strong>(Reference Data)，表示被系统、应用、数据存储、进程、报表乃至事务性或主数据所引用的值或分类模式的集合，例如状态码、名词简写、产品类型等静态数据。</p>

<p><strong>元数据</strong>(Metadata)，表示数据本身的数据，方便数据的检索、解释和使用。</p>

<p><strong>历史数据</strong>(Historical Data)，表示在某个时刻发生、且不可修改的数据，例如日志。</p>

<p><strong>临时数据</strong>(Temporary Data)，表示因为某些技术需求而被临时创建的数据，通常没有独立的业务含义。</p>

<p>值得一提的是，上述分类方法只应被看作一个指导性原则，具体实践时应视上下文灵活调整。在本例中，对应前面提到的三种数据模型，概念数据模型通常考虑主数据和元数据，逻辑数据模型进一步包括了事务性和引用数据，物理数据模型最终实现覆盖全部类型的数据。采用前文提到的ER模型即可对这三种数据模型分别建模。</p>

<h4>关系范式</h4>

<p>在构建逻辑和物理数据模型时，为了能尽可能降低关系模型中的关系表示所带来的数据冗余，从而加强数据的一致性，关系模型提出了<strong>规范化</strong>(Normalization)的概念，以对关系表示本身进行约束，并在此后一段时间相继发展出了多种范式。其中常用的范式包括：第一范式(1NF)，即没有多值属性的关系；第二范式(2NF)，即满足第一范式且非主属性不依赖任何候选键的子集；第三范式(3NF)，即在第二范式的基础上不存在传递依赖。虽然规范化对强化数据一致性约束方面有促进作用，但其造成的后果是使许多数据表示被物理隔离，从而在实现数据操作方面引起额外耗费。因此在实际设计数据模型时，规范化设计的采用是和系统的非功能需求(Non-functional requirement)密切相关的。</p>

<h2>结论</h2>

<p>数据模型是信息系统设计的重要内容，在经历上世纪70年代的激烈竞争后，关系模型因占据理论高位更加受到学术界青睐，最终成就了80年代起通用关系型数据库系统的统治地位。ER模型和ER图因其更具表达能力，从而成为最重要的数据建模工具。数据模型方法领域的先驱Bachman(网络模型)、Codd(关系模型)和Chen(ER模型)也先后因其开创性贡献而获颁图灵奖。</p>

<h2>引用</h2>

<p>CWB69, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.172.3370&amp;rep=rep1&amp;type=pdf">Data Structure Diagrams</a></p>

<p>EFC70, <a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf">A Relational Model of Data for Large Shared Data Banks</a></p>

<p>PPC76, <a href="https://www.csc.lsu.edu/~chen/pdf/erd-5-pages.pdf">The Entity-Relationship Model-Toward a Unified View of Data</a></p>

<p>PPC02, <a href="https://csc.lsu.edu/~chen/pdf/Chen_Pioneers.pdf">Entity-Relationship Modeling: Historical Events, Future Trends, and Lessons Learned</a></p>

<p>DMG08, <a href="https://dl.acm.org/citation.cfm?id=2821563">Executing Data Quality Projects: Ten Steps to Quality Data and Trusted Information</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(5)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5/"/>
    <updated>2018-10-23T11:42:00-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5</id>
    <content type="html"><![CDATA[<p>上接<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">软件设计与架构笔记(4)</a></p>

<p>前文描述的HIPO模型是一个典型的基于结构图的IPO系统设计模型，其基本思想依然是由顶至下，逐步求精。基于经验Larry进一步总结了通用的系统设计准则[SMC74]。</p>

<ol>
<li><p><strong>程序结构</strong>和<strong>问题结构</strong>。减少程序变更所造成影响的重要方法之一，就是保证设计结构匹配问题本身的结构。由顶至下的思维模式会天然形成一种层级结构，因此重点在于如何决定设计单元在相同层级，或隶属于不同层级，而关键又在于理解问题本身。</p></li>
<li><p><strong>模块控制范围</strong>和<strong>决策影响范围</strong>。控制范围指模块以及归属于该模块的子模块的集合；影响范围指某个设计决策所造成变更的所有模块集合。当设计决策的影响范围尽可能位于该决策所在的模块控制范围之内时，该系统设计就可以被认为是“简洁”的。保持简洁性的方法之一可以是提升某些决策相关的元素的层级；或者把受到相同决策影响，但位于不同控制结构的模块重新划分至相同控制范围。</p></li>
<li><p><strong>模块大小</strong>。模块的实际大小可被用于描述潜在问题的信号。过小的模块可能缺少功能性绑定，而过大的模块可能涵盖了超过一个功能性绑定。前者可以通过inline的方式消除以减少模块规模，后者由于可理解性和可读性问题需要进行进一步拆分。</p></li>
<li><p><strong>错误</strong>和<strong>文件终止处理</strong>。当模块的一部分功能需要通知其调用者发生某件错误时，可通过返回某种错误参数实现，该参数的值最好是二元类型，对于流数据处理的EOF标记也需要进行类似处理。同时这些参数也不应该包含如何处理当前错误的信息，而是由调用者决定。当然，如果模块本身不需要错误标记时，系统设计就更简洁了。</p></li>
<li><p><strong>初始化</strong>。某些模块由于需要依赖初始化操作，从而可能存在“简洁”但导致“弱绑定”的设计。例如，读模块的access方法可能会遇到“文件未打开”的错误，如果选择将错误信息返回，调用者自然会选择调用open方法然后重新read；但另一种维护“黑盒性”的做法是，在access内部遇到该错误时自动通过open和reread进行恢复，那么调用者就不需要知道“文件未打开”这种错误并且重复进行处理了。</p></li>
<li><p><strong>模块选择</strong>。消除重复的功能，而非消除重复的代码。如果只是通过抽取的方式简单消除重复代码，那么有可能导致某个变更造成更多的修改。一种识别该问题的方法是，关注那些被其它不同模块调用，以及调用其它不同模块的对象，判断是否存在其子功能与不同的模块集合关联的情况，如果是则意味着存在层级或模块缺失的可能。</p></li>
<li><p><strong>隔离软件规格说明</strong>。软件设计规格的重要内容就是描述特定的数据类型、记录布局以及索引结构，设计应尽量使其与系统其他模块进行隔离，从而减少规格变更导致的重写。</p></li>
<li><p><strong>参数数量</strong>。尽量减少模块间调用的参数数量（不只是个数），如果参数中存在一个完整的数据记录，应尽量只传递必要的数据记录，否则也会导致该记录的变更对模块造成潜在影响。</p></li>
</ol>


<h3>结构化分析(Structured Analysis)</h3>

<p>随着软件设计方法论的发展和问题复杂度的增加，人们发现设计不再是解决复杂系统面临的唯一难题。比如，传统的软件设计过程一般是按由顶至下的方法，依照<strong>需求规格说明(requirement specification)</strong>给出具体的软件对象定义，那么如何构建规范合理的需求规格说明呢？另外，如果软件设计过程愈加复杂，是否可以按照经典的分治法(divide-and-conquer)对其进行分解和简化呢？</p>

<p>世界上存在多种多样的原始需求形态，例如采用<strong>文字叙述(narrative)</strong>可以说是最普遍的形式之一。当问题复杂度增加时，软件设计已经不能从简单的叙述中加以消化并诞生，于是就出现了<strong>需求分析</strong>的过程。这种把问题从原始形式转换成可进一步规范设计的规格说明的过程，被称为<strong>系统分析</strong>。<strong>结构化分析</strong>作为软件系统分析最早流行起来的方法论，是在早期工业界数十年的探索中发展起来的。</p>

<p>由于传统的文字叙述不足以表达复杂系统，人们开始重视并使用符号语言，例如德国数学家Carl Adam Petri发表于1962年的<strong>Petri Net</strong>。60年代中期，女数学家Erna Schneider Hoover在贝尔实验室领导了一支团队，其目标是分析电话交换机系统的性能和宕机时间，Erna使用了Petri Net来模拟复杂的电话交换系统。受此启发，同时困扰于晦涩难懂的叙述式规格说明的年轻工程师Tom DeMarco由此开始开发一套网络符号语言，由此发展并最终在1978年发表了<strong>结构化分析</strong>方法[TOM78]。</p>

<h4>结构化分析与传统系统分析</h4>

<p>Tom认为传统的系统分析包含如下目标：</p>

<ol>
<li><p>确定最优化目标。</p></li>
<li><p>生成该目标的细节描述，并且能够被后期的实现过程用于评估该目标是否实现。</p></li>
<li><p>生成该目标相关的重要参数预测，包括花费、收益、日程以及性能特性。</p></li>
<li><p>得出所有被影响部分之上的项的并发性。</p></li>
</ol>


<p>为了达成这些目标，系统分析活动需要涉及用户沟通、撰写规格说明、损耗收益研究、可行性分析以及估算等。然而，这些活动都因高复杂性存在很多问题。针对这些问题，结构化分析进一步拓展了系统分析的目标：</p>

<ol>
<li><p>分析的产生物必须是<strong>可维护</strong>的，特别是针对<strong>目标文档(Target Document)</strong>。</p></li>
<li><p>必须采用有效的分割方法解决大小的问题，摒弃维多利亚小说式的规格说明。</p></li>
<li><p>尽可能使用<strong>图形表达</strong>。</p></li>
<li><p>必须区分逻辑和物理设计，并且基于此在分析师和用户之间合理分配职责。</p></li>
<li><p>必须在具体实现之前构建逻辑系统模型，使用户熟悉系统特性。</p></li>
</ol>


<p>同时，结构化分析描述了一系列可被用于不同分析阶段的工具：<strong>数据流程图(Data Flow Diagram, DFD)</strong>、<strong>数据字典(Data Dictionary)</strong>以及逻辑策略表达工具，例如<strong>结构化英语(Structured English)</strong>、<strong>决策表(Decision Tables)</strong>以及<strong>决策树(Decision Trees)</strong>等。</p>

<h4>数据流程图</h4>

<p>DFD是一种描述相互关联的过程的网络，其作用是帮助分割需求，并在撰写规格说明之前记录这种分割。与普通流程图的区别是，DFD只聚焦在数据流动的过程，因此基本没有任何关于循环或逻辑决策的控制信息。为了举例说明DFD，[TOM78]描述了一个软件咨询公司的自动化管理和运营辅助系统，该系统的功能包含了学员注册、支付、人员管理、课程管理等方面。下图是对该公司的早期运营模型的描述：</p>

<p><img src="http://content.hanyi.name/images/structured_analysis/logical_dfd.png" alt="Logical DFD" /></p>

<p>该图是一种Logical DFD，图中的输入被称作<strong>事务(Transaction)</strong>。以其中一条主要路径的部分为例，该路径共描述了5种事务：Cancellations, Enrollments, Payments, Inqueries和Rejects(这里指不属于前4种类型的事务的统称)，以及数据在这些事务间可能的流动关系。此外还有一种包含了系统具体实现信息的DFD，被称作Physical DFD。</p>

<p>DFD有时又被称作<strong>气泡图(Bubble Diagram)</strong>，原因是其描述数据转换过程的符号——气泡。此外DFD还包含<strong>命名向量</strong>，用于表示数据路径；<strong>直线段</strong>，表示文件或数据库；<strong>矩形(或称为源/入节点)</strong>，表示网络的起点或数据的接收者(通常是当前领域外的人或组织)。</p>

<p>DFD清晰地表达了工具的自然特征——如果DFD存在任何错误，也应当是显而易见、毋庸置疑的，这无疑减少了分析师与用户间产生认知分歧的可能。另一方面，实践证明DFD无论在概念描述或是建模方面都有显著价值。更重要的是，它提供了一种基于功能的系统分割方法，并且描述了不同部分之间的接口。在系统评审中，任何接口或过程的缺失都能够证明当前DFD的缺陷——这比纯粹的数学方式更加直观和有效。</p>

<p>在实际分析活动中通常使用分级数据流程图(Levelled DFD, LDFD)逐步求精分割系统功能。在LDFD中，通常存在3层、有时甚至更多层具有不同功能解析度的DFD。</p>

<p>Level 0，也被称为上下文图，通常仅包含一个气泡——也就是系统总的过程单位以及其它元素。这种图可以被用于和最宽泛的用户进行交流，例如干系人、业务分析员、数据分析员以及程序员。</p>

<p>Level 1，对上下文图的唯一气泡进行细分，将其分解成不同过程单位，以及相关的文件或数据库。</p>

<p>Level 2，进一步对Level 1进行划分，因此需要更多的文字和符号标记。</p>

<p>Level 3+，一般很少出现Level 3+的DFD，原因是这种级别的DFD可能存在过多的细节，从而导致难以沟通、比较和有效建模的问题。</p>

<h4>数据字典</h4>

<p>数据字典用于追踪和评估系统不同部分之前的接口，是对DFD的一种有效补充。以前面描述的系统DFD为例，过程3和7之间的数据流动Payment-Data，可以用如下公式进一步描述：</p>

<pre><code>Payment-Data = Customer-Name +              
               Customer-Address +
               Invoice-Number +
               Amount-of-Payment
</code></pre>

<p>换句话说，Payment-Data包括了该公式右值的所有数据项，且这些数据项需依序且非空。更进一步，数据字典还可能需要对某些数据项进行进一步描述，例如Invoice-Number：</p>

<pre><code>Invoice-Number = State-Code +
                 Customer-Account-Number +
                 Salesman-ID +
                 Sequential-Invoice-Count
</code></pre>

<p>与DFD类似，数据字典也是呈现了由顶至下的细分过程。每个DFD应该携带相应的数据字典描述，二者共同组成了系统分析的图形化产生物。</p>

<h4>逻辑策略表达</h4>

<p>逻辑策略表达用于替代传统冗长的文字叙述式的规格说明。最常见的结构化表达方式被称作结构化英语，例如采用按行缩进的方式表述不同层级的规格说明：</p>

<pre><code>If the amount of the voice exceeds $500.
    If the account has any invoice more than 60 days overdue.
        hold the confirmation pending resolution of the debt.
    Else (account is in good standing).
        issue confirmation and invoice.
Else (invoice $500 or less).
    If the account has any invoice more than 60 days overdue.
        issue confirmation, invoice and write message on the 
        credit action report.
    Else (account is in good standing).
        issue confirmation and invoice.
</code></pre>

<p>使用决策表表达上述规格说明，结果如下：</p>

<pre><code>                           RULES
CONDITIONS              1  2  3  4

1.Invoice &gt; $500        Y  N  Y  N
2.Account overdue
by 60+ days             Y  Y  N  N

ACTIONS

1.Issue confirmation    N  Y  Y  Y
2.Issue Invoice         N  Y  Y  Y
3.Msg to C.A.R.         N  Y  N  N
</code></pre>

<p>决策树的表达结果如下：</p>

<p><img src="http://content.hanyi.name/images/structured_analysis/decision_tree.png" alt="Decision Tree" /></p>

<h2>结论</h2>

<p>结构化设计为软件设计提供了有效的结构图工具，以及作者Larry富有经验的设计准则，至今仍极具指导意义。为了保证设计阶段能使用清晰有效的规格说明，结构化分析提供了强大的DFD分析工具和规格说明描述工具，尽管其核心依然是逐步求精的设计思想，但已经开始涉足于比编程活动更加宽泛的软件工业领域，最终形成了较为独立的需求工程，成为软件构建过程中不可或缺的环节。</p>

<h2>引用</h2>

<p>SMC74, <a href="https://ieeexplore.ieee.org/document/5388187">Structured design</a></p>

<p>TOM78, <a href="https://books.google.com/books/about/Structured_Analysis_and_System_Specifica.html?id=7o0-AAAAIAAJ">Structured Analysis and System Specification</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(4)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/"/>
    <updated>2018-10-12T15:28:06-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4</id>
    <content type="html"><![CDATA[<h2>结构化分析与设计方法(Structured Analysis and Design Methods)</h2>

<p>除了指导<a href="http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2/">程序设计</a>，结构化方法还被广泛应用于系统分析和设计领域，成为软件设计方法论的开端。从时间轴来看，从结构化编程到结构化程序设计，再到软件的结构化设计和分析，软件设计的方法论是从底向上发展的，其根本推动力是日益增加的系统复杂性。</p>

<h3>结构化设计(Structured Design)</h3>

<p>1974年，Larry Constantine等提出了一系列通过降低系统复杂性，从而提高编码、调试、修改等工作效率的软件设计思想，并将其统一命名为结构化设计[SMC74]。通用的结构化设计思想包括<strong>简洁性</strong>和<strong>可观测性</strong>，其中，简洁性作为衡量和评估设计方案的主要度量指标，体现在分割后的系统模块间具有设计、开发、更正、修改的独立性；可观测性则体现了软件易被感知功能和原理的能力。尽管系统分割具有良好的工程意义，但其引起的模块间重叠部分代码以及相互关系反而可能会增加复杂性。前文我们已经介绍了信息隐藏这一重要的模块化概念，结构化设计则提出了一个更具实践意义的设计指标：<strong>耦合(coupling)</strong>。</p>

<h4>耦合</h4>

<p>通常情况下，更少或更简洁的模块间连接就意味着更好的可理解性，同时变更或出错所引起的模块间传递也会受到抑制。系统复杂度不仅体现在模块间的连接数量，更体现在每个连接所承担的关联强度，这种强度的度量被称作<strong>耦合度</strong>。强耦合意味着高复杂度，造成模块难以被理解、修改和更正的后果。因此，软件设计可以通过建立模块间的弱耦合降低系统复杂度。</p>

<p>一个特定连接产生的耦合度是一个包含多重因子的函数，这些因子包括连接复杂度、连接指向模块自身亦或其内部、连接所发送或接收的内容等，Larry将其归纳为三个主要的耦合因子：接口复杂度、连接类型和通信类型。耦合度受这三个因子的变化规律如下表所示：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">Coupling</th>
<th style="text-align:center;">Interface complexity</th>
<th style="text-align:center;">Type of connection  </th>
<th style="text-align:center;">Type of communication</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">Low     </td>
<td style="text-align:center;">simple,obvious      </td>
<td style="text-align:center;">to module by name   </td>
<td style="text-align:center;">data                 </td>
</tr>
<tr>
<td style="text-align:center;">        </td>
<td style="text-align:center;">                    </td>
<td style="text-align:center;">                    </td>
<td style="text-align:center;">control              </td>
</tr>
<tr>
<td style="text-align:center;">High    </td>
<td style="text-align:center;">complicated,obscure </td>
<td style="text-align:center;">to internal elements</td>
<td style="text-align:center;">hybrid               </td>
</tr>
</tbody>
</table>


<p>Larry认为，弱耦合应具有接口简单直观，只通过名字引用其它模块，以及尽量仅通过数据进行通信等特征，反之则会增加耦合度。具体来说：</p>

<ol>
<li><p>接口复杂度，指模块间接口是否能清晰地表述连接，而不是包含了过多的信息导致难以理解。特别当多个模块通过共享一个公共环境(common environment)实现交互时，该公共环境中任意元素的增加都可能会导致系统整体复杂度的显著提升。例如在M个对象中，存在M(M-1)对相互关系，假设这些对象之间的公共环境包含N个元素，那么就有NM(M-1)对一阶关系，亦即变更或错误传递的可能路径数量。可见接口复杂度对系统整体复杂度的显著影响。</p></li>
<li><p>连接类型，指模块间相互关联的形式，例如仅通过模块名字进行关联，还是进一步引用了模块内部的元素。在后一种情况下，该模块内部的修改很可能传递至其它依赖它的模块，导致潜在的复杂度增加。</p></li>
<li><p>通信类型，指模块间通信内容的形式。对于系统中任何有效模块，其或者通过传递数据实现通信，或者通过被“控制”进行某项任务。显然，仅通过数据实现通信的接口更易被理解，而控制类型的通信使模块功能难以被直观理解。</p></li>
</ol>


<p>实现<strong>弱耦合</strong>的途径不一，一个方向是尽量降低元素间关系发生在不同模块间的可能，简单来说就是最小化模块间的关联，并且保证元素间关系只发生在相同模块内部。为了验证元素间关系是否都存在于模块内，Larry同时给出了一个描述模块内部元素间相互绑定程度的指标：<strong>内聚(Cohesiveness)</strong>。</p>

<h4>内聚</h4>

<p>由前述可知，实现内部高度绑定的模块，就能够达到降低耦合的目标，即模块自身的强内聚性。一般而言，对模块内聚程度的描述可以被划分成如下六个层级（由弱到强的非线性关系）：</p>

<ol>
<li><p>巧合的(Coincidental)。例如元素通过某种模块化方法被“无意间”划分到某个共同模块中，或者某个模块的创建仅仅是为了消除重复代码。在这种情况下，模块极易因为变更而变得“不可重用”，因此这类绑定只是发生于巧合之中。</p></li>
<li><p>逻辑的(Logical)。这种关系通常隐含了某种逻辑联系，例如负责程序中所有输入输出的模块，或者负责操作所有数据的模块。其问题在于，以此类关系实现的模块易存在内部元素间的相互缠绕，从而降低元素间的独立性，同时也会导致模块接口的复杂性增加。</p></li>
<li><p>一时的(Temporal)。该关系建立在逻辑层面的关系基础上，同时元素间还存在某种时间上的一致性。例如程序的初始化、终止、清理等阶段的操作，其元素间存在一定的功能逻辑，同时也常一起发生。尽管如此，这种关系依然存在于逻辑层面类似的缺陷。</p></li>
<li><p>通信的(Communicational)。元素间通过相同输入/输出数据集合的引用进行关联，例如“打印”和“装订”文件，显示出更强的绑定关系。</p></li>
<li><p>连续的(Sequential)。如果某个元素的输出恰好是另一个元素的输入，即意味着目标问题可以通过简单流程图进行描述和解决，那么其存在连续的强绑定关系。但需要注意，这种过程式处理会导致该模块独立于程序的其它功能部分，从而使其难以被其它系统模块复用。这也是连续层面与进一步功能层面关系所导致的内聚度存在较大差距的原因。</p></li>
<li><p>功能的(Functional)。在这种层面的关系下，模块中的元素都与同一个独立功能相关。一种判断某个模块是否为功能层面的绑定的方法是，通过一句话描述该模块功能，然后进行验证：</p>

<ol type="a">
<li><p>该句是否为复合句，是否包含逗号、多个动词等等，如果是则该模块可能包含连续或通信层面的绑定；</p></li>
<li><p>如果语句中包含时间相关的词，那么可能存在一时或连续层面的绑定；</p></li>
<li><p>如果语句中动词的操作对象不是一个特定对象，那么可能存在逻辑层面绑定；</p></li>
<li><p>如果语句中包含初始化、清理等词，说明可能是一时层面的绑定。</p></li>
</ol>
</li>
</ol>


<p>值得注意，元素间可能存在多个上述的关系，而通常我们可以使用其中内聚度表现最高的关系表示整体程度。但是如果模块中没有一组元素的关系表现为功能层面绑定，那么该模块的内聚性就表现较低。</p>

<h4>可预测模块</h4>

<p>模块的可预测性是指当给定相同的输入时，该模块每次被调用所发生的操作也完全相同，亦即独立于环境的特性。不可预测的模块不一定是存在错误的，例如当模块内部维持某种状态，该状态在针对当前模块的操作下会发生不断变化，从而导致返回结果或实际发生操作的不同。这种不可预测的模块在实际应用中经常发生，尽管是无错误的。模块的可预测性，有时也被成为“黑盒性”，使该模块能较容易被清楚地理解，例如通过简单的注释、描述性的名字或者良好定义的接口等方法。</p>

<h3>结构化设计技术</h3>

<p>软件设计过程可以被看作包含一般设计和详细设计两个部分。一般设计的目的在于确定系统需要的函数有哪些(回答what)，详细设计描述如何实现这些函数(回答how)。这些设计阶段需要确定函数标识、函数范围结构的调用参数和调用关系、所关联的模块等信息，并且保证模块能够被独立设计、实现和测试。</p>

<h4>结构图(Structure Chart)</h4>

<p>传统的流程图方法能够描述代码块执行的顺序和条件分支，但是在一般设计阶段，由于我们侧重于了解what，流程图会不可避免地增加设计复杂度。因此这里介绍一种较为简单的结构图用于表述函数及其调用关系。结构图所包含的符号标记如下图所示：</p>

<p><img src="http://content.hanyi.name/images/structured_design/definitions_of_symbols_used_in_structure_charts.png" alt="Definitions of symbols used in structure charts" /></p>

<p>假设某系统设计包含三个模块，分别是A、B和C，其中模块间的关系是A调用B，B调用C；从执行顺序上看，B的代码会首先执行，然后是C，最后是A。那么上述信息可以分别用结构图和流程图表示如下：</p>

<p><img src="http://content.hanyi.name/images/structured_design/structure_chart_vs_flowchart.png" alt="Structure Chart vs Flowchart" /></p>

<p>从上图可以看出，相比于流程图，结构图能够清楚表示模块间关系，并且有潜力进一步描述模块的接口信息，这恰好是在一般程序设计阶段需要进行的工作，流程图就不具有优势。</p>

<h4>基于结构图的软件设计过程</h4>

<p>下面以设计一个较为复杂的模拟输入——处理——输出(Input Process Output, IPO)类型的系统为例，给出一种衍生自结构图、由IBM开发的基于层次输入处理输出(Hierarchical IPO)图的一般设计过程：</p>

<p>Step 1. 根据问题描述，绘出系统大致的功能性草图。本例中模拟系统的大致功能是一个数据输入、处理和输出的过程，其大致可以被描述如下：</p>

<p><img src="http://content.hanyi.name/images/structured_design/rough_structure_of_simulation_system.png" alt="Rough structure of simulation system" /></p>

<p>Step 2. 识别外部的概念数据流，指来源于系统外的、独立于具体物理I/O设备的相关数据流。在本例中，概念数据流包括输入参数、格式化的返回结果等。</p>

<p>Step 3. 识别问题中的主要概念数据流(包括输入和输出)，确定该问题的功能图中的“最高级抽象”节点。对于输入的数据流而言，其抽象节点存在于距离物理输入形态最远，但依然可以视作输入数据的阶段。本例中该节点可能在于构建矩阵阶段。同时，针对输出数据流可以把结果矩阵作为输出的抽象节点，如下图所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/determining_points_of_highest_abstraction.png" alt="Determining points of highest abstraction" /></p>

<p>Step 4. 根据前面步骤得到的信息，针对每个抽象输入数据节点，使用一个源模块(source module)表示其结构。相应设计对应的入模块(sink module)。通常系统存在一个源和入分支，具体参数依赖问题描述而定，但其通用模式如下图所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/the_top_level.png" alt="The Top Level" /></p>

<p>在本例中，模块A即系统入口，也就是说模块A的功能意味着整个问题的解决；模块B用于获取主要数据流；模块C用于把主要输入流变换成主要输出流；模块D用于处理主要的输出数据流。</p>

<p>Step 5. 针对源模块，通过识别其中最后一次变换操作，生成当前模块的数据返回形式，然后再识别前一次变换的抽象节点。对于入模块，与源模块相反，通过识别其中第一次处理操作，确认抽象输出节点，直到获取期望的输出形式。基于逐步求精的思想重复步骤5，直到抵达最初的源模块和最后的入模块。构建出的部分结构图如下所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/lower_levels.png" alt="Lower Levels" /></p>

<p>在这一逐步求精的设计过程中，划分的终止条件因具体问题而异，通用的判断方法之一即前文提到的耦合与内聚等设计思想。</p>

<p>（未完待续）</p>

<h2>结论</h2>

<p>结构化设计的兴起使结构图及其衍生工具成为软件设计领域的重要工具。同时，在软件设计模块化道路上的深入实践也促使许多重要的软件设计思想被提出，诸如耦合、内聚等重要概念被广泛用于指导包括结构化设计及后续的设计方法论，影响至今。</p>

<h2>引用</h2>

<p>SMC74, <a href="https://ieeexplore.ieee.org/document/5388187">Structured design</a></p>
]]></content>
  </entry>
  
</feed>
