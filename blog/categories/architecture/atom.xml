<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Wing of Dream 梦境之翼]]></title>
  <link href="http://www.hanyi.name/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://www.hanyi.name/"/>
  <updated>2021-11-04T21:27:31+08:00</updated>
  <id>http://www.hanyi.name/</id>
  <author>
    <name><![CDATA[Han Yi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(18): 面向质量属性的架构模式]]></title>
    <link href="http://www.hanyi.name/blog/2021/11/04/software-design-and-architecture-notes-18/"/>
    <updated>2021-11-04T21:50:48+08:00</updated>
    <id>http://www.hanyi.name/blog/2021/11/04/software-design-and-architecture-notes-18</id>
    <content type="html"><![CDATA[<p>截至目前我们已经讨论了若干种架构风格，实际上绝大多数工程实践都具备一定的架构风格(尽管有些风格是显式定义、有些则是隐式存在的)。显式地定义架构风格有助于维护架构设计的稳定性，例如表现该设计是基于C/S、SOA、REST或反应式架构风格，以及在应用架构风格时引入的自定义部分。某些被广泛采用的架构风格，有时也有另一个名字——<strong>架构模式</strong>(这里主要指基础架构模式)。风格与模式是完全不同的概念，前者通常更具理论性和抽象性，多用于描述设计指南或方法论；后者更注重实践性和可复用性，且通常遵循一套标准的模式语言(这得益于<a href="http://www.hanyi.name/blog/2019/03/29/software-design-and-architecture-notes-11/">面向对象设计模式</a>的流行)，具有更精确的问题域和规范说明。而接下来首先要讨论的基础架构模式则兼具风格和模式的属性，它们具有普遍适用性，擅长于复杂问题的高层架构设计，当然也包含明确的结构和行为约束。此外还有数量更多的架构模式专注于解决特定场景中的问题，尽管这些问题可谓五花八门，但大部分的根本动机是改善架构质量属性，这也是本文讨论架构模式的主要视角。下一篇文章会从应用场景的角度讨论架构模式。</p>

<h3>基础架构模式</h3>

<p>基础架构模式产生于对复杂问题的初步认知和分解，类似构建思维导图，良好、清晰的系统结构往往是深入解决方案的前提。例如网络通信系统，先有经典的OSI七层模型，也有流行的TCP/IP五层模型，这里应用了分治策略把一个复杂问题分割为几个子问题(层)，同时定义了子问题之间的关联方式。再例如一个信息系统可被划分为如下层次：表现层、领域层、数据驱动层。这种由上(外)及下(内)的层次结构，相邻层通过预定义的接口实现服务式交互，即下层作为服务提供者，上层作为消费者，即架构模式中最经典的<strong>分层模式</strong>(Layered Pattern)。分层模式表现出的优势在于:1)层次间相互独立；2)每层可复用；3)每一层可替换；4)易于理解，从而有利于维持架构设计的一致性。</p>

<p>分层模式并非万能，特别是某些糟糕的分层设计可能会导致较高的设计复杂度，比如虽然表面上实现了层次间的独立，但仍然存在大量逻辑和数据耦合，导致每层内部的变更不得不传递至外部——从相邻层乃至跨多层的级联变更，结果反而造成更高的维护成本和引发质量问题。同时，由于引入了层次间隔离，大多数分层设计会损失性能，在进行性能调优时也可能与该层的功能性划分冲突，导致更大范围的变更影响。分层模式的另一个挑战是软件的容错性:例如在设计错误处理时，除错误的描述以外，还要额外考虑错误处理的职责分配、处理方式、跨层传递以及其它现实因素。一种常见原则是在尽可能低层处理发生的错误，然后把错误信息传递给上层，其优点是避免由上层单独维护大量的错误处理场景。但上层通常也需要被告知错误信息并做出反应，甚至直达交互界面，以及方便运行时排错和易用性。因此，错误处理通常要在全局设计阶段进行考虑。</p>

<p>基础架构模式中还有一种常见的、类似水厂工艺流程的流水线(Pipeline)结构。在流水线中，原水被输入管道。依照标准工序，原水需要经过若干过滤方法处理，每道工序由对应的过滤器负责，过滤器从上游管道接收水进行加工，再把处理后水输入下游管道，再由后续过滤器处理——最终获得符合标准的自来水。在数据处理系统中，原始数据作为原水流经数据管道，管道中的过滤器依次对数据进行处理——这就是<strong>管道——过滤器模式</strong>(Pipe &amp; Filters Pattern)。如果把过滤器视为层，那么管道——过滤器模式可以看作是分层模式的一种特例，特别是在可复用性、可替换性等方面的优势对数据处理系统来说更具价值。此外，该模式还支持可伸缩性:1)支持流(增量)数据的高效处理，因为上游过滤器不需要处理完全部数据再交给下游，从而减少整体等待时间；2)支持分块数据的高效处理，采用并行计算的能力实现过滤器的横向伸缩，缩短整体处理时间。</p>

<p>管道——过滤器模式也存在对应陷阱，比如一般要求过滤器之间应当完全独立，因为耦合意味着可能需要提供全局状态——这就限制了该模式在可伸缩性方面的优势，也可能会损害整体可维护性。此外，过滤器的接口设计也十分重要，例如Unix中的管道接口统一采用标准字节流，并不规定具体数据格式，因此管道两端的程序都需要实现相应的数据转换。这种方式的优点是保证高可移植性，但会增加数据序列化/反序列化的维护成本和系统开销。在许多实践中，上述成本远远超过了过滤器自身的负载需求。管道——过滤器模式还具有较分层模式更严重的容错性问题。因为不同于分层模式的“双向”通信，管道——过滤器一般是“单向”的，上游一般无法及时了解下游的错误状态，一种方法是引入全局状态管理错误信息，在此基础上实现过滤器同步——无疑会导致复杂性、可维护性以及性能等方面的损失。因此，数据处理系统一般尽量避免引入复杂的错误处理逻辑，只聚焦在错误信息采集和管理——意味着一旦错误发生，只能通过重启整条流水线来恢复系统。而如果系统对容错性有很严格的要求，则只有考虑更普适的分层模式作为妥协。</p>

<p>实践中还有许多复杂性问题是非确定的，例如天气/地震预报、语音识别乃至自动控制系统(机器人、无人驾驶或导弹防御系统等)，凭借当前科技水平很难找到一个精确的模型能够与之对应。因此，为了不断优化得到更合理的结果，通常会考虑组合多种近似模型进行协作。其中，单一模型可能是复杂但相对确定的，多个模型间的协作方式则不确定。如果把每个模型视为独立组件，也就不存在一个固定的组件间依赖结构。这时可以采用中心化结构，即通过一个控制器控制组件协作，并且每个组件只从数据中心获取或写入数据，即<strong>黑板模式</strong>(Blackboard Pattern)。该模式包含三个基本元素:</p>

<ul>
<li><p>黑板，即数据中心，向知识源和控制器开放读写功能。可以是文件系统、数据库或消息队列等。</p></li>
<li><p>知识源，即组成整体解决方案的组件，例如各种传感器、雷达、车辆控制器、武器发射控制器等。</p></li>
<li><p>控制器，负责控制知识源的运行。</p></li>
</ul>


<p>从结构上看，黑板模式可能是最复杂的、但也最灵活的一种架构模式。灵活性在于组件只需要考虑针对黑板的增删改查，由控制器负责监控黑板状态并调度组件执行，组件间几乎完全解耦。黑板模式同样具有良好的独立性、可复用性、可替换性和易修改性，还包括容错性——因为知识源只从黑板中读取和写入数据，组件错误不会发生级联传递。黑板模式主要的缺点在于响应性和复杂性，前者主要是由于组件间通信的不确定性，导致缺少可预估且合理的系统响应时间；后者是因为应用该模式所需的额外复杂度，整个工程包括前期设计、实现、调试和测试等活动都会面临挑战，当然其中一部分原因是问题自身的不确定性。</p>

<p>至此本文已经讨论了三种基础架构模式，它们分别代表了架构设计中的最基本结构：层次结构、流水线结构和中心化结构。尽管这些结构具有普适性，但也存在相应的陷阱，并最终影响着架构的质量属性。实践中还存在更多针对特定质量属性的架构模式，本文的后半部分将主要讨论这些模式。</p>

<h3>面向可伸缩性的架构模式</h3>

<p>可伸缩性是分布式系统架构的一个重要质量属性。在<a href="http://www.hanyi.name/blog/2021/06/27/software-design-and-architecture-notes-17/">上一篇文章</a>中，我们讨论了几种分布式系统架构风格的演变过程，上文提到的基本结构也普遍存在于分布式系统中。但是，仅凭这些无法实现分布式系统的可伸缩性:例如，分布式组件虽然通常都是物理隔离的，但是组件间的逻辑依赖依然存在。无论是点对点(Peer-to-Peer)结构还是主从(Master-Slave)结构，都无法避免产生组件间协作的需求。最基本的，例如服务调用方需要首先知道服务提供方的地址，这就导致组件间的动态耦合，从而限制了系统的可伸缩性。为解决该问题，实践中通常会引入一个独立的中介组件，服务提供方组件能够在中介组件中动态注册，而服务调用方只需要向中介组件发送消息，再由中介把消息交付至服务提供方——这样通过操作中介组件即可协调各个组件，这就是分布式系统架构的<strong>中介模式</strong>(Broker Pattern)。</p>

<p>中介模式是分布式系统的核心模式之一，如今已发展成为分布式架构的重要基础设施。中介模式的优势在于实现了分布式组件的动态解耦，并且把分布式系统协调的职责尽可能从业务组件中分离，使分布式系统开发的复杂性得到了有效管理。另一方面，中介组件会影响系统的整体响应性，也存在单点失败的问题，为此一般需要采用资源冗余的方式来保证可靠性，采用中介模式的系统还面临可追踪性与可测试性的挑战。因而，采用中介模式无论如何都会引入额外的开发和维护成本。</p>

<h3>面向易用性的架构模式</h3>

<p>系统易用性主要体现在交互方面，而MVC也许是迄今为止该领域中最为人熟知的架构模式，它把交互式系统划分为三种抽象组件:1)模型，提供核心功能和数据；2)视图，定义信息的展示方式；3)控制器，处理用户请求。其中，模型的数据更改会通知视图更新；视图需要依赖模型数据进行信息展示，视图还可以接受用户指令，然后将指令传递给控制器；控制器根据用户具体指令，调用模型中的具体业务逻辑以更改数据，然后调用特定的视图展示修改后的结果。MVC的重要贡献在于在一定程度上分离了模型及其用户端表示，使得交互式系统具有更好的易修改性——这一点尤为重要，因为用户界面往往是系统中改动最频繁的部分，而MVC的职责划分使视图组件更易于修改。另一方面，尽管界面变更的影响得到了限制，但模型变更则可能影响到视图和控制器，从而引起可维护性问题。MVC模式先后衍生出许多变种MV*模式，例如表示-抽象-控制(Presentation-Abstraction-Control)模式，层级模型-视图-控制器(Hierarchical Model-View-Controller)模式，模型-视图-表示(Model-View-Presenter)模式，模型-视图-视图模型(Model-View-ViewModel)模式等，这些模式通过更多抽象旨在进一步简化特定场景的用户界面，但也更加复杂从而导致更多局限性，这里不再进一步展开。</p>

<h3>面向可适应性的架构模式</h3>

<p>可适应性的一个典型的例子是操作系统:向下要支持多种硬件环境，向上要运行海量应用程序。可适应性指系统适应外部需求变化的能力，这一般要依赖于抽象设计:一种方式是构建一个仅实现必要功能的核心组件并对外提供服务接口，以此为基础通过扩展服务实现其它功能，包括外部扩展的功能，即<strong>微内核模式</strong>(Microkernel Pattern)；另一种方式是允许外部环境通过接口改变组件功能和系统结构，即<strong>反射模式</strong>(Reflection Pattern)。下文进一步讨论这两种模式。</p>

<p>微内核模式要求核心组件只包含必要功能、高层结构和扩展接口，并尽可能把大多数功能分配给扩展服务。应用该模式需要先定义一个稳定的抽象内核，其它扩展功能只需要与内核实现交互。例如，通过硬件访问接口就可以把操作系统完整移植到不同的硬件平台。但是，微内核的前提是存在一个稳定的内核设计，这通常并不容易，因此会引入设计复杂度和试错成本。另一个挑战是针对性能可持续优化的能力，因为性能优化和抽象设计往往并不相互正交。</p>

<p>反射模式把系统划分为两层:元层(Meta level)和基础层(Base level)，其中元层用于定义软件自身的结构和行为，元层中的数据被封装在元对象(Metaobjects)中，例如类型定义、算法或者函数调用机制等信息。基础层用于定义应用的基本逻辑，其中的组件通过访问元对象实现具体功能。这样，元对象本身就成为系统对外的扩展点，从实现动态可扩展性。为了对外提供接口，反射模式定义了元对象协议(Metaobject Protocol, MOP)，允许客户端编辑元对象，从而影响基础层中的实际功能。反射模式旨在避免修改系统源代码的前提下实现系统功能扩展乃至变更，当然对降低软件的维护成本有积极意义，但是，这种灵活性是以牺牲可靠性为代价的，因为要验证元对象修改的正确性是十分困难的；同时，反射模式会显著增加系统的设计与开发成本；由于元层和基础层的相互交替也限制了系统性能及可持续优化能力。</p>

<h3>面向可用性的架构模式</h3>

<p>可用性是指系统对外持续提供服务的能力。系统会由于软硬件发生错误、维护等事件被迫停机而导致服务中断，一次关键服务中断可能会造成巨大损失。解决可用性问题的核心思想是引入冗余资源，并能够在错误发生时及时启用备用资源继续提供服务。但是，系统中的许多组件在运行时需要进行额外配置和管理，这些配置可能涵盖功能性和非功能性等方面，一旦配置更改需要进行重新构建组件等操作时就会迫使系统停机。一种解决办法是通过统一接口对外提供针对组件的状态控制和配置功能，包括组件的初始化、挂起、恢复、终止等，中央系统可以从组件仓库中请求获取组件，然后调用对应接口对组件进行动态配置，即<strong>组件配置器模式</strong>(Component Configurator Pattern)。</p>

<p>组件配置器模式的一个重要应用场景是热部署(Hot deployment)，目的是避免大型系统在日常维护时发生中断服务的情况，同时还有助于提高系统的灵活性和可维护性。但是，该模式会导致开发、运维应用以及基础设施的复杂度显著提升，并使系统的安全性与可观测性等方面面临更大挑战。</p>

<h3>面向安全性的架构模式</h3>

<p>安全性是指系统免于被破坏的能力。从架构设计的角度看，一个重要的安全原则是<strong>最小权限原则</strong>(Least Privilege Principle)，即任何个体只拥有访问它需要功能的权限。对此最常见的实践策略是<strong>身份和访问控制</strong>(Identity &amp; Access Control)，即当访问者向某个功能组件请求交互时，通过一个独立的安全组件对其进行验证和授权，后者可以选择允许或拒绝该次请求。由于每个功能组件的安全策略可能不同，因此需要功能组件提供一个可供外部拦截对其请求的接口，再由安全组件针对该接口实现验证或授权，即实现<strong>拦截器模式</strong>(Interceptor Pattern)。</p>

<p>拦截器模式的贡献在于隔离了功能性需求和非功能性需求例如安全性场景，此外还常被用于负载均衡、容错处理等其它场景中。但是，拦截器模式有时会因“过度灵活”而导致滥用，从而损害可维护性:例如一个功能组件被注册了多个拦截器，这些拦截器的影响并不正交，再结合执行序列问题，导致拦截器组件之间发生了逻辑耦合，额外增加了架构复杂度。</p>

<h2>结论</h2>

<p>本文讨论了几种经典架构模式[POSA96]，包括基础架构模式，以及面向特定质量属性的架构模式。但这只是架构模式领域的冰山一角，直至今日依然不断有新的架构模式被提出和讨论。架构模式也从最初的普适性，到跟随应用场景的变化不断细分。尽管经过快速发展，始终不变的是任何模式都会导致后果——即对质量属性的影响，亦即架构模式的动机与陷阱。</p>

<h2>引用</h2>

<p>POSA96, <a href="http://www.dre.vanderbilt.edu/~schmidt/POSA/">Pattern-Oriented Software Architecture</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(17): 架构风格演变——从Client/Server出发]]></title>
    <link href="http://www.hanyi.name/blog/2021/06/27/software-design-and-architecture-notes-17/"/>
    <updated>2021-06-27T16:50:48+08:00</updated>
    <id>http://www.hanyi.name/blog/2021/06/27/software-design-and-architecture-notes-17</id>
    <content type="html"><![CDATA[<p>我们可能听说过多种架构风格，不同架构风格之间往往不是非此即彼的关系，它们或可以被组合使用，或包含相同的成分，也可能存在各自的侧重方向。更重要的是，一组架构风格之间有时存在继承和发展关系，即本文要讨论的演变。人们通常更重视架构风格的具体内容，缺少理解架构风格的动机，极少了解背后隐藏的陷阱，而它们的重要性是依次上升的，这也从根本上导致了架构风格演变的产生。下文就以C/S架构风格的演变为例进一步讨论。</p>

<h2>起源——Client/Server(C/S)</h2>

<p>计算机网络的发明令计算资源的跨空间共享成为可能。受到这种能力所蕴含的经济价值驱动，人们在网络诞生初期就发明了集中式的计算设施(如Mainframe)以及更多相对轻量的工作站(如Workstation)，分散的工作站通过远程作业输入(Remote Job Entry)实现向Mainframe发送数据处理作业并由后者进行处理。这就是如今早已枝繁叶茂的C/S架构风格雏形。</p>

<p>虽然在诞生初期即取得巨大成功，但C/S也经历了曲折的发展时期。一个极端是终端逐渐控制台化，仅提供基本输入输出能力，如数据库管理系统(DBMS)。另一个极端是，随着个人计算机(PC)问世，各种新领域需求激增，在一段时期内受网络、硬件条件限制，人们不再满足于轻量化终端，开始推崇更强大的通用型计算机，富客户端(Rich client)概念由此产生(单机软件需求在这一时期也达到了巅峰)。而如今，互联网、云计算、移动/IOT等领域的应用无一不建立在C/S(B/S)的基础上，多以服务的形式提供给用户或其它服务。另一方面，如今很少人会专门谈论C/S，因为随着应用场景的丰富以及待解决问题的深入，人们更多关注C/S的某些细节领域，从而衍生出细分的架构风格。然而，前述演变与C/S本身的动机和陷阱息息相关。</p>

<p>作为一种中心化的分布式架构，C/S相较于非分布式架构天然地具有更多复杂性，从今天的工程角度看绝不应把复杂性作为首选项。但我们知道，C/S最根本的出发点是提高软件(计算资源)的经济价值，这种价值判断一般更合理地来自业务评估(尽管有时可能也会受到IT管理制约)，因此这种架构风格更多是被应用环境决定——这在如今互联网时代更加如此。</p>

<p>而C/S复杂性就在于，它把本就繁杂的<a href="http://hanyi.name/blog/2019/06/08/software-design-and-architecture-notes-15/">架构质量属性</a>的复杂度进一步提高了数个维度，且后果往往超出业务预料:</p>

<ul>
<li><p>可靠性，由本地环境到不稳定网络和共享服务端环境，可靠性保证的复杂度无疑显著增加。</p></li>
<li><p>易用性，在相似开发成本和客户端侧技术等条件下，C/S的易用性往往较差。</p></li>
<li><p>高效性，C/S的初衷是共享资源，从而提高利用率，但这并非是免费午餐。在满足相同服务等级的条件下，C/S要通过额外的动态资源调整以实现高效性。</p></li>
<li><p>兼容性，表现基本一致。</p></li>
<li><p>安全性，由于资源和服务共享的原因，C/S面临更复杂的安全问题。</p></li>
<li><p>可维护性，相同系统复杂性条件下，C/S具有更高的设计成本，也因此具备可维护性优势。但C/S产品通常被寄希望于覆盖更多业务场景，导致复杂度一般更高，也因此更难以维护。</p></li>
<li><p>可移植性，面向服务的C/S通常具有优势。但如果软件不是以服务的形式提供，而是所谓的On premise部署，其复杂性则会显著增加。</p></li>
</ul>


<p>C/S逐步流行后，针对上述挑战，逐渐衍生出诸多细分的架构风格，对过去半个世纪乃至今天的软件架构产生了深远影响。</p>

<h2>发展——远程过程调用(RPC)</h2>

<p>上文提到由于C/S的分布式特征，使其面临极高的复杂度，这里原因之一是网络通信的不可靠性。因此人们首先想到抽象出一个独立的通信层，该层负责向下管理进程间通信要解决的问题，向上为应用层提供面向通信领域的语言级接口，即本节要讨论的RPC。</p>

<p>从工程实践的角度看，RPC拥有曲折的发展历程，此类汇总文献很多，本文不再赘述。如今随着RPC成为分布式架构的基础元素之一，不同平台、语言、甚至科技公司都专门开发了方便落地的RPC框架和工具。这里把RPC视为一种架构风格，因为除了眼花缭乱的RPC实现，绝大多数RPC都集中在解决如下几个问题，且具有相似的针对性约束和模式:</p>

<h3>消息表示</h3>

<p>虽然定义为语言级，但为了保证兼容性，RPC需要采用中立的通信数据流，即不依赖任何具体的系统或语言。例如常见且兼容性好的JSON、XML、YAML，或开放但实际专属的Protobuff、Thrift、Java Object Serialization Stream Protocol等，这就需要RPC框架各自实现语言的内存模型和数据流之间的相互模式——序列化和反序列化。兼容性和高效性是这里最关注的质量属性。</p>

<h3>消息传递</h3>

<p>消息传递往往是RPC中功能最复杂的部分，它主要提供对网络传输的抽象，因此包括但不限于通信模型、地址、协议栈、异常/超时处理、安全、多线程、缓存等众多领域。如果一个RPC框架试图解决前述所有问题，就不得不需要借助更高级别的抽象，难以想象其复杂性和易用性。因此，如今轻量化成为RPC领域的主流。</p>

<h3>接口表示</h3>

<p>理想情况下，程序中的方法应可直接作为RPC的接口使用，这也是定位于语言级的初衷。但实际上如今流行RPC框架都拥有跨语言的特性，一种更流行的模式就是构建一个中立的接口层，使用语言无关的技术定义接口信息，再在语言层面映射到具体方法。例如gRPC中采用Protocol Buffers定义服务:</p>

<pre><code>service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
</code></pre>

<p>上述服务定义可以被直接编译成目标语言的客户端和服务端代码，从而作为接口被引用。</p>

<p>如今选择RPC更多是出于高效性或定制化的目的，即强烈依赖某些RPC工具的特性或特定场景。而一旦进入互联网的开放世界，这种依赖就成为普适性的阻碍，人们就会倾向于更加中立的架构风格。</p>

<h2>成熟——REST</h2>

<p>在互联网时代，应用面临着高效性、可维护性、简洁性和可靠性等方面更严峻的挑战。REST就是为了解决上述挑战而被设计和提出的，其本身由一套支持HTTP 1.1和URI标准协议的核心设计原则组成，后者已成为互联网标准之一。</p>

<p>REST的全称是表述性状态转移(REpresentational State Transfer)，它把互联网抽象成一个由Web资源组成的网络，用户通过资源标识符和相关操作符向应用发送请求，以获取目标资源或更改目标资源的状态。REST包含如下设计约束:</p>

<ul>
<li><p>C/S架构，即组件间的交互方式是以客户端向服务端的资源URI请求，由此获得响应。</p></li>
<li><p>无状态性，即服务端不直接保持与客户端的会话信息，如有需要应由客户端在发起会话时携带相关信息。无状态使服务端避免维持与多个客户端之间会话信息，从而保证高效性。</p></li>
<li><p>可缓存性，即Web资源应具有描述可缓存性的能力，并且客户端和其它中间设施应能够根据这些描述选择暂存相关资源，从而减轻服务端负载。</p></li>
<li><p>分层系统，通过划分出具有不同职责的中间层，实现负载均衡、缓存、认证和授权等具体特性。</p></li>
<li><p>统一接口，即组件间接口应遵循以下原则:</p>

<ul>
<li><p>采用资源标识符识别目标资源，资源表示支持多种格式，例如HTML、XML、JSON。</p></li>
<li><p>通过资源表示实现资源操作，特别是针对资源的增加、修改、删除操作，要求客户端首先应保持目标资源的表示。</p></li>
<li><p>自描述性消息，即消息本身应携带充分的描述，例如消息格式等信息，从而允许消费方能正确解析该消息。</p></li>
<li><p>HATEOAS(Hypermedia as the engine of application state)，即客户端只需要保留访问应用的初始URI，其他资源的URI应当由每次请求返回的资源本身提供。</p></li>
</ul>
</li>
<li><p>可编程客户端(可选)，通过编程的方式向客户端提供可供执行的程序，从而提高易用性。</p></li>
</ul>


<p>REST侧重于解决更广泛存在的问题，其绝对的中立性是一大优势。但另一方面，除了总结出互联网应用架构设计的基本约束，REST缺少具体的设计和实践指南。在一段时期内，人们忽视了HTTP协议的开放价值，反而推崇大厂商通过合纵连横试图达到垄断的标准。</p>

<h2>繁盛——面向服务架构(SOA)</h2>

<p>与RPC、REST关注高效性、简洁性等基础架构属性相比，<strong>SOA</strong>是在分布式场景下面向业务模型的更高层抽象。这里的服务对应业务活动单元，并且多个服务可以组合成为更复杂的业务活动单元，这是一种旨在适应业务模型的架构风格，也一度被认为是未来互联网的标准。</p>

<p>从技术角度看，SOA把组件划分成三个基本角色:服务提供、服务消费、服务注册，服务提供和消费方通过服务注册进行识别，从而实现相互通信，以此为基础构建分布式架构。由少数厂商联盟发起，在SOA发展伊始就陆续推出了一套基于Web的服务架构协议，即风靡一时的<strong>Web服务</strong>(Web services)。这些基于XML的协议族包括了:</p>

<ul>
<li>SOAP(Simple Object Access Protocol)，规定消息表示，具体包含消息属性和内容。下列代码片段是Google搜索引擎的SOAP消息封装:</li>
</ul>


<pre><code>&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;soap:Body&gt;
    &lt;gs:doGoogleSearch xmlns:gs="urn:GoogleSearch"&gt; 
      &lt;key&gt;00000000000000000000000000000000&lt;/key&gt;
      &lt;q&gt;REST book&lt;/q&gt;
      &lt;start&gt;0&lt;/start&gt;
      &lt;maxResults&gt;10&lt;/maxResults&gt;
      &lt;filter&gt;true&lt;/filter&gt;
      &lt;restrict/&gt;
      &lt;safeSearch&gt;false&lt;/safeSearch&gt;
      &lt;lr/&gt;
      &lt;ie&gt;latin1&lt;/ie&gt;
      &lt;oe&gt;latin1&lt;/oe&gt;
    &lt;/gs:doGoogleSearch&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt; 
</code></pre>

<ul>
<li>WSDL(Web Services Description Language)，规定接口表示。具体包括抽象类型定义(types)、参数具体类型(message)、接口和SOAP绑定(binding)和服务描述(service)。下列代码片段把ping命令的功能封装为Web服务，并用WSDL进行描述:</li>
</ul>


<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;definitions xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="uri:weblogscom" targetNamespace="uri:weblogscom"&gt;
  &lt;types&gt;
    &lt;s:schema targetNamespace="uri:weblogscom"&gt;
      &lt;s:complexType name="pingResult"&gt;
        &lt;s:sequence&gt;
          &lt;s:element minOccurs="1" maxOccurs="1" name="flerror" type="s:boolean" /&gt;
          &lt;s:element minOccurs="1" maxOccurs="1" name="message" type="s:string" /&gt;
        &lt;/s:sequence&gt;
      &lt;/s:complexType&gt;
    &lt;/s:schema&gt;
  &lt;/types&gt;
  &lt;message name="pingRequest"&gt;
    &lt;part name="weblogname" type="s:string" /&gt;
    &lt;part name="weblogurl" type="s:string" /&gt;
  &lt;/message&gt;
  &lt;message name="pingResponse"&gt;
    &lt;part name="result" type="tns:pingResult" /&gt;
  &lt;/message&gt;
  &lt;portType name="pingPort"&gt;
    &lt;operation name="ping"&gt;
      &lt;input message="tns:pingRequest" /&gt;
      &lt;output message="tns:pingResponse" /&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;binding name="pingSoap" type="tns:pingPort"&gt;
    &lt;soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http" /&gt;
    &lt;operation name="ping"&gt;
      &lt;soap:operation soapAction="/weblogUpdates" style="rpc" /&gt;
      &lt;input&gt;
        &lt;soap:body use="encoded" namespace="uri:weblogscom" encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" /&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="encoded" namespace="uri:weblogscom" encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" /&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
  &lt;service name="weblogscom"&gt;
    &lt;document&gt;For a complete description of this service, go to the following
URL: http://www.soapware.org/weblogsCom&lt;/document&gt;
    &lt;port name="pingPort" binding="tns:pingSoap"&gt;
      &lt;soap:address location="http://rpc.weblogs.com:80/" /&gt;
    &lt;/port&gt;
  &lt;/service&gt;
&lt;/definitions&gt;
</code></pre>

<ul>
<li>UDDI(Universal Description, Discovery, and Integration)，规定服务注册和发布等。下列代码片段用于把前面提到的ping服务发布在UDDI目录中:</li>
</ul>


<pre><code>&lt;businessEntity businessKey="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" 
                operator="www.weblogs.com/services/uddi" 
                authorizedName="xxxxxxxxxx"&gt;
  &lt;discoveryURLs&gt;
    &lt;discoveryURL useType="businessEntity"&gt;http://www.weblogs.com/services/uddi/uddiget?businessKey=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&lt;/discoveryURL&gt;
  &lt;/discoveryURLs&gt;
  &lt;name&gt;Services&lt;/name&gt;
  &lt;description xml:lang="en"&gt;Web services resource site&lt;/description&gt;
  &lt;contacts&gt;
    &lt;contact useType="Founder"&gt;
      &lt;personName&gt;XX XX&lt;/personName&gt;
      &lt;phone useType="Founder" /&gt;
      &lt;email useType="Founder"&gt;xx@xx.xx&lt;/email&gt;
    &lt;/contact&gt;
  &lt;/contacts&gt;
  &lt;businessServices&gt;
    &lt;businessService serviceKey="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" 
                     businessKey="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"&gt;
      &lt;name&gt;Ping&lt;/name&gt;
      &lt;description xml:lang="en"&gt;This is a ping service&lt;/description&gt;
      &lt;bindingTemplates&gt;
        &lt;bindingTemplate bindingKey="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" 
                         serviceKey="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"&gt;
          &lt;description xml:lang="en"&gt;SOAP binding for ping service&lt;/description&gt;
          &lt;accessPoint URLType="http"&gt;http://rpc.weblogs.com:80/&lt;/accessPoint&gt;
          &lt;tModelInstanceDetails&gt;
            &lt;tModelInstanceInfo tModelKey="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" /&gt;
          &lt;/tModelInstanceDetails&gt;
        &lt;/bindingTemplate&gt;
      &lt;/bindingTemplates&gt;
    &lt;/businessService&gt;
  &lt;/businessServices&gt;
&lt;/businessEntity&gt;
</code></pre>

<p>上述XML协议族看似提供了语言和平台无关的特性，但过度繁冗引发高效性的担忧。同时Web服务意图达到事无巨细，即便在今天也堪称过度设计，给当时软件开发造成了额外负担，与方兴未艾的敏捷运动背道而驰，却很少有人看到Web服务的真正价值。此外，Web服务的某些重要组件，例如其负责服务注册和通信的核心模式ESB(Enterprise Service Bus)在实践中引发严重的可维护性问题，企业往往投入巨资采购ESB却使得软件修改变得更加困难——成为过度设计的后遗症。因而尽管得到了大厂商鼓吹和投资，SOA包括Web服务终成昙花一现，逐渐被弃用。</p>

<p>必须承认，SOA同样也具有普适性的内核，许多SOA时代的设计成果如今已经成为<a href="http://hanyi.name/blog/2015/02/18/microservices-trap/"><strong>微服务</strong></a>最佳实践的一部分，区别是它们不再成为少数大厂商及其联盟的专利。</p>

<h2>回归——RESTful</h2>

<p>当人们面对Web服务浩如烟海的XML协议群焦头烂额之际，目光重新聚焦在轻量化设计，伴随敏捷开发运动兴起，Web服务的最初形式逐渐被弃用，取而代之的是RESTful和相关开源社区崛起。</p>

<p>RESTful提倡充分利用HTTP 1.1和URI等既有协议，思考包括资源表示、状态表示、语义化API、资源定位等核心约束。同时得以兼容开源社区对HTTP生态的高效性、安全性扩展，最终形成了互联网时代的标准参考架构。</p>

<p>本节之所以称为回归RESTful，是因为从RPC到Web服务，架构设计一直试图以不断分层的方式重新定义问题和寻找新的解决方案，以至于忽视了很多当时已经成熟的方案。例如一些Web服务采用RPC over HTTP方案，即把HTTP仅作为消息传递工具，再在其上重新设计一套复杂的RPC框架——相当于坐在汽车上重新造轮子。当然，对于组织内部应用来说这也许只是一种潜在的过度设计，实施起来并没有太大麻烦，但这种笨重性根本无法适用于开放的互联网时代。RESTful相比于Web服务的过度设计，后者存在许多冗余特性，且在既有HTTP协议中存在对等替代，例如:</p>

<ul>
<li><p>SOAP协议用XML重新封装了消息属性和内容，然后再用RPC或HTTP进行传递。但HTTP协议自带的头属性(Header)、内容(Body)、状态(Status)和方法(Methods)天然就拥有这种职责划分，且具备更好的性能。</p></li>
<li><p>WSDL协议用于描述服务接口、参数静态类型和消息格式，但在实际应用中很少有人会手写这些繁冗的信息，而是通过基于Java或C#等语言的工具自动生成WSDL，然后提供给需要服务的客户端应用，其目的是客户端可以通过方法调用的形式实现Web服务调用(与RPC类似)。这种接口层在某些封闭场景下可能是合理的，但在当前互联网时代只能是掣肘大于收益，缺少普适性。实际上，RESTful社区也曾经提出过一种同样基于XML但较轻量的WADL(Web application description language)作为替代协议，却永久停留在了文本阶段，甚至从未落地。</p></li>
<li><p>UDDI协议用于服务注册和发布，这是一种比WSDL更复杂的、希望把服务与业务需求关联起来并对外发布的目录协议，客户端可以使用UDDI查询并浏览可用的服务。遗憾的是，与其复杂的协议内容相比，UDDI这种超前设计实际缺少应用场景。今天的RESTful也只是实现了以开放API规范(OpenAPI Specification)等发布API功能和描述的最佳实践。</p></li>
</ul>


<p>RESTful在Web服务中的回归使人的注意力重新回到对设计本质的思考，最终形成具有普适性的Web API设计指南——RESTful API，并伴随着开源Web框架Ruby on Rails、Django推广并流行至今，产生了巨大影响力，在如今开源Web框架领域，已经很难看到不支持RESTful API了。</p>

<h2>展望——后RESTful时代</h2>

<p>RESTful已成为互联网时代最具标志性的架构风格，尽管由于各种原因，许多应用实际上并未严格遵循RESTful，也会在细分场景中寻找替代方案。例如，RESTful(或RPC)中的每一个Endpoint都要提供明确的接口描述，包括URI、请求内容、响应内容等。由于接口的特殊性，实践中因为需求变更导致接口变更是一个繁琐且容易引起BUG的过程。当在数据读取的场景中所需数据可能发生频繁变更时，GraphQL就成为RESTful之外的另一个选项。</p>

<p>GraphQL旨在提供一种长期稳定且一致的API接口，从而避免频繁接口变更，其实现思路与RPC over HTTP类似，即通过向单一Endpoint发送一个数据查询对象，再获得所请求的数据，因此这种API是可以根据客户端需求动态返回恰好所需数据的。与RESTful相比，GraphQL无法充分利用HTTP的固有特性，特别是URI、缓存、数据操作等，因此不得不引入额外依赖并导致复杂性，在实践中也面临较多限定条件，例如查询语言、实现框架等。因此，GraphQL通常是作为RESTful的补充，而非绝对替代。RESTful的普适性还体现在云计算、移动/IOT领域的广泛应用场景。在服务化思想盛行的今天，RESTful的中立和兼容性使其仍然是互联网应用的默认选择。</p>

<h2>结论</h2>

<p>本文讨论了架构风格演变，特别是从计算机网络诞生到互联网时代，架构风格从C/S一路发展到RESTful的整个过程，以及各个里程碑背后的动机和陷阱。对于架构质量属性，单独了解和掌握并不困难，但工程中往往需要综合考虑多个质量属性，这就要求针对相关设计约束进行系统管理，架构风格就是这个过程里每个里程碑输出的产品。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(16): 架构风格——反应式架构]]></title>
    <link href="http://www.hanyi.name/blog/2020/06/29/software-design-and-architecture-notes-16/"/>
    <updated>2020-06-29T15:20:02+08:00</updated>
    <id>http://www.hanyi.name/blog/2020/06/29/software-design-and-architecture-notes-16</id>
    <content type="html"><![CDATA[<h2>架构风格——反应式架构</h2>

<p>在过去10年，多核、云计算、移动/IOT、用户体验等相关领域的发展使传统上以可维护性为核心的软件架构面临着新的挑战，这主要体现在软件系统的<strong>即时响应性</strong>(Responsiveness)、<strong>回弹性</strong>(Resilience)以及<strong>弹性</strong>(Elasticity)等架构质量属性[JDRM14]。</p>

<p>即时响应性旨在合理成本范围内提供低延迟的用户体验。显然这并非是全新的质量属性，传统上围绕它的解决方案包括算法优化、摩尔定律等。然而，随着系统复杂性不断上升，即时响应性不可避免地受到损害，业界发明了许多技术解决这一问题。从架构角度看，这些技术可以被划分为<strong>纵向</strong>(Scale up/down)和<strong>横向</strong>(Scale out/in)两种基本的扩展方案。其中，前者以多核技术为代表，后者则依赖分布式技术，两者在架构方面互为补充。由此衍生的细分领域包括但不限于并发编程、分布式通信、数据一致性、节点协调、错误处理、职责分离等，这些技术在实践中形成了一系列设计原则和模式。<strong>反应式架构</strong>(Reactive architecture)就是以这些原则和模式为基础、进而发展为一种面向现代高即时响应性的软件系统的架构风格。</p>

<h3>多核与反应式编程</h3>

<p>多核技术提供了纵向的单机扩展能力，但要利用这种底层能力离不开上层并发编程的支持。经典的并发编程框架如Java Concurrency[BG99]，提供了最接近底层且功能强大的并发编程API，例如下列一个爬虫的代码片段(例子来源于互联网):</p>

<pre><code>public class Crawler {
   private ConcurrentHashMap&lt;String, Boolean&gt; seen = new ConcurrentHashMap&lt;String, Boolean&gt;();
   private AtomicInteger pending = new AtomicInteger(0);

   public Crawler(String baseUrl, int numOfThreads) {
       this.client = HttpClientBuilder.create().build();
       this.baseUrl = baseUrl;
       this.executorService = Executors.newFixedThreadPool(numOfThreads, new ThreadFactory() {
          public Thread newThread(Runnable r) {
              return new Thread(r, "Crawler-Worker");
           }
       });
   }

   public void start() {
       handle(baseUrl);
   }

   private void handle(final String link) {        
      if (seen.containsKey(link))
          return;
      seen.put(link, true);
      pending.incrementAndGet();
      executorService.execute(new Runnable() {
          public void run() {
              List&lt;String&gt; links = getLinksFromUrl(link);
              for (String link : links) {
                  handle(link);
              }
              pending.decrementAndGet();
              if (pending.get() == 0) {
                  synchronized (lock) {
                      lock.notify();
                  }
              }
          }
      });
   }
}
</code></pre>

<p>客户端代码如下:</p>

<pre><code>public class Main{
    public static void main(String[] args) throws InterruptedException {
        if (args.length != 2) {
            System.err.println("Invalid syntax: &lt;baseUrl&gt; &lt;numOfThreads&gt;");
            System.exit(1);
        }
        String baseUrl = args[0];
        int numOfThreads = Integer.parseInt(args[1]);
        Crawler crawler = new Crawler(baseUrl, numOfThreads);
        crawler.start();
        crawler.join();
        crawler.shutdown();
    }
}
</code></pre>

<p>该例中的爬虫实现基于Java Concurrency的ExecutorService API，一种共享状态并发式编程模型。为了保证线程安全，代码中采用了ConcurrentHashMap、AtomicInteger、Lock和Synchronized等Java特有的并发编程技术，存在复杂度较高、易理解性差、共享状态维护难度高、易出错等缺点。</p>

<p><strong>反应式编程</strong>(Reactive programming)是一种具有异步编程风格的编程框架，其衍生自基于数据流的并发声明式编程模型，采用事件驱动和非阻塞线程技术，从而降低因为资源等待导致的并发性能瓶颈。首先来看一个基于RxJava[RXJ14]的爬虫代码片段(例子来源于互联网):</p>

<pre><code>public class ObservableCrawler {
  private Subscriber&lt;? super String&gt; subscriber;

  public static Observable&lt;String&gt; create(Crawler crawler, String url, int numOfThreads) {
      ObservableCrawler o = new ObservableCrawler(crawler, numOfThreads);
      return Observable.create(subscriber -&gt; {
          o.subscriber = subscriber;
          if (o.executorService == null) {
              o.process(url);
              subscriber.onCompleted();
          } else {
              o.processAsync(url);
          }
      });
  }
  private ObservableCrawler(Crawler crawler, int numOfThreads) {
      this.crawler = crawler;
      this.executorService = numOfThreads &gt; 0 ?
              Executors.newFixedThreadPool(numOfThreads, r -&gt; new Thread(r, "Crawler-" + threadIdGenerator.incrementAndGet()))
              : null;
  }

  private void processAsync(String url) {
         pendingTasks.incrementAndGet();
         executorService.submit(() -&gt; {
             // If item is not unique, skip processing
             boolean isFirstTime =  results.add(url);
             if (isFirstTime) {
                 subscriber.onNext(url);
                 crawler.crawl(url, this::processAsync);
             }
             if (pendingTasks.decrementAndGet() == 0) {
                 subscriber.onCompleted();
                 executorService.shutdown();
             }
         });
  }
}
</code></pre>

<p>其客户端代码如下:</p>

<pre><code>public class CrawlerClient {
  public CrawlerClient(Crawler crawler, String url, int numOfThreads) {
      this.observable = ObservableCrawler.create(crawler, url, numOfThreads);
      observable.subscribe(this::onNext, this::onError, this::onCompleted);
  }

  public void waitForCompletion() throws InterruptedException {
      completionLatch.await();
  }
}
</code></pre>

<p>与前面直接基于Java Concurrency的例子类似，该例同样采用了ExecutorService实现爬虫的并发执行，其中waitForCompletion也提供了阻塞客户端的能力。两者的区别在于，RxJava的版本采用观察者模式对爬虫类进行了封装，客户端不再需要等待代码执行结束后再执行后续指令。其中的一部分技术细节，例如线程安全代码被封装在API中，再通过回调函数接口提供给客户端，后者只需要关心onNext、onError和onCompleted的线程安全实现，这在一定程度上降低了Java并发编程的复杂度。</p>

<p>除了上例介绍中朴素的回调函数API之外，反应式编程通常还可能提供多种异步编程风格API，包括但不限于:</p>

<ul>
<li><p>Futures/Promises，一种单赋值容器，支持针对单写/多读场景的、自上而下的异步编程风格，能够有效解决回调地狱(Callback hell)的问题。</p></li>
<li><p>流(Streams)，一种无界限的数据处理流，支持多个源点、汇点间的异步、非阻塞、背压(Backpressure)的数据变换管道。例如函数组合(Functional composition)提供的map、filter、fold等流式操作。这里的背压是指当异步执行管道中的消费端计算能力不足，上游仍然持续生产事件，从而导致系统过载的问题。反应式编程API一般通过配置不同策略以防止潜在的系统灾难。</p></li>
<li><p>数据流变量(Dataflow variables)，一种单赋值变量，能够基于输入、过程和其它变量实现自动更新。</p></li>
</ul>


<p>前述例子中采用的RxJava遵循了ReactiveX标准——一套反应式编程的技术规范[REX]，类似的反应式编程扩展(Rx)支持已被添加至许多编程语言中，如RxJS、Rx.NET、RxScala等。此外，RxJava还支持JVM平台的反应式流规范(Reactive Streams Specification)[RSS]，从而具备与其它反应式编程API之间的互操作性。与传统编程模型相比，反应式编程在多核利用率、并发编程、系统模块性、工作流组装方面相较于传统编程模型具有优势。但其同样可能会损害代码的易理解性，并且通常只局限于单机计算，虽然有助于加强即时响应性，但并不能满足反应式架构要求的另外两个核心质量属性:</p>

<ul>
<li><p>回弹性，指系统在出错时能够自动恢复并保持正常的即时响应性目标。</p></li>
<li><p>弹性，是指系统在异常工作负载下，能够自适应调整自身容量从而维持其正常的即时响应性目标。</p></li>
</ul>


<p>这正是分布式系统成为云计算、移动/IOT领域核心技术的重要原因。</p>

<h3>分布式与异步消息传递</h3>

<p>分布式技术的目标是为系统提供横向扩展能力。通过负载监控和自动化伸缩技术，实现系统容量的自适应调节，从而满足弹性需求。另外，通过隔离组件控制系统错误/灾难的级联传递，再将错误提交至安全上下文中即时处理，从而满足回弹性需求。</p>

<p>反应式架构使用<strong>异步消息传递</strong>作为组件间的通信模式，通过在组件间建立临时边界，实现组件间的松耦合、隔离与地址透明化，达到时间、空间二重解耦的目的。值得注意的是，这里的空间解耦既可以指单机中的线程/进程，也可以指分布式系统的组件。“消息传递”意味着组件通常是长期存活且可被调用者直接定位、实现定向通信的方式，这与另一种流行的分布式系统通信模式——“事件传递”有着重要区别。因为“事件传递”是通过事件源的状态变化引发相应事件，再通过观察者模式通知“订阅”的组件，因此其关注点在于<strong>可定位事件源</strong>。而在“消息传递”中则相反，调用者需要明确知道被调用者的位置信息，即更加关注<strong>可定位接收者</strong>——这是反应式架构实现回弹性和弹性的重要基础。因为后者具有更强的控制力:负载管理、错误检测、消息丢弃/复制/排序、通过监控和调整消息队列实现流量控制以及背压等。</p>

<p>以应对回弹性为例，为了使系统在出错时仍然保持正常的即时响应性，需要实现调用者和被调用者的完全隔离，使后者发生的错误不被传递至前者，同时应支持消息被传递到多个复制组件中，即便错误发生时系统仍能正常提供服务。虽然容错性也是受到普遍重视的质量属性之一，但是传统上强耦合、深度嵌套的同步调用链代码缺少一致的容错方案。反应式架构明确要求把错误信息封装在消息中传递至其它组件，并使其在出错组件外部的一个安全上下文中得到有效处理(代理模式)。这里体现的基本思想是把错误处理从原有调用链中解耦，即移除客户端中针对服务端错误进行处理的职责。</p>

<p>再以弹性计算为例，系统被要求能够根据实际负载需求自动增加或减少所占用资源，从而动态调整吞吐量。这种自适应性意味着无介入实现系统伸缩、状态/行为冗余、负载均衡、失效备援和系统升级等能力。其基本思想是在编程抽象和语义层面实现组件空间位置的透明化，使系统更易于伸缩，且这种可伸缩性无需局限于CPU核甚至数据中心。</p>

<h3>消息传递并发式模型及其应用</h3>

<p>消息传递并发式模型是一种通过异步通信信道实现组件间通信的编程模型，目前被广泛应用于实现反应式架构中的“异步消息传递”模式，例如经典的Actor模型[CPR73]。</p>

<p>Actor是一种相比基于线程的并发编程更高级的抽象模型，其旨在解决如下问题:</p>

<ul>
<li><p>伸缩性，指包括单机和分布式环境下的系统扩容能力，即隐藏系统横向、纵向扩展的底层技术差异。</p></li>
<li><p>透明性，指同时适应单机和分布式环境下的定位能力，例如在单机环境下采用并发编程语言，在分布式环境下采用网络通信，这些完全不同的资源定位方式导致系统难以从单机向分布式演化。</p></li>
<li><p>不一致性，这里的不一致性是指在许多超大型系统中，面向人的信息系统交互存在不一致的问题，例如文档、标准等。</p></li>
</ul>


<p>在Actor模型中，最基本的并发计算元素被称作actor。actor之间可以发送和接收消息，并且各自维护一个内部状态。当actor接收到消息时，可以并行执行下列响应方法:</p>

<ul>
<li><p>创建有限数量的新actor。</p></li>
<li><p>发送有限数量的消息给其它actor。</p></li>
<li><p>定义下一次接收消息时触发的行为。</p></li>
</ul>


<p>Actor模型无论在计算理论还是在实际应用中都产生了重要影响，特别是可以被用于描述一些流行的并发编程框架，例如下面要介绍的Erlang/OTP Processes[EOP]和Akka Actors[AA]。</p>

<h4>Erlang/OTP Processes</h4>

<p>Erlang是一种声明式编程语言，除了基本的语法规则外，Erlang在其内核语言的基础上还提供了一套专有运行时系统和库——OTP(Open Telecom Platform)，后者是Erlang实现分布式、软实时、高容错、高可用、热部署的基础[OTP]。其中，<strong>进程</strong>(Processes，注意这里不是操作系统进程)是Erlang并发编程的基本计算元素，类似actor。如下列代码所示(例子来源于互联网):</p>

<pre><code>-module(counter).
-export([run/0, counter/1]).

run() -&gt;
    S = spawn(counter, counter, [0]),
    send_msgs(S, 100000),
    S.

counter(Sum) -&gt;
    receive
        value -&gt; io:fwrite("Value is ~w~n", [Sum]);
        {inc, Amount} -&gt; counter(Sum+Amount)
    end.

send_msgs(_, 0) -&gt; true;
send_msgs(S, Count) -&gt;
    S ! {inc, 1},
    send_msgs(S, Count-1).

% Usage:
%    1&gt; c(counter).
%    2&gt; S = counter:run().
%       ... Wait a bit until all children have run ...
%    3&gt; S ! value.
%    Value is 100000
</code></pre>

<p>上例中实现了一个并发计数器counter，并向外部提供两个函数run和counter。其中run函数的作用是创建一个新的counter进程，然后向其发送倒计时时间消息。counter定义了消息接收行为，包括打印和增数。send_msgs通过!向S进程发送消息，然后通过递归实现倒数。与actor概念类似，Erlang的进程相互之间完全隔离，并通过消息传递相互通信。由于进程的创建和销毁十分轻量化，从而允许系统中容纳数量非常可观的进程(在普通PC中即可实现千万级进程数)，这些进程可以在运行时系统中存在很长时间，如果没有消息接收或者运行了太长时间，进程就会被重新放入调度队列，避免影响其它正常运行进程。</p>

<h4>Akka Actors</h4>

<p>Akka是一个基于JVM的并发编程框架，其中的核心模块Akka Actors的Scala语法部分借鉴自Erlang，例如:</p>

<pre><code>object HelloWorld {
  final case class Greet(whom: String, replyTo: ActorRef[Greeted])
  final case class Greeted(whom: String, from: ActorRef[Greet])

  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =&gt;
    context.log.info("Hello {}!", message.whom)
    message.replyTo ! Greeted(message.whom, context.self)
    Behaviors.same
  }
}
</code></pre>

<p>与此相比Java版本就显得较为繁琐一些，但也很容易理解:</p>

<pre><code>public class HelloWorld extends AbstractBehavior&lt;HelloWorld.Greet&gt; {

  public static final class Greet {
    public final String whom;
    public final ActorRef&lt;Greeted&gt; replyTo;

    public Greet(String whom, ActorRef&lt;Greeted&gt; replyTo) {
      this.whom = whom;
      this.replyTo = replyTo;
    }
  }

  public static final class Greeted {
    public final String whom;
    public final ActorRef&lt;Greet&gt; from;

    public Greeted(String whom, ActorRef&lt;Greet&gt; from) {
      this.whom = whom;
      this.from = from;
    }
  }

  public static Behavior&lt;Greet&gt; create() {
    return Behaviors.setup(HelloWorld::new);
  }

  private HelloWorld(ActorContext&lt;Greet&gt; context) {
    super(context);
  }

  @Override
  public Receive&lt;Greet&gt; createReceive() {
    return newReceiveBuilder().onMessage(Greet.class, this::onGreet).build();
  }

  private Behavior&lt;Greet&gt; onGreet(Greet command) {
    getContext().getLog().info("Hello {}!", command.whom);
    command.replyTo.tell(new Greeted(command.whom, getContext().getSelf()));
    return this;
  }
}
</code></pre>

<p>从编程模型的角度看，Akka Actors与Erlang Processes本质上是一致的，然而其底层系统存在巨大差别——更多是JVM与OTP的差别。两者如今也都形成了各自庞大的生态系统，成为设计反应式架构的重要参考，并且在通信、数字金融、在线游戏、在线交易、统计、社交媒体、移动应用等领域得到了广泛应用。</p>

<h2>结论</h2>

<p>本文介绍了一种流行的架构风格——反应式架构，详细讨论了即时响应性、回弹性和弹性等质量属性以及异步消息传递模式。在具体实践层面，首先讨论了事件驱动模式的反应式编程及其在多核环境中的应用，进一步介绍了消息传递模式的Actor模型及相关的流行编程框架——Erlang Processes和Akka Actors。由此可见，<strong>参考架构风格的关键在于理解其要解决的核心问题，即要满足的特定的功能或非功能需求是否符合期望。一旦确定架构风格，其特定的设计原则就应尽量被作为软件开发的通用设计原则。而针对架构风格中包含的多种模式、框架和系统，就需要依据具体上下文灵活做出选择。</strong></p>

<h2>引用</h2>

<p>JDRM14, <a href="https://www.reactivemanifesto.org/">https://www.reactivemanifesto.org/</a></p>

<p>BG99, <a href="https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">Java Concurrency in Practice</a></p>

<p>RXJ14, <a href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a></p>

<p>REX, <a href="http://reactivex.io/">http://reactivex.io/</a></p>

<p>RSS, <a href="http://www.reactive-streams.org/">http://www.reactive-streams.org/</a></p>

<p>CPR73, <a href="https://dl.acm.org/doi/10.5555/1624775.1624804">A universal modular ACTOR formalism for artificial intelligence</a></p>

<p>EOP, <a href="https://erlang.org/doc/reference_manual/processes.html">https://erlang.org/doc/reference_manual/processes.html</a></p>

<p>AA, <a href="https://doc.akka.io/docs/akka/current/typed/index.html">https://doc.akka.io/docs/akka/current/typed/index.html</a></p>

<p>OTP, <a href="https://erlang.org/doc/">https://erlang.org/doc/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(15)]]></title>
    <link href="http://www.hanyi.name/blog/2019/06/08/software-design-and-architecture-notes-15/"/>
    <updated>2019-06-08T13:14:00-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/06/08/software-design-and-architecture-notes-15</id>
    <content type="html"><![CDATA[<h2>软件架构说什么？</h2>

<p><strong>架构</strong>(Architecture)一词源自建筑领域，尽管看起来与软件设计毫无关联，但人们从上世纪60年代起就注意到两者的相似性[PHJ06]，并从结构和工程等方面大量借鉴了这个古老的学科，软件设计也因此获益匪浅[GHJV95]。当然不仅是软件，这个词也被其它领域广泛借鉴，例如作为计算机基础的<strong>体系结构</strong>(Computer architecture)，后者主要指计算机的物理结构或者CPU指令集。又比如<strong>企业架构</strong>(Enterprise architecture)、<strong>解决方案架构</strong>(Solution architecture)或者<strong>信息架构</strong>(Information architecture)等，则是表示针对各自问题域的专业性实践集合。</p>

<p>虽然架构与<strong>设计</strong>同属于本系列的主题之一，但迄今为止我们都很少提及。一方面是因为，作为诞生于上世纪90年代的buzz word，软件架构是在软件设计的基础上发展而来的，前者继承了后者的许多核心思想，例如模块化、原则、模式等，逐渐形成了更加庞大的体系。另一方面，架构一词如今具有极其丰富的含义，以至于可能达到阻碍交流的地步，因此确有必要首先对部分概念予以澄清。此外，除非特别说明，本系列文章中的架构均指软件架构。</p>

<h3>定义和解释</h3>

<p><em>架构是指一个系统在其所在环境中的基本概念和属性，这体现为系统的元素、关系及其设计和演进的原则。</em></p>

<p>虽然这是ISO/IEC 42010对架构的正式定义，另一种USP(Unique selling proposition)定义则更详细地解释了这一点:</p>

<p><em>架构是一系列重要的决策，涉及描述软件系统的组织、确定结构化元素及其接口、确定元素在协作中的特定行为、指导结构和行为元素通过组合逐渐形成较大子系统的风格(涉及元素、接口、协作和组织等)。此外还要考虑用途、功能、性能、适应力、可重用性、可理解性、经济性、技术限制及其权衡、美学等因素。</em></p>

<p>以上定义明确指出了架构的<strong>表示</strong>(Representation)、<strong>质量属性</strong>(Quality attribute)以及<strong>风格</strong>(Style)等核心内容。此外，针对已有的架构方案，有时需要进行专门的<strong>架构评估</strong>(Architecture evaluation)，从而提前发现问题并控制潜在风险。本文剩余部分将作进一步讨论。</p>

<h3>架构表示</h3>

<p>由于架构本身的丰富性，采用适当方法描述架构就变得非常重要，一种基本的架构描述工具是<strong>架构视图</strong>(Architecture view)，其被用于表示架构在解决特定问题时所体现的结构化信息。由于完整的架构一般会涉及众多干系人，在单一视图中无法清楚表示所有信息，因此为了进一步在视图中区分来自不同干系人的诉求，采用<strong>架构视点</strong>(Architecture viewpoint)聚焦于某一类架构决策，并采用特定的标记和建模技术建立对应的架构视图。常见的架构视点有功能、逻辑、数据、模块、组件-连接器、需求、实现、并发、性能、安全、部署、用户使用及反馈等，由此可见其对应的架构视图也就非常丰富。</p>

<p>以组件-连接器类型的架构视图为例，该架构视图定义了系统中的可计算组件及其交互方式，其中组件是指可独立运行、且支持交互或存储数据的软件单元，连接器则被用于描述组件之间的交互机制。在构建组件-连接器视图的过程中，组件可以根据承担功能、可重用性、硬件单元，甚至团队的技术背景、康威定律以及产品演化路径等方式定义。同时，组件还需要描述其对外提供交互的接口(API)，包括访问端口、参数以及参数类型。然后根据组件间交互的需求，如同步、异步、延迟、吞吐量等确定连接器的类型和通信协议。连接器两端的组件分别被称为调用者和被调用者，组件与连接器之间通常需要相关配置以确定关联信息。</p>

<h4>架构描述语言</h4>

<p>通常，架构视图是采用<strong>架构描述语言</strong>(Architecture description languages，ADL)具体实现的，如AADL、Wright、ACME、xADL等专门面向软件架构的语言。同时也可以采用通用的建模语言，例如UML，实际上后者在工业界更加流行。架构视图和ADL共同组成了架构表示的基本方法，但仍不足以有效应对架构的复杂性。这是因为在真实场景中架构视点可能是非常多的，架构需要从核心视点出发逐步完善，因此需要进一步参考适当的<strong>架构框架</strong>(Architecture framework)。</p>

<h4>架构框架</h4>

<p>架构框架是指在特定应用领域或干系人社区中，创建、解释、分析和使用架构表示的通用实践集合。一种经典的架构框架是“4+1架构视图模型”[PK95]，其基本思想是需要采用若干个相互平行、且具有不同架构视点的架构视图，具体来说就是<strong>逻辑视图</strong>、<strong>进程视图</strong>、<strong>开发视图</strong>和<strong>物理视图</strong>等四种主要架构视图，以及相应的<strong>用例和场景</strong>说明，从而达到表示完整架构的目的。</p>

<ul>
<li><p>逻辑视图，即把系统按照功能、通信、行为等进行结构化分解的结果，描述系统的静态信息。具体可以采用UML中的类图或状态图实现。</p></li>
<li><p>进程视图，即对系统中进程和线程的通信、执行过程进行描述，即系统的动态运行信息。具体可以采用UML中的部署图和活动图实现。</p></li>
<li><p>开发视图，也称作<strong>实现视图</strong>，用于描述软件开发过程中的软件结构，例如组件、包、类、子系统、代码库、文件等。具体可采用UML的组件图或包图实现。</p></li>
<li><p>物理视图，描述系统运行的硬件资源结构，及其与系统进程之间的映射关系。具体可采用UML中的部署图、时序图或协作图实现。</p></li>
<li><p>用例和场景，也称作<strong>用例视图</strong>，即从少量核心用例出发，描述系统中对象间、进程间的交互顺序。该视图主要用于构建可验证的架构原型，从而对当前架构进行测试。</p></li>
</ul>


<p>根据上述5种架构视图，4+1架构视图模型能够建立一个核心的软件架构表示。然而从架构对整个软件工程的影响角度来说，架构框架作为架构表示的核心，往往还需要更多架构视点的支持，这与具体上下文密切相关，特别是接下来要讨论的质量属性。</p>

<h3>质量属性</h3>

<p>除了满足功能需求，架构还需要考虑系统的非功能需求(二者相互正交)，后者也被称作系统的质量属性，例如性能、可靠性、资源利用率、可用性、精确性等。与功能需求最显著的不同在于，质量属性往往是相对概念，一般表现为某种程度，且具备多种领域背景。正因为如此，质量属性大大提升了架构的复杂性，也是除了功能需求变化外另一个可能引起架构变化的重要原因。</p>

<p>ISO/IEC 25010对软件质量进行了明确定义，其中功能性表示系统功能的完整性、正确性、适当性与合规性，此外还包含7种非功能属性以及对应的子属性:</p>

<ul>
<li><p>可靠性，指系统在特定时间和条件下维持当前性能的能力，包括成熟度、容错性、可恢复下、可用性等指标。</p></li>
<li><p>易用性，指个体或群体在使用系统时的难易程度。包括易理解性、易学习性、易操作性、界面美观性、操作错误保护以及可访问性。</p></li>
<li><p>高效性，指系统在特定条件下，资源使用量与软件性能之间的关系。包括耗时、资源利用率、容量等指标。</p></li>
<li><p>兼容性，指系统在特定的软、硬件环境中能够正常运行的能力。包括共存性、互操作性等指标。</p></li>
<li><p>安全性，指系统保护数据和执行正当行为的能力。包括保密性、完整性、非拒绝性、可审计性以及可验证性。</p></li>
<li><p>可维护性，指系统在需要做出特定修改时所花费的成本大小。包括可分析性、可改变性、稳定性、可测试性、模块性、可重用性以及可修改性。</p></li>
<li><p>可移植性，指系统迁移到其它环境的能力。包括可适应性、可安装性、可替换性等。</p></li>
</ul>


<p>值得一提的是，经验研究表明并非所有的非功能需求都有同等机会引发架构变化[JAD16]，尽管它们可能拥有相同的重要性。但在进行架构相关决策时，依然不可避免地要考虑功能以及多种质量属性，这就导致从零开始设计架构具有极高的成本和风险。因此绝大多数架构设计活动实际上是遵循着经受实践检验的经验，即下面要讨论的<strong>架构风格</strong>。</p>

<h3>架构风格</h3>

<p>架构风格是指一系列满足功能和特定质量属性的设计决策与约束子集[RNE09]，其意义在于:</p>

<ul>
<li><p>提供可重用的领域和工程知识，特别是相同领域或产品族中与应用无关的设计规则和决策，避免重新发明轮子。</p></li>
<li><p>阻止架构腐化和偏离，帮助未来开发人员在不损害基本架构原则的基础上扩展系统。</p></li>
<li><p>根据质量需求指导设计。</p></li>
</ul>


<p>以经典的<strong>管道-过滤器</strong>架构为例，在该架构风格中，所有的过滤器都通过两个字节流“输入”和“输出”进行通信，这样就保证了任何过滤器都能够互相连接——即满足兼容性。另外，过滤器之间可以一次只传递部分数据，这样就能够尽可能提高过滤器之间并行计算的能力，从而提高系统效率。除此之外，应用中常见的架构风格还包括但不限于:</p>

<ul>
<li><p>客户端-服务器(C/S)架构。</p></li>
<li><p>分层(三层或N层)架构。</p></li>
<li><p>点对点(Peer-to-peer)架构。</p></li>
<li><p>事件驱动(Event-driven)架构，也称隐式调用架构。</p></li>
<li><p>表述性状态转移(REST)架构。</p></li>
<li><p>面向服务架构(SOA)。</p></li>
<li><p>领域驱动设计(DDD)。</p></li>
</ul>


<p>限于篇幅本文无法详细讨论每种架构风格。而事实上，在实际软件开发过程中架构风格往往是在最初就确定的，因此可被视为架构设计的设计规则。另外，大部分情况下整个系统会拥有多种架构风格，从而满足各种质量属性需求。</p>

<h3>架构评估</h3>

<p>由于架构的重要性，团队通常需要对已有的架构方案进行评估。架构权衡分析(Architecture tradeoff analysis method)是一种架构评估方法，采用该方法首先需要建立一个专门的架构评审小组，该小组应至少包含所有的干系人。启动评估后，首先应确保所有参与者熟悉评估流程以及业务背景。向所有评估者展示更高层次的系统架构，包括所采用的架构风格。然后通过<strong>质量属性树</strong>描述系统所要特别关注的质量属性，并且为每个所要满足的属性提供一个具体场景。一个质量属性树的例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/architecture/quality_tree.png" alt="Quality attribute tree" /></p>

<p>把所有场景按照优先级进行排序，然后逐一分析当前架构对该场景的适用性，根据相关反馈进行调整。最后在更大范围的干系人组织中分享当前架构知识。</p>

<h2>结论</h2>

<p>软件架构包含三个核心问题，分别是架构表示、质量属性和架构风格。架构表示是架构得以沟通并完善的重要途径，在架构设计的过程中不仅要考虑功能需求，还要考虑非功能需求(质量属性)，不同的架构风格在应对特定质量属性方面具有优势，因此真实场景中需要组合架构风格以满足来自不同干系人的需求。</p>

<h2>引用</h2>

<p>PHJ06, <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1605175">The Past, Present, and Future of Software Architecture</a></p>

<p>GHJV95, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/DSBP-2018-01/recursos/Erich%20Gamma,%20Richard%20Helm,%20Ralph%20Johnson,%20John%20M.%20Vlissides-Design%20Patterns_%20Elements%20of%20Reusable%20Object-Oriented%20Software%20%20-Addison-Wesley%20Professional%20%281994%29.pdf">Design Patterns: Elements of Reusable Object-Oriented Software</a></p>

<p>PK95, <a href="https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf">Architectural Blueprints—The “4+1” View
Model of Software Architecture</a></p>

<p>RNE09, <a href="https://www.softwarearchitecturebook.com/">Software Architecture: Foundations, Theory, and Practice</a></p>

<p>JAD16, <a href="http://www.aset.tu-berlin.de/fileadmin/fg331/Publications/ICSE16.pdf">Are “Non-functional” Requirements really Non-functional?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(14)]]></title>
    <link href="http://www.hanyi.name/blog/2019/06/01/software-design-and-architecture-notes-14/"/>
    <updated>2019-06-01T23:31:49-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/06/01/software-design-and-architecture-notes-14</id>
    <content type="html"><![CDATA[<h2>敏捷软件设计</h2>

<p>早期的软件开发方法源自传统制造业和建筑业，即按照需求、分析、设计、开发、测试、运营等阶段顺序执行。这种线性的软件开发过程被称作<strong>瀑布模型</strong>(Waterfall)。瀑布模型在上世纪70年代逐渐发展成熟，成为软件开发方法的事实标准。随着互联网的出现，软件工业迈入飞速发展，频繁变更的需求和快速更替的技术使瀑布模型遭遇了空前挑战。于是，通过从先进制造业汲取经验，行业一线的职业程序员们开始调整原有方法，90年代先后诞生了<strong>统一过程</strong>(Unified process)、<strong>Scrum</strong>、<strong>极限编程</strong>(Extreme programming)等轻量级软件开发方法。2001年，程序员们从这些方法的核心思想中提炼出了著名的<strong>敏捷宣言</strong>，由此敏捷成为前述一系列软件开发方法的代名词。时至今日，对于需求明确并且依赖成熟技术的软件开发活动来说，严谨且可靠的瀑布模型仍然占有一席之地。敏捷思想则在自互联网时代开启的一系列新兴领域中更受欢迎，也更具备发展空间。</p>

<p>敏捷对软件设计产生了重大影响，正如Martin Fowler所指出的，极限编程不仅宣告了Big Design Up Front的终结，还严重影响了一批热门的技术实践例如UML、框架构建、设计模式[MFL00]。然而软件设计并未因敏捷而消失，敏捷也不意味着无设计或设计灾难，为了与传统瀑布模型的<strong>计划设计</strong>(Planned design)进行区别，敏捷设计被描述为<strong>演进式设计</strong>(Evolutionary design)、<strong>持续设计</strong>(Continuous design)或<strong>浮现式设计</strong>(Emergent design)，或许这些名词有时夹带了浓厚的宣传意味，但是不可否认分析与设计、原则与模式依然是敏捷软件设计的核心，后者的主要特点在于更加强调轻量化的敏捷设计实践。这往往意味着:</p>

<ul>
<li><p>强调价值交付，交付价值是推动整个软件工业发展的重要经济基础，因此价值应当始终是软件开发的优先选项。</p></li>
<li><p>强调团队责任，而不是把职责局限于分析师、设计师、XX师等不同工种，从而减少<strong>单点失败</strong>(Single point failure)。</p></li>
<li><p>强调快速反馈，无论是测试驱动开发还是持续集成，通过尽可能的自动化实现软件设计质量的实时监控，且应保证快速响应。</p></li>
</ul>


<p>具备代表性的实践有面向设计一致性的<a href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/"><strong>代码味道</strong></a>和<strong>重构</strong>、面向功能一致性的<strong>测试驱动开发</strong>(Test driven development)以及面向团队一致性的<strong>结对编程</strong>(Pair programming)、<strong>代码评审</strong>(Code review)和<strong>持续集成</strong>(Continuous integration)等。敏捷正是通过前述一系列实践，从而避免从BDUF走向另一个设计熵增的极端。本文剩余部分将进一步讨论价值交付、团队责任和快速反馈在敏捷软件设计活动中的具体体现。</p>

<h3>价值交付：扩展—收缩模式(Expand-Contract Pattern)</h3>

<p>应对变化是敏捷软件设计的永恒主题。当现有设计发生变化时，这种变化可能通过接口向模块外传递，从而影响更多其它模块。特别对于<a href="https://martinfowler.com/bliki/PublishedInterface.html">公共接口</a>来说，变更现有设计会产生较高成本，进而影响交付的价值。[MFL14]讨论了一种扩展—收缩模式，其核心思想是在变更设计的同时保持向后兼容，当新设计产生的价值得到验证后再移除旧设计。例如下列代码:</p>

<pre><code>class WindowFactory {

    public Window createWindow(String title, int x, int y, int width, int height) {
        ...
    }
}
</code></pre>

<p>该例中的抽象工厂类WindowFactory能够创建不同类型的Window，参数列表接受窗口名、位置和尺寸等信息，其中位置和尺寸能够使用Rect对象代替，从而有:</p>

<pre><code>class WindowFactory {

    public Window createWindow(String title, Rect rect) {
        ...
    }
}
</code></pre>

<p>如果该接口属于公共接口，那么所有客户端组件都必须被动修改，否则将无法正常工作。更加合理的做法是首先保留原接口(<strong>扩展</strong>):</p>

<pre><code>class WindowFactory {

    public Window createWindow(String title, int x, int y, int width, int height) {
        ...
    }

    public Window createWindow(String title, Rect rect) {
        ...
    }
}
</code></pre>

<p>当客户端组件迁移完成后，再移除失效的接口(<strong>收缩</strong>)。通过采用扩展—收缩模式，能够有效控制设计变更对交付价值的影响，这也是敏捷软件设计的核心目标之一。</p>

<p>同样的模式还被应用于演进式数据库设计[MFL16]，特别是当数据模式发生破坏性修改时(修改表名、列名等操作)，需要保证在迁移阶段同时支持新旧两种数据访问模式。例如当修改表名时，可以通过创建与旧表名相同的视图提供向后支持。当设计需要修改列名时，可以先创建新的列，然后通过触发器实现新旧两列的同步，直至迁移阶段结束再清理旧模式。在真实场景中应根据数据库类型、应用类型等相关上下文决定具体实现，但设计思想仍然遵循扩展—收缩模式。</p>

<h3>团队责任：模型风暴(Model Storming)</h3>

<p>模型风暴是一种即时建模活动，其目的是把设计责任赋予团队而非个人。理论上说模型风暴可以发生在敏捷软件开发过程的任何时间，但通常是由一名用户故事的所有者(Story owner)在进入开发阶段前发起。首先由所有者确保理解所要解决的问题，然后集合若干团队成员(通常是2~3人)进行站立会议(Stand session)。在所有者介绍完背景并确保所有人理解上下文后，团队开始在一个共享建模工具上探索设计方案，直至大家充分理解并达成一致，会议结束(通常是5~10分钟)。</p>

<p>模型风暴有两种应用场景——分析和设计。分析模型风暴主要是帮助团队理解需求，这时应尽可能集合相关干系人(产品负责人、业务分析师、设计师、质量分析师和开发等)，然后通过绘制草图帮助所有人理解原始需求，并澄清相关问题。这一阶段的关键在于鼓励各种干系人参与建模过程，于是应尽量采用包容性建模(Inclusive modeling)及相关工具，避免过度专业和复杂的工具应用，从而促进沟通。常见的包容性工具有白板、索引卡、便利贴、白板纸等。</p>

<p>设计模型风暴是在编写代码前由若干开发人员共同完成的设计活动。根据开发人员的技术背景，建模过程可以采用<a href="http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8/">UML</a>、<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">类职责协作卡</a>(CRC)、<a href="http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5/">数据流程图</a>或一般流程图等包容性工具。具体过程可以参考<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">前文</a>介绍的CRC及其在协作式OOD中的应用。</p>

<p>模型风暴能够促进设计知识在团队中进行传递，从而有效控制软件设计的单点失败风险。</p>

<h3>快速反馈：设计监测(Design Monitoring)</h3>

<p>快速反馈主要是指能够快速验证当前设计的完整性，并在发现设计缺陷时提供警报，这往往需要依赖专业面向软件设计的静态代码分析工具来完成。通常的做法是把相关工具集成进现有的持续集成过程，并作为某种质量检测报告输出，从而实现设计监测。设计监测工具主要通过分析软件结构中的依赖热点(Hotspot)进行，一般有两种途径分析这些热点——<strong>度量</strong>和<strong>模式</strong>。</p>

<p>度量是通过对软件结构中的实体及其依赖关系进行量化分析，从而反映软件模块化的程度。一种可量化的设计原则是<a href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/">包依赖原则</a>，在此基础上的经典Java开源实现即JDepend(现基本停止维护)，该工具以Java语言的包为单位，分别计算每个包的类数量(TC)、具体类数量(CC)、抽象类数量(AC)、传入耦合(Ca)、传出耦合(Ce)、抽象系数(A)、不稳定性(I)、偏离距离(D)，每种度量的具体定义本文不再赘述。</p>

<p>模式主要是指检测依赖中的反模式，后者主要是违反设计原则的实际情况，例如违反包间无环依赖，接口隔离、Liskov替换、依赖倒置等。具体做法是把软件设计中的依赖关系用图表示，然后检测图中存在的违反设计原则的特定模式(Motif)，经典开源实现即Google的<a href="https://code.google.com/archive/p/gueryframework/">GUERY</a>(停止维护)。该工具能够根据图中的顶点、关系及其路径长度等条件识别特定模式，并且根据Tarjan算法计算强联通子图进而生成凝聚图。</p>

<p>免费工具除前述外，还有针对Java程序的依赖抽取和可视化工具<a href="http://www.dependency-analyzer.org/">Class Dependency Analyzer(CDA)</a>，CDA能够把相关依赖以UML的形式进行可视化，帮助用户理解并管理复杂软件结构。专业用于依赖分析的商业工具有<a href="http://www.lattix.com/">Lattix</a>、<a href="http://www.hello2morrow.com/products/sonargraph">SonarGraph</a>、<a href="http://www.headwaysoftware.com/products/?code=Structure101">Structure 101</a>、<a href="https://www.jarchitect.com/">JArchitect</a>/<a href="https://www.ndepend.com/">NDepend</a>/<a href="https://www.cppdepend.com/">CppDepend</a>等，本文不再赘述。</p>

<p>值得一提的是，面向软件设计领域无论是免费还是商业工具，尽管其内置的设计规则具有普遍性，同时也支持自定义规则，但通常都存在较高的学习、维护和实施成本，实际上并不能真正达到快速反馈的目的。对处于一线的中小型敏捷团队来说过重，更适用于一些已经具备较高价值的商业软件开发和大型软件组织的架构看护活动。</p>

<p><a href="https://www.archunit.org">ArchUnit</a>是一个基于Java语言的开源依赖检查框架，用户通过编写测试断言的形式约束软件结构依赖，并且通过现有单元测试框架如Junit实现自动运行。与前面提到的主流第三方工具相比，该工具也定义了一些具有普遍意义的依赖规则，同时还具有如下优势:</p>

<ul>
<li><p>直接采用原生语言并作为宿主的测试实现，支持包、类、注解、分层、分片等多种概念实体，使定义复杂的Java代码依赖规则更加容易。</p></li>
<li><p>采用单元测试的思路，使依赖规则能够更快响应软件结构变化，降低规则维护的成本，真正实现快速反馈。</p></li>
<li><p>允许开发人员结合价值交付、团队责任等灵活定制依赖规则，特别适用于敏捷软件设计的场景。</p></li>
</ul>


<p>该工具的缺点是无法向多数GUI工具那样支持依赖分析，内置规则也不如成熟商业工具丰富，因此要求开发人员深入理解设计原则，并能够结合上下文定制恰当的规则。</p>

<h2>结论</h2>

<p>在一般的敏捷宣传语言中，诸如<strong>大道至简</strong>(You Aren&rsquo;t Gonna Need It，YAGNI)和<strong>恰如其分</strong>(Just enough)等词汇往往被使用且被轻易误解。原因在于脱离了具体的实践，敏捷就只剩下一个以人为本的空壳，并不能反映出源自核心的根本经济动力。因此无论是从软件匠艺(Craftsmanship)还是专业主义(Professionalism)来看，敏捷对开发人员的要求都要更高。反映在软件设计领域，具体就是除了基本的分析和设计方法、原则和模式等知识外，进一步注重软件设计中的价值交付、团队责任以及快速反馈等实践。</p>

<h2>引用</h2>

<p>MFL00, <a href="https://martinfowler.com/articles/designDead.html">Is Design Dead?
</a></p>

<p>MFL14, <a href="https://martinfowler.com/bliki/ParallelChange.html">Parallel Change</a></p>

<p>MFL16, <a href="https://martinfowler.com/articles/evodb.html">Evolutionary Database Design</a></p>
]]></content>
  </entry>
  
</feed>
