<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Wing of Dream 梦境之翼]]></title>
  <link href="http://www.hanyi.name/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://www.hanyi.name/"/>
  <updated>2018-10-23T22:49:04-04:00</updated>
  <id>http://www.hanyi.name/</id>
  <author>
    <name><![CDATA[Han Yi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(5)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5/"/>
    <updated>2018-10-23T11:42:00-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5</id>
    <content type="html"><![CDATA[<p>上接<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">软件设计与架构笔记(4)</a></p>

<p>前文描述的HIPO模型是一个典型的基于结构图的IPO系统设计模型，其基本思想依然是由顶至下，逐步求精。基于经验Larry进一步总结了通用的系统设计准则[SMC74]。</p>

<ol>
<li><p><strong>程序结构</strong>和<strong>问题结构</strong>。减少程序变更所造成影响的重要方法之一，就是保证设计结构匹配问题本身的结构。由顶至下的思维模式会天然形成一种层级结构，因此重点在于如何决定设计单元在相同层级，或隶属于不同层级，而关键又在于理解问题本身。</p></li>
<li><p><strong>模块控制范围</strong>和<strong>决策影响范围</strong>。控制范围指模块以及归属于该模块的子模块的集合；影响范围指某个设计决策所造成变更的所有模块集合。当设计决策的影响范围尽可能位于该决策所在的模块控制范围之内时，该系统设计就可以被认为是“简洁”的。保持简洁性的方法之一可以是提升某些决策相关的元素的层级；或者把受到相同决策影响，但位于不同控制结构的模块重新划分至相同控制范围。</p></li>
<li><p><strong>模块大小</strong>。模块的实际大小可被用于描述潜在问题的信号。过小的模块可能缺少功能性绑定，而过大的模块可能涵盖了超过一个功能性绑定。前者可以通过inline的方式消除以减少模块规模，后者由于可理解性和可读性问题需要进行进一步拆分。</p></li>
<li><p><strong>错误</strong>和<strong>文件终止处理</strong>。当模块的一部分功能需要通知其调用者发生某件错误时，可通过返回某种错误参数实现，该参数的值最好是二元类型，对于流数据处理的EOF标记也需要进行类似处理。同时这些参数也不应该包含如何处理当前错误的信息，而是由调用者决定。当然，如果模块本身不需要错误标记时，系统设计就更简洁了。</p></li>
<li><p><strong>初始化</strong>。某些模块由于需要依赖初始化操作，从而可能存在“简洁”但导致“弱绑定”的设计。例如，读模块的access方法可能会遇到“文件未打开”的错误，如果选择将错误信息返回，调用者自然会选择调用open方法然后重新read；但另一种维护“黑盒性”的做法是，在access内部遇到该错误时自动通过open和reread进行恢复，那么调用者就不需要知道“文件未打开”这种错误并且重复进行处理了。</p></li>
<li><p><strong>模块选择</strong>。消除重复的功能，而非消除重复的代码。如果只是通过抽取的方式简单消除重复代码，那么有可能导致某个变更造成更多的修改。一种识别该问题的方法是，关注那些被其它不同模块调用，以及调用其它不同模块的对象，判断是否存在其子功能与不同的模块集合关联的情况，如果是则意味着存在层级或模块缺失的可能。</p></li>
<li><p><strong>隔离软件规格说明</strong>。软件设计规格的重要内容就是描述特定的数据类型、记录布局以及索引结构，设计应尽量使其与系统其他模块进行隔离，从而减少规格变更导致的重写。</p></li>
<li><p><strong>参数数量</strong>。尽量减少模块间调用的参数数量（不只是个数），如果参数中存在一个完整的数据记录，应尽量只传递必要的数据记录，否则也会导致该记录的变更对模块造成潜在影响。</p></li>
</ol>


<h3>结构化分析(Structured Analysis)</h3>

<p>随着软件设计方法论的发展和问题复杂度的增加，人们发现设计不再是解决复杂系统面临的唯一难题。比如，传统的软件设计过程一般是按由顶至下的方法，依照<strong>需求规格说明(requirement specification)</strong>给出具体的软件对象定义，那么如何构建规范合理的需求规格说明呢？另外，如果软件设计过程愈加复杂，是否可以按照经典的分治法(divide-and-conquer)对其进行分解和简化呢？</p>

<p>世界上存在多种多样的原始需求形态，例如采用<strong>文字叙述(narrative)</strong>可以说是最普遍的形式之一。当问题复杂度增加时，软件设计已经不能从简单的叙述中加以消化并诞生，于是就出现了<strong>需求分析</strong>的过程。这种把问题从原始形式转换成可进一步规范设计的规格说明的过程，被称为<strong>系统分析</strong>。<strong>结构化分析</strong>作为软件系统分析最早流行起来的方法论，是在早期工业界数十年的探索中发展起来的。</p>

<p>由于传统的文字叙述不足以表达复杂系统，人们开始重视并使用符号语言，例如德国数学家Carl Adam Petri发表于1962年的<strong>Petri Net</strong>。60年代中期，女数学家Erna Schneider Hoover在贝尔实验室领导了一支团队，其目标是分析电话交换机系统的性能和宕机时间，Erna使用了Petri Net来模拟复杂的电话交换系统。受此启发，同时困扰于晦涩难懂的叙述式规格说明的年轻工程师Tom DeMarco由此开始开发一套网络符号语言，由此发展并最终在1978年发表了<strong>结构化分析</strong>方法[TOM78]。</p>

<h4>结构化分析与传统系统分析</h4>

<p>Tom认为传统的系统分析包含如下目标：</p>

<ol>
<li><p>确定最优化目标。</p></li>
<li><p>生成该目标的细节描述，并且能够被后期的实现过程用于评估该目标是否实现。</p></li>
<li><p>生成该目标相关的重要参数预测，包括花费、收益、日程以及性能特性。</p></li>
<li><p>得出所有被影响部分之上的项的并发性。</p></li>
</ol>


<p>为了达成这些目标，系统分析活动需要涉及用户沟通、撰写规格说明、损耗收益研究、可行性分析以及估算等。然而，这些活动都因高复杂性存在很多问题。针对这些问题，结构化分析进一步拓展了系统分析的目标：</p>

<ol>
<li><p>分析的产生物必须是<strong>可维护</strong>的，特别是针对<strong>目标文档(Target Document)</strong>。</p></li>
<li><p>必须采用有效的分割方法解决大小的问题，摒弃维多利亚小说式的规格说明。</p></li>
<li><p>尽可能使用<strong>图形表达</strong>。</p></li>
<li><p>必须区分逻辑和物理设计，并且基于此在分析师和用户之间合理分配职责。</p></li>
<li><p>必须在具体实现之前构建逻辑系统模型，使用户熟悉系统特性。</p></li>
</ol>


<p>同时，结构化分析描述了一系列可被用于不同分析阶段的工具：<strong>数据流程图(Data Flow Diagram, DFD)</strong>、<strong>数据字典(Data Dictionary)</strong>以及逻辑策略表达工具，例如<strong>结构化英语(Structured English)</strong>、<strong>决策表(Decision Tables)</strong>以及<strong>决策树(Decision Trees)</strong>等。</p>

<h4>数据流程图</h4>

<p>DFD是一种描述相互关联的过程的网络，其作用是帮助分割需求，并在撰写规格说明之前记录这种分割。与普通流程图的区别是，DFD只聚焦在数据流动的过程，因此基本没有任何关于循环或逻辑决策的控制信息。为了举例说明DFD，[TOM78]描述了一个软件咨询公司的自动化管理和运营辅助系统，该系统的功能包含了学员注册、支付、人员管理、课程管理等方面。下图是对该公司的早期运营模型的描述：</p>

<p><img src="http://content.hanyi.name/images/structured_analysis/logical_dfd.png" alt="Logical DFD" /></p>

<p>该图是一种Logical DFD，图中的输入被称作<strong>事务(Transaction)</strong>。以其中一条主要路径的部分为例，该路径共描述了5种事务：Cancellations, Enrollments, Payments, Inqueries和Rejects(这里指不属于前4种类型的事务的统称)，以及数据在这些事务间可能的流动关系。此外还有一种包含了系统具体实现信息的DFD，被称作Physical DFD。</p>

<p>DFD有时又被称作<strong>气泡图(Bubble Diagram)</strong>，原因是其描述数据转换过程的符号——气泡。此外DFD还包含<strong>命名向量</strong>，用于表示数据路径；<strong>直线段</strong>，表示文件或数据库；<strong>矩形(或称为源/入节点)</strong>，表示网络的起点或数据的接收者(通常是当前领域外的人或组织)。</p>

<p>DFD清晰地表达了工具的自然特征——如果DFD存在任何错误，也应当是显而易见、毋庸置疑的，这无疑减少了分析师与用户间产生认知分歧的可能。另一方面，实践证明DFD无论在概念描述或是建模方面都有显著价值。更重要的是，它提供了一种基于功能的系统分割方法，并且描述了不同部分之间的接口。在系统评审中，任何接口或过程的缺失都能够证明当前DFD的缺陷——这比纯粹的数学方式更加直观和有效。</p>

<p>在实际分析活动中通常使用分级数据流程图(Levelled DFD, LDFD)逐步求精分割系统功能。在LDFD中，通常存在3层、有时甚至更多层具有不同功能解析度的DFD。</p>

<p>Level 0，也被称为上下文图，通常仅包含一个气泡——也就是系统总的过程单位以及其它元素。这种图可以被用于和最宽泛的用户进行交流，例如干系人、业务分析员、数据分析员以及程序员。</p>

<p>Level 1，对上下文图的唯一气泡进行细分，将其分解成不同过程单位，以及相关的文件或数据库。</p>

<p>Level 2，进一步对Level 1进行划分，因此需要更多的文字和符号标记。</p>

<p>Level 3+，一般很少出现Level 3+的DFD，原因是这种级别的DFD可能存在过多的细节，从而导致难以沟通、比较和有效建模的问题。</p>

<h4>数据字典</h4>

<p>数据字典用于追踪和评估系统不同部分之前的接口，是对DFD的一种有效补充。以前面描述的系统DFD为例，过程3和7之间的数据流动Payment-Data，可以用如下公式进一步描述：</p>

<pre><code>Payment-Data = Customer-Name +              
               Customer-Address +
               Invoice-Number +
               Amount-of-Payment
</code></pre>

<p>换句话说，Payment-Data包括了该公式右值的所有数据项，且这些数据项需依序且非空。更进一步，数据字典还可能需要对某些数据项进行进一步描述，例如Invoice-Number：</p>

<pre><code>Invoice-Number = State-Code +
                 Customer-Account-Number +
                 Salesman-ID +
                 Sequential-Invoice-Count
</code></pre>

<p>与DFD类似，数据字典也是呈现了由顶至下的细分过程。每个DFD应该携带相应的数据字典描述，二者共同组成了系统分析的图形化产生物。</p>

<h4>逻辑策略表达</h4>

<p>逻辑策略表达用于替代传统冗长的文字叙述式的规格说明。最常见的结构化表达方式被称作结构化英语，例如采用按行缩进的方式表述不同层级的规格说明：</p>

<pre><code>If the amount of the voice exceeds $500.
    If the account has any invoice more than 60 days overdue.
        hold the confirmation pending resolution of the debt.
    Else (account is in good standing).
        issue confirmation and invoice.
Else (invoice $500 or less).
    If the account has any invoice more than 60 days overdue.
        issue confirmation, invoice and write message on the 
        credit action report.
    Else (account is in good standing).
        issue confirmation and invoice.
</code></pre>

<p>使用决策表表达上述规格说明，结果如下：</p>

<pre><code>                           RULES
CONDITIONS              1  2  3  4

1.Invoice &gt; $500        Y  N  Y  N
2.Account overdue
by 60+ days             Y  Y  N  N

ACTIONS

1.Issue confirmation    N  Y  Y  Y
2.Issue Invoice         N  Y  Y  Y
3.Msg to C.A.R.         N  Y  N  N
</code></pre>

<p>决策树的表达结果如下：</p>

<p><img src="http://content.hanyi.name/images/structured_analysis/decision_tree.png" alt="Decision Tree" /></p>

<h2>结论</h2>

<p>结构化设计为软件设计提供了有效的结构图工具，以及作者Larry富有经验的设计准则，至今仍极具指导意义。为了保证设计阶段能使用清晰有效的规格说明，结构化分析提供了强大的DFD分析工具和规格说明描述工具，尽管其核心依然是逐步求精的设计思想，但已经开始涉足于比编程活动更加宽泛的软件工业领域，最终形成了较为独立的需求工程，成为软件构建过程中不可或缺的环节。</p>

<h2>引用</h2>

<p>SMC74, <a href="https://ieeexplore.ieee.org/document/5388187">Structured design</a></p>

<p>TOM78, <a href="https://books.google.com/books/about/Structured_Analysis_and_System_Specifica.html?id=7o0-AAAAIAAJ">Structured Analysis and System Specification</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(4)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/"/>
    <updated>2018-10-12T15:28:06-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4</id>
    <content type="html"><![CDATA[<h2>结构化分析与设计方法(Structured Analysis and Design Methods)</h2>

<p>除了指导<a href="http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2/">程序设计</a>，结构化方法还被广泛应用于系统分析和设计领域，成为软件设计方法论的开端。从时间轴来看，从结构化编程到结构化程序设计，再到软件的结构化设计和分析，软件设计的方法论是从底向上发展的，其根本推动力是日益增加的系统复杂性。</p>

<h3>结构化设计(Structured Design)</h3>

<p>1974年，Larry Constantine等提出了一系列通过降低系统复杂性，从而提高编码、调试、修改等工作效率的软件设计思想，并将其统一命名为结构化设计[SMC74]。通用的结构化设计思想包括<strong>简洁性</strong>和<strong>可观测性</strong>，其中，简洁性作为衡量和评估设计方案的主要度量指标，体现在分割后的系统模块间具有设计、开发、更正、修改的独立性；可观测性则体现了软件易被感知功能和原理的能力。尽管系统分割具有良好的工程意义，但其引起的模块间重叠部分代码以及相互关系反而可能会增加复杂性。前文我们已经介绍了信息隐藏这一重要的模块化概念，结构化设计则提出了一个更具实践意义的设计指标：<strong>耦合(coupling)</strong>。</p>

<h4>耦合</h4>

<p>通常情况下，更少或更简洁的模块间连接就意味着更好的可理解性，同时变更或出错所引起的模块间传递也会受到抑制。系统复杂度不仅体现在模块间的连接数量，更体现在每个连接所承担的关联强度，这种强度的度量被称作<strong>耦合度</strong>。强耦合意味着高复杂度，造成模块难以被理解、修改和更正的后果。因此，软件设计可以通过建立模块间的弱耦合降低系统复杂度。</p>

<p>一个特定连接产生的耦合度是一个包含多重因子的函数，这些因子包括连接复杂度、连接指向模块自身亦或其内部、连接所发送或接收的内容等，Larry将其归纳为三个主要的耦合因子：接口复杂度、连接类型和通信类型。耦合度受这三个因子的变化规律如下表所示：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">Coupling</th>
<th style="text-align:center;">Interface complexity</th>
<th style="text-align:center;">Type of connection  </th>
<th style="text-align:center;">Type of communication</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">Low     </td>
<td style="text-align:center;">simple,obvious      </td>
<td style="text-align:center;">to module by name   </td>
<td style="text-align:center;">data                 </td>
</tr>
<tr>
<td style="text-align:center;">        </td>
<td style="text-align:center;">                    </td>
<td style="text-align:center;">                    </td>
<td style="text-align:center;">control              </td>
</tr>
<tr>
<td style="text-align:center;">High    </td>
<td style="text-align:center;">complicated,obscure </td>
<td style="text-align:center;">to internal elements</td>
<td style="text-align:center;">hybrid               </td>
</tr>
</tbody>
</table>


<p>Larry认为，弱耦合应具有接口简单直观，只通过名字引用其它模块，以及尽量仅通过数据进行通信等特征，反之则会增加耦合度。具体来说：</p>

<ol>
<li><p>接口复杂度，指模块间接口是否能清晰地表述连接，而不是包含了过多的信息导致难以理解。特别当多个模块通过共享一个公共环境(common environment)实现交互时，该公共环境中任意元素的增加都可能会导致系统整体复杂度的显著提升。例如在M个对象中，存在M(M-1)对相互关系，假设这些对象之间的公共环境包含N个元素，那么就有NM(M-1)对一阶关系，亦即变更或错误传递的可能路径数量。可见接口复杂度对系统整体复杂度的显著影响。</p></li>
<li><p>连接类型，指模块间相互关联的形式，例如仅通过模块名字进行关联，还是进一步引用了模块内部的元素。在后一种情况下，该模块内部的修改很可能传递至其它依赖它的模块，导致潜在的复杂度增加。</p></li>
<li><p>通信类型，指模块间通信内容的形式。对于系统中任何有效模块，其或者通过传递数据实现通信，或者通过被“控制”进行某项任务。显然，仅通过数据实现通信的接口更易被理解，而控制类型的通信使模块功能难以被直观理解。</p></li>
</ol>


<p>实现<strong>弱耦合</strong>的途径不一，一个方向是尽量降低元素间关系发生在不同模块间的可能，简单来说就是最小化模块间的关联，并且保证元素间关系只发生在相同模块内部。为了验证元素间关系是否都存在于模块内，Larry同时给出了一个描述模块内部元素间相互绑定程度的指标：<strong>内聚(Cohesiveness)</strong>。</p>

<h4>内聚</h4>

<p>由前述可知，实现内部高度绑定的模块，就能够达到降低耦合的目标，即模块自身的强内聚性。一般而言，对模块内聚程度的描述可以被划分成如下六个层级（由弱到强的非线性关系）：</p>

<ol>
<li><p>巧合的(Coincidental)。例如元素通过某种模块化方法被“无意间”划分到某个共同模块中，或者某个模块的创建仅仅是为了消除重复代码。在这种情况下，模块极易因为变更而变得“不可重用”，因此这类绑定只是发生于巧合之中。</p></li>
<li><p>逻辑的(Logical)。这种关系通常隐含了某种逻辑联系，例如负责程序中所有输入输出的模块，或者负责操作所有数据的模块。其问题在于，以此类关系实现的模块易存在内部元素间的相互缠绕，从而降低元素间的独立性，同时也会导致模块接口的复杂性增加。</p></li>
<li><p>一时的(Temporal)。该关系建立在逻辑层面的关系基础上，同时元素间还存在某种时间上的一致性。例如程序的初始化、终止、清理等阶段的操作，其元素间存在一定的功能逻辑，同时也常一起发生。尽管如此，这种关系依然存在于逻辑层面类似的缺陷。</p></li>
<li><p>通信的(Communicational)。元素间通过相同输入/输出数据集合的引用进行关联，例如“打印”和“装订”文件，显示出更强的绑定关系。</p></li>
<li><p>连续的(Sequential)。如果某个元素的输出恰好是另一个元素的输入，即意味着目标问题可以通过简单流程图进行描述和解决，那么其存在连续的强绑定关系。但需要注意，这种过程式处理会导致该模块独立于程序的其它功能部分，从而使其难以被其它系统模块复用。这也是连续层面与进一步功能层面关系所导致的内聚度存在较大差距的原因。</p></li>
<li><p>功能的(Functional)。在这种层面的关系下，模块中的元素都与同一个独立功能相关。一种判断某个模块是否为功能层面的绑定的方法是，通过一句话描述该模块功能，然后进行验证：</p>

<ol type="a">
<li><p>该句是否为复合句，是否包含逗号、多个动词等等，如果是则该模块可能包含连续或通信层面的绑定；</p></li>
<li><p>如果语句中包含时间相关的词，那么可能存在一时或连续层面的绑定；</p></li>
<li><p>如果语句中动词的操作对象不是一个特定对象，那么可能存在逻辑层面绑定；</p></li>
<li><p>如果语句中包含初始化、清理等词，说明可能是一时层面的绑定。</p></li>
</ol>
</li>
</ol>


<p>值得注意，元素间可能存在多个上述的关系，而通常我们可以使用其中内聚度表现最高的关系表示整体程度。但是如果模块中没有一组元素的关系表现为功能层面绑定，那么该模块的内聚性就表现较低。</p>

<h4>可预测模块</h4>

<p>模块的可预测性是指当给定相同的输入时，该模块每次被调用所发生的操作也完全相同，亦即独立于环境的特性。不可预测的模块不一定是存在错误的，例如当模块内部维持某种状态，该状态在针对当前模块的操作下会发生不断变化，从而导致返回结果或实际发生操作的不同。这种不可预测的模块在实际应用中经常发生，尽管是无错误的。模块的可预测性，有时也被成为“黑盒性”，使该模块能较容易被清楚地理解，例如通过简单的注释、描述性的名字或者良好定义的接口等方法。</p>

<h3>结构化设计技术</h3>

<p>软件设计过程可以被看作包含一般设计和详细设计两个部分。一般设计的目的在于确定系统需要的函数有哪些(回答what)，详细设计描述如何实现这些函数(回答how)。这些设计阶段需要确定函数标识、函数范围结构的调用参数和调用关系、所关联的模块等信息，并且保证模块能够被独立设计、实现和测试。</p>

<h4>结构图(Structure Chart)</h4>

<p>传统的流程图方法能够描述代码块执行的顺序和条件分支，但是在一般设计阶段，由于我们侧重于了解what，流程图会不可避免地增加设计复杂度。因此这里介绍一种较为简单的结构图用于表述函数及其调用关系。结构图所包含的符号标记如下图所示：</p>

<p><img src="http://content.hanyi.name/images/structured_design/definitions_of_symbols_used_in_structure_charts.png" alt="Definitions of symbols used in structure charts" /></p>

<p>假设某系统设计包含三个模块，分别是A、B和C，其中模块间的关系是A调用B，B调用C；从执行顺序上看，B的代码会首先执行，然后是C，最后是A。那么上述信息可以分别用结构图和流程图表示如下：</p>

<p><img src="http://content.hanyi.name/images/structured_design/structure_chart_vs_flowchart.png" alt="Structure Chart vs Flowchart" /></p>

<p>从上图可以看出，相比于流程图，结构图能够清楚表示模块间关系，并且有潜力进一步描述模块的接口信息，这恰好是在一般程序设计阶段需要进行的工作，流程图就不具有优势。</p>

<h4>基于结构图的软件设计过程</h4>

<p>下面以设计一个较为复杂的模拟输入——处理——输出(Input Process Output, IPO)类型的系统为例，给出一种衍生自结构图、由IBM开发的基于层次输入处理输出(Hierarchical IPO)图的一般设计过程：</p>

<p>Step 1. 根据问题描述，绘出系统大致的功能性草图。本例中模拟系统的大致功能是一个数据输入、处理和输出的过程，其大致可以被描述如下：</p>

<p><img src="http://content.hanyi.name/images/structured_design/rough_structure_of_simulation_system.png" alt="Rough structure of simulation system" /></p>

<p>Step 2. 识别外部的概念数据流，指来源于系统外的、独立于具体物理I/O设备的相关数据流。在本例中，概念数据流包括输入参数、格式化的返回结果等。</p>

<p>Step 3. 识别问题中的主要概念数据流(包括输入和输出)，确定该问题的功能图中的“最高级抽象”节点。对于输入的数据流而言，其抽象节点存在于距离物理输入形态最远，但依然可以视作输入数据的阶段。本例中该节点可能在于构建矩阵阶段。同时，针对输出数据流可以把结果矩阵作为输出的抽象节点，如下图所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/determining_points_of_highest_abstraction.png" alt="Determining points of highest abstraction" /></p>

<p>Step 4. 根据前面步骤得到的信息，针对每个抽象输入数据节点，使用一个源模块(source module)表示其结构。相应设计对应的入模块(sink module)。通常系统存在一个源和入分支，具体参数依赖问题描述而定，但其通用模式如下图所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/the_top_level.png" alt="The Top Level" /></p>

<p>在本例中，模块A即系统入口，也就是说模块A的功能意味着整个问题的解决；模块B用于获取主要数据流；模块C用于把主要输入流变换成主要输出流；模块D用于处理主要的输出数据流。</p>

<p>Step 5. 针对源模块，通过识别其中最后一次变换操作，生成当前模块的数据返回形式，然后再识别前一次变换的抽象节点。对于入模块，与源模块相反，通过识别其中第一次处理操作，确认抽象输出节点，直到获取期望的输出形式。基于逐步求精的思想重复步骤5，直到抵达最初的源模块和最后的入模块。构建出的部分结构图如下所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/lower_levels.png" alt="Lower Levels" /></p>

<p>在这一逐步求精的设计过程中，划分的终止条件因具体问题而异，通用的判断方法之一即前文提到的耦合与内聚等设计思想。</p>

<p>（未完待续）</p>

<h2>结论</h2>

<p>结构化设计的兴起使结构图及其衍生工具成为软件设计领域的重要工具。同时，在软件设计模块化道路上的深入实践也促使许多重要的软件设计思想被提出，诸如耦合、内聚等重要概念被广泛用于指导包括结构化设计及后续的设计方法论，影响至今。</p>

<h2>引用</h2>

<p>SMC74, <a href="https://ieeexplore.ieee.org/document/5388187">Structured design</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(3)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/03/software-design-and-architecture-notes-3/"/>
    <updated>2018-10-03T14:34:10-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/03/software-design-and-architecture-notes-3</id>
    <content type="html"><![CDATA[<h2>模块化编程(Modular Programming)：信息隐藏与职责分割</h2>

<p>上世纪60年代起，人们意识到实现复杂系统的前提是把系统合理分割为相互独立的部分，这些独立的部分被称作<strong>模块</strong>。与前文提到的结构化编程和过程式编程的区别是，一个模块可包含若干个子程，也允许组装不同模块以实现子程或程序。D.L. Parnas把这种编程技术称为<strong>模块化编程</strong>[DLP72]，其中模块意味着任务职责，而模块化设计则表示一系列的跨模块的“系统级”设计决策。自此，模块化成为软件设计领域的重要主题之一。</p>

<p>针对模块化的研究包含两个基本组成部分：</p>

<ol>
<li><p>一个良好的模块化系统（设计）应具备哪些特征？</p></li>
<li><p>一个良好的模块化系统（设计）应如何实现？</p></li>
</ol>


<h3>信息隐藏(Information Hiding)</h3>

<p>最初的软件设计方法论认为，组织应当建立统一的文档管理系统，软件由设计人员设计好后开放给全体人员，从而让每个人都尽量了解设计背后包含的一系列<strong>决策</strong>。1971年，Parnas首次提出<strong>信息隐藏</strong>的概念，反驳了前述的传统设计“广播”实践[DLP71]。</p>

<p>从软件结构的角度看，软件设计包含了对模块自身特征以及模块间的连接(connetion)的描述，其中连接意味着设计对模块间作用的假设。而我们已经知道软件结构最重要的两个目标：<strong>系统变更</strong>和<strong>正确性检验</strong>，而一个好的软件结构应使上述目标变得更加容易。以简化系统变更为例，如何使针对当前模块的变更不会传递到其它模块呢？答案当然是应尽量使针对当前模块的变更不至于打破其它模块对其所做的假设，即连接的稳定性。那么如何保证连接的稳定呢？直观来看当然是尽量减少假设的规模，即减少连接所包含的信息。</p>

<p>再以软件文档系统为例，实践证明，保证系统设计文档和代码的一致性需要花费可观的成本，这在大多数组织来说都难以实现。同时为了保证文档自身的可理解性，一个好的实践是建立组织统一的标准和术语，但实践证明这也很难做到，因为假设总会根据需求发生变更，而一旦新的假设违反了组织统一标准，则会引起标准的误用，而反过来扩展标准又有可能造成对已有文档假设的破坏。上述复杂性意味着，在一个实践统一文档标准的组织内，标准会尽量维持系统设计的最小假设，而这又会与文档本身的知识传递作用相违背。</p>

<p>Parnas认为设计人员应尽量“控制”信息的传播，例如在设计中只使用外部<strong>接口</strong>描述该模块，从而避免细节过早暴露，对外部隐藏那些尚待决定、不稳定或不应被外部了解的具体实现。</p>

<h3>职责分割(Responsibility Segment)</h3>

<p>人们普遍认为应根据功能职责划分系统模块，但缺少统一的划分方法，导致具体划分时会出现不同结果，原因在于实际问题域的复杂性。以比较简单的经典<a href="https://en.wikipedia.org/wiki/Key_Word_in_Context">KWIC</a>系统为例，考虑如下两种模块化设计方案：</p>

<ol>
<li><p>系统被划分成5个部分：分别是输入模块I、循环移位(circular shift)模块C、字母排序(Alphabetizing)模块A、输出模块O和主控制模块M。具体来说，I接受行格式的数据输入，把每个单词用四个字母进行压缩表示，其余字母作为单词的结尾，然后将其存储到系统核心(core)；当I读完所有数据，C先对核心中每行数据进行循环移位处理，并记录每条新数据到原始数据的索引，最后把数据存储回核心；然后，A从核心中读取数据，把C中生成的数据按字母进行排序并存储回核心；最后O把A中排序好的数据结合I中获得的原始数据进行匹配和格式化输出；主控制模块M负责控制其余模块的调用顺序，进行错误处理和进行一些必要的空间分配等操作。从实践角度考虑，该方案具备良好的职责分割和接口设计。</p></li>
<li><p>系统被划分成6个部分：行存储模块L、输入模块I&#8217;、循环移位器C&#8217;、排序器A&#8217;、输出模块O&#8217;
和主控制模块M&#8217;。具体来说，L负责提供对行数据进行操作的功能，例如常见的增删改查等；I&#8217;负责读入数据并调用L写入数据；C&#8217;用来计算并返回所有的循环移位索引。A&#8217;的功能是返回给定索引序号的字母序序号；O&#8217;用于输出L或C&#8217;中包含的数据；M&#8217;与方案1中M的功能类似。该方案也具有良好的职责分割和接口设计。</p></li>
</ol>


<p>为了进一步比较这两种方案的区别，首先来看两者在分析该问题时所作出的设计决策及其可能影响：</p>

<ol>
<li><p>输入格式。</p></li>
<li><p>存储介质，例如把所有行数据存储在core中，那么假设数据集较大，则该决策就会面临挑战。</p></li>
<li><p>存储压缩，例如对每个单词进行压缩，假设数据集不大，处理时间反而会因为不必要的压缩而增加。</p></li>
<li><p>为循环移位器创建索引，而非直接存储所有数据，对于较小的数据集而言，后一选项可能更加合适。</p></li>
<li><p>为所有数据进行一次性按字母序排序，而非只在需要时进行搜索或只进行部分排序。在某些场景中，可能更希望把索引计算量分配至不同时间的字母序操作中。</p></li>
</ol>


<p>以下分别使用<strong>是否容易变更</strong>、<strong>是否可独立开发</strong>和<strong>是否便于理解</strong>三个具有共识的软件设计目标分析和比较上述方案。</p>

<p><strong>易变更性</strong>，由于都拥有唯一的输入模块，那么决策1的任何潜在变化都不会导致输入模块以外的变化；对决策2和3来说，由于涉及数据的格式表示，方案1中由于多个模块都需要直接读写core中的数据，一旦存储格式因假设发生变化就会导致所有关联模块的修改，相应的方案2由于独立出了行存储功能，因此依旧把改动影响限制在了一个模块之内。同样，决策4的变更可能导致存储格式的变化，方案2中的C&#8217;模块只用于计算而非存储，因此变更影响小于方案1；决策5的情况则与决策4类似，方案2具有更好的易变更性。</p>

<p><strong>可独立开发</strong>，方案1的模块间接口实际上是通过数据存取间接实现的，其实质是数据格式和表结构的设计，在这种情况下，所有相关模块的接口设计都存在一定联系。而方案2通过若干个函数及其参数就实现了模块间的接口，因此对模块分别可独立开发有更好的支持。</p>

<p><strong>可理解性</strong>，根据方案1，为了理解模块职责，需要至少理解模块I、C、A内部的实现，特别是数据存取的设计和实现，才能了解模块间的相互关系；相反方案2只需要通过接口函数的定义就可以了解模块职责了。</p>

<p>从职责分割的角度来说，上述两种方案都给出了初看相当合理的划分，但经过分析我们的结论显然是方案2比方案1更好，那么如何实现诸如本例中更好的职责分割呢？</p>

<h2>一种用于模块分割的标准与系统设计方法</h2>

<p>实际经验表明，人们直观上会倾向于作出符合上节提到的方案1的设计，这是因为方案1更加显而易见：例如借助流程图(flowchart)工具描述系统功能和流程，再自然映射在模块的划分上。而方案2的核心在于每个模块都努力隐藏其设计决策，包括接口和定义也都以较少的信息呈现，Panars认为这反映了一种以隐藏自身设计决策为目标的模块间分割标准，与传统的流程式思考模式有显著区别。</p>

<p>由于构建计算机系统的复杂性，设计人员在60年代起开始采用一些系统模拟语言(Simulation languages)辅助系统设计。显然，当系统需求越复杂，模拟语言也就会变得更复杂，就越难以满足设计人员的目标，因此模拟语言最初的应用并不成功。1968年，沃森研究院的F. W. Zurcher描述了一种迭代式的多层建模方法，通过在不同的抽象层级(Levels of abstraction)上安排设计决策，为设计人员提供了有效的系统思考工具。</p>

<p>Zurcher提出在一个模型中构建系统的多重表示，即<strong>抽象层级</strong>。以计算机系统为例，在最上层，该模型只表示系统的若干基本任务，并且给定这些功能所达到的目标，即始终优先回答what；进一步，在下一层引入CPU、存储层级和文件系统的概念，并指定连接上层每个任务的程序和数据的划分；然后，再下一层级描述更加细节的系统表示，直到完整描述了整个系统设计，即回答how。<strong>迭代</strong>在实现上述方法中同样重要。在采用模拟语言时，先实现上一层的系统设计描述程序，程序应包括本层所含的所有抽象定义；在进入下一层时，构建一个独立的可被上层操作的实现本层抽象意义的模拟程序，从而实现迭代式的层次设计结构。</p>

<p>这种层级建模方法中，每一层都仅包含该层定义范围内的设计决策，即令设计人员更容易理解模型及其具体行为，并且把针对设计的修改限定在本层级范围内，降低了设计变更的影响范围。当进入正式实现阶段时，编程人员可以用具体的算法和数据结构实现替换最底层的模拟程序，从而构建完整系统。</p>

<h2>结论</h2>

<p>如果说结构化编程奠定了现代编程语言的基础，那么模块化编程则为软件设计提供了应对复杂问题的有效工具。与结构化编程和过程式编程几乎一锤定音相比，模块化编程在过去50年间历经了长期演进，虽然70年代开始大量编程语言开始引入模块(module)的概念，但抽象表达本身的复杂性使整个软件设计和开发过程经历了飞速的变革，而这一切源于模块化的设计思想。</p>

<h2>引用</h2>

<p>[DLP72], <a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">On the Criteria to be Used in Decomposing Systems into Modules</a></p>

<p>[DLP71], <a href="http://cseweb.ucsd.edu/~wgg/CSE218/Parnas-IFIP71-information-distribution.PDF">Information distribution aspects of design methodology</a></p>

<p>[FWZ68], <a href="https://pdfs.semanticscholar.org/d99a/732db8e249be47bdf4aacd260f608b632099.pdf">ITERATIVE MULTI-LEVEL MODELLING - A METHODOLOGY FOR COMPUTER SYSTEM DESIGN</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(2)]]></title>
    <link href="http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2/"/>
    <updated>2018-09-25T09:46:21-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2</id>
    <content type="html"><![CDATA[<h2>结构化编程(Structured Programming)：计算语言的突破</h2>

<p>上世纪50-60年代，人类的计算能力实现了迅猛发展，各界对计算机的应用也有很高期许，越来越多的领域希望得到强大的计算赋能从而实现飞跃。然而当面临的问题越多、越复杂时，人们在解决问题的道路上发现了一条巨大的鸿沟，即以现有的软件构建理论和方法难以应对这些挑战。机遇与挑战并存，这场<strong>软件危机</strong>(Software Crisis)最终促成了软件工程作为一门独立的学科从计算机科学的襁褓中成长起来。</p>

<p>软件危机这个词最早在1968年的北约组织软件工程会议上被诸多与会者提出[NATO68]，由此引发的技术创新和组织行为思辨至今依然活跃。而更现实的影响是，科学家们首先在编程语言本身找到了突破口——<strong>结构化编程</strong>。</p>

<p>发明于上世纪50年代的ALGOL语言，首次用begin&hellip;end语句引入了<strong>代码块</strong>的概念，通过限定其中变量声明的词法作用域，提高程序的<strong>可读性</strong>，从此引起了围绕代码块的研究。1966年，论文[Bohm66]证明使用三种基本的程序结构就能表达任何可计算函数：顺序执行、条件选择和循环迭代，这为随后针对结构化编程的讨论提供了理论依据。1968年，Dijkstra发表了著名的”GOTO语句有害“的观点，并且肯定了如条件选择、循环等语句的应用，同时称GOTO语句应该在所有“高级语言”（这里指除了机器码之外的语言）中被废除[EWD68]。Dijkstra认为应当尽可能减少静态程序和动态运行进程之间的差距，而GOTO语句造成了大量程序难以被理解，即人很难从混乱的静态代码中认识程序的真正意图。这一废除GOTO语句的言论激起旷日持久的争论，反对者认为GOTO所具有的灵活性能满足持续的系统优化工作，但争论两方基本同意应当对GOTO限制使用。于是，结构化编程开始被广泛接受。</p>

<p>伴随着结构化编程的普及，过程式编程(Procedural programming)也在60年代起被许多流行语言采纳，如COBOL和BASIC。这种编程方法以代码块为基础，允许使用子过程（也称子程或函数）编写程序单元，并且可以被程序随时调用。使得来自不同程序员甚至不同组织的代码变得简单可复用，为随后代码库的流行奠定基础。</p>

<h2>结构化程序设计与分析</h2>

<p>结构化编程实现了编程语言的巨大进步，作为首席布道者，Dijkstra发表了很多关于程序的可理解性以及结构化编程实践的原则性观点[EWD70]，但如何设计结构化程序还需要进一步说明。1971年，在计算机教育领域功勋卓著的Niklaus Wirth详细解释了一种自顶而下逐步求精的程序设计方法，并以数学中经典的八皇后问题（把这个著名问题作为编程案例，原因之一是尚无该问题的已知解析解）为例演示了程序设计从问题分析到实现的过程[NW71]。</p>

<p>简单分析可以得到八皇后问题的直观解法：对于全体候选解的集合A，其中每个解元素x满足条件函数p，即(x ∈ A) ∧ p(x)，则：
<code>
repeat Generate the next element of A and call it x
until p(x) ∨ (no more elements in A);
if p(x) then x = solution
</code>
由排列组合知识可知，集合A的空间可达2<sup>32</sup>，枚举算法效率较低。通过对问题进一步的分析，使用回溯法解决该问题的算法效率较高，即：
<code>
j := l;
repeat trystep j;
if successful then advance else regress
until (j &lt; 1) ∨ (j &gt; n)
</code>
以上述程序分析结果为基础构建程序，按照回溯算法的基本思想，首先依照specification给出初步实现：
<code>
variable board, pointer, safe;
considerfirstcolumn;
repeat trycolumn;
    if safe then
    begin setqueen; considernextcolumn
    end else regress
until lastcoldone ∨ regressoutoffirstcol
</code>
根据现有结构化编程语言的表达能力，对如下指令进一步分解：</p>

<p>trycolumn:
<code>
procedure trycolumn;
repeat advancepointer; testsquare
until safe ∨ lastsquare
</code></p>

<p>regress:
<code>
procedure regress;
begin reconsiderpriorcolumn
    if ¬ regressoutoffirstcol then
    begin removequeen;
        if lastsquare then
        begin reconsiderpriorcolumn;
            if ¬ regressoutoffirstcol then
                removequeen
        end
    end
end
</code>
截至目前，如需对上述程序中的指令做进一步分解，就需要设计额外的数据表示了。通过分析待分解语句，可知需要设计一个记录每位皇后位置的数据表示，例如使用二维数组表达棋盘上的每个方块。这里给出一个优化的数据表示方式：
<code>
integer j (0 ≤ j ≤ 9)
integer array x[1:8] (0 ≤ x[i] ≤ 8)
</code>
其中j表示当前被检查的列序号，一维数组x用于存储上一次被检查方块的坐标，程序的部分指令可以被进一步细化为：
<code>
procedure considerfirstcolumn;
    begin j := 1; x[1] := 0 end
procedure considernextcolumn;
    begin j := j + 1; x[j] := 0 end
procedure reconsidetpriorcolumn; j := j - 1
procedure advancepointer;
    x[j] := x[j] + 1
Boolean procedure lastsquare;
    lastsquare := x[j] = 8
Boolean procedure lastcoldone;
    lastcoldone := j &gt; 8
Boolean procedure regressoutoffirstcol;
    regressoutoffirstcol := j &lt; 1
</code>
接下来考虑剩余指令testsquare、setqueen和removequeen。</p>

<p>指令testsqaure需要验证是否满足问题条件，通过已知的x数组应不难通过计算进行判定，问题是可能导致较高的计算量，同时考虑到testsquare的调用频次较高，这里采用额外数据表示进行优化，设计三个Boolean型数组，其意义如下：
<code>
a[k] = true : no queen is positioned in row k
b[k] = true : no queen is positioned in the /-diagonal k
c[k] = true : no queen is positioned in the \-diagonal k
</code>
那么testsquare就可以用简单的布尔运算表示，其余指令也可以通过上述结构完成：
<code>
procedure testsquare;
    safe := a[x[j]] ∧ b[j+x[j]] ∧ c[j-x[j]]
procedure setqueen;
    a[x[j]] := b[j+x[j]] := x[j-x[j]] := false
procedure removequeen;
    a[x[j]] := b[j+x[j]] := c[j-x[j]] := true
</code>
此时发现上述实现的x[j]调用次数过多，为了进一步优化，把x[j]用变量i表示，从而有：
<code>
procedure testsquare;
    safe := a[i] ∧ b[i+j] ∧ c[i-j]]
procedure setqueen;
    a[i] := b[i+j] := c[i-j] := false
procedure removequeen;
    a[i] := b[i÷j] := c[i-j] := true
procedure considerflrstcolumn ;
    begin j:= 1; i:= 0 end
procedure advancepointer; i := i + l
procedure considernextcolumn
    begin x[j] := i; j:=j+l; i := 0 end
Boolean procedure lastsquare;
    lastsquare := i = 8
</code>
通过inline替换程序中的部分指令，其余采用过程调用，从而最终实现如下程序：
<code>
j := 1; i := 0;
repeat
    repeat i := i + 1 ; testsquare
    until safe ∨ (i = 8);
    if safe then
    begin setqueen; x[j] := i; j := j + 1; i := 0
    end else regress
until (j &gt; 8) ∨ (j &lt; 1);
if i &gt; 8 then PRINT(x) else FAILURE
</code>
前述过程清晰解释了逐步求精这种非常经典的结构化程序的分析和设计过程，从早期分析确定适用算法，然后利用基本的结构化编程元素描述初步程序，对复杂过程进一步分解，同时考虑额外必要的数据表示和程序运行效率优化，最终使用目标编程语言实现程序。这是一种具有普遍适用意义的编程方法论，也呼应了Wirth的那句名言：程序=算法+数据结构。</p>

<h2>结论</h2>

<p>50年前的软件危机所揭露的问题成为今天软件工程研究的基石。GOTO语句的争论直至今天，从历史发展看，更多人选择支持Dijkstra的GOTO有害论，许多90年代以后出现的编程语言并没有在应用层面设计GOTO语句。但是，GOTO争论背后有关编程语言灵活和统一的争辩还远未结束。另一方面，结构化编程促成了一套良好的编程方法论，迄今Wirth的逐步求精方法还被采用于程序设计课程，为计算机教育的普及和广泛应用打下了坚实基础。同时，软件设计所要解决的问题也得以提升到更高的复杂度水平。</p>

<h2>引用</h2>

<p>NATO68, <a href="http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF">NATO Software Engineering Conference</a></p>

<p>Bohm66, <a href="http://www.cs.unibo.it/~martini/PP/bohm-jac.pdf">Flow Diagrams, Turing Machines and Languages with Only Two Formation Rules</a></p>

<p>EWD68, <a href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF">Go-to statement considered harmful</a></p>

<p>EWD70, <a href="https://pure.tue.nl/ws/files/2408738/252825.pdf">Notes on structured programming</a></p>

<p>NW71, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.119.8111&amp;rep=rep1&amp;type=pdf">Program Development by Stepwise Refinement</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(1)]]></title>
    <link href="http://www.hanyi.name/blog/2018/09/24/software-design-and-architecture-notes/"/>
    <updated>2018-09-24T11:57:34-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/09/24/software-design-and-architecture-notes</id>
    <content type="html"><![CDATA[<p><strong><em>《软件设计与架构笔记》系列，是笔者对自上世纪60年代末至今在工业界和学术界皆有一定影响的软件设计方法的学习和记录，期望通过历史的时间轴把握相关技术发展的脉络，尝试理解推动了这一领域中概念、方法、原则、模式、实践不断演进的若干基本动机，倚靠巨人的肩膀，但求一条少些人云亦云的实践之路。</em></strong></p>

<p>自诞生之日起，软件设计就同时在工业界和学术界探索和实践着，然而二者的动机和方法大相径庭。例如计算机科学家Edsger W. Dijkstra，一生就致力于对计算的简洁性和精确性的探索，其工作背后蕴含了严谨的数学美学；而工业界则侧重于使用由计算衍生的自动化方法解决传统生产的问题，根本目的是追求经济利益的最大化。有趣的是，二者的偶然交汇就迸发出这一系列文章的主题——软件设计，而软件架构——作为稍晚出现的buzz word，有时也被本文采用以和行业用语保持一致。</p>

<h2>THE Multiprogramming system：早期探索</h2>

<p>1965年，Dijkstra在埃因霍温科技大学领导了一支团队在Electrologica(EL) X8上开发多道程序系统，该系统的主要目标是能够平滑地处理持续的用户程序流，并将其作为服务提供给学校。该系统的设计目标是：1.降低短程序运行的周转时间； 2.更经济地使用外设; 3.结合后备存储器的自动控制和中央处理器的经济使用; 4.验证一种经济可行性，即将EL X8用于运行在不依赖容量和计算能力，仅需要通用计算机灵活性的应用程序。</p>

<p>出于多道程序系统的<strong>复杂性</strong>，实时触发中断的偶然性和不可复现性使系统开发的debug面临挑战。为此，团队决定在系统构建之初就重视对debug能力的设计，从而在具体实现前就能证明系统的逻辑可靠性，并显著降低了实际bug数量。在论文EWD68中，为了提高<strong>可测试性</strong>，设计者采用层级结构划分整个系统，并以不同的职责区分系统层级：</p>

<p>0级，负责把逻辑可用的进程分配给处理器。为了防止任何进程独占处理器，该层实现了一个实时时钟中断功能。</p>

<p>1级，实现“段控制器”，通过中断与上层的顺序进程保持同步，负责从自动后备存储器中记录数据。</p>

<p>2级，实现“消息解释器”，负责在控制键盘的输入时产生中断，并且联接系统对话的操作员和特定的目标进程。</p>

<p>3级，实现与输入流缓冲和输出流解缓冲相关的顺序进程，通过逻辑通信单元实现对具体外设的抽象，并按照资源限制采用同步方法限制外设运行的数量。</p>

<p>4级，实现独立用户程序。</p>

<p>根据上述层级划分，团队制定了需求规格说明书，并依此实现系统。在验证阶段，在添加下一层级前，需要对前一层进行充分测试，例如针对0级中实现的实时中断和处理器分配，首先设计一个完整的测试状态空间，然后依次进行测试。而当对1级的“段控制器”进行测试时，可以在0级时制定的测试状态空间的基础上，通过引入“请求页”操作，实现状态空间的扩展，只需引入少量新的测试就可以满足当前层的测试需求，直至完成整个系统。</p>

<p>Dijkstra认为，虽然在概念和设计阶段花费了较长时间，但是该过程为系统贡献了良好的设计，避免传统非层级实现可能面临的测试状态空间“爆炸”问题，从而对系统质量提供保证。</p>

<p>虽然缺少定量的研究方法，发布于1968年的THE Multiprogramming System可以说是首次定性地证明了<strong>结构</strong>在软件设计中的重要作用，并且以系统的可测试性为例进行了深入阐释。</p>

<h2>结论</h2>

<p>系统的复杂性引出了软件设计问题。Dijkstra把软件开发过程划分成三个阶段：概念、构建和验证，并且由一个基于层级划分的设计案例指出结构因素在软件设计中的重要性。虽然工业界可能面临更多的问题（例如成本、人员、规模、业务复杂程度等），但是概念阶段产出的良好设计，能使验证阶段受益，从而实现整体的系统质量保证（笔者注：某种程度上也起到控制成本的作用），是THE多道程序系统的一项重要结论，也启发后人对软件概念阶段本身和其边际效应的进一步研究。</p>

<p>值得一提的是，按照不同职责划分层级，底层能够对上层隐藏其核心概念和具体实现，例如0级隐藏了处理器操作，1级隐藏了“页存储”机制，2级隐藏了电传打印控制台等。但是“信息隐藏”作为一个基本设计概念被明确提出，则是若干年以后了。</p>

<h2>引用</h2>

<p>[EWD68] EW Dijkstra, <a href="http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD196.PDF">The structure of the &lsquo;THE&rsquo;-multiprogramming system.</a></p>
]]></content>
  </entry>
  
</feed>
