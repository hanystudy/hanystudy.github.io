<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Wing of Dream 梦境之翼]]></title>
  <link href="http://www.hanyi.name/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://www.hanyi.name/"/>
  <updated>2019-03-10T18:00:41-04:00</updated>
  <id>http://www.hanyi.name/</id>
  <author>
    <name><![CDATA[Han Yi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(10)]]></title>
    <link href="http://www.hanyi.name/blog/2019/03/10/software-design-and-architecture-notes-10/"/>
    <updated>2019-03-10T03:11:07-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/03/10/software-design-and-architecture-notes-10</id>
    <content type="html"><![CDATA[<h2>面向模式的领域分析与建模</h2>

<p><a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">前文</a>讨论了OOA/OOD的基本概念、工具和方法。我们已经知道，当面临稍复杂的问题域或特殊的上下文时，朴素方法会面临许多挑战，使软件开发风险难以得到有效控制。模式的发现和应用为工业界带来了高效的解决方案，也因此成为甚至比朴素方法更易流行的方法论，即<strong>面向模式</strong>(Pattern oriented)。本文是对前文OOA部分的进一步补充和扩展，首先讨论<strong>领域分析</strong>(Domain analysis)，及其与数据建模和OOA的关系，然后深入讨论面向对象分析模式，这些模式大多采用领域特定的概念模型(也称分析模型)进行描述，与纯粹抽象的表达方式相比更易理解，然而其模型结构和分析过程可被应用至更广泛的领域。</p>

<h3>领域分析</h3>

<p><strong>领域分析</strong>是指为了满足跨组件的可复用性，对软件开发信息进行识别、收集、组织的过程[RPD90]。当相似的问题域重现时，期待所构建的软件能够尽可能被复用，从而提高软件的经济效益，这是领域分析的根本动机。因此，相对于可复用的代码，领域分析主要关注于分析和设计的可复用性，这通常反映为组件级的可复用性[JMN80]。</p>

<p>在软件工程的语境下，<strong>领域</strong>是指所构建软件系统的实际应用场景。具体来说，一个领域既可以大至银行业务，也能小至算术运算。一个领域还能被分解成多个子领域，因此复杂的领域可被看成是一种层级的网状结构，层级越高则意味着领域的复杂度也就越高。<strong>领域边界</strong>用于描述领域的范围，定义了每个领域中的对象、操作以及相互之间的关系。<strong>组件</strong>是指一个独立的软件单位，这种独立性可以指独立开发、独立部署或独立运维等特性，并且组件之间还能通过某种协议进行通信。领域是业务单位(例如对应不同的业务部门)，组件则是工程单位(例如对应不同的项目或开发团队)，但二者最终存在一定的映射关系。虽然领域分析有比较明确的目标，但具体的实现方法属于非平凡问题。例如如何确定领域层级、如何确定领域边界以及如何建立与组件之间的映射关系等。</p>

<h4>领域分析的框架模型</h4>

<p>[RPD90]描述了领域分析的结构化上下文视图(SADT Context View)，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/domain_analysis.png" alt="Domain analysis" /></p>

<p>在上述模型看来，领域分析实际上是一种依赖多种输入且高度参数化的框架，其最终产出也可根据参数进行定制。例如，当核心是某个产品而非技术时，领域分析主要关注战略一致性、市场策略、产品定位、风险分析、日常外观等一系列产品特性，这时需要用到通用术语调研、逻辑架构、可靠性标准等方法——这种领域分析活动被称为<strong>产品定义领域分析</strong>(Product definition domain analysis)。当有明确的证据支持当前产品流时，即可进一步就具体产品展开分析，这时往往是概念性领域分析，该活动被称为<strong>需求领域分析</strong>(Requirement domain analysis)。当表示产品线的领域趋于稳定时，就可以考虑构建特定领域的生成器，从而满足高效构建新产品的需求，此过程被称作<strong>生成器领域分析</strong>(Generator domain analysis)。</p>

<h4>领域分析、数据建模、OOA</h4>

<p>我们在<a href="http://www.hanyi.name/blog/2018/12/09/software-design-and-architecture-notes-6/">数据模型与数据建模</a>一文曾讨论过数据建模。从上世纪80年代初期开始，由于关系模型和关系数据库系统的流行，信息系统的构建往往都强依赖于数据库系统。为了保证概念模型能直接用于后续设计和实现，数据建模、特别是概念数据建模成为需求领域分析活动的主要内容之一。其中，实体-关系建模(ER modeling)是数据建模中最具代表性的方法，其分析结果即ER图，后者往往被直接用于数据库设计甚至应用构建[DCH96]。虽然数据建模也重视对真实世界的反映，但其更侧重于表现状态而非过程，而事实上两者对于软件开发同样重要，这也是兼具二者的OOA后来居上的原因。而OO天然具有的<strong>抽象层级</strong>和<strong>抽象边界</strong>等概念，与前文提到的领域和领域边界的概念能够一一对应，且其最终得到的领域概念和对象，亦即需求领域分析的目标。</p>

<p>因此，数据建模和OOA都是领域分析采用相应建模技术的具体实现。在领域分析方法的发展过程中，二者都扮演了重要角色。虽然至今领域分析方法都在不断演进，但从已有经验总结得出的分析模式，能够为常规的领域分析活动提供可靠的候选参考。</p>

<h3>面向对象分析模式</h3>

<p>概念模型是理解和模拟真实世界的基础，但由于后者的复杂性通常都超乎想象，导致概念模型基本不存在正确与否的问题。对此Martin Fowler用模拟斯诺克的例子解释：当需要对球的运动进行建模时，经典牛顿力学和爱因斯坦的狭义相对论都可以作为候选模型，前者非常直观且易于实现，后者实现复杂但具备更好的适应性和精确度。显然，最终生成软件的灵活性和可重用性强烈依赖于所采用的概念模型。但除了个别质量属性外，软件工程中还存在更多的权衡因子，一个典型的例子是可维护性和成本之间的矛盾。一种平衡前述因子的有效办法是构建<strong>极简概念模型</strong>(Simplest conceptual model)——这并非一个容易达成的目标，因为“极简”不是指问题域中最简单的一部分，而是指在更高抽象层级构建概念模型，其内核虽然是“极简”的，却因为良好的伸缩性得以适应更复杂的问题域。在[MFR96]中，Martin用<strong>分析模式</strong>表示用于构建概念模型的模式，随之用<strong>支持模式</strong>表示将概念模型转化为OOD的模式。前者是下面要讨论的重点，后者属于OOD的范畴，本文不做专门讨论。</p>

<ul>
<li><strong>职责模式</strong>(Accountability)，该模式用于表示个人或者组织之间的职责。在一些问题域中经常需要表示相关职责，例如组织结构、合约、雇佣等，这些都无一例外体现为某种真实对象之间的关系。这里我们把个人、组织这种具体领域的词汇统称为更加抽象的词——<strong>实体</strong>。当不同的实体表现出趋同的职责时，应考虑构建一个更高抽象层级的实体。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/generalized_party.png" alt="Generalized party" /></p>

<p>当不同实体之间存在灵活的组织层级关系时，可以从中提取抽象实体，通过递归引用构建这种层级关系，从而易于应对层级变化。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/organization_hierarchy.png" alt="Organization hierarchy" /></p>

<p>当实体的子类型间的层级关系存在某种约束时，可以把其添加至相应的子类型内部，从而避免改变模型结构。此外，实体间还可能存在多个层级关系，可以把上述显式引用的关系替换为<strong>关系类型</strong>(Typed relationship)，后者被用于表示实体间组织结构的对象类型，实体通过关联的多个结构对象实现不同的层级关系。同样，实体的结构类型也可以关联相应的约束规则，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/multiple_organization_hierarchies.png" alt="Multiple organization hierarchies" /></p>

<p>上述方法的优势是如果实体的关系类型比较复杂，约束规则可以对应至每种关系类型进行管理。问题在于，如果实体的子类型变化比关系类型更多，那么任何子类型的增删改都会影响现有规则，这时可以把规则关联到每个实体的子类型，而非关系类型。</p>

<p>显然此时模型的复杂度已经有了明显增加，为了方便分析这种复杂性，把当前模型划分成<strong>运行等级</strong>(Operational level)和<strong>知识等级</strong>(Knowledge level)两个部分，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/knowledge_and_operational_levels.png" alt="Knowledge and operational levels of accountability" /></p>

<p>其中运行等级包含职责、实体和两者的关系，知识等级包含职责类型、实体类型和两者的关系。前者用于记录领域中发生的日常事件，后者记录用于监管前者的规则。</p>

<p>另外，实体类型也可能具有抽象层级，这样就能描述更加复杂的场景。例如对于全科医生和专科医生来说，两种类型既具有共性也具有特殊性，因此可以创建一个更加抽象的层级——医生来管理其共性。</p>

<p>职责类型也具有抽象层级，随着职责类型不断增加，相应规则数量也会随之增加。但是，如果职责类型表现为固定且简单的等级关系，例如常见的办公室、部门、区域等，那么可以采用分级职责类型，即直接在职责类型对象内存储静态等级列表和相应规则。后者比传统按抽象层级创建新的职责类型相比更加简单，但缺少灵活性。</p>

<p>职责类型描述职责的种类，但一个具体的职责通常包含更多细节信息，例如地点、数量、内容等，这里称为<strong>运行范围</strong>(Operating scope)。运行范围也可能具有复杂的抽象层级和关联关系，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/operating_scope.png" alt="Operating scope" /></p>

<p>运行范围的一个典型用例是职位描述(Job description)，也就意味着职位描述是与工作职责相互关联的，而非具体的员工实体，这也更加符合真实世界的场景。假设具有某项职责的员工离职，那么其承担的职责应被移交给接替者，可以在此基础上创建一个新的<strong>职位</strong>(Post)实体，于是就避免了职责与员工的直接关联，而是让两者通过职位间接产生关联，从而实现更好的灵活性。</p>

<ul>
<li><strong>观察与测量模式</strong>(Observations and measurements)，该模式用于表示真实世界对象的信息。以数值类属性为例，体重是人的基本属性之一，一般用数值类型存储。然而如果领域要求更精确一些，数值类属性还需要额外的单位信息，这时就需要构建抽象数据类型，这里称为<strong>Quantity</strong>。几乎一定会用到Quantity类型的领域包括财务(货币单位)、医疗(剂量单位)等。</li>
</ul>


<p>Quantity通常意味着单位转换的问题。一个简单的单位转换率模型如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/unit_conversion.png" alt="Unit conversion" /></p>

<p>如果问题域中包含大量的转换率，可以把单位用量纲表示，这样就可以动态计算单位之间的转换率。对于更复杂的单位转换需求，例如摄氏和华氏这两个温度单位，就需要引入携带计算行为的单位转换模型。在真实世界中，一种物理量的单位经常需要用一些基本单位组合表示，例如平方英尺、米每秒等，这时就需要引入<strong>复合单位</strong>，即引用其它单位的单位。</p>

<p><strong>测量</strong>是一种表示实体中数值属性的抽象数据类型。当一个实体具有大量属性、且这些属性分别用于不同操作时，实体中就可能存在大量针对这些属性的操作。测量的目的就是抽出这些操作，并在此基础上分离出位于知识等级层面的现象类型(Phenomenon type)。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/measurement.png" alt="Measurement" /></p>

<p>实体还可能包含非数值属性，与测量类似，可以采用独立的抽象数据类型表示非数值属性，二者可以共同提取出更高的抽象层级——<strong>观察</strong>。观察中所包含的规则、解释和创建方式等可以进一步提取出来，构成<strong>协议</strong>。观察往往具有一定的时效性，即观察值仅当满足特定时间段时才有效，可以通过关联时间对象解决。在一些问题域中，观察值可能被发现是无效的，但基于可追溯性无法删除已有的观察值，因此通常是给原有观察关联一个新的<strong>不合格观察</strong>。例如在医疗领域中，患者的检测报告有可能因为各种原因被识别为无效，但仍需要保留历史记录以便追踪治疗历史。医生会根据检测结果诊断病因，有时会因为某种测量结果而判断病因，也可能因后续测量结果调整治疗方案。为了表示观察值所带来的影响，可以将其划分为三种子类型:假设、投影和活动观察。其中活动观察指当前最被信任的观察，假设指需要进一步测试才能确定的观察，投影指医生认为未来可能出现的观察。</p>

<p>观察是可以相互关联并产生影响的，这种情况被称为<strong>关联观察</strong>。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/associated_observation.png" alt="Associated observation" /></p>

<ul>
<li><strong>引用对象</strong>(Referring to objects)，这是一种表示对象间引用关系的模式。真实世界的对象大都存在交互，OO首先要解决的问题就是引用对象，这通常是基于一个显式的身份标识。最简单的对象引用方式就是按名字引用其它对象，具体可以是对象名，也可以是对象id。</li>
</ul>


<p>当对象可能在不同场景中具有多种的标识时，简单的名字引用就难以应对各类场景中的特定对象。例如一个学生可能同时有身份证号、学号、甚至准考证号等标识，此时可以采用标识对象表示引用关系，描述场景的对象被称作<strong>标识模式</strong>，这是一种具有上下文信息的人工标识方法。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/identification_scheme.png" alt="Identification scheme" /></p>

<ul>
<li><strong>库存与会计</strong>(Inventory and accounting)，一种跟踪企业资金流动的模式，主要用于财务会计、库存和资源管理等领域。通常用<strong>账户</strong>表示具有实际价值及其历史记录的实体，例如银行账户、库存账户等。对于账户中的每两条历史记录(指包含存和取的“两腿交易”)，都能够对应一个<strong>交易</strong>，后者用于记录价值流动的细节。如果问题域存在多腿交易，例如一次交易超过了两个参与方，则允许一个交易引用多条历史记录。从模型的角度看，两腿交易属于多腿交易的一种特殊情况，因此后者的灵活性更好。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/multilegged_transaction.png" alt="Multilegged transaction" /></p>

<p>如果同时拥有多个账户，那么通常会需要额外创建一种<strong>总结账户</strong>，后者被用于汇总其它细节账户，因此这里可以抽取出账户的一个更高抽象层级表示。在税务领域中还存在另一种账户类型——<strong>备忘录账户</strong>，这种账户并非记录当前的实际价值，而是额外存放一份“应税价值”，优点是能实时监测某种价值的累积和变更情况，从而为领域添加更好的可预测性，例如方便进行年度报税。为了保证备忘录账户能够被及时更新，通常在账户中会创建一个触发器，每当一个新的记录被创建，则根据触发规则(Posting rule)创建另一条记录，后者即应税价值。如果创建新记录需要比较复杂的计算，则需要给触发规则关联一个额外的计算对象。值得注意的是，触发规则通常是可逆的，同时由于规则本身包含了交易细节，备忘录账户中的历史记录也就无须保存相应的交易记录。</p>

<p>不同的账户可能具有不同的触发规则，一种方法是把触发规则与账户类型相关联，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/posting_rule.png" alt="Posting rule" /></p>

<p>该模型体现了良好的概念表示，实则兼有利弊。因为其基本假设是账户类型与触发规则应存在某种强关联性，否则反而会使情况更加复杂。一个替代做法是直接把触发规则关联至某个总结账户，这样灵活性就更好，但在概念表现上则比较隐晦。</p>

<p><strong>会计</strong>的实质就是在触发规则的基础上，构建一个多账户网络。这就需要能随时获取指定类型的账户和指定类型的触发规则记录。一般情况下，如果实体具有多个账户，那么该实体会附带一个相应的会计操作。如果问题域中具有极其复杂的会计操作，例如不同类型的触发规则对应不同的会计操作，那么可以通过添加会计操作类型的概念对逻辑进行合理分配。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/accounting_practice.png" alt="Accounting practice" /></p>

<p>基于上述模型的历史记录具有更强的追溯性，例如每条记录可以查找对应的源——交易，然后根据交易查询其触发规则。同时还能根据问题域创建对应的资产负债表(Balance sheet)账户和损益表(Income statement)账户，前者记录当前实际价值，例如资产总额；后者则记录每笔交易的具体流向。这两种账户虽然具有不完全相同的历史记录，但实际是一个概念的不同方面，被称作<strong>相关账户</strong>。相关性可能存在于多个账户之间，且具有对称性和传递性的特征。</p>

<p>针对一条记录可能存在于多个账户的场景，还需要注意账户间关联应遵循有向无环图(Directed acyclic graph, DAG)，从而保证正确性。如果问题域要求更多的记录类型，可以采用前文讨论的备忘录账户，也可以创建子类型账户。前者具有简单的模型，适合满足简单的报表类需求，对于更加复杂的场景，就需要采用后者负责针对特定记录类型的操作。</p>

<ul>
<li><strong>计划</strong>(Planning)，该模式用于表示计划，包括制定和追踪两部分内容。任何计划都可以被看作由若干基本<strong>动作</strong>(Action)组成，与计划强调整体性不同的是，动作可以拥有不同的粒度，一个简单的动作可以包含人物、时间和地点等信息。</li>
</ul>


<p>动作通常是状态化的，也可能因为不同状态表现出不同的行为，其中最重要的两个状态是<strong>建议</strong>和<strong>实施</strong>，前者是指动作已经被创建，并且可能已经被赋予了某些资源；后者指动作已经开始执行。虽然同时指向一个真实世界的动作，但是建议和实施实际上可能具有很大的区别，因此，通常不使用关联的动作值/对象表示这两种状态，而是通过创建动作的两个子类型做彻底区分，同时同一个动作的两个子类型之间保持关联，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/proposed_and_implemented_action.png" alt="Proposed and implemented action" /></p>

<p>类似地，如果某个动作处于完成状态，但由于完成的动作可能仍需要追溯性，通常可以将其作为实施动作的一个特例。在某些问题域中需要丢弃已经完成的动作，于是需要丢弃状态，丢弃也可能是在实施之前发生，因此丢弃动作应当是独立于建议和实施的动作。如果问题域允许暂停一个动作，那么就需要给动作关联一个暂停对象，该对象携带一个有效期信息，当时间位于该有效期内时，动作将被挂起直到暂停有效期结束。</p>

<p>最基本的计划即一组建议动作的有序集合，这种顺序需要给动作添加依赖保证。当具有多个计划时，一个动作也可能同时位于多个计划中。如果动作允许嵌套，那么计划也可以被看作是一种特殊的动作。</p>

<p>通常企业的运行过程可以用通用的动作进行表示，其中动作和计划位于运行等级，我们把位于知识等级的部分称作<strong>协议</strong>，其结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/structure_for_protocol.png" alt="Structure for protocol" /></p>

<p>动作通常是基于协议创建的，最简单的方法是根据协议创建关联的建议动作，也可以在更高层级创建等同于计划的建议动作。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/plan_action_protocol.png" alt="Relationship of plan, action and protocol" /></p>

<p>我们知道动作在实施前需要分配资源。资源可以被划分为两种基本类型，例如药品、针头、源材料等属于消费型资源，又如设备、房间、人等属于资产型资源。每种资源类型都具备对应的分配方式，这些分配方式具有统一的资源分配接口。</p>

<p>计划是通过观察启动的，后者是基于假设和投影的结果。因此计划的输出结果也应该是观察的形式。与计划类似，观察也是动作的一种子类型，并且可以作为计划的一部分。前述两种观察在知识等级可以采用启动函数和输出函数表示，前者用于触发协议，后者用于把输入的协议和观察组合进行转换并以两个观察概念集合输出:一个表示协议的使用目标，另一个记录边际效应。</p>

<ul>
<li><strong>交易</strong>(Trading)，指在变化的市场条件下销售和购买商品的模式。<strong>合约</strong>是最基本的交易形式，具体的实现手段包括股票、商品、外汇等。例如大多数市场都以货币为交易手段，于是交易价格就以货币方式表示。交易的两种类型做多(Long)和做空(Short)分别代表买入和卖出，一个基本的交易模型如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/contract.png" alt="Contract" /></p>

<p>银行的风控系统通常以<strong>交易组合</strong>(Portfolio)为单位监控异常交易，交易组合一般拥有采用合约构建其自身的方法，该方法通过合约选择器筛选出合约，并保存在自身记录中。交易组合可以是短期或长期的，短期交易组合是按需创建，使用完成后丢弃；而长期交易组合能存在较长一段时间，因此当新的交易产生时，系统会将其与所有的长期交易组合进行匹配，并添加至满足条件的长期交易组合。</p>

<p>任何金融市场的交易都有<strong>报价</strong>(Quote)，多数情况下“报价”其实包含两个值——买入价和卖出价，这被称为<strong>双向价格</strong>(Two way pricing)。相应地，在某些问题域中也存在<strong>单向价格</strong>(One way pricing)，后者可以被看作是双向价格的一种特殊情况。为了同时支持这两种报价类型，需要构建一个更高抽象层次的报价类型，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/quote.png" alt="Quote" /></p>

<p>如果问题域中单向价格和双向价格的差别非常大，那么抽象类型反而会造成很多局限性，此时就需要对两种价格类型分别建模。</p>

<p>市场中的报价是瞬息万变的，因此报价通常会携带时刻信息。如果想查询市场上所有股票的价格，需要抽取每只股票截至某个时刻的最后一次报价，然后把这些报价添加至一个集合——<strong>场景</strong>(Scenario)，即表示市场在某一时刻的状态。从满足需求的角度来说，直接从全部报价中根据时刻抽取相应报价，即可方便获得市场上的公开价格。但场景是对某个时刻市场价格的抽象表示，可以方便后续的价格查询、分析和比较等。问题域在外汇市场变得更加复杂，由于汇率不再是由单一来源发布，因此需要额外添加一个实体作为价格发布者，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/party.png" alt="Party and scenario" /></p>

<ul>
<li><strong>交易包</strong>(Trading package)，一种把较大的领域模型拆分为更多小型领域模型的模式。<strong>包</strong>通常指一个独立且具有一定规模的软件模块，例如在OO中包可以是一些类的集合，其内部可见性也表明了包的内聚性。包之间一般存在<strong>多重访问等级</strong>，例如在交易领域中，交易组合会把市场指标作为其描述，场景则为市场指标提供价格计算，交易组合与合约通过场景对自身进行定价，但反过来场景并不需要依赖交易组合或合约。这种包之间的可见性如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/package_visibility.png" alt="Package visibility" /></p>

<p>进一步，交易组合需要从市场指标中获取价格，但并不需要了解场景是如何被创建的。因此虽然之前我们讨论了包之间存在可见性的必要性，但这种可见性必须是可控的。一种解决办法是通过额外的接口实现包之间的依赖，然后针对这些接口创建新的包，从而实现更细粒度的包可见性依赖。这种方法的缺点是包的概念和结构变得更加复杂，进而引发可维护性问题。另一种办法是在现有概念模型的基础上引入表示应用逻辑和表现层的组件，例如创建一个新的风险管理应用包和场景管理应用包，前者负责沟通交易组合与场景，后者专门负责创建场景，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/application_packages.png" alt="Application package" /></p>

<p>注意在上图中还有一个新的包“场景结构”，其目的是为了保证场景包对外提供统一的接口，从而将部分职责从原始场景包中进行了分离。</p>

<p>如果一个包是另一个包的子类型，那么不应出现后者依赖前者的情况，否则会损害子类型的可扩展性。包有时还会出现<strong>互相依赖</strong>的问题，进而导致过高的耦合性，这时需要考虑把这种双向依赖转变为单向依赖，因为后者的耦合度更低，但也可能会增加使用上的复杂度。例如对于实体和合约来说，实体有时需要知道与之相关的合约，反之合约也需要知道参与的实体。对此如果要消除双向依赖，就必须消除某个方向的依赖关系。但是无论是消除任一种关系，都会造成某些客户端应用的复杂度增加的问题。除此之外还可以选择把两个包合并，但也可能引入不恰当的可见性问题。因此对这种互相依赖的解决需要考虑更多上下文进行综合判断。</p>

<h2>结论</h2>

<p>模式是对实践经验的积累和发散，真实世界的复杂性导致了模式只能被发现而不能被发明出来，也因此很难避免其在面临复杂问题域时的局限性。然而，与后续会讨论的其它类型的模式相比，分析模式其实具备更高的灵活性和适用性，特别是比形式化的模式表述更加接近真实的思维方式。</p>

<h2>引用</h2>

<p>RPD90, <a href="http://www.engr.sjsu.edu/fayad/current.courses/cmpe202-spring2015/docs/CmpE202-SE-Link-Part-Two-Fall2013/11-Domain%20Analysis/Domain%20Analysis%20-%20An%20Introduction.pdf">Domain analysis: introduction</a></p>

<p>JMN80, <a href="http://www.bayfronttechnologies.com/thesis.pdf">Software Construction Using Components</a></p>

<p>DCH96, <a href="http://ptgmedia.pearsoncmg.com/images/9780133492125/samplepages/0133492125.pdf">Data model patterns: conventions of thought</a></p>

<p>MFR96, <a href="https://martinfowler.com/books/ap.html">Analysis patterns
</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(9)]]></title>
    <link href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/"/>
    <updated>2019-02-11T09:28:50-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9</id>
    <content type="html"><![CDATA[<h2>面向对象——分析与设计</h2>

<p><strong>分析</strong>(Analysis)与<strong>设计</strong>(Design)是软件开发过程中的两种重要活动。分析研究需求和问题本身，决定“做正确的事”；设计则侧重于提出概念性解决方案，决定“正确地做事”[CLA01]。在软件工程实践中，分析主要围绕需求进行，这里既包括功能需求，也包括非功能需求；设计则围绕具体实现进行，例如计划设计、技术设计、用户体验设计、测试设计、运维设计等。面向对象建模技术在上世纪90年代中期的兴起，使其被广泛应用于软件的分析和设计过程，逐渐成为企业级开发领域的主宰范式。</p>

<h3>面向对象分析(OOA)</h3>

<p>OOA的目的是识别和描述问题域中的概念和对象。问题域通常以软件需求为主要的呈现形式，其中包括了功能需求和非功能需求。前者描述面向用户的软件行为，后者则包括了其它类型的需求，例如可用性、可靠性、性能和可支持性(可维护性)等，此类软件属性也被称作软件的<strong>质量属性</strong>(Quality attributes)。功能需求可通过<strong>用例模型</strong>描绘出更多细节，非功能需求则作为前者的补充性规格说明进行呈现。如何恰当地描述用例可以进一步参考[ACB99]，本文后续部分假设用例和非功能需求已经被有效地描述，因为这是进行面向对象分析的重要前提。</p>

<h4>用例建模(Use case modeling)</h4>

<p>当具有初步的用例描述时，可以采用用例模型对问题域进一步分析，从而整理出<strong>系统事件</strong>(System event)及其相应的输入和输出，为之后的逻辑设计建立基础。构建用例模型的过程被称为<strong>用例建模</strong>，可用的工具和方法包括<strong>用例图</strong>、<strong>系统时序图</strong>和<strong>系统契约</strong>等。</p>

<ul>
<li><p>用例图实现了对基于文本描述用例的可视化表示，使其在概念级别更易于理解和沟通，通常采用UML用例图作为工具。</p></li>
<li><p>系统时序图与UML的时序图类似，不同之处在于前者把整个系统作为黑盒，主要描述系统的外部交互过程。这些交互可以是位于用户与系统间，也可以位于不同系统之间。在系统时序图中，系统事件是系统与外部交互的唯一方式，而为了描述系统事件则需首先确定<strong>系统边界</strong>(System boundary)，即系统的功能集合。系统时序图着重于描述系统事件类型、参数、发生顺序和其它关键特性。</p></li>
<li><p>系统契约能够进一步描述系统事件所引起的领域模型中对象的状态变化规则，相当于系统级别的<strong>设计契约</strong>，针对后者的讨论可参考下文面向对象设计一节的设计契约部分。</p></li>
</ul>


<p>用例模型是需求分析的重要交付物，其实质是针对领域的过程化描述，但这种形式不足以启发后续的面向对象设计，因此需要进一步建立接近面向对象概念的<strong>领域模型</strong>，针对后者的构建方法就是接下来要讨论的<strong>领域建模</strong>。</p>

<h4>领域建模(Domain modeling)</h4>

<p>领域模型描述了问题域中的<strong>概念类</strong>(Conceptual class)，概念类与面向对象中的类有一定相似性，但与设计和实现阶段创建的类没有必然的对应关系。领域模型有时也被称作概念模型、领域对象模型或分析对象模型，其通常应包含如下信息:</p>

<ul>
<li><p>领域对象或概念类。</p></li>
<li><p>概念类之间的关联关系。</p></li>
<li><p>概念类的属性。</p></li>
</ul>


<p>一个采用UML类图描述的领域模型例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/domain_model.png" alt="Domain model" /></p>

<p>领域建模首先需要识别概念类。[MO95]提出了概念类的三要素:1.符号(Symbol)，用于表示概念类的文字或图像信息；2.含义(Intension)，概念类的定义；3.扩展(Extension)，描述所有同属于该概念类的案例集合。例如，概念类Sale应包含以下信息:1.表示概念类的符号“Sale”；2.其含义是一次购买交易的事件，包括了date和time两个附加属性；3.扩展即是所有销售的案例集合。对概念类Sale的三要素进行可视化的例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/conceptual_classes.png" alt="Conceptual classes" /></p>

<p>在复杂的问题域中，为了识别出所有概念类，需要对领域进行实体分解。一般方法是从用例描述中的名词短语直接提取概念类，但是受限于自然语言的随意性，把任何提取出的词汇都映射为概念类极有可能出错。除了进一步澄清所提取的词汇外，还可以借助<strong>概念类分类表</strong>(Conceptual class category list)，后者是对特定领域中常用概念类的一种分类形式，可用于对照用例描述中的词汇获取预设的概念类。例如在商场中，一次交易可以包含Sale或者Payment等概念，而在机场可能还涉及Reservation等概念。通过上述方法可以获取候选的概念类列表，例如在表示交易的领域模型中，我们可以提取出Store、Register和Sale等作为候选概念类列表。需知候选概念类列表并非是唯一确定的，其具体的覆盖范围应结合上下文综合考虑。</p>

<p>下面讨论领域建模的一般步骤。</p>

<ol>
<li><p>结合上下文列出候选概念类列表。</p></li>
<li><p>采用领域模型对概念类进行可视化表示，即UML类图的最基本形式。</p></li>
<li><p>添加概念类之间的关系记录。作为领域模型的重要信息之一，关联关系有助于深入理解领域模型，下文会做进一步讨论。</p></li>
<li><p>添加概念类内部的属性记录。领域模型中的属性表示概念类中需要被记录的信息，其既可以是由用例描述中显式给出的，也可以是间接获取的。属性通常包含属性名和类型两个部分，其中属性类型可以是原始类型(Primitive type)或值对象(Value object)。此外，领域模型的属性应当排除外键属性的情况，后者应在设计阶段再予以考虑。</p></li>
</ol>


<p>关联是指概念类之间的、持续一定时长的关系，这里主要是为了强调关联的时间概念，用于和瞬间性关系进行区别。领域模型中的关系主要包含以下两类:1.<strong>须知型关系</strong>，即用例中明确指出的关联关系，属于领域模型的核心内容；2.<strong>理解型关系</strong>，即用例未显式说明但实际有助于理解领域模型的关联关系。</p>

<p>与概念类的三要素类似，关联也具有三个重要组成部分，分别是<strong>关联名字</strong>(Name)、<strong>多重性</strong>(Multiplicity)和<strong>导航性</strong>(Navigability)。其中关系命名可以遵照TypeName-VerbPhrase-TypeName的规则，在UML类图中体现为由上至下、由左至右的顺序；多重性与UML类图的概念基本一致；导航性是指关联关系在其两端概念类各自的可见性，例如可以是单向关联或是双向关联。</p>

<p>与提取概念类相似，关联关系可以通过从用例描述中提取动词短语发现，也可以对照<strong>通用关联关系表</strong>(Common Associations List)——一种领域特定的常见关联关系分类表。虽然在真实场景中可能存在非常多的概念类间关系，领域模型中仅需要表示重要关系，具体应依用例描述和上下文而定。</p>

<p>一个完整的领域模型例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/complete_domain_model.png" alt="A complete domain model" /></p>

<h4>基于彩色UML的通用领域建模模式</h4>

<p>当面对复杂问题域或特殊上下文时，朴素的领域建模方法会面临挑战。为了控制风险，常见解决办法是在分析过程中应用<strong>模式</strong>(Pattern)。模式是一种经过验证的经验性方法，且能够满足大多数的软件开发需求。领域建模的模式可以是基于特定领域的，也可以不限领域——即所谓的通用模式。本文不会就模式本身或其它类型的领域建模模式展开，下面仅讨论一种较为通用的领域建模模式。</p>

<p>[CDL99]描述了一种基于彩色UML的通用领域建模模式。该模式的作者从数百种领域模型中总结出了一种<strong>领域中立组件</strong>(Domain-neutral component)模型，该模型可以被应用至大部分的领域建模过程，从而得到理想的领域模型。领域中立组件模型由下面四种最基本的<strong>原型</strong>(Archetype)组成:</p>

<ul>
<li>时刻或时段(Moment-interval)原型，表示在某个时刻或时段内出于业务或合法性原因需要追踪的事物。例如一次销售在某个时刻发生，那么这次销售就有日期和时间；一次租赁发生在某个时间段，于是有起始时间和终止时间；一次销售甚至可以发生在某个时间段，从而允许对整个销售过程的效率进行评估。采用UML类图表示如下:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/moment.png" alt="Moment-interval" /></p>

<ul>
<li>角色(Role)原型，表示参与者、地点或事物(统称实体或Player)的参与方式。同一个实体可能扮演了多个角色，同一个角色也可能由多个实体扮演。实体自身拥有与角色无关的核心属性和行为，但有时也会具有跨角色的接口方法，用UML表示如下:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/role.png" alt="Role" /></p>

<ul>
<li><p>参与者、地点或事物(Party, place or thing)原型，表示问题域中的人、组织、地点或者事物，即实体。</p></li>
<li><p>描述(Description)原型，这种原型与目录项类似(Catalog-entry-like)，表示反复出现的值的集合以及这些集合项所共有的行为。例如一辆汽车拥有序列号、购买日期、颜色、里程表等多种信息，其中与目录项类似的描述主要是指车辆描述，例如制造商、型号、生产日期以及可选颜色等。</p></li>
</ul>


<p>为了在UML中描述前述原型，一般可以采用UML中的构造型(Stereotype)工具，但是当复杂性进一步增加时这种方式就不够直观，进而妨碍理解和后续建模。[CDL99]给UML添加了一个新的视觉维度，即采用粉-黄-绿-蓝四种颜色分别代表上述四种原型，颜色体现了原型的重要性程度，下图描述了原型、颜色及其相互关联:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/color_uml.png" alt="Archetypes and their colors" /></p>

<p>每个原型在属性、链接、方法、插入点和交互等方面具有相应特征:</p>

<p>时刻或时段原型是领域模型的核心，该原型的对象通常用于封装最有价值的内容，包含序号、日期、时刻或时段、优先级、总数和状态等属性。该对象方法包括创建支持业务流程的对象、添加细节、计算总数、完成或取消时刻或时段对象、以及访问其它同类对象，例如获取同类对象列表、计算平均时刻或时段等。当某些业务流程较复杂时，需要引入插入点使其更加适应变化。</p>

<p>角色原型是第二重要的部分，该原型的对象包含序号、状态等属性。角色原型对象通常会链接到对应的时刻或时段对象。该对象方法包括确定相应实体的可用性、提供业务值或性能估算，且都需要和对应的时刻或时段对象交互。</p>

<p>接下来是实体原型，该原型的对象通常作为角色对象的容器，包含序号、地址和自定义值等属性。实体对象通常会链接到角色对象。该对象方法包括查询可用性(自身状态或角色对象上的状态)、获取自定义值(当其不可用时则从对应的描述对象获取默认值)以及提供业务值或性能估算(与对应的角色对象交互)。</p>

<p>最后是描述原型，该原型的对象包含类型、描述、编号和默认值等属性。描述对象通常会链接到实体对象，但某些时候也会直接链接到时刻或时段对象。该对象方法包括查询可用的实体、计算可用实体的数量，这些方法都需要和对应的实体对象交互。当对象具备复杂算法的行为时，需要引入一个支持提供替代行为的插入点。</p>

<p>在领域建模中，根据所属原型的特征定义概念类的职责，从而使原本偏向静态表示的UML类图进一步表达了类似时序图或协作图的动态交互信息，这也是彩色UML工具的一大优势。此外，[CDL99]借助领域中立组件模式构建了12种<strong>领域特定组件</strong>(Domain-specific component)，经验表明这些领域特定组件能够直接应用于大多数领域建模过程。在面临复杂系统时，可以通过恰当的领域特定模型描述系统中不同的子概念，然后基于是否需要可扩展性，采用直接连接或插入点连接实现组件间联通，从而组装成最终的领域模型。</p>

<h3>面向对象设计(OOD)</h3>

<p>OOA通常要求领域专家、需求分析和技术专家共同参与，体现的是团队对问题域的一致性描述，也就是本文最开始提到的“做正确的软件”。为了“正确的做软件”，OOD更多需要技术团队的更多参与，进一步描述实现中所需对象及其协作的定义。与OOA不同的是，OOD更关注实现细节，例如创建与实际编码中对应的对象、定义对象行为以及对象间的交互等。在过去数十年中，一系列工具、方法、原则、模式等被提出和应用至OOD，限于篇幅本文不可能覆盖前述所有主题，下面仅讨论具有代表性的工具和方法。</p>

<h4>GRASP:基于通用职责分配软件模式的面向对象设计</h4>

<p>[CLA01]提出了一种基于<strong>通用职责分配软件模式</strong>(General Responsibility Assignment Software Patterns, GRASP)的OOD方法，该方法被用于生成可供参考实现的<strong>设计模型</strong>(Design Model)。其基本思路是从用例模型和领域模型出发创建交互图，采用GRASP模式对交互图进行不断优化，并随时补全所需的类图，最终得到的交互图和类图就是设计模型的主要内容。前文已经介绍过时序图和通信图，这里不再赘述。下面讨论GRASP模式及其在设计中的应用。</p>

<p>在UML中，职责是指契约或者义务，这些通常是通过对象的行为体现出来的。职责包含以下两种类型:</p>

<ul>
<li><p>行为型(Doing)责任，例如自身行为、驱动其它对象的行为以及在其它对象中起到控制和协调作用的行为。</p></li>
<li><p>知识型(Knowing)责任，例如自身封装的数据和功能以及与自身相关的其它对象。</p></li>
</ul>


<p>在领域模型中，概念类的职责通常是显式的。但在实际设计中，来自领域模型的职责需要被分配至不同粒度的类或方法。例如“创建一个销售”这类职责可能只需要一两个方法，但是“提供关系数据库的连接”这类职责就可能需要更多类和方法了。为了完成某项职责，对象可以仅通过自身方法完成，也可能依赖其它对象的方法，因此可以认为OOD的本质就是把职责分配到不同的对象中，这也是GRASP的核心思想。</p>

<p>由职责的定义可知，最能完整体现职责的UML工具是交互图，因为后者同时包含了对象、方法和交互信息，这也是从交互图出发进行OOD的原因。GRASP为职责分配提供了一系列指南，以下用其中5个代表性条目为例:</p>

<ul>
<li><p>信息专家(Information Expert)，指如果某个对象具有满足职责的必要信息，那么职责就分配给该对象。同时满足该职责所需的信息可能保存在不同对象中，那么就需要把职责分配至不同的对象，并通过对象协作完成整个职责。</p></li>
<li><p>创造者(Creator)，指如果对象A的职责是创建对象B，那么需要满足A对B的紧密包含关系，例如组合、聚合、强使用关联、强数据关联等场景。</p></li>
<li><p>高内聚(High Cohesion)，指职责分配应保证高内聚，低内聚意味着对象包含了许多无关或者过多的职责，从而影响可理解性、可复用性、可维护性等方面，同时极易被外部影响而发生改动。</p></li>
<li><p>低耦合(Low Coupling)，指职责分配应保证低耦合，强耦合意味着对象更易受到外部变的影响，低可理解性和低可复用性。</p></li>
<li><p>控制器(Controller)，指接收和处理系统消息的职责应分配给具备以下条件的对象:1.代表整个子系统;2.代表某个用例场景。前者相当于系统的外观控制器(Facade Controller)，后者则只表示一个事件处理器(Handler)或协调器(Coordinator)。</p></li>
</ul>


<p>基于GRASP的设计过程相当于把职责从领域模型转移到设计模型，优先从设计模型中选择已有的类，如果没有该类再从领域模型中抽取概念类，直到满足全部用例。</p>

<h4>类职责协作卡(Class-responsibility-collaboration card, CRC)</h4>

<p>目前为止，UML在OOA和OOD中都占据了主流地位，但是我们仅采用了其中不到5%的内容。同时，UML及相关的<strong>计算机辅助软件工程</strong>(Computer-aided software engineering, CASE)工具，使OOD在纸面上花费了大量时间，却难以应付软件工程中出现的各种变化。强调团队协作是应对变化的重要手段之一，因此OOD需要与之相适应的轻量级工具，其中有代表性的就是本节将讨论的<strong>类职责协作卡</strong>(CRC)。</p>

<p>CRC是一种专注于描述类的职责分配和对象协作的轻量级OOD工具，其最初被用于针对团队的OOD培训并取得了良好效果[BC89]，后来因其面向团队协作的特点，被广泛应用至协作式的OOD活动。下图展示了CRC的基本格式:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/crc.png" alt="CRC" /></p>

<p>CRC的形式很容易理解，也比UML的交互图更加轻便，但其可表达的信息类型数和精确性不如后者，其优势在于团队协作设计。基于CRC的团队协作设计流程大致如下:</p>

<ol>
<li><p>集合团队，首先解释当前用例及其具体场景描述。</p></li>
<li><p>从场景中提取相应职责，并将其分配给合适的CRC卡(即类)。</p></li>
<li><p>确定该职责是否需要协作类，并且移动卡片使相互关联的类挨在一起。</p></li>
<li><p>如果存在替代方案，可以快速创建新的卡片，并将其和原方案放在一起比较，经过团队讨论做出进一步设计决定。</p></li>
</ol>


<p>应当注意，上述活动中除了步骤1之外，都离不开OOD原则和模式的指导。经过准确解释和高效协作，CRC能够帮助团队快速理解上下文并就OOD达成一致的方案。当然，CRC的成功应用离不开一系列敏捷实践的共同作用，否则很容易导致“欲速则不达”的后果。</p>

<h4>设计契约(Design by contract)</h4>

<p>随着OOD/OOP在软件设计和开发中流行，如何保证对象间协作的可靠性逐渐受到重视。软件的可靠性包含了正确性和鲁棒性(或者可直观表达为bug的数量)。我们知道，检验软件本身及其设计的正确性是非常困难的。因此，在设计和开发阶段采取措施是加强可靠性的重要手段。例如采用<strong>防御式编程</strong>(Defensive programming)，即意味着在对象方法的执行过程中做大量检查，例如参数合法性、状态合法性、返回结果合法性等。但是，防御式编程会引入大量冗余且复杂的代码，进而降低软件的可维护性，也不利于维持可靠性。[BM92]提出了设计契约的概念，通过在面向对象的类和方法级别定义合适的契约，从而在设计阶段就引入可靠性保障，该思想同时被引入到实现过程中，成为软件开发的重要技巧之一。</p>

<p><strong>断言</strong>(Assertion)是设计契约的核心，断言要求对应的布尔表达式返回值必须为True，否则即意味着异常和潜在bug并且立即报错。同时，断言应当仅被用于表示OOD的契约，而非具体用例场景，因此其只能被用于debug和测试场景。OOD的设计契约包含三种类型的断言:</p>

<ul>
<li><p>前提条件(Pre-condition)，指某个方法执行前的期望，例如检查输入参数是否合法。采用断言作为前置条件，即意味着输入合法性应实际由方法的调用者保证。而断言的引入则确保在debug和测试阶段验证调用者是否实现了正确的参数检查。</p></li>
<li><p>后置条件(Post-condition)，指某个方法执行后的期望。与方法体本身不同的是，后置条件语句侧重于描述执行结果，而非前者的过程。</p></li>
<li><p>不变量(Invariant)，指某个类本身的断言。不变量应当对类的所有对象都始终为True，也就是说，不变量实际上是所有公共方法的默认前提条件和后置条件。</p></li>
</ul>


<p>面向对象中的继承给断言带来了一定的复杂性。对于不变量和后置条件来说，子类只能选择强化父类中的断言或维持不变；但是对前提条件而言，子类只能选择弱化父类断言或维持不变。前述约束是由继承引入的动态绑定特性所带来的[MFR03]。</p>

<h2>结论</h2>

<p>本文所讨论的OOA和OOD分别对应了不同的动机、方法论和评价方式。工具和方法离不开原则和模式的指导，原则和模式在工具和方法的帮助下实现了解释和落地，这些设计元素已然形成了有机整体。前述这些方法论极大促进了软件分析和设计朝着“两个正确”的方向前进。另一方面，以80年代末SEI发起的CMM(Capability Maturity Model)和90年代中期UML的标准化为标志，软件设计乃至整个软件工程开始迈向标准化时代。但是，看似科学的设计和过程随即受到互联网时代巨大变化的冲击，敏捷的思想就是在这种背景下诞生和发展起来的。例如，敏捷强调良好的沟通和协作胜于功能强大的工具，在OOD中正如UML这类大杀器，但也有更轻量的CRC，因此后者被更多用于敏捷软件设计活动。无论如何，在可以预见的未来，业界在“两个正确”的方向上仍有很长一段路要走。</p>

<h2>引用</h2>

<p>CLA01, <a href="https://www.utdallas.edu/~chung/SP/applying-uml-and-patterns.pdf">Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and the Unified Process</a></p>

<p>ACB99, <a href="https://www.infor.uva.es/~mlaguna/is1/materiales/BookDraft1.pdf">Writing Effective Use Cases</a></p>

<p>MO95, <a href="https://dl.acm.org/citation.cfm?id=561612">Object-oriented methods: a foundation</a></p>

<p>CDL99, <a href="https://dl.acm.org/citation.cfm?id=554136">Java Modeling in Color with UML</a></p>

<p>BC89, <a href="http://c2.com/doc/oopsla89/paper.html">A Laboratory For Teaching
Object-Oriented Thinking</a></p>

<p>BM92, <a href="http://se.inf.ethz.ch/~meyer/publications/computer/contract.pdf">Applying “Design by Contract”</a></p>

<p>MFR03, <a href="https://martinfowler.com/books/uml.html">UML Distilled</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(8)]]></title>
    <link href="http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8/"/>
    <updated>2019-02-06T16:23:31-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8</id>
    <content type="html"><![CDATA[<h2>面向对象——概念与建模</h2>

<p>由前文<a href="blog/2019/01/24/software-design-and-architecture-notes-7/">编程范式</a>我们知道，对象作为最基础的编程概念广泛存在于各类编程范式中，采用这种范式的语言被称为基于对象语言(Object based language)。本文讨论的<strong>面向对象</strong>(Object oriented)的概念则首次出现在1967年诞生的Simula 67，其中除了对象概念本身外，还进一步提出了<strong>继承</strong>和<strong>多态</strong>这两个重要特性，成为此后长期影响学术界的语言之一。而面向对象在工业界的兴起则始于上世纪80年代，以Smalltalk和C++的相继发明为标志，深刻影响了此后近四十年的软件工程。</p>

<h3>基本概念</h3>

<p>继承是区分面向对象和基于对象的重要特征，大部分面向对象语言的继承是采用<strong>类</strong>(Class)实现的(注意“类”和“对象”是完全不同的编程概念)。我们知道类可被看作是能够创建对象的工厂对象，继承则允许增量式地进行对象扩展。因此，类作为数据抽象的核心，在其基础上实现继承就自然地支持增量式的数据抽象。除了类之外，面向对象还支持一种基于<strong>原型</strong>(Prototype)的特殊实现，后者通常并不包含类定义，任何对象都能够唯一地指定另一个对象作为其原型，其中对象的属性和事件沿原型链传递查找，从而实现继承。从支持增量式对象扩展的角度看，类继承和原型继承没有本质区别。下面讨论在面向对象语境下的一些重要概念。</p>

<ul>
<li>类。类是一个可能同时包含部分具体实现的抽象数据类型[BMR97]，其被用于描述一组存在于内存中且可直接被用于计算的实例。类的特点在于其同时扮演了<strong>模块</strong>和<strong>类型</strong>两种角色。其中模块作为一种语法概念，通常被用于表示软件分解单元，而类型则被用于动态对象的静态描述，相当于一种语义概念。在非面向对象模式中，上述两种概念通常是被分开表示的。</li>
</ul>


<p>在某些面向对象系统中(例如Smalltalk和Ruby)，类自身也可能是通过对象实现的，这种实例依然是其本身的类被称作<strong>元类</strong>(Metaclass)，面向对象语言或编程环境的作者可以利用元类方便地实现某些动态扩展特性，例如Ruby的<a href="http://www.hanyi.name/blog/2015/08/29/metaprogramming-ruby-core-concepts-object-oriented-hierarchies/">单例类</a>。</p>

<ul>
<li>对象。对象是指某个类的运行时实例[BMR97]。</li>
</ul>


<p>虽然“对象”一词最初来源于对真实世界物体的描述，但在实际编程场景中对象已经不仅仅被用于描述真实物体，例如用于描述一组配置属性等因技术需求而诞生的对象。对象是通过<strong>引用</strong>(Reference)进行表示的，并且可以被自身或其它对象引用。一个对象引用唯一地指向了该对象唯一且不变的<strong>标识</strong>(Identity)。对象标识是用于区分不同对象的唯一凭证。</p>

<p>对象的创建过程通常是在面向对象系统中默认定义的，一般包括分配内存空间和初始化两个步骤，前者由系统自身负责，后者允许在程序中自定义初始化过程。以Java的面向对象系统为例，类支持以构造函数(Constructor)定义初始化过程，如果某个类没有包含显式的构造函数，编译器会自动加入一个默认的无参构造函数并在其中调用父类的无参构造函数。</p>

<ul>
<li>组合与聚合。如果采用引用表示对象，那么对象之间就可以通过引用产生<strong>关联</strong>(Association)。但是仅使用引用不足以描述对象间真实的关系特征，从而无法满足<strong>忠实建模</strong>(Faithful modeling)。<strong>组合</strong>(Composition)关系是指一个对象包含了另一个对象的值，这种关系超过了一般引用的定义，特别是指被包含对象的生命周期被限制在其父对象内。<strong>聚合</strong>(Aggregation)关系指一个对象由另外多个对象组成，其组成关系通过引用实现。与组合的区别在于，聚合中被包含对象的生命周期不受父对象限制。</li>
</ul>


<p>从面向对象中对关系分类的角度看，组合与聚合可以统一被看作<strong>客户</strong>(Client)关系，其实质是对对象间关系的描述。</p>

<ul>
<li><p>继承。继承描述了一种类之间的扩展关系。在面向对象中，类本身具备良好的模块化特性，从而能够满足信息隐藏的原则，但模块化并不直接提供增量式设计和开发的途径。继承支持了类之间的扩展、特化和组成关系，显著增强了面向对象的可重用性和可扩展性。其中包括四个重要的衍生概念:</p>

<ul>
<li>重定义(Redefinition)，指子类能够重新实现父类中定义的过程，有时也称作<strong>覆盖</strong>(Override)。</li>
<li>多态(Polymorphism)，指一个变量实体或数据结构元素，在具备可控静态声明的前提下能够在运行时阶段绑定至不同类型的对象。例如当类A继承类B，那么类A的对象a，可以被赋于类型为B的变量b，且并不违反类型检查。</li>
<li>静态类型(Static typing)，前面提到多态的前提是具备“可控静态声明”，具体是指对于一个变量的声明类型(也称变量的静态类型)，尽管允许其被赋予不同类型(也称变量的动态类型)，但其动态类型必须是静态类型的后代(后代定义包含其自身)。</li>
<li>动态绑定(Dynamic binding)，是指变量所指向对象的动态类型决定被调用操作的具体位置。</li>
</ul>
</li>
</ul>


<p>本质上，继承同时包含了两个角色且互有重叠:模块和类型。从模块的角度看，继承提供了一种有效的可重用特性。这里提到的有效是指当类A继承类B时，A就立即拥有了B的全部特性，且无须进行任何改动。从类型的角度看，继承同时增强了可重用性和可扩展性，这主要体现在: 1.对于类Rectangle继承类Polygon，即Rectangle的全部实例同时也是Polygon全部实例的子集。2.对于类A继承类B，那么B的任意实例所具有的操作也同时存在于A。在许多文献中，继承也被称作is-a关系。</p>

<ul>
<li>多重继承。在真实世界中，对象可能同时包含了不同领域的抽象，对应在面向对象中就是多重继承，即一个类可以同时拥有多个父类。例如，类Teacher和类Student都继承了类UniversityPerson，这时需要一个类TeachingAssistant且同时继承自类Teacher和类Student，也就是说通过两个父类间接继承了类UniversityPerson，即<strong>重复继承</strong>。重复继承可能会造成一定的函数访问冲突，特别是当调用类TeachingAssistant的对象的name函数，而其实际上位于类UniversityPerson时，系统就面临多重函数查找路径的问题。而由此引发的复杂性使得多重继承在许多现代面向对象实践中被认为弊大于利，且不被推荐使用。但不可否认，多重继承实际上体现了真实世界原本的复杂性。</li>
</ul>


<p>在支持多重继承的面向对象系统中，通常采用<strong>复制</strong>(Replication)和<strong>共享</strong>(Sharing)两个策略解决前述重复继承问题。复制是指当遇到重复继承时，子类实际上包含了所有继承路径上属性和函数的副本，程序这时需要具体指定被调用副本的名称。共享是指程序可以指定在子类中只保留一份来自祖先的副本，这样就避免了名字冲突的问题，例如C++的<strong>虚继承</strong>(Virtual inheritance)。</p>

<p>许多现代面向对象语言不支持多重继承，但同时为了保留一定的设计能力大多采用了折衷方案，例如Java的<strong>接口</strong>(Interface)、Ruby的<strong>混入</strong>(Mixin)等。</p>

<ul>
<li>泛型。继承本质上体现了一种纵向的层级扩展关系，由上至下可以被看作是面向对象从抽象化到特化。而<strong>泛型</strong>(Genericity)则支持横向的同级扩展关系，即类型参数化。</li>
</ul>


<p>泛型最经典的案例就是编程语言标准库中常见的容器类，例如Set、List、Map等，这些容器类实际上是参数化的抽象数据类型，其本身包含了抽象数据类型中的具体操作，并藉由客户代码通过指定参数决定具体的元素类型。由于历史的原因，许多现代编程语言中虽然提供了泛型特性，但其实现原理差别巨大。例如C++的模板能完整地重新编译目标代码，最终根据模板参数生成不同的函数和类；而Java的泛型实际上是一种为了增强代码类型安全的语法特性，编译器对泛型语法进行类型检查，并最终通过<strong>类型擦除</strong>(Type erasure)生成无类型参数的目标代码；C#的泛型实现则介于C++的灵活和Java的简易之间，通过运行时<strong>实化</strong>(Reification)进行类型检查和具体操作，从而避免了类型擦除的缺点(例如无法实现泛型数组)，同时把类型参数保留在运行时，从而满足在泛型条件下支持反射。</p>

<h3>面向对象建模(Object Oriented Modeling)</h3>

<p>从上世纪80年代起，随着工业界对面向对象语言从逐渐认识到深入实践，面向对象开始代替传统的结构化方法成为主宰范式。但是，基于面向对象的软件开发很快就面临了更多数量的对象以及更加复杂的关系，实现系统设计也变得空前复杂。作为OO的早期布道者之一，Grady Booch等分别在面向对象的基本概念基础上发展出了一系列全新的建模方法，被统称为<strong>面向对象建模</strong>。</p>

<h4>统一建模语言(Unified Modeling Language, UML)</h4>

<p>1997年，Three amigos在Grady Booch的Booch method、James Rumbaugh的Object modeling technique(OMT)以及Ivar Jacobson的Object oriented software engineering(OOSE)的基础上，正式发布了UML 1.1。UML是一种编程语言无关的通用建模技术，旨在采用统一语言对复杂问题的不同关注点进行建模。</p>

<p>UML由<strong>图形标记</strong>(Graphical notations)和<strong>元模型</strong>(Meta-model)组成。其中图形标记定义了相关概念的图形表示法，也是UML建模的主要工具。元模型是一种对UML模型的形式化表示方法，用于对UML规格说明的精确表达。后者常被用于构建基于UML的计算机辅助软件工程(Computer Aided Software Engineering, CASE)系统。这里只讨论UML的图形标记方法。</p>

<p>下图展示了UML 2.5.1的图形标记分类[UML17]。其中<strong>结构图</strong>(Structure diagrams)用于代表系统中对象的静态结构，通常能够表示系统的核心概念及行为定义，但并不包括行为的动态细节。<strong>行为图</strong>(Behavior diagrams)表示系统中的动态行为，包括方法、协作、活动和状态历史记录等。</p>

<p><img src="http://content.hanyi.name/images/object_oriented/uml_diagrams_overview.png" alt="The taxonomy of UML diagrams" /></p>

<p>随着UML被纳入国际标准，其复杂度不断增加，即使由对象管理组织(Object Management Group, OMG)定义的狭义UML规范也已经十分臃肿，使其逐渐脱离了日常的软件设计实践。但不可否认，UML的核心内容依然在面向对象建模中占据权威地位。为了保证UML的实用性，本文接下来只讨论核心的图形标记[MFR03]。</p>

<ul>
<li>类图(Class diagrams)，表示系统中的对象类型及其相互之间的静态关系。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/class_diagrams_overview.png" alt="Class diagram" /></p>

<p>在上图中，每个方框表示类的属性和操作，方框间的实线表示类的相互关系，在每种关系上还标记了两个类之间的<strong>多重关系</strong>(Multiplicity)。关系是UML中最复杂的概念之一，甚至允许通过构造型(Stereotype)对关系进一步扩充。UML的基本关系种类包括：1. 关联(Association)，指类之间的持续性关系，例如类的属性类型，关联采用实线表示，并且可以是无向、单向和双向，带方向的关联进一步揭示了源类中包含以目标类作为类型的属性；2. 依赖(Dependency)，指一个元素(Supplier)的变更可能引起另一个元素(Client)的变更，依赖采用单向的虚线表示；3. 泛化(Generalization)，表示类之间的类型层级关系，例如继承采用带三角箭头的实线表示，如果目标类是接口类，那么采用带三角箭头的虚线表示，抽象类需要额外使用斜体表示。</p>

<p>从上述关系的定义来看，依赖是含义最广泛的关系，也是面向对象建模中需要仔细考虑的问题。过多的依赖路径会导致修改时发生涟漪效应(Ripple effect)，从而降低系统的可维护性。关联进一步包含了前文讨论的组合和聚合关系，其中组合使用一端实心菱形和单向箭头的实线表示，聚合采用一端空心菱形和单向箭头的实线表示，分别如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/aggregation.png" alt="Aggregation" /></p>

<p><img src="http://content.hanyi.name/images/object_oriented/composition.png" alt="Composition" /></p>

<p>UML中的大部分工具实质上都是为了设置约束，但仅通过图形标记无法表示所有类型的约束，因此UML支持使用{}表示自定义的约束。自定义约束的具体形式没有严格限定，可以是自然语言、伪代码，也可以采用对象约束语言(Object constraint language, OCL)。</p>

<ul>
<li>对象图(Object diagrams)，是指系统在某个时间点的对象快照，也被称作实例图。虽然类图能够完整表达对象的结构信息，但有时候并不容易理解，对象图能够以某个真实案例对前者进行补充。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/object_diagram.png" alt="Object diagram" /></p>

<ul>
<li>包图(Package diagrams)，指一组类或嵌套包的集合。包也被称作命名空间(Namespace)，其作用是定义比类层次更高的系统结构。包图在UML中使用带标签名的方框表示，包之间也可以定义类似类图中关系。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/package_diagram.png" alt="Package diagrams" /></p>

<ul>
<li>部署图(Deployment diagrams)，指系统的物理结构，特别是软件及其所运行的硬件框架。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/deployment_diagram.png" alt="Deployment diagram" /></p>

<ul>
<li>组合结构图(Composite diagrams)，指对一个类的内部结构进行层级表示，从而使其更容易被理解。以类TV Viewer为例，下面是TV Viewer的类图:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/composite_structure_1.png" alt="Class diagram of TV Viewer" /></p>

<p>如果用组合结构图进一步描述TV Viewer，则如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/composite_structure_2.png" alt="Composite structure diagram of TV Viewer" /></p>

<ul>
<li>组件图(Component diagrams)。在UML中，组件是一种从功能角度上看可以独立分发和升级的模块。组件图用于表示组件之间的交互关系，如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/component_diagram.png" alt="Component diagram" /></p>

<ul>
<li>时序图(Sequence diagrams)，表示一组对象及其之间的协作关系。具体来说，时序图通常限定在一个单独的场景下，包含了一组对象以及依据用例而发生的对象间消息传递，特别是展示了消息发生的顺序信息。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/sequence_diagram.png" alt="Sequence diagram" /></p>

<p>在时序图中，由于第一个消息通常不在参与者(Participants)中，因此也被称作<strong>创始消息</strong>(Found message)。另外，时序图中的参与者是可以被动态创建和销毁的。同时消息传递过程也支持循环、分支以及异步等特性。</p>

<ul>
<li>状态机图(State machine diagrams)，也称作状态图，表示单个对象的整个生命周期行为。在面向对象中状态具体包括了对象中所有属性值的集合，而状态图则侧重于抽象的状态定义，即提供不同的事件响应方式。一个简单的状态图例子如下:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/state_machine_diagram.png" alt="State machine diagram" /></p>

<p>该状态图表示了一座城堡中的安全机关。图中方框表示一个状态，除了状态名之外，还可以填入状态的内部活动，包括状态事件(Event)、看守(Guard)和活动(Activity)，当某个事件发生时，可根据当前状态选择迁移(Transition)或保持状态不变。更进一步，状态既可以是静止的也可以是活动的，例如当前对象某个正在发生的动作。状态也可以被分组，其作用是表示组内所有子状态的同一个向外部某个超状态(Superstate)迁移的路径。</p>

<p>在并发场景中，单个状态可以被分割成几个正交的子状态图，一个闹钟的例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/concurrent_state_diagram.png" alt="Concurrent state diagram" /></p>

<p>该图中用一个历史伪状态标记代替了初始状态标记，意味着当开关打开时，初始状态应为上一次开关关闭时所处的状态。</p>

<p>值得注意的是，状态图对应着两种可能的实现，一种是采用控制流代码或面向对象实现，另一种是基于状态表的解析和查询。前者具有更加复杂的代码结构，且需要持续维护相关代码；后者需要在初期实现一个较复杂的状态表解析和查询特性，后期则主要集中于状态表的数据维护。无论采用哪一种实现，其最终代码都具有一定的样板特征，因此结合代码生成技术都是更好的选择。</p>

<ul>
<li>活动图(Activity diagrams)，表示过程逻辑的业务流程的行为，且通常是跨多个用例或线程的行为。先看一个活动图的例子:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram.png" alt="Activity diagram" /></p>

<p>从上例可以看出，该活动图与传统的流程图十分类似，最主要的区别在于前者支持并发活动，例如<strong>分叉</strong>(fork)操作可以产生并发的子活动，所有子活动的同步操作通过<strong>结合</strong>(join)进行。活动图中的动作(Action)之间使用流(Flow)或者边(Edge)进行连接，且可以被进一步分解成更多子活动，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_2.png" alt="Action decomposition" /></p>

<p>一般而言，活动图更多聚焦于描述业务过程而非实现，但通过分区(Partition)可以进一步表示不同动作的负责对象，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_3.png" alt="Partition" /></p>

<p>活动图支持基于信号的动作触发场景，信号可以被直接触发并接收，也可以通过定时器触发，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_4.png" alt="Signal" /></p>

<p>活动图还进一步支持采用动作方框下放置别针(Pin)表示该动作的输入和输出参数，如果某个动作的输出与下一个动作的输入参数不同，还需要使用参数变换(Transformation)使其一致。当一个动作会导致下一个动作触发多次时，可以采用扩展区域(Expansion regions)标记需要响应多次的动作集合，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_5.png" alt="Expansion regions" /></p>

<p>在该例中，扩展区域中的动作流程可能会部分导致终止，因此采用终止流(Flow final)进行标记。</p>

<ul>
<li>通信图(Communication diagrams)，在UML 1.x中被称作协作图(Collaboration diagram)，用于表示对象交互过程中的数据连接，如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/communication_diagram.png" alt="Communication diagram" /></p>

<p>通信图所表达的信息与时序图类似，形式相对灵活但不如后者规整，因此其受欢迎程度也不如后者。</p>

<ul>
<li>交互概述图(Interaction overview diagrams)，指结合了活动图和时序图的概述表示。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/interaction_overview_diagram.png" alt="Interaction overview diagram" /></p>

<p>交互概述图实际上是一种针对对象交互行为的整体表现方案的总结。</p>

<ul>
<li>时间图(Timing diagrams)，表示单个或一组对象交互的时间约束。特别是当对象的某个状态存在一定时间约束时，如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/timing_diagram.png" alt="Timing diagram" /></p>

<ul>
<li>用例图(Use case diagrams)，表示系统的功能需求。用例(Use case)是一种对用户与系统或系统自身交互的描述。用例更注重用户的一般目标，与用户场景(User scenario)不同，后者详细描述了用户与系统的每一步交互(这里的用户不仅指人类)，如果交互过程中发生分支则产生新的场景。也就是说，一个用例包含了许多用户场景。下图是一个用例图的例子:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/use_case_diagram.png" alt="Use case diagram" /></p>

<p>用例是对系统功能的更高级描述，与极限编程中的用户故事(User stories)相比，后者侧重于表示系统特性，且可以用于安排迭代计划，而用例则是单纯的系统功能性描述。在具体实践中，一个特性可能直接对应用例，或者用例中的一个步骤，也可能对应于其中一个场景。而大多数情况下用例要比特性具有更粗的粒度。</p>

<h2>结论</h2>

<p>本文首先讨论了面向对象的核心概念；随着面向对象编程的流行，开发中面临的问题复杂度不断提升，由此催生了面向对象建模技术。UML旨在实现语言无关的通用建模语言，被广泛用于面向对象分析(OOA)和设计(OOD)等活动。另一方面，随着相关国际标准的建立，UML也逐渐变得更加臃肿，因此实践中，视实际情况选择性地对工具进行裁剪就变得尤为重要。</p>

<h2>引用</h2>

<p>BMR97, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/POO-2016-01/documentos/Object%20Oriented%20Software%20Construction-Meyer.pdf">Object-Oriented Software Construction</a></p>

<p>UML17, <a href="https://www.omg.org/spec/UML/">The unified modeling language specification</a></p>

<p>MFR03, <a href="https://martinfowler.com/books/uml.html">UML Distilled</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(7)]]></title>
    <link href="http://www.hanyi.name/blog/2019/01/24/software-design-and-architecture-notes-7/"/>
    <updated>2019-01-24T14:29:52-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/01/24/software-design-and-architecture-notes-7</id>
    <content type="html"><![CDATA[<h2>编程范式(Programming Paradigms)</h2>

<p><em>作为专业程序员，对方法论的持续抽象绝对是一项明智的长期投资。</em></p>

<p>Robert W. Floyd在1978年图灵奖颁奖礼上如是说[RWF79]，这里所说的“方法论”即<strong>编程范式</strong>(Programming Paradigms)。<strong>范式</strong>一词源自Thomas S. Kuhn的《科学革命的结构》，Kuhn认为过去数个世纪的科学变革，实质上是主宰范式的更替，而这些范式却都曾在一段时期内常自认为能够独立揭示科学的内涵[TSK62]。具体到程序设计领域，范式表示为编程活动中存在的公共风格或方法论。例如，结构化编程可看作是上世纪70年代的主宰范式，但并非唯一。即使是忠实的拥趸也必须承认，结构化编程在解决某些问题时并不理想，于是持续有诸如分支限定(branch-and-bound)、分治(divide-and-conquer)、状态机(state machine)等其他更高层级范式的提出。或许有人认为使用较为底层的编程范式照样可以完成绝大部分任务，但却低估了软件的运行效率和经济效益等重要因素。因此Floyd认为，编程技术得以持续进步的重要前提即是新范式的发明、阐释和交流。</p>

<h3>编程范式的概念组成(Conceptual Composition of Programming Paradigms)</h3>

<p>任何一种编程范式都可以被看作是由一组编程概念(Programming concepts)，通过组装内核语言(Kernel language)而形成[PVR04]。从数量上看，编程语言要比编程范式种类更多，编程概念则较少，假设存在n种概念，则理论上可以有2<sup>n</sup>种范式。下面以一些重要的编程概念为例：</p>

<ul>
<li><strong>变量</strong>(Variables)，通常由标识符(Identifier)和存储变量(Store variable)组成，前者相当于变量的名字，后者则是变量在内存中的实际位置。一个变量需要使用声明语句加以创建，例如：</li>
</ul>


<pre><code>declare
V=9999*9999
</code></pre>

<p>这里declare语句的作用相当于执行创建标识符和存储变量两个任务。</p>

<ul>
<li><strong>函数</strong>(Functions)。函数由标识符、参数列表和函数体组成，标识符的作用与变量一致，参数列表规定函数的输入，而函数体用于容纳一段程序代码，例如：</li>
</ul>


<pre><code>declare
fun {Fact N}
if N==0 then 1 else N*{Fact N-1} end
end
</code></pre>

<p>在该例中，Fact函数接受参数N，并且计算并返回N的阶乘。值得注意的是，函数体中的代码包含了条件表达式，以及对应于阶乘数学定义的<strong>递归</strong>表达式。递归使函数具有相对复杂的数学表达能力，例如求解组合数函数：</p>

<pre><code>declare
fun {Comb N K}
{Fact N} div ({Fact K}*{Fact N-K})
end
</code></pre>

<p>尽管该函数体只有一条语句，但精确反映了组合数的数学定义。但需要注意，Comb函数本身需要依赖之前定义的Fact函数，这种使用已有函数组成新函数的形式，被称作<strong>函数抽象</strong>(Functional abstraction)。</p>

<ul>
<li><strong>表</strong>(Lists)。当参与计算的数达到一定数量，就需要一个方便的方式表示数的集合了。例如计算杨辉三角( Pascal’s triangle)，其实质是对组合数在自然数序列上的枚举，即“从n中取k个数”，其中n为自然数序列，k则是从0到n范围内的自然数，在杨辉三角中n表示三角形的行数，而k表示为列数。那么为了保存该问题中的数列，就需要引出表的定义：</li>
</ul>


<pre><code>T=[5, 6, 7, 8]
</code></pre>

<p>表实际上是一条由连接构成的链，其中每个连接由两部分组成：表元素和剩余链部分的引用。Lisp语言使用cons函数动态地在表中创建新的连接，类似地这里用H|T表示cons，例如：</p>

<pre><code>H=4
T=[5, 6, 7, 8]
M=H|T
</code></pre>

<p>该例中M的值为[4, 5, 6, 7, 8]。反过来，也可以在一个表中实现逆cons操作，例如：</p>

<pre><code>L=[5 6 7 8]
{Browse L.1}
{Browse L.2}
</code></pre>

<p>这里L.1输出5，L.2输出为6, 7, 8。</p>

<p>表通常支持<strong>模式匹配</strong>(Pattern matching)操作，目的是更方便对表进行分解，例如该例中的case指令：</p>

<pre><code>declare
L=[5 6 7 8]
case L of H|T then {Browse H} {Browse T} end
</code></pre>

<p>这里case通过指定一种cons模式对表L进行分解，并使用H和T两个局部变量保存分解后的值，该局部变量的作用域仅限于case语句的then..end代码块内。</p>

<ul>
<li><strong>基于表的函数应用</strong>(Functions over lists)</li>
</ul>


<p>现在设计函数计算杨辉三角，计算原理是，对于第n行数列，分别将其左移一位和右移一位生成两个新的数列(末端补0)，然后将两列相加，即得到第n+1行数列。下面用自上而下法编程解决该问题。</p>

<pre><code>declare Pascal AddList ShiftLeft ShiftRight
fun {Pascal N}
    if N==1 then [1]
    else
        {AddList {ShiftLeft {Pascal N-1}} {ShiftRight {Pascal N-1}}}
    end
end
</code></pre>

<p>该函数在最顶端模拟了前述文字描述的算法，其余函数可分别表示为：</p>

<pre><code>fun {ShiftLeft L}
    case L of H|T then
    H|{ShiftLeft T}
    else [0] end
end
</code></pre>

<pre><code>fun {ShiftRight L} 0|L end
</code></pre>

<pre><code>fun {AddList L1 L2}
    case L1 of H1|T1 then
        case L2 of H2|T2 then
            H1+H2|{AddList T1 T2}
        end
    else nil end
end
</code></pre>

<p>可以看出，当程序引入了函数和表操作时，其复杂度也相应增加。那么应如何判别该程序的正确性呢？</p>

<ul>
<li><p><strong>正确性</strong>(Correctness)。程序的正确性验证是一个非常复杂的问题，因为它不仅涉及编写的程序本身，还依赖对编译器、运行时系统、操作系统、硬件环境乃至其它物理因素的正确性验证。因此对程序的正确性验证首先要确定一个合理范围，并假设范围之外的部分是可信的，例如要验证前面计算阶乘的代码片段，通常需要经过以下步骤：1. 建立对应编程语言中各种操作的数学模型，称作语义模型。2. 定义程序的行为，通常是对程序输入和输出的数学定义，称作程序的规格说明。3. 基于1的语义模型，借助数学方法推导程序的运行结果，从而证明程序符合2定义的规格说明。</p></li>
<li><p><strong>复杂度</strong>(Complexity)。这里主要指时间复杂度。观察前面给出的Pascal函数，{Pascal N-1}在函数体中出现了两次，由于其递归的特性，最终计算量将正比于2<sup>n</sup>，从而当输入稍大时就会导致很长的运行时间。为了提高程序运行效率，可以消除一次{Pascal N-1}的计算，所以有：</p></li>
</ul>


<pre><code>fun {FastPascal N}
    if N==1 then [1]
    else L in
        L={FastPascal N-1}
        {AddList {ShiftLeft L} {ShiftRight L}}
    end
end
</code></pre>

<p>改进后的程序时间复杂度达到了n<sup>2</sup>的多项式时间，从而远好于之前的指数时间。理想状态的时间复杂度应尽量满足低阶多项式时间。</p>

<ul>
<li><strong>懒求值</strong>(Lazy evaluation)。一般而言被直接调用的函数会立即被计算，这种模式被称作及早求值(Eager evaluation)，与之相反则被称作懒求值。在懒求值下，计算只会在其结果被需要时发生。懒求值对于程序代码的优化有一定意义，如下例：</li>
</ul>


<pre><code>fun lazy {Ints N}
    N|{Ints N+1}
end
</code></pre>

<p>如果Ints函数是及早求值，那么调用该函数会直接进入死循环，直到调用栈溢出，但懒求值则不会。例如：</p>

<pre><code>L={Ints 0}
case L of A|B|C|_ then {Browse A+B+C} end
</code></pre>

<p>该例只会导致Ints被执行三次，模式匹配中抽出的A、B、C将等于列表中的前三个数。与及早求值相比，懒求值其实意味了对程序的更多控制权，避免像普通的递归函数一样过早进行了大量计算。</p>

<ul>
<li><strong>高阶编程</strong>(Higher-order programming)。如果需要计算一个杨辉三角的变种，例如每行数列的获取不是通过对上一行的数做加法，而是改用减法、异或等算术表达式，那么最直观的方法就是对Pascal程序进行改造，特别是替换FastPascal函数中的AddList为新的函数调用。这就导致FastPascal函数可能需要频繁修改，甚至重复才能满足不同类型的计算需求。高阶编程允许将函数作为另一个函数调用的参数，从而满足统一的代码实现：</li>
</ul>


<pre><code>fun {GenericPascal Op N}
    if N==1 then [1]
    else L in
        L={GenericPascal Op N-1}
        {OpList Op {ShiftLeft L} {ShiftRight L}}
    end
end
</code></pre>

<p>GenericPascal就是理想的统一代码实现，允许通过Op传递所需的计算函数，避免了计算功能需要扩展时再次发生修改的可能。</p>

<ul>
<li><strong>并发</strong>(Concurrency)。真实世界中存在大量相互独立、且根据自身情况决定执行节奏的活动，这被称为“并发”。除非程序建立了通信机制，否则并发的活动相互间不会发生干涉。程序中的并发通常借助线程实现，如下例所示：</li>
</ul>


<pre><code>thread P in
    P={Pascal 30}
    {Browse P}
end
</code></pre>

<p>当线程代码开始运行时，尽管Pascal函数的执行需要较长时间，但程序本身依然会继续向下执行。</p>

<ul>
<li><strong>数据流</strong>(Dataflow)。如果某个操作引用了一个尚无法被绑定的变量，例如在并发编程中，该变量正在被另一个线程所绑定，那么理想的行为是请求绑定的一方陷入阻塞，直到获得该变量的绑定，这被称为数据流。例如：</li>
</ul>


<pre><code>declare X in
thread {Delay 10000} X=99 end
{Browse start} {Browse X*X}
</code></pre>

<p>上例中X*X会发生阻塞，直到X被主线程绑定。</p>

<ul>
<li><strong>显式状态</strong>(Explicit state)。与并发类似，真实世界中也会存在某种行为依赖于历史记录的情况，这就需要程序语言的函数具有维持内部状态的能力，大多数情况下我们把这种状态保存在变量中，这里使用<strong>内存单元</strong>(Memory cell)表示，以便和前文同样提到的变量概念进行区分。下例显示了如何在FastPascal中引入显式状态：</li>
</ul>


<pre><code>declare
C={NewCell 0}
fun {FastPascal N}
C:=@C+1
{GenericPascal Add N}
end
</code></pre>

<ul>
<li><strong>对象</strong>(Objects)。对象即带有内部状态的函数，一个包含多个函数的对象例子如下：</li>
</ul>


<pre><code>declare
  local C in
  C={NewCell 0}
  fun {Bump}
    C:=@C+1
    @C
  end
  fun {Read}
    @C
  end
end
</code></pre>

<p>本例中local..end定义了变量C的作用域范围，也就是说C对local..end定义的代码范围之外的部分不可见，即<strong>封装</strong>(Encapsulation)。封装意味着隔离了对象状态与程序的其它部分，从而具有了信息隐藏的特性。此外，该对象还包含两个方法：Bump和Read实现对其状态的操作，即对象的<strong>接口</strong>(Interface)。一旦对象的接口能维持一致，那么客户程序就无需了解对象具体的方法实现，并能够直接调用任何具有相同接口的对象方法，这种特性即多态(Polymorphism)。在封装和多态背后，针对接口与其实现的分离即<strong>数据抽象</strong>(Data abstraction)的实质。</p>

<ul>
<li><strong>类</strong>(Classes)。对象极大提升了程序的可复用性和可维护性，那么如果程序中需要超过一个对象呢？一种解决办法就是创建一个“工厂对象”，将其用于生产更多的对象，这个工厂对象即<strong>类</strong>(Class)。下例演示了如何利用函数创建类：</li>
</ul>


<pre><code>declare
fun {NewCounter}
C Bump Read in
  C={NewCell 0}
  fun {Bump}
    C:=@C+1
    @C
  end
  fun {Read}
      @C
  end
  counter(bump:Bump read:Read)
end
</code></pre>

<p>该例中NewCounter函数每次调用都能返回一个具有独立内部状态以及Bump和Read函数的新函数(对象)，即利用了前文提到的高阶编程的概念。对类的使用如下所示：</p>

<pre><code>declare
Ctr1={NewCounter}
Ctr2={NewCounter}
</code></pre>

<p>其中Ctr1和Ctr2相当于独立的对象，程序进而可以通过.操作符调用其中的方法，例如：</p>

<pre><code>{Browse {Ctr1.bump}}
</code></pre>

<p>值得注意的是，截至目前我们介绍了类和对象的概念，但这并非<strong>面向对象编程</strong>(Object oriented programming)的全部，也不意味着使用类和对象的编程概念就可以被称为“面向对象语言”。</p>

<ul>
<li><strong>非确定性和时间</strong>(Nondeterminism and time)。当程序具有并发和状态等概念时，问题就会变得更加复杂，这是因为并发所引起的线程时序是非确定的，而状态的改变也会因此变得不稳定。这里需要强调，非确定性本身不会带来问题，只有当程序中的非确定性具有可观测性时，进而引发的竞争条件才会导致潜在问题。</li>
</ul>


<pre><code>declare
C={NewCell 0}
thread
  C:=1
end
thread
  C:=2
end
</code></pre>

<p>在本例中，从字面上无法判断出在某个时刻变量C的值，即所谓的可观测非确定性。在这种情况下，程序的线程之间会因为<strong>交叉存取</strong>(Interleaving)问题而变得极不稳定，因此避免和限制交叉存取是保证高质量程序的重要经验之一。</p>

<ul>
<li><strong>原子性</strong>(Atomicity)。解决交叉存取问题的途径之一就是引入原子操作(Atomic operation)。原子性意味着任何中间状态都无法被观测，即从初始态直接跳跃至最终态。原子操作的实现方法之一即引入锁(Lock)对象，锁保证了在任何时刻只有一个线程在其中执行，此时其它线程只能在锁外等待。例如：</li>
</ul>


<pre><code>declare
C={NewCell 0}
L={NewLock}
thread
  lock L then I in
    I=@C
    C:=I+1
  end
end
thread
  lock L then J in
    J=@C
    C:=J+1
  end
end
</code></pre>

<p>锁的使用一般包含两步操作：1.创建锁对象；2.使用锁对象加锁并执行目标代码。代码运行结束后锁对象被立即释放，后续线程可以继续对该对象加锁。</p>

<h3>编程范式的分类(Taxonomy of Programming Paradigms)</h3>

<p>由于概念——范式——语言之间的组合构成关系，理论上说出于更上层次范式和语言的数量相比较于编程概念而言是十分巨大的。然而在多数情况下，实用的范式应当是图灵完备的。例如函数式编程，基于头等函数(First-class function)或闭包(Clusure)的概念，因此其相当于和λ算子等价，从而可以被证明图灵完备。下面讨论由基本编程概念组合而成的编程范式类别，这种分类法覆盖了绝大多数的实用编程范式(在[PVR04]中也被称作计算模型)。</p>

<h4>声明式模型(Declarative model)</h4>

<p>作为最早出现也是最简单的编程范式类别，声明式是指通过定义数学函数实现编程，从而使其最易被推导和测试，也是所有其它类别的编程范式的基础。</p>

<p>声明式编程首先定义了语法(Syntax)和语义(Semantics)的概念，其中语法用于规定合法的语言形式，由于编程不可能像自然语言完全一样灵活自由，因此通常具有极为限定的语法形式和约束。一种常用的语法标记即扩展巴科斯范式(Extended Backus-Naur Form, EBNF)，其基本形式是从非终结符开始，由左向右列出记号(Token)序列，其中任何遇到的终结符可以被直接加入序列，而非终结符则需要被它的展开式替换，并在选择项(Choice)前任选一个作为替换。上述这种语法定义形式被称为上下文无关文法(Context-free grammars)，因为其非终结符在任何情况下的展开都是唯一确定的。须知上下文无关文法是可能会存在歧义的，例如：</p>

<pre><code>&lt;exp&gt; ::= &lt;int&gt;|&lt;exp&gt; &lt;op&gt; &lt;exp&gt;
&lt;op&gt; ::= + | *
</code></pre>

<p>对于表达式2 * 3 + 4来说，其解析树存在两种可能，一种的叶结点是2 * 3和4，另一种的叶结点是2和3 + 4。为了消除这种歧义性，编程语言层面会定义更多约束以保证确定性：例如确定运算符优先级或者定义计算表达式的默认方向。</p>

<p>在语义方面，无论现代编程语言被设计得多复杂，其底层一定是基于一个纯数学的、易于推导的模型，这种模型被称作内核语言。实际上，本文所讨论的编程范式，就是通过定义内核语言形成对编程语言的语义化翻译，进而更容易被机器或操作系统所识别。</p>

<p>声明式编程有时也被称为无状态式编程，也即以下两种编程范式的核心思想——<strong>函数式编程</strong>(Functional programming，例如Scheme和Standard ML)和<strong>逻辑式编程</strong>(Logic programming，例如Prolog)。以该范式为基础为编程语言构建了庞大的特性集合，例如大部分常用的语法规则、编译技术、内存管理技术和异常管理技术等，都超出了本文的主题。</p>

<h4>并发声明式模型(Concurrent declarative model)</h4>

<p>该范式在声明式编程的基础上引入并发的概念。在本文的编程概念部分就已经讨论过，并发本身并不显著提高复杂度，只有并发和状态同时存在时问题才可能会出现，即前文提到的可观测非确定性问题。并发声明式的主要特点在于数据流概念的引入，既保留了声明式编程的基本特征，也允许更加灵活的增量执行属性，且避免引入可观测非确定性。</p>

<p>一般的声明式编程都是按照语句的出现顺序、由左至右依次执行，这种执行方式即所谓的及早求值或数据驱动求值(Data driven evaluation)。在某些应用场景中，及早求值并非最佳方案。例如在同时包含生产者和消费者的程序中，传统的及早求值要求生产者确定是否已经发送了完整的数据，而如果由消费者来负责就能进一步保证处理后的数据完整性，后者就采用了懒求值的思想，也被称作需求驱动求值(Demand driven evaluation)。在声明式编程中引入懒求值的特性，即<strong>懒声明式模型</strong>(Lazy declarative model)。该范式允许在某些潜在的无限制数据结构基础上实现编程，更有利于资源管理和程序结构的模块化。</p>

<p>懒求值最早是在函数式编程中被发现，最初仅被视为声明式编程的一种执行策略，可用于帮助设计具有良好平摊性或最坏时间上界的算法；后来被进一步应用于包含声明式子集且更具表达性的范式中，强化其模块化特性。采用懒求值的例子包括Haskell和Miranda。</p>

<h4>消息传递并发式模型(Message-passing concurrent model)</h4>

<p>由于前文所描述的并发声明式编程不具备可观测非确定性，使其在描述能力上有所限制。例如经典的C/S系统，任何时刻服务器都无法预知客户端发来的下一条消息，而这在并发声明式编程中就无法实现。而消息传递并发式编程则在前者的基础上引入了一个异步通信信道，任何程序中的实体都能从该信道中写入和读取消息，从而满足了可观测非确定性编程的需求。该范式创建了一个具有关联流的信道——<strong>端口</strong>(Port)。任何实体可以向该端口发送消息，一个具体的作法是创建一个流对象并将其和对应端口相关联，这里称其为端口对象。于是，实体就可以通过该端口对象对其它端口对象发送和接收消息。一个端口对象通常是一个声明式的递归过程，从而使其拥有声明式编程的一部分特性。</p>

<p>采用消息传递并发式的例子包括Actor模型和Erlang。</p>

<h4>状态式模型(Stateful model)</h4>

<p>状态式编程，也称命令式编程(Imperative programming)。本质上状态式相当于声明式+显式状态的组合，这里的显式状态是指某个过程调用依赖于超出该过程生命周期的状态，且该状态没有出现在过程的调用参数列表中。状态式编程增强了范式的抽象能力，这种能力被视为构建复杂系统的关键。以传统的无状态编程为例，尽管程序中的一个过程可以根据外界传递的参数做出对应的行为，但这始终是针对特定输入而产生确定性结果。而对于状态式编程而言，其自身拥有了更多能力从而变得相对较“智能”，这也更接近对真实世界活动的模拟。</p>

<p>范式的抽象能力可以通过以下特性衡量：1.封装性；2.组合性；3.可实例化和可调用性。其中，封装性的意义在于，我们知道程序的可推导性能够保证其正确性，但显式状态的引入会使得程序推导变得十分困难，一个例子是带有<strong>边际效应</strong>(Side effect)的函数。而封装性的提高可以降低状态带来的不利影响，特别是维持不变量(Invariant)，这在一定程度上提高可推导性。</p>

<p>状态式编程能够描述出行为依据状态而发生变化的程序，从而进一步有利于模块化程序，且如果封装和不变量使用得当，则其会拥有与声明式编程相当的可推导能力。</p>

<p>在状态式编程的基础上，采用一组交互式数据抽象的集合描述最终程序，即<strong>面向对象式模型</strong>(Object oriented model)。这里的数据抽象具有状态化和对象化二元特性。状态化意味着模块化能力，而对象化则进一步启发了多态和继承——这就是面向对象编程的基本原理。多态允许更细粒度的模块化，在合理的职责划分下依旧能保证统一接口；而继承则开辟了增量式的抽象构建，使程序模块易于复用，从而降低潜在的开发成本。</p>

<p>在最近40年里，面向对象编程在工业界和学术界都得到了深入研究和广泛应用，并且在绝大多数现代编程语言中都得到了支持。</p>

<h4>共享状态并发式模型(Shared-state concurrent model)</h4>

<p>与消息传递并发式类似，共享状态并发式也提供了可观测非确定性编程的能力，区别在于后者借助了共享且可变的显式状态（这里称作单元）而非异步通信信道来实现。尽管实质上都是状态化，但共享状态并发式编程较前者具有更加复杂的实现。</p>

<p>前文已经提到，并发声明式编程不具备可观测非确定性，这点其实兼有利弊，特别是无法实现完全独立的并发线程，或是超过两条线程以上的通信，这也是状态化并发编程的主要目的。但是为了应对随之而来的即交叉存取问题，除了异步消息信道外，还可以通过引入锁、监控和事务等实现针对共享状态单元的原子操作，这些解决方案适用于不同的问题。</p>

<p>事实上，共享状态并发式编程在绝大多数语言中都得到了支持，这主要得益于状态式编程（特别是面向对象编程）的广泛应用。颇为讽刺的是，尽管这种范式可能受到了更加彻底的研究，但建立在其基础上的应用程序至今仍面临复杂且严峻的挑战。</p>

<h4>关系式模型(Relational model)</h4>

<p>声明式编程的基本特性源于数学计算，包括过程、输入参数、输出参数等概念。当一个给定输入参数集合仅有一组输出参数集合时，同样可以用关系式编程实现。后者比声明式具有更高的灵活性：1.允许有0至多个结果；2.输入参数和输入参数可以在每次调用时都不同。从而令关系式编程在数据库、歧义性语法解析和复杂组合问题的枚举实现等领域具有一定优势。</p>

<p>具体实现上，关系式在声明式基础上引入了<strong>选择</strong>(Choice)语句，这种选择语句能够通过搜索自由抽取出一个结果集，虽然算法是确定的，但最终结果仍然是非确定。Prolog的search特性就是基于这种范式的逻辑式编程语言。</p>

<h3>编程范式的比较(Comparison of Programming Paradigms)</h3>

<p>编程范式对软件工程的意义在于满足<strong>天然性</strong>(Natural)和<strong>高效性</strong>(Efficient)。天然性意味着相关程序使用了尽可能少的、与问题本身不相干的代码，例如某些纯技术原因导致的代码。一般采用<strong>模块化</strong>、<strong>非确定性</strong>和<strong>对接真实世界</strong>来衡量范式的天然性。高效性则意味着程序与解决同一问题的嵌入式编程只存在常数级差别。由于通常无法同时兼顾这两种属性，于是它们就成为衡量编程范式的重要工具。</p>

<p>声明式编程的简洁和可推导性，使得程序较易于保证正确性，尽管多数时候由于不可变(Immutable)数据类型而需要为计算结果开辟新空间，但这引来的性能损耗在真实场景中几乎可以忽略不计，因此总体上说声明式编程具有高效性。但在满足天然性方面，朴素的声明式编程首先并不具备模块化特性，除非向其注入显式状态；其次，虽然声明式编程支持并发，但由于本身不支持状态，从而不具备可观测非确定性；由于前两者不满足，声明式编程也就不具备对接真实世界的特性。因此可以认为声明式编程并不具备良好的天然性。</p>

<p>状态式编程一般要求程序采用顺序执行，但真实世界的实体通常既是状态的也是平行的，这就需要引入并发来解决这一问题，即增加可观测非确定性。另一方面，在分布式环境中，状态的存储也面临一致性和效率问题，于是导致了一套复杂的一致性等级和协调算法解决方案，极大提升了状态式编程在解决分布式问题中的复杂度。这些问题对面向对象编程同样适用，而对后者而言，其相较于其它范式显然更符合天然性要求，这也是其流行至今的原因之一。</p>

<p>在并发编程方面，并发声明式作为基于数据流的、最简单的并发编程范式，无疑是实现确定性并发编程的最佳工具；真实世界中更多时候面临着可观测非确定性问题的挑战，于是推动了消息传递和共享状态两种应对方案的出现。对于消息传递并发式来说，程序描述了一批相互协调的活动实体，更加适用于多代理场景，例如通信；而对于共享状态并发式来说，程序描述了一批实现一致性修改的数据仓库，适用于以数据为中心的计算场景。而事实上，这两种范式在真实的软件工程实践中是可以并存使用的。</p>

<h2>结论</h2>

<p>编程范式用于描述编程活动中的风格和方法论，该问题是软件设计和实现的共同基础。本文首先介绍了编程范式的基本组成和重要的编程概念，并在此基础上进一步介绍了一种编程范式分类法[PVR04]，并在此基础上对不同类型的编程范式进行了比较。了解这种分类法能够便于理解编程语言的动机和设计原理，并且掌握语言发展的历史、现状和趋势，从而为进一步构建得以实用的软件设计提供更好的理论和技术储备。</p>

<h2>引用</h2>

<p>[RWF79], <a href="https://dl.acm.org/citation.cfm?id=359140">The Paradigms of Programming</a></p>

<p>[TSK62], <a href="https://projektintegracija.pravo.hr/_download/repository/Kuhn_Structure_of_Scientific_Revolutions.pdf">The Structure of Scientific Revolutions</a></p>

<p>[PVR04], <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.7366&amp;rep=rep1&amp;type=pdf">Concepts, Techniques, and Models of Computer Programming</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(6)]]></title>
    <link href="http://www.hanyi.name/blog/2018/12/09/software-design-and-architecture-notes-6/"/>
    <updated>2018-12-09T10:53:07-05:00</updated>
    <id>http://www.hanyi.name/blog/2018/12/09/software-design-and-architecture-notes-6</id>
    <content type="html"><![CDATA[<h2>数据模型与数据建模(Data Model and Data Modeling)</h2>

<p><strong>信息系统</strong>(Information Systems)是人类社会重要的基础应用之一，也是计算机自诞生起最重要的应用领域。在计算机信息系统中，<strong>数据</strong>(Data)作为信息的主要载体，也是沟通人与硬件系统的桥梁，其复杂性不言而喻。可以说，本文涉及的数据模型与数据建模技术的发展，始终是以弥补人机之间的鸿沟为目标的。</p>

<h3>数据模型</h3>

<p>在设计信息系统时，为了应对信息的复杂性，人们利用<strong>数据模型</strong>描述数据元素、元素间关系及其与真实世界实体的映射，从而达成抽象且一致的信息表示。初期的数据模型包括<strong>文件系统模型</strong>(File System Model)、<strong>层级模型</strong>(Hierarchical Model)和<strong>网络模型</strong>(Network Model)等。</p>

<p>文件系统模型利用计算机文件系统模拟制表(Tabulation)，包含一般表格中的字段、记录等概念、且具备顺序和随机访问文件的能力，数据可按文本或二进制类型进行存储。这是一种非常简洁的数据模型，诸如csv、dsv等标准格式至今仍被广泛使用。</p>

<p>层级模型与文件系统模型拥有类似的字段和记录等概念，所不同的是记录之间可以按树形结构进行关联，从而表示记录之间的关系。相比较于文件系统模型，层级模型能够显式表达记录间的连接关系，并允许按照标准的树遍历算法进行数据遍历；缺点在于子记录只能拥有唯一的父记录，反过来则没有限制。发布于1966年的IBM Information Management System(IMS)就是基于层级模型构建。</p>

<p>网络模型旨在克服层级模型对关系限制的缺陷，允许每条记录拥有多个父记录和子记录。从<strong>数据模式</strong>(Data Schema)的描述上来看，网络模型的对象关系呈现出一个通用的网状结构，从而具有较层级模型更好的表达能力。1969年，数据系统语言委员会(CODASYL)下属的数据仓库任务小组(DBTG)发布了网络模型规范，该规范包括了一种用于定义数据模式的<strong>数据定义语言</strong>(DDL)，以及能够被嵌入宿主语言的<strong>数据操纵语言</strong>(DML)，首次提出了独立于宿主语言的数据语言的概念，并且通过国际标准化组织制定了多项标准。但是自诞生后，网络模型并未被工业界和学术界广泛接纳，并在此后十年的竞争中败给更具形式化能力的<strong>关系模型</strong>(Relational Model)和后续模型。</p>

<p>Edgar F. Codd在1970年提出了关系模型[EFC70]，其包含两个主要内容：</p>

<ol>
<li><p>对应于N个数据集合，使用N元关系组表达集合间的关系，使模型具备更精确的数学表达能力。</p></li>
<li><p>一种具有强描述能力的全局数据子语言，该语言基于结构化一阶谓词逻辑算子，能够用于表达基于关系模型的数据操作。</p></li>
</ol>


<p>关系模型为设计人员提供了统一抽象的界面，很好地隐藏了数据操作与底层系统交互的实现细节。但是也存在一些不足：</p>

<ol>
<li><p>根据关系模型的数学定义，集合之间的关系通过维护单独的N元关系组实现，其实质是集合间的笛卡尔积。但是通过这种形式化表示无法进一步揭示笛卡尔积的基数信息，而实践证明这种数量关系在描述数据模型时非常重要。</p></li>
<li><p>与问题1类似，关系模型的形式化表达缺乏一定的语义信息，无法进一步揭露关系的实质。尽管这种针对关系的语义信息不是始终必要的，但实践证明语义对数据模型的可表达能力具有重要意义。</p></li>
</ol>


<p>为了解决上述问题，Peter Chen进一步发展出了<strong>实体-关系模型</strong>(ER模型)，后者成为当前数据模型的重要描述工具和行业标准[PPC76]。ER模型包含四个主要概念：<strong>实体</strong>(Entity)，即现实世界的实例，通常是名词形式；<strong>关系</strong>(Relationship)，实体间的关联方式，通常是动词形式；<strong>类型</strong>(Type)，对实体的类别定义，通常是名词形式；<strong>角色</strong>(Role)，对实体在某个关系下的特殊定义，通常也是名词形式[PPC02]。</p>

<p>ER模型的一个重要技术是<strong>实体-关系图</strong>(ER Diagram，ER图)，即用图展示前述的概念及其联系，其中方框表示实体的类型；菱形表示关系；圆圈表示实体或关系类型的属性；实体类型关系和实体属性关系上还标注了数量关系。一个典型的ER图如下图所示。</p>

<p><img src="http://content.hanyi.name/images/data_model_and_data_modeling/er_diagram.png" alt="er diagram" /></p>

<p>尽管本节介绍的数据模型为数据表达提供了形式化工具，但是在面对复杂系统时，设计人员不可能凭空得出系统终极的数据表示，于是<strong>数据建模</strong>就成为支撑构建数据模型的重要方法论。</p>

<h3>数据建模</h3>

<p>实践表明，在软件需求分析起初就需要开始构建数据模型，数据建模应关注数据的需求和实现等特定方面。一般的数据建模过程依次产生下列三种数据模型：</p>

<ol>
<li><p>概念数据模型(Conceptual Data Model)，从高层角度描述系统的信息需求，具体包括主要的信息概念及其相互关系。1969年，网络模型之父Charles W. Bachman提出了数据结构图(Data Structure Diagram)[CWB69]，并将其用于描述概念数据模型。
<img src="http://content.hanyi.name/images/data_model_and_data_modeling/data_structure_diagram.png" alt="data structure diagram" /></p></li>
<li><p>逻辑数据模型(Logical Data Model)，描述信息中领域的具体结构，例如表、列及其关系等。在复杂度较低时，设计人员往往可以跳过概念数据模型，从而直接得出逻辑数据模型。该模型与概念数据模型都是独立于具体的持久化技术（例如通用的数据库管理系统）。</p></li>
<li><p>物理数据模型(Physical Data Model)，满足非功能需求的且可立即被实现的数据模型。该模型与存储技术、维护技术和更新/查询场景等因素密切相关。</p></li>
</ol>


<h4>数据分类</h4>

<p>在开始构建数据模型之前，需要首先识别系统需求中的数据分类，从而确定相应的问题范围，并使用相应的数据模型进行建模。实践中存在多种逻辑思维实践以实现前期的数据分析，[DMG08]描述了一种被广泛认可的数据分类方式，把数据按照特性划分为下列六类：</p>

<p><strong>主数据</strong>(Master Data)，表示业务需求中出现的人物、地点、事物等信息。</p>

<p><strong>事务性数据</strong>(Transactional Data)，表示业务发生时伴随的内部或外部事件或事务，例如发起订单、创建发票、支付等活动。</p>

<p><strong>引用数据</strong>(Reference Data)，表示被系统、应用、数据存储、进程、报表乃至事务性或主数据所引用的值或分类模式的集合，例如状态码、名词简写、产品类型等静态数据。</p>

<p><strong>元数据</strong>(Metadata)，表示数据本身的数据，方便数据的检索、解释和使用。</p>

<p><strong>历史数据</strong>(Historical Data)，表示在某个时刻发生、且不可修改的数据，例如日志。</p>

<p><strong>临时数据</strong>(Temporary Data)，表示因为某些技术需求而被临时创建的数据，通常没有独立的业务含义。</p>

<p>值得一提的是，上述分类方法只应被看作一个指导性原则，具体实践时应视上下文灵活调整。在本例中，对应前面提到的三种数据模型，概念数据模型通常考虑主数据和元数据，逻辑数据模型进一步包括了事务性和引用数据，物理数据模型最终实现覆盖全部类型的数据。采用前文提到的ER模型即可对这三种数据模型分别建模。</p>

<h4>关系范式</h4>

<p>在构建逻辑和物理数据模型时，为了能尽可能降低关系模型中的关系表示所带来的数据冗余，从而加强数据的一致性，关系模型提出了<strong>规范化</strong>(Normalization)的概念，以对关系表示本身进行约束，并在此后一段时间相继发展出了多种范式。其中常用的范式包括：第一范式(1NF)，即没有多值属性的关系；第二范式(2NF)，即满足第一范式且非主属性不依赖任何候选键的子集；第三范式(3NF)，即在第二范式的基础上不存在传递依赖。虽然规范化对强化数据一致性约束方面有促进作用，但其造成的后果是使许多数据表示被物理隔离，从而在实现数据操作方面引起额外耗费。因此在实际设计数据模型时，规范化设计的采用是和系统的非功能需求(Non-functional requirement)密切相关的。</p>

<h2>结论</h2>

<p>数据模型是信息系统设计的重要内容，在经历上世纪70年代的激烈竞争后，关系模型因占据理论高位更加受到学术界青睐，最终成就了80年代起通用关系型数据库系统的统治地位。ER模型和ER图因其更具表达能力，从而成为最重要的数据建模工具。数据模型方法领域的先驱Bachman(网络模型)、Codd(关系模型)和Chen(ER模型)也先后因其开创性贡献而获颁图灵奖。</p>

<h2>引用</h2>

<p>CWB69, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.172.3370&amp;rep=rep1&amp;type=pdf">Data Structure Diagrams</a></p>

<p>EFC70, <a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf">A Relational Model of Data for Large Shared Data Banks</a></p>

<p>PPC76, <a href="https://www.csc.lsu.edu/~chen/pdf/erd-5-pages.pdf">The Entity-Relationship Model-Toward a Unified View of Data</a></p>

<p>PPC02, <a href="https://csc.lsu.edu/~chen/pdf/Chen_Pioneers.pdf">Entity-Relationship Modeling: Historical Events, Future Trends, and Lessons Learned</a></p>

<p>DMG08, <a href="https://dl.acm.org/citation.cfm?id=2821563">Executing Data Quality Projects: Ten Steps to Quality Data and Trusted Information</a></p>
]]></content>
  </entry>
  
</feed>
