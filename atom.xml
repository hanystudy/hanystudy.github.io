<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Wing of Dream 梦境之翼]]></title>
  <link href="http://www.hanyi.name/atom.xml" rel="self"/>
  <link href="http://www.hanyi.name/"/>
  <updated>2018-10-23T22:49:04-04:00</updated>
  <id>http://www.hanyi.name/</id>
  <author>
    <name><![CDATA[Han Yi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(5)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5/"/>
    <updated>2018-10-23T11:42:00-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5</id>
    <content type="html"><![CDATA[<p>上接<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">软件设计与架构笔记(4)</a></p>

<p>前文描述的HIPO模型是一个典型的基于结构图的IPO系统设计模型，其基本思想依然是由顶至下，逐步求精。基于经验Larry进一步总结了通用的系统设计准则[SMC74]。</p>

<ol>
<li><p><strong>程序结构</strong>和<strong>问题结构</strong>。减少程序变更所造成影响的重要方法之一，就是保证设计结构匹配问题本身的结构。由顶至下的思维模式会天然形成一种层级结构，因此重点在于如何决定设计单元在相同层级，或隶属于不同层级，而关键又在于理解问题本身。</p></li>
<li><p><strong>模块控制范围</strong>和<strong>决策影响范围</strong>。控制范围指模块以及归属于该模块的子模块的集合；影响范围指某个设计决策所造成变更的所有模块集合。当设计决策的影响范围尽可能位于该决策所在的模块控制范围之内时，该系统设计就可以被认为是“简洁”的。保持简洁性的方法之一可以是提升某些决策相关的元素的层级；或者把受到相同决策影响，但位于不同控制结构的模块重新划分至相同控制范围。</p></li>
<li><p><strong>模块大小</strong>。模块的实际大小可被用于描述潜在问题的信号。过小的模块可能缺少功能性绑定，而过大的模块可能涵盖了超过一个功能性绑定。前者可以通过inline的方式消除以减少模块规模，后者由于可理解性和可读性问题需要进行进一步拆分。</p></li>
<li><p><strong>错误</strong>和<strong>文件终止处理</strong>。当模块的一部分功能需要通知其调用者发生某件错误时，可通过返回某种错误参数实现，该参数的值最好是二元类型，对于流数据处理的EOF标记也需要进行类似处理。同时这些参数也不应该包含如何处理当前错误的信息，而是由调用者决定。当然，如果模块本身不需要错误标记时，系统设计就更简洁了。</p></li>
<li><p><strong>初始化</strong>。某些模块由于需要依赖初始化操作，从而可能存在“简洁”但导致“弱绑定”的设计。例如，读模块的access方法可能会遇到“文件未打开”的错误，如果选择将错误信息返回，调用者自然会选择调用open方法然后重新read；但另一种维护“黑盒性”的做法是，在access内部遇到该错误时自动通过open和reread进行恢复，那么调用者就不需要知道“文件未打开”这种错误并且重复进行处理了。</p></li>
<li><p><strong>模块选择</strong>。消除重复的功能，而非消除重复的代码。如果只是通过抽取的方式简单消除重复代码，那么有可能导致某个变更造成更多的修改。一种识别该问题的方法是，关注那些被其它不同模块调用，以及调用其它不同模块的对象，判断是否存在其子功能与不同的模块集合关联的情况，如果是则意味着存在层级或模块缺失的可能。</p></li>
<li><p><strong>隔离软件规格说明</strong>。软件设计规格的重要内容就是描述特定的数据类型、记录布局以及索引结构，设计应尽量使其与系统其他模块进行隔离，从而减少规格变更导致的重写。</p></li>
<li><p><strong>参数数量</strong>。尽量减少模块间调用的参数数量（不只是个数），如果参数中存在一个完整的数据记录，应尽量只传递必要的数据记录，否则也会导致该记录的变更对模块造成潜在影响。</p></li>
</ol>


<h3>结构化分析(Structured Analysis)</h3>

<p>随着软件设计方法论的发展和问题复杂度的增加，人们发现设计不再是解决复杂系统面临的唯一难题。比如，传统的软件设计过程一般是按由顶至下的方法，依照<strong>需求规格说明(requirement specification)</strong>给出具体的软件对象定义，那么如何构建规范合理的需求规格说明呢？另外，如果软件设计过程愈加复杂，是否可以按照经典的分治法(divide-and-conquer)对其进行分解和简化呢？</p>

<p>世界上存在多种多样的原始需求形态，例如采用<strong>文字叙述(narrative)</strong>可以说是最普遍的形式之一。当问题复杂度增加时，软件设计已经不能从简单的叙述中加以消化并诞生，于是就出现了<strong>需求分析</strong>的过程。这种把问题从原始形式转换成可进一步规范设计的规格说明的过程，被称为<strong>系统分析</strong>。<strong>结构化分析</strong>作为软件系统分析最早流行起来的方法论，是在早期工业界数十年的探索中发展起来的。</p>

<p>由于传统的文字叙述不足以表达复杂系统，人们开始重视并使用符号语言，例如德国数学家Carl Adam Petri发表于1962年的<strong>Petri Net</strong>。60年代中期，女数学家Erna Schneider Hoover在贝尔实验室领导了一支团队，其目标是分析电话交换机系统的性能和宕机时间，Erna使用了Petri Net来模拟复杂的电话交换系统。受此启发，同时困扰于晦涩难懂的叙述式规格说明的年轻工程师Tom DeMarco由此开始开发一套网络符号语言，由此发展并最终在1978年发表了<strong>结构化分析</strong>方法[TOM78]。</p>

<h4>结构化分析与传统系统分析</h4>

<p>Tom认为传统的系统分析包含如下目标：</p>

<ol>
<li><p>确定最优化目标。</p></li>
<li><p>生成该目标的细节描述，并且能够被后期的实现过程用于评估该目标是否实现。</p></li>
<li><p>生成该目标相关的重要参数预测，包括花费、收益、日程以及性能特性。</p></li>
<li><p>得出所有被影响部分之上的项的并发性。</p></li>
</ol>


<p>为了达成这些目标，系统分析活动需要涉及用户沟通、撰写规格说明、损耗收益研究、可行性分析以及估算等。然而，这些活动都因高复杂性存在很多问题。针对这些问题，结构化分析进一步拓展了系统分析的目标：</p>

<ol>
<li><p>分析的产生物必须是<strong>可维护</strong>的，特别是针对<strong>目标文档(Target Document)</strong>。</p></li>
<li><p>必须采用有效的分割方法解决大小的问题，摒弃维多利亚小说式的规格说明。</p></li>
<li><p>尽可能使用<strong>图形表达</strong>。</p></li>
<li><p>必须区分逻辑和物理设计，并且基于此在分析师和用户之间合理分配职责。</p></li>
<li><p>必须在具体实现之前构建逻辑系统模型，使用户熟悉系统特性。</p></li>
</ol>


<p>同时，结构化分析描述了一系列可被用于不同分析阶段的工具：<strong>数据流程图(Data Flow Diagram, DFD)</strong>、<strong>数据字典(Data Dictionary)</strong>以及逻辑策略表达工具，例如<strong>结构化英语(Structured English)</strong>、<strong>决策表(Decision Tables)</strong>以及<strong>决策树(Decision Trees)</strong>等。</p>

<h4>数据流程图</h4>

<p>DFD是一种描述相互关联的过程的网络，其作用是帮助分割需求，并在撰写规格说明之前记录这种分割。与普通流程图的区别是，DFD只聚焦在数据流动的过程，因此基本没有任何关于循环或逻辑决策的控制信息。为了举例说明DFD，[TOM78]描述了一个软件咨询公司的自动化管理和运营辅助系统，该系统的功能包含了学员注册、支付、人员管理、课程管理等方面。下图是对该公司的早期运营模型的描述：</p>

<p><img src="http://content.hanyi.name/images/structured_analysis/logical_dfd.png" alt="Logical DFD" /></p>

<p>该图是一种Logical DFD，图中的输入被称作<strong>事务(Transaction)</strong>。以其中一条主要路径的部分为例，该路径共描述了5种事务：Cancellations, Enrollments, Payments, Inqueries和Rejects(这里指不属于前4种类型的事务的统称)，以及数据在这些事务间可能的流动关系。此外还有一种包含了系统具体实现信息的DFD，被称作Physical DFD。</p>

<p>DFD有时又被称作<strong>气泡图(Bubble Diagram)</strong>，原因是其描述数据转换过程的符号——气泡。此外DFD还包含<strong>命名向量</strong>，用于表示数据路径；<strong>直线段</strong>，表示文件或数据库；<strong>矩形(或称为源/入节点)</strong>，表示网络的起点或数据的接收者(通常是当前领域外的人或组织)。</p>

<p>DFD清晰地表达了工具的自然特征——如果DFD存在任何错误，也应当是显而易见、毋庸置疑的，这无疑减少了分析师与用户间产生认知分歧的可能。另一方面，实践证明DFD无论在概念描述或是建模方面都有显著价值。更重要的是，它提供了一种基于功能的系统分割方法，并且描述了不同部分之间的接口。在系统评审中，任何接口或过程的缺失都能够证明当前DFD的缺陷——这比纯粹的数学方式更加直观和有效。</p>

<p>在实际分析活动中通常使用分级数据流程图(Levelled DFD, LDFD)逐步求精分割系统功能。在LDFD中，通常存在3层、有时甚至更多层具有不同功能解析度的DFD。</p>

<p>Level 0，也被称为上下文图，通常仅包含一个气泡——也就是系统总的过程单位以及其它元素。这种图可以被用于和最宽泛的用户进行交流，例如干系人、业务分析员、数据分析员以及程序员。</p>

<p>Level 1，对上下文图的唯一气泡进行细分，将其分解成不同过程单位，以及相关的文件或数据库。</p>

<p>Level 2，进一步对Level 1进行划分，因此需要更多的文字和符号标记。</p>

<p>Level 3+，一般很少出现Level 3+的DFD，原因是这种级别的DFD可能存在过多的细节，从而导致难以沟通、比较和有效建模的问题。</p>

<h4>数据字典</h4>

<p>数据字典用于追踪和评估系统不同部分之前的接口，是对DFD的一种有效补充。以前面描述的系统DFD为例，过程3和7之间的数据流动Payment-Data，可以用如下公式进一步描述：</p>

<pre><code>Payment-Data = Customer-Name +              
               Customer-Address +
               Invoice-Number +
               Amount-of-Payment
</code></pre>

<p>换句话说，Payment-Data包括了该公式右值的所有数据项，且这些数据项需依序且非空。更进一步，数据字典还可能需要对某些数据项进行进一步描述，例如Invoice-Number：</p>

<pre><code>Invoice-Number = State-Code +
                 Customer-Account-Number +
                 Salesman-ID +
                 Sequential-Invoice-Count
</code></pre>

<p>与DFD类似，数据字典也是呈现了由顶至下的细分过程。每个DFD应该携带相应的数据字典描述，二者共同组成了系统分析的图形化产生物。</p>

<h4>逻辑策略表达</h4>

<p>逻辑策略表达用于替代传统冗长的文字叙述式的规格说明。最常见的结构化表达方式被称作结构化英语，例如采用按行缩进的方式表述不同层级的规格说明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>If the amount of the voice exceeds $500.
</span><span class='line'>    If the account has any invoice more than 60 days overdue.
</span><span class='line'>        hold the confirmation pending resolution of the debt.
</span><span class='line'>    Else (account is in good standing).
</span><span class='line'>        issue confirmation and invoice.
</span><span class='line'>Else (invoice $500 or less).
</span><span class='line'>    If the account has any invoice more than 60 days overdue.
</span><span class='line'>        issue confirmation, invoice and write message on the 
</span><span class='line'>        credit action report.
</span><span class='line'>    Else (account is in good standing).
</span><span class='line'>        issue confirmation and invoice.</span></code></pre></td></tr></table></div></figure>


<p>使用决策表表达上述规格说明，结果如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>                       RULES
</span><span class='line'>CONDITIONS              1  2  3  4
</span><span class='line'>
</span><span class='line'>1.Invoice &gt; $500        Y  N  Y  N
</span><span class='line'>2.Account overdue
</span><span class='line'>by 60+ days             Y  Y  N  N
</span><span class='line'>
</span><span class='line'>ACTIONS
</span><span class='line'>
</span><span class='line'>1.Issue confirmation    N  Y  Y  Y
</span><span class='line'>2.Issue Invoice         N  Y  Y  Y
</span><span class='line'>3.Msg to C.A.R.         N  Y  N  N</span></code></pre></td></tr></table></div></figure>


<p>决策树的表达结果如下：</p>

<p><img src="http://content.hanyi.name/images/structured_analysis/decision_tree.png" alt="Decision Tree" /></p>

<h2>结论</h2>

<p>结构化设计为软件设计提供了有效的结构图工具，以及作者Larry富有经验的设计准则，至今仍极具指导意义。为了保证设计阶段能使用清晰有效的规格说明，结构化分析提供了强大的DFD分析工具和规格说明描述工具，尽管其核心依然是逐步求精的设计思想，但已经开始涉足于比编程活动更加宽泛的软件工业领域，最终形成了较为独立的需求工程，成为软件构建过程中不可或缺的环节。</p>

<h2>引用</h2>

<p>SMC74, <a href="https://ieeexplore.ieee.org/document/5388187">Structured design</a></p>

<p>TOM78, <a href="https://books.google.com/books/about/Structured_Analysis_and_System_Specifica.html?id=7o0-AAAAIAAJ">Structured Analysis and System Specification</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(4)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/"/>
    <updated>2018-10-12T15:28:06-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4</id>
    <content type="html"><![CDATA[<h2>结构化分析与设计方法(Structured Analysis and Design Methods)</h2>

<p>除了指导<a href="http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2/">程序设计</a>，结构化方法还被广泛应用于系统分析和设计领域，成为软件设计方法论的开端。从时间轴来看，从结构化编程到结构化程序设计，再到软件的结构化设计和分析，软件设计的方法论是从底向上发展的，其根本推动力是日益增加的系统复杂性。</p>

<h3>结构化设计(Structured Design)</h3>

<p>1974年，Larry Constantine等提出了一系列通过降低系统复杂性，从而提高编码、调试、修改等工作效率的软件设计思想，并将其统一命名为结构化设计[SMC74]。通用的结构化设计思想包括<strong>简洁性</strong>和<strong>可观测性</strong>，其中，简洁性作为衡量和评估设计方案的主要度量指标，体现在分割后的系统模块间具有设计、开发、更正、修改的独立性；可观测性则体现了软件易被感知功能和原理的能力。尽管系统分割具有良好的工程意义，但其引起的模块间重叠部分代码以及相互关系反而可能会增加复杂性。前文我们已经介绍了信息隐藏这一重要的模块化概念，结构化设计则提出了一个更具实践意义的设计指标：<strong>耦合(coupling)</strong>。</p>

<h4>耦合</h4>

<p>通常情况下，更少或更简洁的模块间连接就意味着更好的可理解性，同时变更或出错所引起的模块间传递也会受到抑制。系统复杂度不仅体现在模块间的连接数量，更体现在每个连接所承担的关联强度，这种强度的度量被称作<strong>耦合度</strong>。强耦合意味着高复杂度，造成模块难以被理解、修改和更正的后果。因此，软件设计可以通过建立模块间的弱耦合降低系统复杂度。</p>

<p>一个特定连接产生的耦合度是一个包含多重因子的函数，这些因子包括连接复杂度、连接指向模块自身亦或其内部、连接所发送或接收的内容等，Larry将其归纳为三个主要的耦合因子：接口复杂度、连接类型和通信类型。耦合度受这三个因子的变化规律如下表所示：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">Coupling</th>
<th style="text-align:center;">Interface complexity</th>
<th style="text-align:center;">Type of connection  </th>
<th style="text-align:center;">Type of communication</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">Low     </td>
<td style="text-align:center;">simple,obvious      </td>
<td style="text-align:center;">to module by name   </td>
<td style="text-align:center;">data                 </td>
</tr>
<tr>
<td style="text-align:center;">        </td>
<td style="text-align:center;">                    </td>
<td style="text-align:center;">                    </td>
<td style="text-align:center;">control              </td>
</tr>
<tr>
<td style="text-align:center;">High    </td>
<td style="text-align:center;">complicated,obscure </td>
<td style="text-align:center;">to internal elements</td>
<td style="text-align:center;">hybrid               </td>
</tr>
</tbody>
</table>


<p>Larry认为，弱耦合应具有接口简单直观，只通过名字引用其它模块，以及尽量仅通过数据进行通信等特征，反之则会增加耦合度。具体来说：</p>

<ol>
<li><p>接口复杂度，指模块间接口是否能清晰地表述连接，而不是包含了过多的信息导致难以理解。特别当多个模块通过共享一个公共环境(common environment)实现交互时，该公共环境中任意元素的增加都可能会导致系统整体复杂度的显著提升。例如在M个对象中，存在M(M-1)对相互关系，假设这些对象之间的公共环境包含N个元素，那么就有NM(M-1)对一阶关系，亦即变更或错误传递的可能路径数量。可见接口复杂度对系统整体复杂度的显著影响。</p></li>
<li><p>连接类型，指模块间相互关联的形式，例如仅通过模块名字进行关联，还是进一步引用了模块内部的元素。在后一种情况下，该模块内部的修改很可能传递至其它依赖它的模块，导致潜在的复杂度增加。</p></li>
<li><p>通信类型，指模块间通信内容的形式。对于系统中任何有效模块，其或者通过传递数据实现通信，或者通过被“控制”进行某项任务。显然，仅通过数据实现通信的接口更易被理解，而控制类型的通信使模块功能难以被直观理解。</p></li>
</ol>


<p>实现<strong>弱耦合</strong>的途径不一，一个方向是尽量降低元素间关系发生在不同模块间的可能，简单来说就是最小化模块间的关联，并且保证元素间关系只发生在相同模块内部。为了验证元素间关系是否都存在于模块内，Larry同时给出了一个描述模块内部元素间相互绑定程度的指标：<strong>内聚(Cohesiveness)</strong>。</p>

<h4>内聚</h4>

<p>由前述可知，实现内部高度绑定的模块，就能够达到降低耦合的目标，即模块自身的强内聚性。一般而言，对模块内聚程度的描述可以被划分成如下六个层级（由弱到强的非线性关系）：</p>

<ol>
<li><p>巧合的(Coincidental)。例如元素通过某种模块化方法被“无意间”划分到某个共同模块中，或者某个模块的创建仅仅是为了消除重复代码。在这种情况下，模块极易因为变更而变得“不可重用”，因此这类绑定只是发生于巧合之中。</p></li>
<li><p>逻辑的(Logical)。这种关系通常隐含了某种逻辑联系，例如负责程序中所有输入输出的模块，或者负责操作所有数据的模块。其问题在于，以此类关系实现的模块易存在内部元素间的相互缠绕，从而降低元素间的独立性，同时也会导致模块接口的复杂性增加。</p></li>
<li><p>一时的(Temporal)。该关系建立在逻辑层面的关系基础上，同时元素间还存在某种时间上的一致性。例如程序的初始化、终止、清理等阶段的操作，其元素间存在一定的功能逻辑，同时也常一起发生。尽管如此，这种关系依然存在于逻辑层面类似的缺陷。</p></li>
<li><p>通信的(Communicational)。元素间通过相同输入/输出数据集合的引用进行关联，例如“打印”和“装订”文件，显示出更强的绑定关系。</p></li>
<li><p>连续的(Sequential)。如果某个元素的输出恰好是另一个元素的输入，即意味着目标问题可以通过简单流程图进行描述和解决，那么其存在连续的强绑定关系。但需要注意，这种过程式处理会导致该模块独立于程序的其它功能部分，从而使其难以被其它系统模块复用。这也是连续层面与进一步功能层面关系所导致的内聚度存在较大差距的原因。</p></li>
<li><p>功能的(Functional)。在这种层面的关系下，模块中的元素都与同一个独立功能相关。一种判断某个模块是否为功能层面的绑定的方法是，通过一句话描述该模块功能，然后进行验证：</p>

<ol type="a">
<li><p>该句是否为复合句，是否包含逗号、多个动词等等，如果是则该模块可能包含连续或通信层面的绑定；</p></li>
<li><p>如果语句中包含时间相关的词，那么可能存在一时或连续层面的绑定；</p></li>
<li><p>如果语句中动词的操作对象不是一个特定对象，那么可能存在逻辑层面绑定；</p></li>
<li><p>如果语句中包含初始化、清理等词，说明可能是一时层面的绑定。</p></li>
</ol>
</li>
</ol>


<p>值得注意，元素间可能存在多个上述的关系，而通常我们可以使用其中内聚度表现最高的关系表示整体程度。但是如果模块中没有一组元素的关系表现为功能层面绑定，那么该模块的内聚性就表现较低。</p>

<h4>可预测模块</h4>

<p>模块的可预测性是指当给定相同的输入时，该模块每次被调用所发生的操作也完全相同，亦即独立于环境的特性。不可预测的模块不一定是存在错误的，例如当模块内部维持某种状态，该状态在针对当前模块的操作下会发生不断变化，从而导致返回结果或实际发生操作的不同。这种不可预测的模块在实际应用中经常发生，尽管是无错误的。模块的可预测性，有时也被成为“黑盒性”，使该模块能较容易被清楚地理解，例如通过简单的注释、描述性的名字或者良好定义的接口等方法。</p>

<h3>结构化设计技术</h3>

<p>软件设计过程可以被看作包含一般设计和详细设计两个部分。一般设计的目的在于确定系统需要的函数有哪些(回答what)，详细设计描述如何实现这些函数(回答how)。这些设计阶段需要确定函数标识、函数范围结构的调用参数和调用关系、所关联的模块等信息，并且保证模块能够被独立设计、实现和测试。</p>

<h4>结构图(Structure Chart)</h4>

<p>传统的流程图方法能够描述代码块执行的顺序和条件分支，但是在一般设计阶段，由于我们侧重于了解what，流程图会不可避免地增加设计复杂度。因此这里介绍一种较为简单的结构图用于表述函数及其调用关系。结构图所包含的符号标记如下图所示：</p>

<p><img src="http://content.hanyi.name/images/structured_design/definitions_of_symbols_used_in_structure_charts.png" alt="Definitions of symbols used in structure charts" /></p>

<p>假设某系统设计包含三个模块，分别是A、B和C，其中模块间的关系是A调用B，B调用C；从执行顺序上看，B的代码会首先执行，然后是C，最后是A。那么上述信息可以分别用结构图和流程图表示如下：</p>

<p><img src="http://content.hanyi.name/images/structured_design/structure_chart_vs_flowchart.png" alt="Structure Chart vs Flowchart" /></p>

<p>从上图可以看出，相比于流程图，结构图能够清楚表示模块间关系，并且有潜力进一步描述模块的接口信息，这恰好是在一般程序设计阶段需要进行的工作，流程图就不具有优势。</p>

<h4>基于结构图的软件设计过程</h4>

<p>下面以设计一个较为复杂的模拟输入——处理——输出(Input Process Output, IPO)类型的系统为例，给出一种衍生自结构图、由IBM开发的基于层次输入处理输出(Hierarchical IPO)图的一般设计过程：</p>

<p>Step 1. 根据问题描述，绘出系统大致的功能性草图。本例中模拟系统的大致功能是一个数据输入、处理和输出的过程，其大致可以被描述如下：</p>

<p><img src="http://content.hanyi.name/images/structured_design/rough_structure_of_simulation_system.png" alt="Rough structure of simulation system" /></p>

<p>Step 2. 识别外部的概念数据流，指来源于系统外的、独立于具体物理I/O设备的相关数据流。在本例中，概念数据流包括输入参数、格式化的返回结果等。</p>

<p>Step 3. 识别问题中的主要概念数据流(包括输入和输出)，确定该问题的功能图中的“最高级抽象”节点。对于输入的数据流而言，其抽象节点存在于距离物理输入形态最远，但依然可以视作输入数据的阶段。本例中该节点可能在于构建矩阵阶段。同时，针对输出数据流可以把结果矩阵作为输出的抽象节点，如下图所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/determining_points_of_highest_abstraction.png" alt="Determining points of highest abstraction" /></p>

<p>Step 4. 根据前面步骤得到的信息，针对每个抽象输入数据节点，使用一个源模块(source module)表示其结构。相应设计对应的入模块(sink module)。通常系统存在一个源和入分支，具体参数依赖问题描述而定，但其通用模式如下图所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/the_top_level.png" alt="The Top Level" /></p>

<p>在本例中，模块A即系统入口，也就是说模块A的功能意味着整个问题的解决；模块B用于获取主要数据流；模块C用于把主要输入流变换成主要输出流；模块D用于处理主要的输出数据流。</p>

<p>Step 5. 针对源模块，通过识别其中最后一次变换操作，生成当前模块的数据返回形式，然后再识别前一次变换的抽象节点。对于入模块，与源模块相反，通过识别其中第一次处理操作，确认抽象输出节点，直到获取期望的输出形式。基于逐步求精的思想重复步骤5，直到抵达最初的源模块和最后的入模块。构建出的部分结构图如下所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/lower_levels.png" alt="Lower Levels" /></p>

<p>在这一逐步求精的设计过程中，划分的终止条件因具体问题而异，通用的判断方法之一即前文提到的耦合与内聚等设计思想。</p>

<p>（未完待续）</p>

<h2>结论</h2>

<p>结构化设计的兴起使结构图及其衍生工具成为软件设计领域的重要工具。同时，在软件设计模块化道路上的深入实践也促使许多重要的软件设计思想被提出，诸如耦合、内聚等重要概念被广泛用于指导包括结构化设计及后续的设计方法论，影响至今。</p>

<h2>引用</h2>

<p>SMC74, <a href="https://ieeexplore.ieee.org/document/5388187">Structured design</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(3)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/03/software-design-and-architecture-notes-3/"/>
    <updated>2018-10-03T14:34:10-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/03/software-design-and-architecture-notes-3</id>
    <content type="html"><![CDATA[<h2>模块化编程(Modular Programming)：信息隐藏与职责分割</h2>

<p>上世纪60年代起，人们意识到实现复杂系统的前提是把系统合理分割为相互独立的部分，这些独立的部分被称作<strong>模块</strong>。与前文提到的结构化编程和过程式编程的区别是，一个模块可包含若干个子程，也允许组装不同模块以实现子程或程序。D.L. Parnas把这种编程技术称为<strong>模块化编程</strong>[DLP72]，其中模块意味着任务职责，而模块化设计则表示一系列的跨模块的“系统级”设计决策。自此，模块化成为软件设计领域的重要主题之一。</p>

<p>针对模块化的研究包含两个基本组成部分：</p>

<ol>
<li><p>一个良好的模块化系统（设计）应具备哪些特征？</p></li>
<li><p>一个良好的模块化系统（设计）应如何实现？</p></li>
</ol>


<h3>信息隐藏(Information Hiding)</h3>

<p>最初的软件设计方法论认为，组织应当建立统一的文档管理系统，软件由设计人员设计好后开放给全体人员，从而让每个人都尽量了解设计背后包含的一系列<strong>决策</strong>。1971年，Parnas首次提出<strong>信息隐藏</strong>的概念，反驳了前述的传统设计“广播”实践[DLP71]。</p>

<p>从软件结构的角度看，软件设计包含了对模块自身特征以及模块间的连接(connetion)的描述，其中连接意味着设计对模块间作用的假设。而我们已经知道软件结构最重要的两个目标：<strong>系统变更</strong>和<strong>正确性检验</strong>，而一个好的软件结构应使上述目标变得更加容易。以简化系统变更为例，如何使针对当前模块的变更不会传递到其它模块呢？答案当然是应尽量使针对当前模块的变更不至于打破其它模块对其所做的假设，即连接的稳定性。那么如何保证连接的稳定呢？直观来看当然是尽量减少假设的规模，即减少连接所包含的信息。</p>

<p>再以软件文档系统为例，实践证明，保证系统设计文档和代码的一致性需要花费可观的成本，这在大多数组织来说都难以实现。同时为了保证文档自身的可理解性，一个好的实践是建立组织统一的标准和术语，但实践证明这也很难做到，因为假设总会根据需求发生变更，而一旦新的假设违反了组织统一标准，则会引起标准的误用，而反过来扩展标准又有可能造成对已有文档假设的破坏。上述复杂性意味着，在一个实践统一文档标准的组织内，标准会尽量维持系统设计的最小假设，而这又会与文档本身的知识传递作用相违背。</p>

<p>Parnas认为设计人员应尽量“控制”信息的传播，例如在设计中只使用外部<strong>接口</strong>描述该模块，从而避免细节过早暴露，对外部隐藏那些尚待决定、不稳定或不应被外部了解的具体实现。</p>

<h3>职责分割(Responsibility Segment)</h3>

<p>人们普遍认为应根据功能职责划分系统模块，但缺少统一的划分方法，导致具体划分时会出现不同结果，原因在于实际问题域的复杂性。以比较简单的经典<a href="https://en.wikipedia.org/wiki/Key_Word_in_Context">KWIC</a>系统为例，考虑如下两种模块化设计方案：</p>

<ol>
<li><p>系统被划分成5个部分：分别是输入模块I、循环移位(circular shift)模块C、字母排序(Alphabetizing)模块A、输出模块O和主控制模块M。具体来说，I接受行格式的数据输入，把每个单词用四个字母进行压缩表示，其余字母作为单词的结尾，然后将其存储到系统核心(core)；当I读完所有数据，C先对核心中每行数据进行循环移位处理，并记录每条新数据到原始数据的索引，最后把数据存储回核心；然后，A从核心中读取数据，把C中生成的数据按字母进行排序并存储回核心；最后O把A中排序好的数据结合I中获得的原始数据进行匹配和格式化输出；主控制模块M负责控制其余模块的调用顺序，进行错误处理和进行一些必要的空间分配等操作。从实践角度考虑，该方案具备良好的职责分割和接口设计。</p></li>
<li><p>系统被划分成6个部分：行存储模块L、输入模块I&#8217;、循环移位器C&#8217;、排序器A&#8217;、输出模块O&#8217;
和主控制模块M&#8217;。具体来说，L负责提供对行数据进行操作的功能，例如常见的增删改查等；I&#8217;负责读入数据并调用L写入数据；C&#8217;用来计算并返回所有的循环移位索引。A&#8217;的功能是返回给定索引序号的字母序序号；O&#8217;用于输出L或C&#8217;中包含的数据；M&#8217;与方案1中M的功能类似。该方案也具有良好的职责分割和接口设计。</p></li>
</ol>


<p>为了进一步比较这两种方案的区别，首先来看两者在分析该问题时所作出的设计决策及其可能影响：</p>

<ol>
<li><p>输入格式。</p></li>
<li><p>存储介质，例如把所有行数据存储在core中，那么假设数据集较大，则该决策就会面临挑战。</p></li>
<li><p>存储压缩，例如对每个单词进行压缩，假设数据集不大，处理时间反而会因为不必要的压缩而增加。</p></li>
<li><p>为循环移位器创建索引，而非直接存储所有数据，对于较小的数据集而言，后一选项可能更加合适。</p></li>
<li><p>为所有数据进行一次性按字母序排序，而非只在需要时进行搜索或只进行部分排序。在某些场景中，可能更希望把索引计算量分配至不同时间的字母序操作中。</p></li>
</ol>


<p>以下分别使用<strong>是否容易变更</strong>、<strong>是否可独立开发</strong>和<strong>是否便于理解</strong>三个具有共识的软件设计目标分析和比较上述方案。</p>

<p><strong>易变更性</strong>，由于都拥有唯一的输入模块，那么决策1的任何潜在变化都不会导致输入模块以外的变化；对决策2和3来说，由于涉及数据的格式表示，方案1中由于多个模块都需要直接读写core中的数据，一旦存储格式因假设发生变化就会导致所有关联模块的修改，相应的方案2由于独立出了行存储功能，因此依旧把改动影响限制在了一个模块之内。同样，决策4的变更可能导致存储格式的变化，方案2中的C&#8217;模块只用于计算而非存储，因此变更影响小于方案1；决策5的情况则与决策4类似，方案2具有更好的易变更性。</p>

<p><strong>可独立开发</strong>，方案1的模块间接口实际上是通过数据存取间接实现的，其实质是数据格式和表结构的设计，在这种情况下，所有相关模块的接口设计都存在一定联系。而方案2通过若干个函数及其参数就实现了模块间的接口，因此对模块分别可独立开发有更好的支持。</p>

<p><strong>可理解性</strong>，根据方案1，为了理解模块职责，需要至少理解模块I、C、A内部的实现，特别是数据存取的设计和实现，才能了解模块间的相互关系；相反方案2只需要通过接口函数的定义就可以了解模块职责了。</p>

<p>从职责分割的角度来说，上述两种方案都给出了初看相当合理的划分，但经过分析我们的结论显然是方案2比方案1更好，那么如何实现诸如本例中更好的职责分割呢？</p>

<h2>一种用于模块分割的标准与系统设计方法</h2>

<p>实际经验表明，人们直观上会倾向于作出符合上节提到的方案1的设计，这是因为方案1更加显而易见：例如借助流程图(flowchart)工具描述系统功能和流程，再自然映射在模块的划分上。而方案2的核心在于每个模块都努力隐藏其设计决策，包括接口和定义也都以较少的信息呈现，Panars认为这反映了一种以隐藏自身设计决策为目标的模块间分割标准，与传统的流程式思考模式有显著区别。</p>

<p>由于构建计算机系统的复杂性，设计人员在60年代起开始采用一些系统模拟语言(Simulation languages)辅助系统设计。显然，当系统需求越复杂，模拟语言也就会变得更复杂，就越难以满足设计人员的目标，因此模拟语言最初的应用并不成功。1968年，沃森研究院的F. W. Zurcher描述了一种迭代式的多层建模方法，通过在不同的抽象层级(Levels of abstraction)上安排设计决策，为设计人员提供了有效的系统思考工具。</p>

<p>Zurcher提出在一个模型中构建系统的多重表示，即<strong>抽象层级</strong>。以计算机系统为例，在最上层，该模型只表示系统的若干基本任务，并且给定这些功能所达到的目标，即始终优先回答what；进一步，在下一层引入CPU、存储层级和文件系统的概念，并指定连接上层每个任务的程序和数据的划分；然后，再下一层级描述更加细节的系统表示，直到完整描述了整个系统设计，即回答how。<strong>迭代</strong>在实现上述方法中同样重要。在采用模拟语言时，先实现上一层的系统设计描述程序，程序应包括本层所含的所有抽象定义；在进入下一层时，构建一个独立的可被上层操作的实现本层抽象意义的模拟程序，从而实现迭代式的层次设计结构。</p>

<p>这种层级建模方法中，每一层都仅包含该层定义范围内的设计决策，即令设计人员更容易理解模型及其具体行为，并且把针对设计的修改限定在本层级范围内，降低了设计变更的影响范围。当进入正式实现阶段时，编程人员可以用具体的算法和数据结构实现替换最底层的模拟程序，从而构建完整系统。</p>

<h2>结论</h2>

<p>如果说结构化编程奠定了现代编程语言的基础，那么模块化编程则为软件设计提供了应对复杂问题的有效工具。与结构化编程和过程式编程几乎一锤定音相比，模块化编程在过去50年间历经了长期演进，虽然70年代开始大量编程语言开始引入模块(module)的概念，但抽象表达本身的复杂性使整个软件设计和开发过程经历了飞速的变革，而这一切源于模块化的设计思想。</p>

<h2>引用</h2>

<p>[DLP72], <a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">On the Criteria to be Used in Decomposing Systems into Modules</a></p>

<p>[DLP71], <a href="http://cseweb.ucsd.edu/~wgg/CSE218/Parnas-IFIP71-information-distribution.PDF">Information distribution aspects of design methodology</a></p>

<p>[FWZ68], <a href="https://pdfs.semanticscholar.org/d99a/732db8e249be47bdf4aacd260f608b632099.pdf">ITERATIVE MULTI-LEVEL MODELLING - A METHODOLOGY FOR COMPUTER SYSTEM DESIGN</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(2)]]></title>
    <link href="http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2/"/>
    <updated>2018-09-25T09:46:21-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2</id>
    <content type="html"><![CDATA[<h2>结构化编程(Structured Programming)：计算语言的突破</h2>

<p>上世纪50-60年代，人类的计算能力实现了迅猛发展，各界对计算机的应用也有很高期许，越来越多的领域希望得到强大的计算赋能从而实现飞跃。然而当面临的问题越多、越复杂时，人们在解决问题的道路上发现了一条巨大的鸿沟，即以现有的软件构建理论和方法难以应对这些挑战。机遇与挑战并存，这场<strong>软件危机</strong>(Software Crisis)最终促成了软件工程作为一门独立的学科从计算机科学的襁褓中成长起来。</p>

<p>软件危机这个词最早在1968年的北约组织软件工程会议上被诸多与会者提出[NATO68]，由此引发的技术创新和组织行为思辨至今依然活跃。而更现实的影响是，科学家们首先在编程语言本身找到了突破口——<strong>结构化编程</strong>。</p>

<p>发明于上世纪50年代的ALGOL语言，首次用begin&hellip;end语句引入了<strong>代码块</strong>的概念，通过限定其中变量声明的词法作用域，提高程序的<strong>可读性</strong>，从此引起了围绕代码块的研究。1966年，论文[Bohm66]证明使用三种基本的程序结构就能表达任何可计算函数：顺序执行、条件选择和循环迭代，这为随后针对结构化编程的讨论提供了理论依据。1968年，Dijkstra发表了著名的”GOTO语句有害“的观点，并且肯定了如条件选择、循环等语句的应用，同时称GOTO语句应该在所有“高级语言”（这里指除了机器码之外的语言）中被废除[EWD68]。Dijkstra认为应当尽可能减少静态程序和动态运行进程之间的差距，而GOTO语句造成了大量程序难以被理解，即人很难从混乱的静态代码中认识程序的真正意图。这一废除GOTO语句的言论激起旷日持久的争论，反对者认为GOTO所具有的灵活性能满足持续的系统优化工作，但争论两方基本同意应当对GOTO限制使用。于是，结构化编程开始被广泛接受。</p>

<p>伴随着结构化编程的普及，过程式编程(Procedural programming)也在60年代起被许多流行语言采纳，如COBOL和BASIC。这种编程方法以代码块为基础，允许使用子过程（也称子程或函数）编写程序单元，并且可以被程序随时调用。使得来自不同程序员甚至不同组织的代码变得简单可复用，为随后代码库的流行奠定基础。</p>

<h2>结构化程序设计与分析</h2>

<p>结构化编程实现了编程语言的巨大进步，作为首席布道者，Dijkstra发表了很多关于程序的可理解性以及结构化编程实践的原则性观点[EWD70]，但如何设计结构化程序还需要进一步说明。1971年，在计算机教育领域功勋卓著的Niklaus Wirth详细解释了一种自顶而下逐步求精的程序设计方法，并以数学中经典的八皇后问题（把这个著名问题作为编程案例，原因之一是尚无该问题的已知解析解）为例演示了程序设计从问题分析到实现的过程[NW71]。</p>

<p>简单分析可以得到八皇后问题的直观解法：对于全体候选解的集合A，其中每个解元素x满足条件函数p，即(x ∈ A) ∧ p(x)，则：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>repeat Generate the next element of A and call it x
</span><span class='line'>until p(x) ∨ (no more elements in A);
</span><span class='line'>if p(x) then x = solution</span></code></pre></td></tr></table></div></figure>


<p>由排列组合知识可知，集合A的空间可达2<sup>32</sup>，枚举算法效率较低。通过对问题进一步的分析，使用回溯法解决该问题的算法效率较高，即：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>j := l;
</span><span class='line'>repeat trystep j;
</span><span class='line'>if successful then advance else regress
</span><span class='line'>until (j &lt; 1) ∨ (j &gt; n) </span></code></pre></td></tr></table></div></figure>


<p>以上述程序分析结果为基础构建程序，按照回溯算法的基本思想，首先依照specification给出初步实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>variable board, pointer, safe;
</span><span class='line'>considerfirstcolumn;
</span><span class='line'>repeat trycolumn;
</span><span class='line'>  if safe then
</span><span class='line'>  begin setqueen; considernextcolumn
</span><span class='line'>  end else regress
</span><span class='line'>until lastcoldone ∨ regressoutoffirstcol</span></code></pre></td></tr></table></div></figure>


<p>根据现有结构化编程语言的表达能力，对如下指令进一步分解：</p>

<p>trycolumn:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure trycolumn;
</span><span class='line'>repeat advancepointer; testsquare
</span><span class='line'>until safe ∨ lastsquare </span></code></pre></td></tr></table></div></figure>


<p>regress:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure regress;
</span><span class='line'>begin reconsiderpriorcolumn
</span><span class='line'>  if ¬ regressoutoffirstcol then
</span><span class='line'>  begin removequeen;
</span><span class='line'>      if lastsquare then
</span><span class='line'>      begin reconsiderpriorcolumn;
</span><span class='line'>          if ¬ regressoutoffirstcol then
</span><span class='line'>              removequeen
</span><span class='line'>      end
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>截至目前，如需对上述程序中的指令做进一步分解，就需要设计额外的数据表示了。通过分析待分解语句，可知需要设计一个记录每位皇后位置的数据表示，例如使用二维数组表达棋盘上的每个方块。这里给出一个优化的数据表示方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>integer j (0 ≤ j ≤ 9)
</span><span class='line'>integer array x[1:8] (0 ≤ x[i] ≤ 8) </span></code></pre></td></tr></table></div></figure>


<p>其中j表示当前被检查的列序号，一维数组x用于存储上一次被检查方块的坐标，程序的部分指令可以被进一步细化为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure considerfirstcolumn;
</span><span class='line'>  begin j := 1; x[1] := 0 end
</span><span class='line'>procedure considernextcolumn;
</span><span class='line'>  begin j := j + 1; x[j] := 0 end
</span><span class='line'>procedure reconsidetpriorcolumn; j := j - 1
</span><span class='line'>procedure advancepointer;
</span><span class='line'>  x[j] := x[j] + 1
</span><span class='line'>Boolean procedure lastsquare;
</span><span class='line'>  lastsquare := x[j] = 8
</span><span class='line'>Boolean procedure lastcoldone;
</span><span class='line'>  lastcoldone := j &gt; 8
</span><span class='line'>Boolean procedure regressoutoffirstcol;
</span><span class='line'>  regressoutoffirstcol := j &lt; 1 </span></code></pre></td></tr></table></div></figure>


<p>接下来考虑剩余指令testsquare、setqueen和removequeen。</p>

<p>指令testsqaure需要验证是否满足问题条件，通过已知的x数组应不难通过计算进行判定，问题是可能导致较高的计算量，同时考虑到testsquare的调用频次较高，这里采用额外数据表示进行优化，设计三个Boolean型数组，其意义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a[k] = true : no queen is positioned in row k
</span><span class='line'>b[k] = true : no queen is positioned in the /-diagonal k
</span><span class='line'>c[k] = true : no queen is positioned in the \-diagonal k </span></code></pre></td></tr></table></div></figure>


<p>那么testsquare就可以用简单的布尔运算表示，其余指令也可以通过上述结构完成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure testsquare;
</span><span class='line'>  safe := a[x[j]] ∧ b[j+x[j]] ∧ c[j-x[j]]
</span><span class='line'>procedure setqueen;
</span><span class='line'>  a[x[j]] := b[j+x[j]] := x[j-x[j]] := false
</span><span class='line'>procedure removequeen;
</span><span class='line'>  a[x[j]] := b[j+x[j]] := c[j-x[j]] := true </span></code></pre></td></tr></table></div></figure>


<p>此时发现上述实现的x[j]调用次数过多，为了进一步优化，把x[j]用变量i表示，从而有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure testsquare;
</span><span class='line'>  safe := a[i] ∧ b[i+j] ∧ c[i-j]]
</span><span class='line'>procedure setqueen;
</span><span class='line'>  a[i] := b[i+j] := c[i-j] := false
</span><span class='line'>procedure removequeen;
</span><span class='line'>  a[i] := b[i÷j] := c[i-j] := true
</span><span class='line'>procedure considerflrstcolumn ;
</span><span class='line'>  begin j:= 1; i:= 0 end
</span><span class='line'>procedure advancepointer; i := i + l
</span><span class='line'>procedure considernextcolumn
</span><span class='line'>  begin x[j] := i; j:=j+l; i := 0 end
</span><span class='line'>Boolean procedure lastsquare;
</span><span class='line'>  lastsquare := i = 8 </span></code></pre></td></tr></table></div></figure>


<p>通过inline替换程序中的部分指令，其余采用过程调用，从而最终实现如下程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>j := 1; i := 0;
</span><span class='line'>repeat
</span><span class='line'>  repeat i := i + 1 ; testsquare
</span><span class='line'>  until safe ∨ (i = 8);
</span><span class='line'>  if safe then
</span><span class='line'>  begin setqueen; x[j] := i; j := j + 1; i := 0
</span><span class='line'>  end else regress
</span><span class='line'>until (j &gt; 8) ∨ (j &lt; 1);
</span><span class='line'>if i &gt; 8 then PRINT(x) else FAILURE </span></code></pre></td></tr></table></div></figure>


<p>前述过程清晰解释了逐步求精这种非常经典的结构化程序的分析和设计过程，从早期分析确定适用算法，然后利用基本的结构化编程元素描述初步程序，对复杂过程进一步分解，同时考虑额外必要的数据表示和程序运行效率优化，最终使用目标编程语言实现程序。这是一种具有普遍适用意义的编程方法论，也呼应了Wirth的那句名言：程序=算法+数据结构。</p>

<h2>结论</h2>

<p>50年前的软件危机所揭露的问题成为今天软件工程研究的基石。GOTO语句的争论直至今天，从历史发展看，更多人选择支持Dijkstra的GOTO有害论，许多90年代以后出现的编程语言并没有在应用层面设计GOTO语句。但是，GOTO争论背后有关编程语言灵活和统一的争辩还远未结束。另一方面，结构化编程促成了一套良好的编程方法论，迄今Wirth的逐步求精方法还被采用于程序设计课程，为计算机教育的普及和广泛应用打下了坚实基础。同时，软件设计所要解决的问题也得以提升到更高的复杂度水平。</p>

<h2>引用</h2>

<p>NATO68, <a href="http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF">NATO Software Engineering Conference</a></p>

<p>Bohm66, <a href="http://www.cs.unibo.it/~martini/PP/bohm-jac.pdf">Flow Diagrams, Turing Machines and Languages with Only Two Formation Rules</a></p>

<p>EWD68, <a href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF">Go-to statement considered harmful</a></p>

<p>EWD70, <a href="https://pure.tue.nl/ws/files/2408738/252825.pdf">Notes on structured programming</a></p>

<p>NW71, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.119.8111&amp;rep=rep1&amp;type=pdf">Program Development by Stepwise Refinement</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(1)]]></title>
    <link href="http://www.hanyi.name/blog/2018/09/24/software-design-and-architecture-notes/"/>
    <updated>2018-09-24T11:57:34-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/09/24/software-design-and-architecture-notes</id>
    <content type="html"><![CDATA[<p><strong><em>《软件设计与架构笔记》系列，是笔者对自上世纪60年代末至今在工业界和学术界皆有一定影响的软件设计方法的学习和记录，期望通过历史的时间轴把握相关技术发展的脉络，尝试理解推动了这一领域中概念、方法、原则、模式、实践不断演进的若干基本动机，倚靠巨人的肩膀，但求一条少些人云亦云的实践之路。</em></strong></p>

<p>自诞生之日起，软件设计就同时在工业界和学术界探索和实践着，然而二者的动机和方法大相径庭。例如计算机科学家Edsger W. Dijkstra，一生就致力于对计算的简洁性和精确性的探索，其工作背后蕴含了严谨的数学美学；而工业界则侧重于使用由计算衍生的自动化方法解决传统生产的问题，根本目的是追求经济利益的最大化。有趣的是，二者的偶然交汇就迸发出这一系列文章的主题——软件设计，而软件架构——作为稍晚出现的buzz word，有时也被本文采用以和行业用语保持一致。</p>

<h2>THE Multiprogramming system：早期探索</h2>

<p>1965年，Dijkstra在埃因霍温科技大学领导了一支团队在Electrologica(EL) X8上开发多道程序系统，该系统的主要目标是能够平滑地处理持续的用户程序流，并将其作为服务提供给学校。该系统的设计目标是：1.降低短程序运行的周转时间； 2.更经济地使用外设; 3.结合后备存储器的自动控制和中央处理器的经济使用; 4.验证一种经济可行性，即将EL X8用于运行在不依赖容量和计算能力，仅需要通用计算机灵活性的应用程序。</p>

<p>出于多道程序系统的<strong>复杂性</strong>，实时触发中断的偶然性和不可复现性使系统开发的debug面临挑战。为此，团队决定在系统构建之初就重视对debug能力的设计，从而在具体实现前就能证明系统的逻辑可靠性，并显著降低了实际bug数量。在论文EWD68中，为了提高<strong>可测试性</strong>，设计者采用层级结构划分整个系统，并以不同的职责区分系统层级：</p>

<p>0级，负责把逻辑可用的进程分配给处理器。为了防止任何进程独占处理器，该层实现了一个实时时钟中断功能。</p>

<p>1级，实现“段控制器”，通过中断与上层的顺序进程保持同步，负责从自动后备存储器中记录数据。</p>

<p>2级，实现“消息解释器”，负责在控制键盘的输入时产生中断，并且联接系统对话的操作员和特定的目标进程。</p>

<p>3级，实现与输入流缓冲和输出流解缓冲相关的顺序进程，通过逻辑通信单元实现对具体外设的抽象，并按照资源限制采用同步方法限制外设运行的数量。</p>

<p>4级，实现独立用户程序。</p>

<p>根据上述层级划分，团队制定了需求规格说明书，并依此实现系统。在验证阶段，在添加下一层级前，需要对前一层进行充分测试，例如针对0级中实现的实时中断和处理器分配，首先设计一个完整的测试状态空间，然后依次进行测试。而当对1级的“段控制器”进行测试时，可以在0级时制定的测试状态空间的基础上，通过引入“请求页”操作，实现状态空间的扩展，只需引入少量新的测试就可以满足当前层的测试需求，直至完成整个系统。</p>

<p>Dijkstra认为，虽然在概念和设计阶段花费了较长时间，但是该过程为系统贡献了良好的设计，避免传统非层级实现可能面临的测试状态空间“爆炸”问题，从而对系统质量提供保证。</p>

<p>虽然缺少定量的研究方法，发布于1968年的THE Multiprogramming System可以说是首次定性地证明了<strong>结构</strong>在软件设计中的重要作用，并且以系统的可测试性为例进行了深入阐释。</p>

<h2>结论</h2>

<p>系统的复杂性引出了软件设计问题。Dijkstra把软件开发过程划分成三个阶段：概念、构建和验证，并且由一个基于层级划分的设计案例指出结构因素在软件设计中的重要性。虽然工业界可能面临更多的问题（例如成本、人员、规模、业务复杂程度等），但是概念阶段产出的良好设计，能使验证阶段受益，从而实现整体的系统质量保证（笔者注：某种程度上也起到控制成本的作用），是THE多道程序系统的一项重要结论，也启发后人对软件概念阶段本身和其边际效应的进一步研究。</p>

<p>值得一提的是，按照不同职责划分层级，底层能够对上层隐藏其核心概念和具体实现，例如0级隐藏了处理器操作，1级隐藏了“页存储”机制，2级隐藏了电传打印控制台等。但是“信息隐藏”作为一个基本设计概念被明确提出，则是若干年以后了。</p>

<h2>引用</h2>

<p>[EWD68] EW Dijkstra, <a href="http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD196.PDF">The structure of the &lsquo;THE&rsquo;-multiprogramming system.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Working with Legacy Engineering]]></title>
    <link href="http://www.hanyi.name/blog/2018/08/23/working-with-legacy-engineering/"/>
    <updated>2018-08-23T15:04:57-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/08/23/working-with-legacy-engineering</id>
    <content type="html"><![CDATA[<p>Looking back to the past five years, my common experience for joining a project is always looking like this:</p>

<p>Learning business knowledge -> Revealing technical context -> Launching a new project and instilling good practices into the team to make better software as usual.</p>

<p>While it&rsquo;s not always true for software engineers, I rarely got chance to work on the pre-existing codebase, not to mention a whole legacy engineering.</p>

<p>Things have changed since I stepped on a new journey. My very first challenge is taking over a legacy engineering. I call it legacy engineering because all I have to care is far more than only the codebase, although it is absolutely focal to tackle with the legacy code. The rest of this article will introduce the steps and thoughts I&rsquo;ve taken during this process.</p>

<h3>Communication</h3>

<p>A good teacher can at least half the work. Everyone who ever worked in the team can teach and benefit, but the following question is how to learn from people more effectively. My answer is no doubt through good communication.</p>

<p>For those who are interested, I would suggest some great learnings like <a href="https://www.nonviolentcommunication.com/">Nonviolent Communication</a> and <a href="https://www.amazon.com/Crucial-Conversations-Talking-Stakes-Second/dp/1469266822">Crucial Conversations</a>. No follow-up discussion since we&rsquo;re not talking about psychology here, but remember it&rsquo;s indeed the first priority soft skill as a professional.</p>

<h3>Documentation</h3>

<p>For a hand-over stage, documentation in any form is less effective than a good communication. But it&rsquo;s worthy to keep valuable knowledge and make it more efficient to spread those to broader stakeholders. Again, it always depends on requirement at the moment for determining the scope of what should be documented. My personal inclination is several topics listed as follows:</p>

<ol>
<li>Team specific knowledge that everyone should be aware of.</li>
<li>Any confusing/complicated part.</li>
<li>The reason for counter-intuitive decisions made by former team members.</li>
</ol>


<p>It finally leads to three basic documents for me:</p>

<ol>
<li>Feature list (Rough is good).</li>
<li>Team engineering practice, like workflow definition and release cycle.</li>
<li>Crucial code design.</li>
</ol>


<p>Of course, the Evernote in hand to prepare for any unknown technologies and skills.</p>

<h3>Codebase</h3>

<p>Being familiar with codebase is always the top priority for a newbie, but former topics we just discussed would influence the effectiveness of codebase learning. As software engineering today has adopted many common practices like CI/CD and DevOps, those automation practices can help to    guide people along with the code or script, rather than outdated document and lengthy tutorial.</p>

<h4>Build (Pipeline)</h4>

<p>Build automation is the most matured practice in nowadays software engineering. For a newbie, the build script provides panorama and coarse-grained view of system modularity and dependency, it would be even clearer if the team is maintaining an effective CI pipeline.</p>

<p>A undoubted fact is that the more matured for build automation, the more efficiency for a newbie to get first wave things done. Otherwise, it would take weeks to set up a local environment by referring to  an far outdated guide and consulting different team members!</p>

<h4>Test</h4>

<p>It&rsquo;s not very common to see &ldquo;effective tests&rdquo; in the codebase, not to mention the practice of the whole test pyramid or <a href="http://www.hanyi.name/blog/2017/12/17/owl-exploratory-testing/">sandwich</a>. Automation test is a proven practice to assure quality, sometimes it is promoted to be the specification of the codebase. However, bad practice for automation test also does harm other than keeping high quality.</p>

<p>For a newbie, in most cases, the tests especially the  bad tests cannot help for specification at all, it shows less value than a good naming practice. My personal experience is that the test is not so good for early learning if it&rsquo;s not well organized and properly implemented. That&rsquo;s not saying that it doesn&rsquo;t play vital role to indicate the consistency when any changes happen.</p>

<p>It&rsquo;s usually easy for everyone to see the value of automation test, while it also  makes this practice be one of the most confusing parts in modern software engineering as  lack of deep understanding.</p>

<h4>Operation</h4>

<p>As DevOps is more adopted, it turns to be more necessary for a newbie to understand operation knowledge. Must-have topics include configuration management and specification of cloud platform and core systems.</p>

<h4>Design (Structural) and Refactor</h4>

<p>The core of codebase learning is about design. A design could be regarded as a collection of decisions along the software development. For a newbie, it&rsquo;s more important to concentrate on the crucial design points than knowing every corners.</p>

<p>Although it varies for the different roles, as a backend newbie, the top concern comes into the structural design. To learn software structure,a  good starting point could be any selected feature from both business and technical perspective, it can help dive into the deeper codebase to understand the structure, then forms into whole picture of modularity design.</p>

<p>A good approach is to elaborate design with some tools, CRC even Naked CRC is agiler, but UML is also very cool and common, it again depends on team background for these tools selection. More important is that whichever tool is used, only the leading design rules need to be considered, rather than drawing a full system map. During this process, design pattern may benefit but also cause restriction.</p>

<p>It&rsquo;s not exactly same for design of software structure and logical data model, but the latter could also be learned via any cleaner ways (like E-R diagram), not necessary to dig into physical data model too early unless there is significant reason to do that.</p>

<h3>Feature Enhancement</h3>

<p>I wouldn&rsquo;t suggest making big change or refactor on the legacy codebase which is just taken over unless the change is too small to cause any visible influence. Before doing any work alone, a newbie still needs to learn from core team members about:</p>

<ol>
<li>Architecture Roadmap.</li>
<li>Non-functional requirements.</li>
<li>Technical debts and roadmap of resolution.</li>
</ol>


<p>Despite the  following work would be feature enhancement in most cases. I&rsquo;d take different strategy depends on the potential influence of the change.</p>

<p>Here I&rsquo;m not going to discuss the case of a tiny change, that wouldn&rsquo;t be a big deal anyway. But if the change is going to happen on the higher level design rule but not touch leading yet (which usually implies a broader influence across code), I could try to add new features via extensional way (rather than editing as is code and making feature changes directly, methods metioned in <a href="https://www.amazon.com/Working-Effectively-Legacy-Robert-Martin-ebook/dp/B005OYHF0A">Working effectively with legacy code</a> are good guidance), and extra feature toggles may help for QA and CD.</p>

<p>The worst case is the desired change must happen on leading design rule, which means it won&rsquo;t work with just simple extension, a big change is definitely required. Even in this case, I wouldn&rsquo;t edit any as is code in an early stage, and purely technical refactor without guidance from business requirement is also not a good option. Instead, I&rsquo;d create a separate package or namespace as the neighbor of the code which is going to die, and naming it &ldquo;experiment&rdquo; or anything makes sense. Using least effort to make experiment code work as well as automation test, without breaking any as is feature or code. Once new feature and refactor direction is confirmed, the experiment code can be transformed into formal and replace dead one.</p>

<p>The benefit of this &ldquo;experimental duplication&rdquo; is that I can continue looking at two implementations and making a trade-off when thinking of the design for following refactor until the new feature is completed and confirmed. Later on, refactor and clean-up can be done to completely remove the deprecation.</p>

<h3>Conclusion</h3>

<p>In this article, we discussed the strategies I would take while working with legacy engineering. Someone calls it reverse engineering to imply the   digestion for an incredibly overdue but complicated legacy codebase or engineering. While in most cases it does not have to make upfront &ldquo;reverse engineering&rdquo; to reach critical decision for future, nor do a hasty change on codebase to cause risk. We can certainly take actions to delay that decision making, by mitigating waste and respecting the economic model of our beloved software industry.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试三明治和雪鸮探索测试]]></title>
    <link href="http://www.hanyi.name/blog/2017/12/17/owl-exploratory-testing/"/>
    <updated>2017-12-17T16:12:58+08:00</updated>
    <id>http://www.hanyi.name/blog/2017/12/17/owl-exploratory-testing</id>
    <content type="html"><![CDATA[<p>测试金字塔理论被广泛应用于计划和实施敏捷软件开发所倡导的的测试自动化，并且取得了令人瞩目的成就。本文尝试从产品开发的角度出发，结合Kent Beck最近提出的3X模型和近年来迅速发展的自动化测试技术，提出并讨论一种新的测试层级动态平衡观：<strong>三明治模型</strong>。同时，为了应对端到端测试在实践中面临的种种挑战，设计并实现了一种面向用户旅程的端到端自动化测试框架——<strong>雪鸮</strong>。实际项目经验表明，雪鸮能够显著提升端到端测试的可维护性，减少不确定性影响，帮助开发人员更快定位和修复问题，对特定时期的产品开发活动更具吸引力。</p>

<h2>背景</h2>

<h3>测试金字塔</h3>

<p>按照自动化测试的层级，从下至上依次为<strong>单元测试</strong>、<strong>集成测试</strong>和<strong>端到端测试</strong>，尽量保持数量较多的低层单元测试，以及相对较少的高层端到端测试，这就是<strong>测试金字塔理论</strong>。随着敏捷软件开发的日益普及，测试金字塔逐渐为人所知，进而得到广泛应用。<a href="https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid">Mike Cohn</a>、<a href="https://martinfowler.com/bliki/TestPyramid.html">Martin Fowler</a>以及<a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html">Mike Wacker</a>等先后对测试金字塔进行了很好的诠释和发展，其主要观点如下：</p>

<ul>
<li>测试层级越高，运行效率就越低，进而延缓持续交付的构建-反馈循环。</li>
<li>测试层级越高，开发复杂度就越高，如果团队能力受限，交付进度就会受到影响。</li>
<li>端到端测试更容易遇到测试结果的不确定性问题，按照Martin Fowler的说法，这种结果不确定性的测试毫无意义。</li>
<li>测试层级越低，测试的代码隔离性越强，越能帮助开发人员快速定位和修复问题。</li>
</ul>


<h3>3X模型</h3>

<p>2016年起，敏捷和TDD先驱Kent Beck开始在个人facebook主页撰写<a href="https://www.facebook.com/notes/kent-beck/comparing-explore-expand-and-extract-topics-in-3x/1241983035834558">系列文章</a>，阐述产品开发的三个阶段——Explore、Expand和Extract，以及在不同阶段中产品与工程实践之间的关系问题，即<strong>3X模型</strong>。近二十年软硬件技术的飞速发展，使得软件开发活动面临敏捷早期从未遇到的市场变革，而根据在facebook工作的经历，Kent Beck把产品开发总结为三个阶段：</p>

<ul>
<li><strong>探索（Explore）</strong>，此时的产品开发仍处于非常初期的阶段，仍然需要花费大量时间寻找产品和市场的适配点，收益也是最低的阶段。</li>
<li><strong>扩张（Expand）</strong>，一旦产品拥有助推器（通常意味着已经找到了市场的适配点），市场需求就会呈现指数级上升，产品本身也需要具备足够的伸缩性以满足这些需求，由此收益也会快速上升。</li>
<li><strong>提取（Extract）</strong>，当位于该阶段时，公司通常希望最大化产品收益。但此时收益的增幅会小于扩张阶段。</li>
</ul>


<p><img src="http://content.hanyi.name/images/owl_exploratory_testing/3x.png" alt="3X" /></p>

<p>Kent Beck<a href="http://redgreenrepeat.com/2016/11/18/kent-beck-3x-and-software-tests/">认为</a>，如果以产品是否成功作为衡量依据，那么引入自动化测试在探索阶段的作用就不大，甚至会延缓产品接受市场反馈循环的速度，对产品的最终成功毫无用处，还不如不引入；当位于扩张阶段时，市场一方面要求产品更高的伸缩性，另一方面也开始要求产品保证一致的行为（例如质量需求），那么此时就该引入自动化测试来保证产品的行为一致性；当产品最终处于提取阶段时，任何改动都应以不牺牲现有行为为前提，否则由此引发的损失可能远高于改动带来的收益，此时自动化测试就扮演了非常重要的角色。</p>

<h3>测试工具爆炸式增长和综合技能学习曲线陡升</h3>

<p>根据<a href="http://www.softwareqatest.com/">SoftwareQATest</a>网站的历史数据，2010年记录的测试工具有440个，共划分为12个大类。这个数字到2017年已经变为560个，共15个大类，且其中有340个在2010年之后才出现。也就是说，平均每年就有50个新的测试工具诞生。</p>

<p>面对测试工具的爆炸式增长，一方面所支持的测试类型更加完善，更加有利于在产品开发过程中保证产品的一致性；另一方面也导致针对多种测试工具组合的综合技能学习曲线不断上升。在实践中，团队也往往对如何定义相关测试的覆盖范围感到不知所措，难以真正发挥测试工具的效用，也很难对产品最终成功作出应有的贡献。</p>

<h2>从金字塔到三明治</h2>

<p>作为敏捷在特定时期的产物，测试金字塔并不失其合理性，甚至还对自动化测试起到了重要推广作用。但是，随着行业整体技术能力的不断提升，市场需求和竞争日趋激烈，在项目中具体实施测试金字塔时往往遭遇困难，即便借助外力强推，其质量和效果也难以度量。</p>

<p>此外，随着软件设计和开发技术的不断发展，低层单元测试的<a href="https://martinfowler.com/articles/mocksArentStubs.html">传统测试技术</a>和落地，因前、后端技术栈的多样化而大相径庭；同时，在经历过<a href="https://stackoverflow.com/questions/90002/what-is-a-reasonable-code-coverage-for-unit-tests-and-why">覆盖率之争</a>，如何确保单元测试的规范和有效，也成为工程质量管理的一大挑战；高层的端到端测试则基本不受技术栈频繁更替的影响，随着不同载体上driver类技术的不断成熟，其开发复杂度反而逐渐降低。</p>

<p>这里讨论一种新的测试层级分配策略，我们称之为<strong>三明治模型</strong> 。如下图所示，该模型允许对不同测试层级的占比进行动态调整，说明了倒金字塔形、沙漏形以及金字塔形分配对特定产品开发阶段的积极作用。</p>

<p><img src="http://content.hanyi.name/images/owl_exploratory_testing/sandwich.png" alt="Sandwich" /></p>

<h3>产品开发的自动化测试策略</h3>

<p>根据3X模型，在探索初期往往选择避开自动化测试。一旦进入扩张期，产品的可伸缩性和行为一致性就成为共同目标，但此时也常会发生大的代码重构甚至重写，如果沿用测试金字塔，无论补充缺失的单元测试，还是只对新模块写单元测试，都既损害了产品的快速伸缩能力，也无法保证面向用户的产品行为一致性。因此，如果在探索后期先引入高层的端到端测试，覆盖主要用户旅程，那么扩张期内所产生的一系列改动都能够受到端到端测试的保障。</p>

<p>需要注意的是，用户旅程在产品即将结束探索期时通常会趋于稳定，在扩张期出现颠覆性变化的概率会逐渐减少，端到端测试的增长率会逐步下降。</p>

<p>除此以外，随着扩张期内不断产生的模块重构和服务化，团队还应增加单元测试和集成测试的占比。其中，单元测试应确保覆盖分支场景（可以在CI中引入基于模块的覆盖率检测）；集成测试和某些团队实践的验收测试，则需进一步覆盖集成条件和验收条件（在story sign-off和code review时验收）。</p>

<p>许多新兴的测试技术和工具擅长各自场景下的验收测试，但更重要的仍是识别产品阶段和当前需求，以满足收益最大化。</p>

<p><img src="http://content.hanyi.name/images/owl_exploratory_testing/sandwich-3x.png" alt="Sandwich-3x" /></p>

<p>由此我们认为，随着产品开发的演进，测试层级的分配应参考三明治模型，动态调整层级占比，更加重视运营和市场反馈，致力于真正帮助产品走向成功。</p>

<h3>端到端测试的机遇和挑战</h3>

<p>与其他测试层级相比，端到端测试技术的发展程度相对滞后。一方面，作为其基础的driver工具要在相应载体成熟一段时间之后才能趋于稳定，web、mobile无不如是。另一方面，端到端测试偏向黑盒测试，更加侧重描述用户交互和业务功能，寻求硬核技术突破的难度较高，于是较少受开发人员青睐。但是，由于端到端测试更接近真实用户，其在特定产品开发活动中的性价比较高，有一定的发展潜力。</p>

<p>然而，当前实践中的端到端测试，普遍存在如下问题：</p>

<ul>
<li><strong>低可维护性</strong>。一般实践并不对测试代码质量作特别要求，而这点在端到端测试就体现得更糟。因为其涉及数据、载体、交互、功能、参照（oracle）等远比单元测试复杂的<a href="https://martinfowler.com/bliki/BroadStackTest.html">broad stack</a>。虽然也有<a href="https://www.thoughtworks.com/insights/blog/using-page-objects-overcome-protractors-shortcomings">Page Object</a>等模式的广泛应用，但仍难以应对快速变化。</li>
<li><strong>低运行效率</strong>。如果拿单次端到端测试与单元测试相比，前者的运行效率肯定更低。因此只一味增加端到端测试肯定会损害构建-反馈循环，进而影响持续交付。</li>
<li><strong>高不确定性</strong>。同样因为broad stack的问题，端到端测试有更高的几率产生不确定测试，表现为测试结果呈随机性成功／失败，进一步降低运行效率，使得真正的问题很容易被掩盖，团队也逐渐丧失对端到端测试的信心。</li>
<li><strong>难以定位问题根因</strong>。端到端测试结果很难触及代码级别的错误，这就需要额外人工恢复测试环境并尝试进行问题重现。其中所涉及的数据重建、用户交互等会耗费可观的成本。</li>
</ul>


<h2>方法</h2>

<p>为了解决传统端到端测试遇到的种种挑战，本文设计了一种面向用户旅程的端到端自动化测试框架——<strong>雪鸮（snowy_owl）</strong>，通过用户旅程优先、数据分离、业务复用和状态持久化等方法，显著提高了端到端测试的可维护性，降低不确定性的影响，并且能够帮助团队成员快速定位问题。</p>

<h3>用户旅程驱动</h3>

<p>端到端测试应尽量贴近用户，从用户旅程出发能保证这一点。在雪鸮中，用户旅程使用被称作play books的若干yaml格式的文件进行组织，例如下列目录结构：</p>

<pre><code>play_books/
  core_journey.yml
  external_integration.yml
  online_payment.yml
</code></pre>

<p>其中每个play book由若干plots所组成，plot用于表示用户旅程中的“情节”单位，其基本特征如下：</p>

<ul>
<li>单一plot可以作为端到端测试独立运行，例如发送一条tweet的情节：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SnowyOwl</span><span class="o">::</span><span class="no">Plots</span><span class="o">.</span><span class="n">write</span> <span class="s1">&#39;send a plain text tweet&#39;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">visit</span> <span class="s1">&#39;/login&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;username&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;password&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Sign In&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already login?</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Home&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already on home page?</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;Hello World&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Send&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already sent?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>单一plot应是紧密关联的一组用户交互，并且具备体现一个较小业务价值的测试参照。</li>
<li>plot可以被play book引用任意次从而组成用户旅程，play book同时定义了所引用plots之间的顺序关系，基本语法如下所示：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">---</span>
</span><span class='line'><span class="o">-</span> <span class="ss">plot_name</span><span class="p">:</span> <span class="nb">send</span> <span class="n">a</span> <span class="n">plain</span> <span class="n">text</span> <span class="n">tweet</span>
</span><span class='line'>  <span class="ss">digest</span><span class="p">:</span> <span class="mi">2</span><span class="n">aae6c35c94fcfb415dbe95f408b9ce91ee846ed</span>
</span><span class='line'>  <span class="ss">parent</span><span class="p">:</span> <span class="n">d6b0d82cea4269b51572b8fab43adcee9fc3cf9a</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中plot_name表示情节的标题，digest和parent分别表示当前情节引用在整个端到端测试过程中的唯一标识和前序情节标识，初期开发人员可以通过各个情节的引用顺序定义用户旅程，大多数情况下digest和parent将由系统自动生成并维护。</p>

<p>整个play books集合将是一个以plots为基础组成的森林结构，而端到端测试的执行顺序则是针对其中每棵树进行深度遍历。</p>

<h3>通用业务复用</h3>

<p>由于plot本身必须是一个独立可运行的端到端测试，那么plots之间通常会共享一部分交互操作，例如用户登录。雪鸮允许把高度可复用的交互代码进行二次抽取，称作determination：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SnowyOwl</span><span class="o">::</span><span class="no">Determinations</span><span class="o">.</span><span class="n">determine</span><span class="p">(</span><span class="s1">&#39;user login&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="p">,</span> <span class="n">user_profile</span><span class="o">|</span>
</span><span class='line'>  <span class="c1"># return if already login</span>
</span><span class='line'>  <span class="n">visit</span> <span class="s1">&#39;/login&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="n">user_profile</span><span class="o">[</span><span class="ss">:username</span><span class="o">]</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="n">user_profile</span><span class="o">[</span><span class="ss">:password</span><span class="o">]</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Sign In&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already login?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，plot的代码就可以简化成:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SnowyOwl</span><span class="o">::</span><span class="no">Plots</span><span class="o">.</span><span class="n">write</span> <span class="s1">&#39;send a plain text tweet&#39;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">determine_user_login</span><span class="p">({</span><span class="ss">username</span><span class="p">:</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="ss">password</span><span class="p">:</span> <span class="s1">&#39;password&#39;</span><span class="p">})</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Home&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already on home page?</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;Hello World&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Send&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already sent?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里应注意Determination和Page Object的区别。看似使用Page Object可以达到相同的目的，但是后者与Page这一概念强绑定。而Determination更加侧重描述业务本身，更符合对用户旅程的描述，因此比Page Object在plot中更具适用性。当然，在描述更低层的组件交互时，Page Object仍然是最佳选择。</p>

<h3>测试数据分离</h3>

<p>合理的数据设计对描绘用户旅程非常重要，雪鸮对测试逻辑和数据进行了进一步分离。例如用户基本数据（profile），同样是使用yaml文件进行表示：</p>

<pre><code>data/
  tweets/
    plain_text.yml
  users/
    plain_user.yml
</code></pre>

<p>那么在plot的实现中，就可以使用同名对象方法替代字面值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SnowyOwl</span><span class="o">::</span><span class="no">Plots</span><span class="o">.</span><span class="n">write</span> <span class="s1">&#39;send a plain text tweet&#39;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">determine_user_login</span><span class="p">({</span><span class="ss">username</span><span class="p">:</span> <span class="n">plain_user</span><span class="o">.</span><span class="n">username</span><span class="p">,</span> <span class="ss">password</span><span class="p">:</span> <span class="n">plain_user</span><span class="o">.</span><span class="n">password</span><span class="p">})</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Home&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already on home page?</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="n">plain_text</span><span class="o">.</span><span class="n">value</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Send&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already sent?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>情节状态持久化</h3>

<p>雪鸮的另一个重要功能是情节状态的持久化和场景复原。为了启用情节状态持久化，开发人员需要自己实现一个持久化脚本，例如对当前数据库进行dump，并按照雪鸮提供的持久化接口把dump文件存储至指定位置。</p>

<p>当端到端测试运行每进入一个新的情节之前，系统会自动执行持久化脚本。也就是说，雪鸮支持保存每个情节的前置运行状态。</p>

<p>当端到端测试需要从特定的情节重新开始运行时，雪鸮同样会提供一个恢复接口，通过用户自定义的数据恢复脚本把指定位置的dump文件恢复至当前系统。</p>

<p>该功能有两处消费场景：</p>

<ul>
<li>由于broad stack的问题，端到端测试不确定性的技术因素一般较为复杂。实际经验表明，测试的随机失败率越低，就越难以定位和修复问题，而通过不断改进测试代码的方式消除这种不确定性的成本较高，效果也不好。但是，可以尽量消除不确定性带来的影响。例如，不确定测试导致的测试失败，通常会导致额外人工验证时间，完全可以选择让系统自动重试失败的测试。另一方面，重试会造成测试运行效率降低，特别是针对端到端测试。当一轮端到端测试结束后，雪鸮只会自动重试失败的情节测试，同时利用该情节对应的数据dump文件保证场景一致性，这就减少了重试整个端到端测试带来的运行效率下降问题。</li>
<li>当团队成员发现端到端测试失败，通常需要在本地复现该问题。而借助测试dump文件，可以直接运行指定plot测试，从而避免额外的人工设置数据和交互操作，加快问题定位和解决。</li>
</ul>


<h2>实践</h2>

<p>雪鸮在笔者所在的项目有超过6个月的应用时间。该项目在产品开发方面长期陷入困境，例如过程中同时兼具了3X每个阶段的特点，不仅缺少清晰的产品主线，还背负了接棒遗留系统的包袱。这种状况对工程质量管理提出了更大挑战。</p>

<p>项目采用雪鸮对已有端到端测试进行了重构，生成了一个核心用户旅程和三个涉及外部系统集成的重要用户旅程，包含24个plots，9个determinations，使端到端测试实现了长期稳定运行。在本地相同软硬件环境下，不确定性导致的随机失败从原有10%降低至1%以内，部署至云环境并采用headless模式后，连续15天测试失败记录为零，运行效率的损失可以忽略不计。同时，当用户旅程产生新分支时，可以引入新的情节测试节点，并且根据业务需求将其加入现有play book树，从而实现端到端测试的快速维护。</p>

<h3>持续集成与常态化运行</h3>

<p>项目完整的端到端测试的平均运行时间保持在19分钟左右，为了不影响现有持续集成节奏，CI每30分钟自动更新代码并运行端到端测试，结果在dashboard同步显示，一旦发生测试失败，第一优先级查找失败原因并尝试在本地复现和修复。</p>

<p>常态化运行端到端测试的另一个好处是，能够以低成本的方式实现24小时监控系统各个组件的功能正确性，有助于更早发现问题：一次，产品即将上线的支付功能发生异常，查看CI记录发现端到端测试在晚上9:15左右出现了首次告警。通过及时沟通，确认是海外团队在当时擅自改动了支付网关的一个配置，造成服务不可用的问题，并迅速得以解决。</p>

<h2>结论与展望</h2>

<p>Kent Beck的3X模型，提出了从不同产品开发阶段看待工程实践的新视角。而敏捷一贯推崇的TDD等实践，更多体现在个人技术专长（Expertise）方面，与产品是否成功并无必然联系。然而，程序员的专业主义（Professionalism）的确同时涵盖了技术专长和产品成功两个方面，二者相辅相成。因此，如何通过平衡众多因素并最终提高整体专业性，这才是软件工程面临的经典问题。本文给出的测试三明治模型，目的就是帮助思考产品开发过程中测试层级间的平衡问题。</p>

<p>为了应对现有端到端测试面临的挑战，本文设计并实现了一种新的面向用户旅程的端到端测试框架，通过职责隔离、业务复用和状态持久化等手段，构建了易于维护且更加有效的端到端测试。同时，基于上述方法构建的测试代码，更易于和自动化测试的其他研究领域相结合，在诸如测试数据构建、用例生成、随机测试和测试参照增强等方向有进一步的应用潜力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微情境混合现实]]></title>
    <link href="http://www.hanyi.name/blog/2016/11/20/micro-situational-mixed-reality/"/>
    <updated>2016-11-20T13:37:28+08:00</updated>
    <id>http://www.hanyi.name/blog/2016/11/20/micro-situational-mixed-reality</id>
    <content type="html"><![CDATA[<p><em>从前有一池清潭，在附近的居民眼里它和普通池塘并没有什么区别。某天一位富绅来到池边，搬起一块巨石砸进了池中心，泛起的沉渣顿时把池水变成了浊潭。富绅见人就说，突然变浑浊的潭水里其实是出土了宝藏，价值万贯。消息传开，好奇的人们不远万里赶到潭边，有的确实想发笔横财，有的只是为了观光。富绅自己则在潭边围起一段栅栏，向来访者销售门票，不日累积万贯。不久，别处的清潭都变浊了。</em></p>

<p>近年火爆的VR/AR在大众眼中是“黑科技”，其实早在50年前(<a href="https://www.youtube.com/watch?v=ISJWZpFIAlQ">The Sword of Damocles，1965</a>)就被人玩剩了，他的创作者是图形学界祖师之一Ivan Sutherland。但可能是发现自己已经走得太远（实际上当时现代图形学基础还没有完全确立），于是萨大爷就带着他一票学生和下属回去后方铺路，后者们先后发明了Smalltalk编程语言、Gouraud着色算法、图形反走样算法，创办创意设计巨头Adobe以及高性能计算鼻祖SGI，甚至还联合乔帮主创办了Pixar（现任Pixar/Disney动画总裁的Edwin Catmull也是图形学巨擘，发明了灰常实用的Catmull-Rom样条函数，直到现在还被用于关键帧插值和<a href="http://www.cemyuksel.com/research/catmullrom_param/">渲染头发丝</a>）。</p>

<p>有意思的是，VR/AR在理论上的研究早已从感知器官上升到哲学范畴&hellip;&hellip;多年来在实践上却仍然停留在科技馆和特殊行业应用领域。最终，geek们期待的科技大跃进并没有真正到来，尘埃褪去，呈现的却是更加亲民的头显（HMD）和各种奇思妙想的控制器（Controller），无不体现着以人为本的时代理念。而如果你能尝试SteamVR上的应用、特别是体验下Proto奖的获奖作品时，你会欣慰地发现，原来真正有梦想、有创造力的人还在不断涌现，你就会从各种捞钱、炫富的纸金现实中暂时解脱出来了。</p>

<p>如果避开硬科幻，从终极关怀的角度审视VR/AR，我们所处时代的主题原来并非“黑科技”，而是“低门槛”和“大众化”。这里，本文提出一种特定场景下的混合现实产品思路，最后以一个真实的开源Demo为例，希望能为许多有想法的人打开一扇窗，鼓励更多人能参与到这一领域中来。</p>

<p><img src="http://content.hanyi.name/images/c22/full.jpg" alt="C22-Full" /></p>

<h4>为什么是特定场景？</h4>

<p>门槛是首要考虑因素。以Daydream为例，在如今诸多VR/AR平台中，Daydream的优势是非常易见的：它太容易接近大众了。对于其它竞品平台，则更多聚焦在高端和行业应用上，不利于小团队做快速原型开发和内容创新（就是说只适合憋大招）。</p>

<p>而Daydream的劣势目前也很明显：3-DOF的控制器无法捕捉用户的全身动作，反馈缺失导致了沉浸感不足（Vive的这一优势在市面上目前还无人匹敌）；另外，移动设备受限的性能、参差不齐的规格也导致潜在的用户体验问题，这恐怕也是Google率先携Pixel发布的初衷。</p>

<p>因此在设计VR/AR产品时，需要首先考虑平台对应用场景的限制。</p>

<h4>微情境（Micro-Situation）</h4>

<p>理论上说，VR/AR技术几乎可以被用于任何情境。基于现实考量，在“微情境”中实现的性价比则更高。</p>

<p>例如<strong>非厨师职业学习做饭</strong>，传统上可能是一对一的学徒体系；后来发展成书籍报刊、电视传播。前者属于文字模式更多得靠个人天赋，后者的声音＋图像模式就更容易被大众所接受。</p>

<p>但有人可能会质疑为什么不真的去尝试做一顿饭？其实这相当于混淆了学习和实践两种活动，“学做饭”和“做饭”本身不是一回事（当然你也可以说在实践中学习，但你也不能证明你是在完全未经过学习的情况下做了一顿饭，况且如果真的是这样，那么满足各位食客的可能性恐怕微乎其微）。</p>

<p>再来看“虚拟学做饭”这一活动的价值，最大的劣势就是你无法从外观之外获得任何的有效反馈，包括直接吃掉自己的学习成果。而优势是节省钱、食材、时间，切身经历每一道工序，这是现有的学习形式都不具备的。</p>

<p>从这一情境本身来说，用户只需要一间整洁的厨房，摆放整齐的食材和调味品，再加上面前一座灶台即可。而交互内容仅需要双手参与。那么即将进入寻常百姓家的Daydream平台完全满足需求，于是皆大欢喜。</p>

<p>其实这里需要考虑的重点在“微”上，什么样的情境才算是“微情境”呢？我们不尝试进一步去做更多的文字游戏，对于“微情境”的发现要更多依赖对情境本身、以及对VR/AR技术的理解和运用，这也是不可避免的过程。</p>

<p>这里再延伸到一个稍“大”一些的微情境：<strong>产品说明书</strong>。</p>

<p>相信大家对各式各样的产品说明书都不陌生，但从现实的生活经验来看，在大多数情况下，要么产品自身完全做到了自说明，要么很难快速（或者根本无法）从说明书中找到自己需要的答案。多年来，尽管平面设计不断进步，多媒体新招层出不穷，也很难断言一个真正有效的用户-产品沟通方式，而VR/AR的普及将为此带来全新的维度。</p>

<p>例如你网购了一套书柜，然而需要自己动手安装，原本自信满满的你花了很长时间，终于无奈地瘫坐在沉甸甸的零件旁，边满头大汗地研究起貌似手绘的安装说明&hellip;&hellip;在当前情境中，家具的零件都可以被虚拟化，用户也不需要真的在场景中走来走去，而是直接上手了解零件功能和安装步骤即可——可以想见，当平台越廉价，“微情境”中的VR/AR应用所带来的附加价值就会越高（例如直接嵌入产品官网Web，并借助移动设备进行VR/AR显示，具体实现请参考文末Demo）。</p>

<p>或许，人们会在不久之后的春晚上体验到VR/AR抢红包之类的全民娱乐呢？</p>

<h4>为什么是混合现实（MR）？</h4>

<p>在这波VR行情之前，就有许多AR应用运行在智能手机上，此外还包括不久前的google glass，却始终没有杀手级应用出现（酝酿多年也才蹦出一只Pokemon Go&hellip;）。原因甚多，其中市场太小、远离大众是一个非常重要的因素。难道VR就没有市场的疑问？否则巨头们为何集体押注在后者身上？由此可猜想投资VR的回报率明显要更高一筹，却万不能沉迷于只做游客。</p>

<p>值得一提的是Hololens展示了当前无与伦比的MR技术，无奈距离大众太过遥远，注定只会面向专业领域。实际上基于现有的VR设备要想直接实现接近Hololens的MR并不困难，毕竟只需要一个透明显示和空间位置标定，如果要做进一步的场景感知会稍复杂（但也已经不是壁垒），不过由此发展的成本肯定比一步到位要低许多。</p>

<p>（这里不得不说句题外话，平台大战可以造就繁荣的假象，但也可能扰乱了内容创造者们的思想，从而延缓技术的最终普及，这种风险在当前看来是不可避免的）</p>

<p>然而如果单纯比拼想象力，MR更胜VR/AR，虽然前者只是模糊了后者之间的界限。在接受程度上，人们总会倾向于那些更加抽象、简洁且表现力更强的形式，MR无疑将会最终胜出。</p>

<p>真正的困难之处在于，MR不仅仅在于两幅人眼画面的结合，也意味着更加复杂的应用场景，以及更具挑战的交互模式，而不是一个看起来更高级的HMD。</p>

<h4>来自22世纪的程序员（C22）</h4>

<p><a href="https://github.com/hanystudy/coder-from-22nd-century">C22</a>是一个基于传统PC+Cardboard的微情境应用。它展示了未来的程序员，能够摆脱固定显示器的束缚，使用HMD、键鼠就可以编写代码，并且在自身环境周围展示各种信息的技术。</p>

<p><img src="http://content.hanyi.name/images/c22/right.png" alt="C22-Right" /></p>

<p>如上图所示，PC中的应用信息被独立传送至HMD中创建的每个虚拟屏幕上，程序员可以在三维场景中浏览各种信息。</p>

<p>除了信息浏览外，C22允许程序员在盲打的情况下使用键盘、鼠标在对应的应用上进行操作，并且能够实时同步。</p>

<p>由于当前C22无法显示在一块透明质的HMD上（类似Hololens），因此也无法真正让普通用户感受到在现实中操作应用。此外由于分辨率的限制，C22目前能实现的用户体验也比较<a href="https://github.com/hanystudy/coder-from-22nd-century#resolution">受限</a>。</p>

<p><img src="http://content.hanyi.name/images/c22/left.png" alt="C22-Left" /></p>

<p>为了快速实现产品原型，C22全部使用JavaScript编写，并且采用了许多尚未广泛兼容的技术（详见<a href="https://github.com/hanystudy/coder-from-22nd-century">项目github主页</a>），由此带来的好处是核心部分搭建只用了两个晚上的时间，后期为了提高体验可能会进一步扩展当前技术栈。</p>

<p>同样由于兼容问题，C22目前只支持Android设备，并计划在<a href="http://www.roadtovr.com/googles-josh-carpenter-bringing-webvr-daydream-2017/">2017年第一季度支持Daydream</a>，届时，用户可以在周围自由设置信息布局。并且由于WebVR将得到浏览器原生支持，C22的渲染能力也将得到显著提升。</p>

<p>2015年举行的<a href="https://www.protoawards.com/">Proto颁奖大会</a>上，年近八旬的萨大爷<a href="https://www.youtube.com/watch?v=R2BfcKxpB8U">获虚拟现实“创始人奖”</a>，大神激励台下一帮天才后辈说：“内容意味着一切，摄像机（指技术）并不创造内容，只有最伟大的创造者才得以使用技术把现实带给人们”。</p>

<p>闻者深受共鸣。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - extensions]]></title>
    <link href="http://www.hanyi.name/blog/2015/11/03/metaprogramming-ruby-core-concepts-extensions/"/>
    <updated>2015-11-03T16:08:28+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/11/03/metaprogramming-ruby-core-concepts-extensions</id>
    <content type="html"><![CDATA[<p>As we already know, ruby provides several ways to extend our classes and objects including but not limit to OO inheritance, Module mix-in, Dynamic Methods, Monkey patching / Refinement, Eval family, Ghost methods, Callable objects, Singleton classes / methods, etc. But there are still some important tips deserve to be mentioned, before we moving forward.</p>

<h3>1. Include vs Extend</h3>

<p>Firstly let’s see an example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">foo</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello world&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello world&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Foo</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Bar</span><span class="o">.</span><span class="n">foo</span> <span class="c1">#NoMethodError: undefined method `foo&#39; for Bar:Class</span>
</span><span class='line'><span class="no">Bar</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">say_hi</span> <span class="c1">#Hello world</span>
</span></code></pre></td></tr></table></div></figure>


<p>It seems that module mix-in can only involve instance methods but not others like class methods. But how to do similar thing at class level? You must hear about extend:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello world&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">Foo</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Bar</span><span class="o">.</span><span class="n">foo</span> <span class="c1">#Hello world</span>
</span></code></pre></td></tr></table></div></figure>


<p>Extend is used in object level, so we are sure it can also be used for any class in ruby. But in previous article, we know that class method is actually saved as a singleton method of the original class, also instance method of its singleton class. So that should also happen on include:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello world&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'>  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">Foo</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Bar</span><span class="o">.</span><span class="n">foo</span> <span class="c1">#Hello world</span>
</span></code></pre></td></tr></table></div></figure>


<p>Thus we can regard extend as a kind of special usage on include through above examples.</p>

<h3>2. Method wrappers</h3>

<p>Method wrapper means wrapping an existing method inside a new method, which is very useful when you want to make extension without changing the source, like code in standard library or other cases.</p>

<p>There are several ways to implement method wrappers in ruby, and they are all in composite form of primitives which’ve already been introduced in previous articles. We’ll go through below.</p>

<h4>Around Alias</h4>

<p>Module#alias_method (also the key word ‘alias’) is used to give another name to ruby methods. It will involve more accessibility if an usual method could have different domain names(e.g. size, length and count). Also more flexibilities if you want, like code below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="n">alias_method</span> <span class="ss">:say_hello</span><span class="p">,</span> <span class="ss">:say_hi</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="n">say_hello</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;World&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">say_hi</span> <span class="c1">#Hello\nWorld\n</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is just a kind of wrapper using open class, alias_method, and method redefinition.</p>

<h4>Refinement</h4>

<p>We talked about refinement and suggested using refine instead of monkey patch. Actually refinement is even more powerful than that.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">FooRefinement</span>
</span><span class='line'>  <span class="n">refine</span> <span class="no">Foo</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>      <span class="k">super</span>
</span><span class='line'>      <span class="nb">p</span> <span class="s1">&#39;World&#39;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">using</span> <span class="no">FooRefinement</span>
</span><span class='line'>
</span><span class='line'><span class="no">Foo</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">say_hi</span> <span class="c1">#Hello\nWorld\n</span>
</span></code></pre></td></tr></table></div></figure>


<p>Only thing you need to notice is that the key word ‘using’ may not work well with your IRB environment, which means you couldn’t get result in mind for some versions of ruby if you run those code in IRB. See more information <a href="https://bugs.ruby-lang.org/issues/9580">here</a>.</p>

<p>The benefit of refinement wrapper is controllable scope of wrapper unlike around alias which affects globally. However, accessibility to original method is also lower than alias way.</p>

<h4>Prepending</h4>

<p>Module#prepend is the simplest way to implement method wrapper without scope configurability like refinement. But much more clear than other two.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">FooPrepending</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="k">super</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;World&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Foo</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">prepend</span> <span class="no">FooPrepending</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Foo</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">say_hi</span> <span class="c1">#Hello\nWorld\n</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. Class Macros</h3>

<p>Ruby objects have no attributes - May this won’t surprise or confuse you too much. Indeed we’ve hear about instance variables or class variables, but you can not access them directly from outside. That means getter or writer can not be avoided:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">bar</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@bar</span> <span class="o">=</span> <span class="n">value</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">bar</span>
</span><span class='line'>    <span class="vi">@bar</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="c1">#Hello</span>
</span></code></pre></td></tr></table></div></figure>


<p>It’s just not ruby style! Ruby provides series accessors for class definition using metaprogramming api, like attr_accessor, attr_reader and attr_writer, they are quite intuitive to use:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="kp">attr_accessor</span> <span class="ss">:bar</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="c1">#Hello</span>
</span></code></pre></td></tr></table></div></figure>


<p>attr_* come from Module as private instance methods, thus they all can be used in module or class definitions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - eval family II]]></title>
    <link href="http://www.hanyi.name/blog/2015/09/16/metaprogramming-ruby-core-concepts-eval-family-ii/"/>
    <updated>2015-09-16T09:20:27+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/09/16/metaprogramming-ruby-core-concepts-eval-family-ii</id>
    <content type="html"><![CDATA[<p>In previous article several basic scope controlling tools are introduced, like block, proc, lambda, and method object. All of them should work well when you organize them in your code reasonably. There are more flexible way to mix code and bindings in ruby - eval, which may not be used broadly than others, so that considerable traps about it are still unclear for us.</p>

<h3>3. instance_eval / instance_exec</h3>

<p>BasicObject#instance_eval can be used almost everywhere in ruby, you can use it like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="vi">@bar</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span> <span class="p">}</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">instance_variable_get</span><span class="p">(</span><span class="s1">&#39;@bar&#39;</span><span class="p">)</span> <span class="c1">#hello</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the block of instance_eval, the scope changes to the instance foo, thus any operations inner it should bind to the instance, except closure variables.</p>

<p>BasicObject#instance_exec has similar feature to eval one, but with arguments support. This benefit shows as below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span>
</span><span class='line'>    <span class="vi">@bar</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;world&#39;</span>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">instance_exec</span><span class="p">(</span><span class="n">output</span><span class="p">){</span><span class="o">|</span><span class="n">output</span><span class="o">|</span> <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@bar</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
</span><span class='line'><span class="n">output</span> <span class="c1">#world</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4. class_eval / class_exec</h3>

<p>Module#class_eval works for evaluating a block in the context of an existing class. It seems to be similar to instance_eval which will have scope changes to instance self, but also changes current class (excluding singleton class).</p>

<p>class_eval can be used to open a existing class, without using keyword ‘class’. That means it has no scope changing issue compared with keyword way. Actually it even does not need to know the constant name of the target, while keyword way indeed needs.</p>

<p>Also Module#class_exec plays same role like instance_exec for instance_eval.</p>

<p>Think about the thing what we’ve discussed several weeks ago, in ruby all items are instance of class, including classes no matter internal or customized. Which means instance_eval and class_eval both can work for classes in many cases, but indeed have different self meaning.</p>

<p>You may also notice that there is also Module#module_eval / Module#module_exec methods, but they are just alias for class_eval / class_exec without any other changes.</p>

<h3>5. Kernel#eval</h3>

<p>Unlike instance_eval/class_eval, Kernel#eval only accept a string of ruby code as its argument, run the code and give the result. Even it’s so powerful, using string of code is not a good choice if you have other ways. The most issue for string of code is security.</p>

<p>Suppose you have eval expression in your code, which means others can evaluate any code using such method, including get/set operations. Ruby defines safe levels, which actually limits the evaluation of code from outside. By default, ruby will mark potentially unsafe objects which many come from external sources. And user could config a global variable $SAFE, it’s range from 0 to 3(0 by default) with more strict.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vg">$SAFE</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="nb">eval</span> <span class="s2">&quot;p &#39;hello </span><span class="si">#{</span><span class="nb">gets</span><span class="p">()</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
</span><span class='line'><span class="n">world</span> <span class="c1">#SecurityError: Insecure operation - eval</span>
</span></code></pre></td></tr></table></div></figure>


<p>By default, eval can accept almost any code from outside. However, it will not be permitted for code from I/O device(tainted object) if $SAFE is none zero. Below gives more details about $SAFE:</p>

<table>
<thead>
<tr>
<th>$SAFE</th>
<th style="text-align:center;"> Constraints</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center;">No checking of the use of externally supplied (tainted) data is performed. This is Ruby’s default mode.</td>
</tr>
<tr>
<td>>= 1</td>
<td style="text-align:center;">Ruby disallows the use of tainted data by potentially dangerous operations.</td>
</tr>
<tr>
<td>>= 2</td>
<td style="text-align:center;">Ruby prohibits the loading of program files from globally writable locations.</td>
</tr>
<tr>
<td>>= 3</td>
<td style="text-align:center;">All newly created objects are considered tainted.</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - eval family I]]></title>
    <link href="http://www.hanyi.name/blog/2015/09/14/metaprogramming-ruby-core-concepts-eval-family/"/>
    <updated>2015-09-14T23:08:19+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/09/14/metaprogramming-ruby-core-concepts-eval-family</id>
    <content type="html"><![CDATA[<p>In ruby, block is the cornerstone of metaprogramming with a surprisingly powerful scope controlling capability. Based on this definition, much brilliant interfaces are introduced, and help to implement many valuable features, like callable objects, eval and its huge family.</p>

<h3>1. blocks</h3>

<p>Block represents a snippet of code, it permits to be called immediately or lately depends on different cases. But compared with some similar concepts in functional programming languages, like Lisp, block still has more limits, and more readability respectively.</p>

<p>In commonly, block can be used like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">show_hello</span>
</span><span class='line'>  <span class="k">yield</span> <span class="s1">&#39;hello&#39;</span> <span class="k">if</span> <span class="nb">block_given?</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">show_hello</span> <span class="p">{</span> <span class="o">|</span><span class="n">say</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">say</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">show_hello</span> <span class="k">do</span> <span class="o">|</span><span class="n">say</span><span class="o">|</span>
</span><span class='line'>  <span class="n">file</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;/tmp/output.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">file</span><span class="o">.</span><span class="n">write</span> <span class="n">say</span>
</span><span class='line'>  <span class="n">file</span><span class="o">.</span><span class="n">close</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>&lsquo;yield&rsquo; is a ruby keyword used to call blocks sent to the current method. block_given? is an instance method from Kernel to probe whether there is a block for current method.</p>

<p>One of the most useful aspect of block is closure, it captures bindings where it&rsquo;s defined, and avoid impact of scope changing by connecting to those bindings, like flat scopes, and shared scopes.</p>

<p>Frankly speaking, block is actually not responsible for running code, but only representation (Except yield, which indeed means running code immediately). There are more powerful tools to help enhance block usage.</p>

<h3>2. callable objects</h3>

<p>Block is just like a package of code, and you need to use yield to execute it if you like. However, there are more ways to package code in ruby, including Proc and lambda.</p>

<h4>Proc</h4>

<p>We already know that block is not an object in ruby which is really quite a few, but Proc is basically a block turned object, can be seen as a consistent form of block, and you do not have to use yield to run it immediately, it will be running later as you want (Deferred Evaluation). you can define a Proc like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">inc</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'><span class="n">inc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#2</span>
</span><span class='line'><span class="n">dec</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'><span class="n">inc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#1</span>
</span></code></pre></td></tr></table></div></figure>


<h4>lambda</h4>

<p>Except for Proc, lambda can also be used for transferring blocks, but with simpler and a little different way:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">inc</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'><span class="n">inc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#2</span>
</span><span class='line'><span class="n">dec</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'><span class="n">dec</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#1</span>
</span></code></pre></td></tr></table></div></figure>


<h4>&amp; operator</h4>

<p>Once you have defined a block for a method, there is a way to convert it to a Proc inner method by using &amp;. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">bar</span>
</span><span class='line'>  <span class="k">yield</span> <span class="s1">&#39;ruby&#39;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">operation</span><span class="p">)</span>
</span><span class='line'>  <span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">operation</span><span class="p">)</span>
</span><span class='line'>  <span class="n">operation</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="s2">&quot;hello </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
</span><span class='line'><span class="c1"># hello ruby</span>
</span><span class='line'><span class="c1"># hello world</span>
</span></code></pre></td></tr></table></div></figure>


<p>&amp; can be seen like transferring a block into Proc, but you need to remove &amp; if you want to use it as a Proc.</p>

<h4>Comparison between procs and lambdas</h4>

<p>You may notice that lambda is also a Proc, but you can still use Proc#lambda? to see the actual type of the target. Besides there are two important differences: keyword &lsquo;return&rsquo; and arguments checking.</p>

<h5>a. return</h5>

<p>As plain blocks, the program will return out of scope where block defined if return statement is set inner block, so does Proc (which may mean that the return may cause exception when the block is called in nonreturnable scope, like top-level). While for lambda, the return only runs out of block, not even farther.</p>

<h5>b. arity</h5>

<p>Arity means the number of arguments. In real case, lambda has less tolerance than Proc, which means that lambda requires correct number of arity, which is no need for procs.</p>

<h4>Method objects</h4>

<p>All methods are objects of Method. You can use Kernel#method or Kernel#singleton_method to get the object of method, then use Method#call to run the method. Also you may use Method#to_proc and define_method to convert method and proc to each other. Eventhough the method still has scope of it&rsquo;s defined.</p>

<h5>Unbound Methods</h5>

<p>Method object can also be unbound from original scopes by using Method#unbind, or Module#instance_method. Generated UnboundMethod object can not be called directly, but you can still call it after bind it to another scope by using UnboundMethod#bind. The only notice is that UnboundMethod object can only be bound to same class or sub if it&rsquo;s from class, and no such limitation when it&rsquo;s from module.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - open classes &amp; refinements]]></title>
    <link href="http://www.hanyi.name/blog/2015/09/08/metaprogramming-ruby-core-concepts-open-classes-and-refinements/"/>
    <updated>2015-09-08T22:40:23+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/09/08/metaprogramming-ruby-core-concepts-open-classes-and-refinements</id>
    <content type="html"><![CDATA[<h3>Opening Classes</h3>

<p>Opening classes brings much flexibility for ruby. It permits you to modify existed classes or modules permanently, without having to implement whole world in case you just need to give a simple patch for current tool. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">String</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">to_alphanumeric</span>
</span><span class='line'>    <span class="nb">gsub</span><span class="p">(</span><span class="sr">/[^\w\s]/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>to_alphanumeric is new interface to return only alpha and numeric part of a string. However, opening class may not work well, especially it&rsquo;s commonly dangerous to opening a frequently used target which would cause unexpected error in code. Due to this reason someone calls opening classes monkey patch and just leaves far from this feature.</p>

<p>While whatever, monkey patch continues conciseness in ruby, sometimes you are able to save your life gracefully with such powerful tool, except the trap behind it.</p>

<h3>Refinements</h3>

<p>From ruby 2.0, there is a more advanced form of monkey patch which is called refinements. Refinements are providing a way to extend classes only under specific scope, but not including modules. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">C</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;C#foo&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">M</span>
</span><span class='line'>  <span class="n">refine</span> <span class="n">C</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;C#foo in M&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Module#refine creates an anonymous module that contains the changes or refinements to the class (C in the example). self in the refine block is this anonymous module similar to Module#module_eval.</p>

<h4>Scope</h4>

<p>We use using to activate refinements defined in any places, but you may only activate refinements at top-level, not inside any class, module or method scope. You may activate refinements in a string passed to Kernel#eval that is evaluated at top-level. Refinements are active until the end of the file or the end of the eval string, respectively.</p>

<p>Refinements are lexical in scope. When control is transferred outside the scope the refinement is deactivated. This means that when you require or load a file or call a method that is defined outside the current scope the refinement will be deactivated.</p>

<p>If a method is defined in a scope where a refinement is active the refinement will be active when the method is called.</p>

<p>When defining multiple refinements in the same module, inside a refine block all refinements from the same module are active when a refined method is called.</p>

<p>You may also activate refinements in a class or module definition, in which case the refinements are activated from the point where using is called to the end of the class or module definition.</p>

<h4>Method lookup under refinement</h4>

<p>When looking up a method for an instance of class C Ruby checks:</p>

<h5>1. If refinements are active for C, in the reverse order they were activated:</h5>

<p>  The prepended modules from the refinement for C</p>

<p>  The refinement for C</p>

<p>  The included modules from the refinement for C</p>

<h5>2. The prepended modules of C</h5>

<h5>3. C</h5>

<h5>4. The included modules of C</h5>

<p>If no method was found at any point this repeats with the superclass of C.</p>

<p>Note that methods in a subclass have priority over refinements in a superclass. For example, if the method / is defined in a refinement for Integer 1 / 2 invokes the original Fixnum#/ because Fixnum is a subclass of Integer and is searched before the refinements for the superclass Integer.</p>

<p>If a method foo is defined on Integer in a refinement, 1.foo invokes that method since foo does not exist on Fixnum.</p>

<h4>Super</h4>

<p>When super is invoked method lookup checks:</p>

<h5>The included modules of the current class. Note that the current class may be a refinement.</h5>

<h5>If the current class is a refinement, the method lookup proceeds as in the Method Lookup section above.</h5>

<h5>If the current class has a direct superclass, the method proceeds as in the Method Lookup section above using the superclass.</h5>

<p>Note that super in a method of a refinement invokes the method in the refined class even if there is another refinement which has been activated in the same context.</p>

<h4>Refinements and module inclusion</h4>

<p>Refinements are inherited by module inclusion. That is, using activates all refinements in the ancestors of the specified module. Refinements in a descendant have priority over refinements in an ancestor.</p>

<p>After all, refinement is still an experiment feature in ruby 2.x series, there is a detailed <a href="https://bugs.ruby-lang.org/projects/ruby-trunk/wiki/RefinementsSpec">specification</a> in official website, which should cover most aspect of it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - scope &amp; self]]></title>
    <link href="http://www.hanyi.name/blog/2015/09/08/metaprogramming-ruby-core-concepts-scope-and-self/"/>
    <updated>2015-09-08T13:47:47+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/09/08/metaprogramming-ruby-core-concepts-scope-and-self</id>
    <content type="html"><![CDATA[<p>Scope defines the circumstance around any ruby statement, which basically limits your accessibility to resources. But ruby also has implicit and complicate Constants/Methods lookup strategy to make things not so easy at all. This article will clarify the concepts about scope and self firstly, then deep into the Constants/Methods lookup strategy. Finally, let&rsquo;s try to understand top-level which may be the most special case in this topic.</p>

<h3>1. Scope</h3>

<p>In most cases, the &lsquo;Scope&rsquo; we say in ruby commonly refers to variable scope, which has a little bit different from other popular languages. For example, there are four basic variable scopes including local, global, instance and class level, none of them has business with each other. We&rsquo;ve already know the naming specification below:</p>

<table>
<thead>
<tr>
<th style="text-align:center;">Name begins with</th>
<th style="text-align:center;">Variable scope</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">[a-z] or _</td>
<td style="text-align:center;">local variable   </td>
</tr>
<tr>
<td style="text-align:center;">$         </td>
<td style="text-align:center;">global variable  </td>
</tr>
<tr>
<td style="text-align:center;">@         </td>
<td style="text-align:center;">instance variable</td>
</tr>
<tr>
<td style="text-align:center;">@@        </td>
<td style="text-align:center;">class variable   </td>
</tr>
</tbody>
</table>


<p>Actually the tricky is not naming, it&rsquo;s about default scope changing. As we know that ruby has lexical scope, but not like others, it does not support nested scope, like inner scope shares outer scope in some languages. Each of four variable scopes in above figure is purely independent to each other.</p>

<h4>message &amp; scope resolution operator</h4>

<p>Dot . is message operator in ruby, mainly used for message receiving, like method call. Double colon :: is scope resolution operator, commonly used for getting constant in specific scope, Like Foo::Bar, means searching ./foo/bar with relative path. If Foo is undefined in current scope, you should always use ::Foo::Bar to figure it out using absolute path.</p>

<h4>scope changing</h4>

<p>There are four basic cases which may create and change the scope lexically: Class definitions (class), Module definitions (module), Methods (def) and Blocks. Block scope is a little bit different from others and more interesting, which would create its own scope after the block defined, but also have closure capability, like code below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span><span class='line'><span class="n">bar</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;hi&#39;</span> <span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="s1">&#39;hello&#39;</span> <span class="p">}</span>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
</span><span class='line'><span class="n">bar</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'><span class="n">foo</span> <span class="c1">#hi</span>
</span></code></pre></td></tr></table></div></figure>


<p>For sure we can break this very easily:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span><span class='line'><span class="n">bar</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="p">;</span><span class="n">foo</span><span class="o">|</span> <span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;hi&#39;</span> <span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="s1">&#39;hello&#39;</span> <span class="p">}</span>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
</span><span class='line'><span class="n">bar</span><span class="o">.</span><span class="n">call</span>
</span><span class='line'><span class="n">foo</span> <span class="c1">#hello</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that |;foo| defines foo as a local variable in its block, this kind of feature was introduced from ruby 1.9.</p>

<h4>constants scope</h4>

<p>The scope we&rsquo;ve talked until now basically only means variable scope. In ruby, constant is totally different type of data compared with other languages like C++ or Java, any constant name must be started with uppercase character. And none of them can be assigned dynamically. Like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>  <span class="no">Bar</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
</span><span class='line'><span class="k">end</span> <span class="c1">#should give SyntaxError for dynamic constant assignment</span>
</span></code></pre></td></tr></table></div></figure>


<p>Constants defined within a class or module can be accessed within its parent. And scope operator we talked before should be used when it&rsquo;s outside the class or module. Constants defined outside any class or module are global scope, can be accessed directly or by using the scope operator &lsquo;::&rsquo; with no prefix.</p>

<h3>2. Self</h3>

<p>As we know that the grail in ruby world would be conciseness. However, such conciseness is built on many bright solutions like keyword self.</p>

<p>if you just type a name in ruby console, it will show you an error:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">foo</span> <span class="c1">#NameError: undefined local variable or method `foo&#39; for main:Object</span>
</span></code></pre></td></tr></table></div></figure>


<p>Indeed it has a huge gap between ruby and other languages in such case. But the expression with only name as a statement in ruby really means asking for local variable first, if found nothing then go on for searching method defined by current object. Here &lsquo;main&rsquo; is a special object which represents the top-level, will have more discussion in the last part of this article.</p>

<h4>calling methods</h4>

<p>When you want to call a method, there should always be a receiver pointed to target object. Commonly that would be in this form:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">some_object</span><span class="o">.</span><span class="n">some_method</span>
</span></code></pre></td></tr></table></div></figure>


<p>If some_object is omitted, some_method will be called on the object where the current scope belongs to. self is one of the keywords referring to the current object. Note that private is an exception in this case, we will show an example here which has already been introduced in last several articles talking about private and public.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>  <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="c1">#Hello</span>
</span><span class='line'><span class="nb">self</span><span class="o">.</span><span class="n">foo</span> <span class="c1">#NoMethodError: private method `foo&#39; called for main:Object</span>
</span></code></pre></td></tr></table></div></figure>


<p>The most usage of self would be defining a class method, or getting singleton class of current class.</p>

<h3>3. Method lookup</h3>

<p>The order of name lookup should be local variable/constant, then method. We has discussed about variable and constant scope in the first part. Here let&rsquo;s have a look at method lookup.</p>

<p>When a message call happens, ruby will found its receiver firstly which should be an object. Since all methods are stored in classes and modules so method lookup walks these, not the objects themselves.</p>

<p>Here is the order of method lookup for the receiver’s class or module R:</p>

<h4>i. The prepended modules of R in reverse order.</h4>

<h4>ii. For a matching method in R.</h4>

<h4>iii. The included modules of R in reverse order.</h4>

<p>If R is a class with a superclass, this is repeated with R‘s superclass until a method is found. And once a match is found method lookup stops. If no match is found this repeats from the beginning, but looking for method_missing. The default method_missing is BasicObject#method_missing which raises a NameError when invoked.</p>

<h3>4. Understanding top-level</h3>

<p>May be you&rsquo;re not interested in top-level mechanism as a rails developer (You have to use top-level one day even you&rsquo;re only develop rails application), but you need to notice that ruby is also regarded as a powerful scripting language and already as a built-in tool in many popular OS distributions. We talk about top-level because it behaves different from any ruby official documents.</p>

<p>I&rsquo;ve found a nice explanation about top-level <a href="https://banisterfiend.wordpress.com/2010/11/23/what-is-the-ruby-top-level/">here</a>, but there are some newer update in latest ruby, we&rsquo;ll go through this.</p>

<p>Most of us may know that top-level refers to main, which is an object of Object. You can prove it very easily like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">self</span> <span class="c1">#main</span>
</span><span class='line'><span class="nb">self</span><span class="o">.</span><span class="n">class</span> <span class="c1">#Object</span>
</span></code></pre></td></tr></table></div></figure>


<p>But how about define a top-level method?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>  <span class="s1">&#39;hello&#39;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">foo</span> <span class="c1">#hello</span>
</span><span class='line'><span class="nb">method</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span><span class="o">.</span><span class="n">owner</span> <span class="c1">#Object</span>
</span><span class='line'><span class="no">Object</span><span class="o">.</span><span class="n">private_method_defined?</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span> <span class="c1">#true</span>
</span><span class='line'><span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">private_instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="c1">#[:foo]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Does that look like a class definition? Even for the constant definition:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Foo</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
</span><span class='line'><span class="no">Object</span><span class="o">.</span><span class="n">const_defined?</span><span class="p">(</span><span class="ss">:Foo</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span> <span class="c1">#true</span>
</span></code></pre></td></tr></table></div></figure>


<p>It just looks like you&rsquo;re operating on class Object. Not only for this, we found that there can also use public, private, or include method, they are shadow in singleton_class of main:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">singleton_class</span><span class="o">.</span><span class="n">private_instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="c1">#[:public, :private, :include, :using, :define_method]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Based on our analyst above, we find a strange dual-nature of ruby top-level with some unexpected definitions in main object in purpose. Matz gives a <a href="http://groups.google.com/group/comp.lang.ruby/browse_thread/thread/7bb7b451a8f3cca7/98c4c62127b9d945">explanation</a> about design of top-level. You can also get more discussion <a href="http://stackoverflow.com/questions/1761148/where-are-methods-defined-at-the-ruby-top-level">here</a>. From my view, such unusual design exactly helps conciseness of this language, but also gains our confusion and curiosity.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - Object Oriented Hierarchies]]></title>
    <link href="http://www.hanyi.name/blog/2015/08/29/metaprogramming-ruby-core-concepts-object-oriented-hierarchies/"/>
    <updated>2015-08-29T22:40:06+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/08/29/metaprogramming-ruby-core-concepts-object-oriented-hierarchies</id>
    <content type="html"><![CDATA[<p>Since last several articles, we&rsquo;ve gone through all basic but the most important internal definitions in Ruby lang. They are BasicObject, Object, Module, and Kernel, don&rsquo;t forget Class. The five composite the root of Object Oriented Hierarchies in Ruby world. One of their most useful benefit is incredible metaprogramming ability, which already provides people revolutionary tools like Ruby on Rails. Frankly speaking, the word metaprogramming makes itself too mysterious to be accepted by most people. Conciseness and Expressiveness - are the only purpose of this feature.</p>

<h3>1. Class</h3>

<p>Classes in Ruby are first-class objects, each class in Ruby is an instance of class Class. Typically, you create a new class by using: Class.new. When a new class is created, an object of type Class is initialized and assigned to a global constant (Name in this case). When Name.new is called to create a new object, the new method in Class is run by default. Classes, modules, and objects are interrelated, we will discuss more in next chapter.</p>

<h4>Public Class Methods</h4>

<h5>new</h5>

<p>Creates a new anonymous (unnamed) class with the given superclass (or Object if no parameter is given). You can give a class a name by assigning the class object to a constant. If a block is given, it is passed the class object, and the block is evaluated in the context of this class using class_eval.</p>

<h4>Public Instance Methods</h4>

<h5>allocate</h5>

<p>Allocates space for a new object of class&rsquo;s class and does not call initialize on the new instance. The returned object must be an instance of class.</p>

<h5>new</h5>

<p>Calls allocate to create a new object of class&rsquo;s class, then invokes that object&rsquo;s initialize method, passing it args. This is the method that ends up getting called whenever an object is constructed using .new.</p>

<h5>superclass</h5>

<p>Returns the superclass of class, or nil. Returns nil when the given class does not have a parent class.</p>

<h4>Private Instance Methods</h4>

<h5>inherited</h5>

<p>Callback invoked whenever a subclass of the current class is created.</p>

<h3>2. Hierarchy of Five Kings</h3>

<p>For more clearly, here we give a figure to cover all five items listed in preface. (We also list two guests in this figure to represent custom codes in the hierarchy)</p>

<p><img src="http://content.hanyi.name/images/metaprogramming_ruby/ruby_oo_hierarchy.png" alt="More advance Ruby OO hierarchy" /></p>

<p>From the figure, we can see that class can be completely separated with objects under well design. Ruby uses this kind of hierarchy to implement its internal Object Oriented design. Here we would like to introduce the responsibilities on metaprogramming for each in above figure, and have deeper discussion on Module and Class, which are directly related to custom codes.</p>

<h4>BasicObject</h4>

<p>BasicObject is the root of all objects in Ruby through its subclass Object. The only class method in BasicObject is &lsquo;new&rsquo;, which is used to allocate memory to new object, and do initialization. For the public instance methods, mainly including object_id, send, and instance_eval/instance_exec to provide basic operations on any objects in Ruby. Also, BasicObject figures out the method_missing mechanism, which is very important for Ruby DSL definition, and singleton methods hook — which actually connects classes and objects in Ruby.</p>

<h4>Object</h4>

<p>If any class is defined by using keyword &lsquo;class&rsquo; without other specific inheritance, it should be inherited from Object by default. Object offers the top useful Constants in Ruby world, like ARGV, ENV, RUBY_VERSION, STDIN/STDOUT/STDERR, etc. Also for public instance methods, it provides objects comparison, clone/dup, freezing, and respond_to? checking, etc.</p>

<p>In metaprogramming field, Object mainly focus on instance level usage, like getting class of object, extend, instance_of?, methods, retrieving singleton_class/singleton_methods of object. etc.</p>

<h4>Kernel</h4>

<p>Kernel is very special in the hierarchy, because it&rsquo;s absolutely not class but an object. On the other hand, Kernel is mixed into class Object, making it become the earliest members in the whole hierarchy and also play very important role in the process.</p>

<p>Unlike Object, Constants in Kernel do not refer to some parameters of internal Ruby lang, they&rsquo;re more like an utility or tool kit for subclasses, especially the reference to popular classes. Kernel also plays hard in Process operations(abort, fork, spawn), Source file loading(auto loading, require), Exception(catch, fail, raise, throw), String(chomp, chop, format, gets, gsub, sprintf, sub), Controlling(loop, sleep, rand, srand, trace/untrace), and IO(open, print, put, readlines, select).</p>

<p>Kernel also enhances the metaprogramming, like binding, block_given?, caller, eval, lambda, and proc.</p>

<h3>3. Modules and Classes</h3>

<h4>Module</h4>

<p>Basically, Modules serve two purposes in Ruby: namespacing and mix-in functionality.</p>

<p>A namespace can be used to organize code by package or functionality that separates common names from interference by other packages. Mix-in functionality allows sharing common methods across multiple classes or modules. Ruby comes with the Enumerable mix-in module which provides many enumeration methods based on the each method and Comparable allows comparison of objects based on the &lt;=> comparison method.</p>

<p>A module is created using the module keyword.</p>

<h4>Class</h4>

<p>Every class is also a module, but unlike modules a class may not be mixed-in to another module (or class). Like a module, a class can be used as a namespace. A class also inherits methods and constants from its superclass. Use the class keyword to create a class. Any method defined on a class is callable from its subclass, the same is true for constants. You can override the functionality of a superclass method by redefining the method. If you wish to invoke the superclass functionality from a method use super.</p>

<p>If you do not supply a superclass your new class will inherit from Object. You may inherit from a different class using &lt; followed by a class name.</p>

<p>When used without any arguments super uses the arguments given to the subclass method. To send no arguments to the superclass method use super(). To send specific arguments to the superclass method provide them manually like super(2). super may be called as many times as you like in the subclass method.</p>

<h4>Common properties</h4>

<p>Note that there are many similarities between modules and classes. Besides the ability to mix-in a module, the description of modules also applies to classes.</p>

<h5>Reopening</h5>

<p>Reopening classes is a very powerful feature of Ruby, but it is best to only reopen classes you own. Otherwise it may lead to naming conflicts or difficult to diagnose bugs.</p>

<h5>Nesting</h5>

<p>Modules may be nested.</p>

<h5>Packaging</h5>

<p>Many packages create a single outermost module (or class) to provide a namespace for their functionality. You may also define inner modules using :: provided the outer modules (or classes) are already defined.</p>

<h5>Self</h5>

<p>self refers to the object that defines the current scope. And it will change when entering a different method or when defining a new module.</p>

<h5>Constants</h5>

<p>Accessible constants are different depending on the module nesting (which syntax was used to define the module). if you use :: to define A::B without nesting it inside A a NameError exception will be raised because the nesting does not include A. If a constant is defined at the top-level you may preceded it with :: to reference it.</p>

<h5>Methods</h5>

<p>Class methods may be called directly(This is slightly confusing, but a method on a module is often called a “class method” instead of a “module method”. See also Module#module_function which can convert an instance method into a class method.). When a class method references a constant it uses the same rules as referencing it outside the method as the scope is the same.
Instance methods defined in a module are only callable when included. These methods have access to the constants defined when they were included through the ancestors list.</p>

<h5>Visibility</h5>

<p>Ruby has three types of visibility. The default is public. A public method may be called from any other object.</p>

<p>The second visibility is protected. When calling a protected method the sender must be a subclass of the receiver or the receiver must be a subclass of the sender. Otherwise a NoMethodError will be raised. Protected visibility is most frequently used to define == and other comparison methods where the author does not wish to expose an object&rsquo;s state to any caller and would like to restrict it only to inherited classes.</p>

<p>The third visibility is private. A private method may not be called with a receiver, not even self. If a private method is called with a receiver a NoMethodError will be raised.</p>

<h5>Alias and Undef</h5>

<p>You may also alias or undefine methods, but these operations are not restricted to modules or classes.</p>

<h3>4. Singleton classes</h3>

<p>The singleton class (also known as the metaclass or eigenclass) of an object is a class that holds methods for only that instance. You can access the singleton class of an object using class &lt;&lt; object like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
</span><span class='line'>    <span class="c1"># self is the singleton class here</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="no">Foo</span>
</span><span class='line'>  <span class="c1"># self is the singleton class here</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>This allows definition of methods and attributes on a class (or module) without needing to write def self.my_method.</p>

<p>Since you can open the singleton class of any object this means that this code block:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bar</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nc">bar</span><span class="o">.</span><span class="nf">bar_method</span>
</span><span class='line'>  <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>is equivalent to this code block:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bar</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="n">bar</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">bar_method</span>
</span><span class='line'>    <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Understanding singleton class in ruby is very important to investigate internal ruby, especially for its OO design. In next article, we&rsquo;ll introduce the scope mechanism in ruby.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - Kernel]]></title>
    <link href="http://www.hanyi.name/blog/2015/08/29/metaprogramming-ruby-core-concepts-kernel/"/>
    <updated>2015-08-29T21:57:31+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/08/29/metaprogramming-ruby-core-concepts-kernel</id>
    <content type="html"><![CDATA[<p>The Kernel is the object of Module, thus it has all instance methods from the parent. Also it&rsquo;s available as instance methods in every Ruby object since the Kernel is included by class Object. Kernel has widespread usage including but not limit to internal Constant references, Processes operations, Loading Strategies, Exceptions, Controlling, IO, and Basic string operations. This article will focus on metaprogramming on instance level.</p>

<h3>Kernel</h3>

<p>All Constants and instance methods are public in Kernel, thus they all can be used in any objects as callee.</p>

<h5>binding</h5>

<p>Returns a Binding object, describing the variable and method bindings at the point of call. This object can be used when calling eval to execute the evaluated command in this environment.</p>

<h5>eval</h5>

<p>Evaluates the Ruby expression(s) in string. If the binding is given, which must be a Binding object, the evaluation is performed in its context. If the optional filename and lineno parameters are present, they will be used when reporting syntax errors.</p>

<h5>block_given? / iterator?</h5>

<p>Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated.</p>

<h5>callcc{|cont| block}</h5>

<p>Generates a Continuation object, which it passes to the associated block. You need to require &lsquo;continuation&rsquo; before using this method. Performing a cont.call will cause the callcc to return (as will falling through the end of the block). The value returned by the callcc is the value of the block, or the value passed to cont.call.
In general, Continuation object is used to be analogous to C setjmp/longjmp, or a thread. cont will return itself, and cont.call will jump to end of callcc block.</p>

<h5>caller</h5>

<p>Returns the current execution stack—an array containing strings in the form file:line or file:line: in &lsquo;method&rsquo;. Returns nil if start is greater than the size of current execution stack. Optionally you can pass a range, which will return an array containing the entries within the specified range.</p>

<h5>caller_locations</h5>

<p>Returns the current execution stack—an array containing backtrace location objects. Returns nil if start is greater than the size of current execution stack. Optionally you can pass a range, which will return an array containing the entries within the specified range.</p>

<h5>eval</h5>

<p>Evaluates the Ruby expression(s) in string. If binding is given, which must be a Binding object, the evaluation is performed in its context. If the optional filename and lineno parameters are present, they will be used when reporting syntax errors.</p>

<h5>global_variables</h5>

<p>Lookup global variables.</p>

<h5>lambda</h5>

<p>Equivalent to Proc.new, except the resulting Proc objects check the number of parameters passed when called.</p>

<h5>proc</h5>

<p>Equivalent to Proc.new</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - Module]]></title>
    <link href="http://www.hanyi.name/blog/2015/08/26/metaprogramming-ruby-core-concepts-module/"/>
    <updated>2015-08-26T23:18:08+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/08/26/metaprogramming-ruby-core-concepts-module</id>
    <content type="html"><![CDATA[<p>For internal ruby, Module is mainly used for holding class methods for descendants. Suppose each object has class of A, A always has class of Class, and Class inherits from Module, thus class A should hold all class methods from instance methods in Module. On the other hand, user can mix in self defined Module to provide more instance methods for their class, or use module function directly.</p>

<h3>Module</h3>

<p>Module provides two kinds of class level metaprogramming methods, either public or private. Each of them has different usage for building descendants.</p>

<h4>Public instance methods</h4>

<h5>ancestors</h5>

<p>Returns a list of modules included/prepended in current module.</p>

<h5>class_eval</h5>

<p>Evaluates the string or block in the context of module, except that when a block is given, constant/class variable lookup is not affected. This can be used to add methods to a class. class_eval returns the result of evaluating its argument.</p>

<h5>class_exec</h5>

<p>Evaluates the given block in the context of the class/module. The method defined in the block will belong to the receiver. Any arguments passed to the method will be passed to the block. This can be used if the block needs to access instance variables.</p>

<h5>class_variable_defined?</h5>

<p>Returns true if the given class variable is defined in object.</p>

<h5>class_variable_get</h5>

<p>Returns the value of the given class variable (or throws a NameError exception). The @@ part of the variable name should be included for regular class variables.</p>

<h5>class_variable_set</h5>

<p>Sets the class variable named by symbol to the given object.</p>

<h5>class_variables</h5>

<p>Returns an array of the names of class variables in current module. This includes the names of class variables in any included modules, unless the inherit parameter is set to false.</p>

<h5>const_defined?</h5>

<p>Says whether module or its ancestors have a constant with the given name: If module is a Module, additionally Object and its ancestors are checked. In each of the checked classes or modules, if the constant is not present but there is an autoload for it, true is returned directly without autoloading. If the constant is not found the callback const_missing is not called and the method returns false. If inherit is false, the lookup only checks the constants in the receiver. In this case, the same logic for autoloading applies. If the argument is not a valid constant name a NameError is raised with the message “wrong constant name name”.</p>

<h5>const_get</h5>

<p>Checks for a constant with the given name in module. If inherit is set, the lookup will also search the ancestors (and Object if module is a Module). The value of the constant is returned if a definition is found, otherwise a NameError is raised. This method will recursively look up constant names if a namespaced class name is provided.</p>

<h5>const_missing</h5>

<p>Invoked when a reference is made to an undefined constant in module. It is passed a symbol for the undefined constant, and returns a value to be used for that constant. If found, it returns the loaded class. It therefore implements an autoload feature similar to Kernel#autoload and #autoload.</p>

<h5>const_set</h5>

<p>Sets the named constant to the given object, returning that object. Creates a new constant if no constant with the given name previously existed. If symbol or string is not a valid constant name a NameError will be raised with a warning “wrong constant name”.</p>

<h5>constants</h5>

<p>Returns an array of the names of the constants accessible in module. This includes the names of constants in any included modules, unless the inherit parameter is set to false.</p>

<h5>instance_method</h5>

<p>Returns an UnboundMethod representing the given instance method in module.</p>

<h5>instance_methods</h5>

<p>Returns an array containing the names of the public and protected instance methods in the receiver. For a module, these are the public and protected methods; for a class, they are the instance (not singleton) methods.</p>

<h5>method_defined?</h5>

<p>Returns true if the named method is defined by module (or its included modules and, if module is a class, its ancestors). Public and protected methods are matched. String arguments are converted to symbols.</p>

<h5>module_eval</h5>

<p>Evaluates the string or block in the context of module, except that when a block is given, constant/class variable lookup is not affected. This can be used to add methods to a class. module_eval returns the result of evaluating its argument.</p>

<h5>module_exec</h5>

<p>Evaluates the given block in the context of the class/module. The method defined in the block will belong to the receiver. Any arguments passed to the method will be passed to the block. This can be used if the block needs to access instance variables.</p>

<h5>name</h5>

<p>Returns the name of the module module. Returns nil for anonymous modules.</p>

<h5>prepend</h5>

<p>Invokes Module.prepend_features on each parameter in reverse order.</p>

<h5>private_class_method</h5>

<p>Makes existing class methods private. Often used to hide the default constructor new.</p>

<h5>private_constant</h5>

<p>Makes a list of existing constants private.</p>

<h5>private_instance_methods</h5>

<p>Returns a list of the private instance methods defined in module. If the optional parameter is false, the methods of any ancestors are not included.</p>

<h5>private_method_defined?</h5>

<p>Returns true if the named private method is defined by _mod_ (or its included modules and, if module is a class, its ancestors).</p>

<h5>protected_instance_methods</h5>

<p>Returns a list of the protected instance methods defined in module. If the optional parameter is false, the methods of any ancestors are not included.</p>

<h5>protected_method_defined?</h5>

<p>Returns true if the named protected method is defined by module (or its included modules and, if module is a class, its ancestors).</p>

<h5>public_class_method</h5>

<p>Makes a list of existing class methods public.</p>

<h5>public_constant</h5>

<p>Makes a list of existing constants public.</p>

<h5>public_instance_method</h5>

<p>Similar to instance_method, searches public method only.</p>

<h5>public_instance_methods</h5>

<p>Returns a list of the public instance methods defined in module. If the optional parameter is false, the methods of any ancestors are not included.</p>

<h5>public_method_defined?</h5>

<p>Returns true if the named public method is defined by module (or its included modules and, if module is a class, its ancestors).</p>

<h5>remove_class_variable</h5>

<p>Removes the definition of the symbol, returning that constant&rsquo;s value.</p>

<h5>singleton_class?</h5>

<p>Returns true if module is a singleton class or false if it is an ordinary class or module.</p>

<h4>Private instance methods</h4>

<p>Private instance methods in Module are mainly used in internal classes level.</p>

<h5>alias_method</h5>

<p>Makes new_name a new copy of the method old_name. This can be used to retain access to methods that are overridden.</p>

<h5>append_features</h5>

<p>When this module is included in another, Ruby calls append_features in this module, passing it the receiving module in module. Ruby&rsquo;s default implementation is to add the constants, methods, and module variables of this module to module if this module has not already been added to module or one of its ancestors.</p>

<h5>define_method</h5>

<p>Defines an instance method in the receiver. The method parameter can be a Proc, a Method or an UnboundMethod object. If a block is specified, it is used as the method body. This block is evaluated using instance_eval, a point that is tricky to demonstrate because define_method is private.</p>

<h5>extend_object</h5>

<p>Extends the specified object by adding this module&rsquo;s constants and methods (which are added as singleton methods). This is the callback method used by Object#extend.</p>

<h5>extended</h5>

<p>The equivalent of included, but for extended modules.</p>

<h5>included</h5>

<p>Callback invoked whenever the receiver is included in another module or class. This should be used in preference to Module.append_features if your code wants to perform some action when a module is included in another.</p>

<h5>method_added</h5>

<p>Invoked as a callback whenever an instance method is added to the receiver.</p>

<h5>method_removed</h5>

<p>Invoked as a callback whenever an instance method is removed from the receiver.</p>

<h5>method_undefined</h5>

<p>Invoked as a callback whenever an instance method undefined but called from the receiver.</p>

<h5>module_function</h5>

<p>Creates module functions for the named methods. These functions may be called with the module as a receiver, and also become available as instance methods to classes that mix in the module. Module functions are copies of the original, and so may be changed independently. The instance-method versions are made private. If used with no arguments, subsequently defined methods become module functions. String arguments are converted to symbols.
prepend_features When this module is prepended in another, Ruby calls prepend_features in this module, passing it the receiving module in module. Ruby&rsquo;s default implementation is to overlay the constants, methods, and module variables of this module to mod if this module has not already been added to mod or one of its ancestors. See also Module#prepend.</p>

<h5>prepended</h5>

<p>The equivalent of included, but for prepended modules.</p>

<h5>refine</h5>

<p>Refine klass in the receiver. Returns an overlaid module.</p>

<h5>remove_const</h5>

<p>Removes the definition of the given constant, returning that constant&rsquo;s previous value. If that constant referred to a module, this will not change that module&rsquo;s name and can lead to confusion.
remove_method Removes the method identified by symbol from the current class. For an example, see Module.undef_method.</p>

<h5>undef_method</h5>

<p>Prevents the current class from responding to calls to the named method. Contrast this with remove_method, which deletes the method from the particular class; Ruby will still search superclasses and mixed-in modules for a possible receiver. String arguments are converted to symbols.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - Object]]></title>
    <link href="http://www.hanyi.name/blog/2015/08/21/metaprogramming-ruby-core-concepts-object/"/>
    <updated>2015-08-21T11:24:33+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/08/21/metaprogramming-ruby-core-concepts-object</id>
    <content type="html"><![CDATA[<p>As the default root of all Rubric objects, Object holds quite a lot valuable instance methods for common usage. It mixes in the Kernel module to provide global accessibility of Kernel APIs for all inherited classes. This article will introduce Object definition.</p>

<h3>Object</h3>

<p>Object only holds a few constants and instance methods for objects of descendants, all these methods are only used for instance level metaprogramming.</p>

<h5>class</h5>

<p>Gets class Constant of object.</p>

<h5>define_singleton_method / new_method</h5>

<p>Defines a singleton method in the receiver. The parameters can be a Proc, a Method or an UnboundMethod object. If a block is specified, it is used as the method body.</p>

<h5>extend</h5>

<p>Enhance object with instance methods from modules given as a parameter.</p>

<h5>instance_of?</h5>

<p>Check if obj is an instance of the given class(Except ancestors).</p>

<h5>instance_variable_defined?</h5>

<p>Check if the given instance variable is defined in obj.</p>

<h5>instance_variable_get</h5>

<p>Gets the value of the given instance variable, or nil if the instance variable is not set. Just note that the @ part of the variable name should be included for regular instance variables.</p>

<h5>instance_variable_set</h5>

<p>Sets the instance variable named by symbol to the given object. The variable does not have to exist prior to this call.</p>

<h5>instance_variables</h5>

<p>Returns array of instance variables</p>

<h5>is_a? / kind_of?</h5>

<p>Returns true if class is the class of object, or if class is one of the superclasses of obj or modules included in obj.</p>

<h5>itself</h5>

<p>returns object itself</p>

<h5>method</h5>

<p>Looks up the named method as a receiver in object, returning a Method object. The Method object acts as a closure in object&rsquo;s object instance, so instance variables and the value of self remain available.</p>

<h5>methods</h5>

<p>Returns a list of the names of public and protected methods of object. This will include all the methods accessible in obj&rsquo;s ancestors. If the optional parameter is false, it returns an array of object&rsquo;s public and protected singleton methods, the array will not include methods in modules included in object.</p>

<h5>private_methods</h5>

<p>Returns the list of private methods accessible to object.</p>

<h5>protected_methods</h5>

<p>Returns the list of protected methods accessible to object.</p>

<h5>public_method</h5>

<p>Similar to method, searches public method only.</p>

<h5>public_methods</h5>

<p>Returns the list of public methods accessible to obj.</p>

<h5>public_send</h5>

<p>Invokes the method identified by symbol, passing it any arguments specified. Unlike send, #public_send calls public methods only.</p>

<h5>remove_instance_variable</h5>

<p>Removes the named instance variable from object, returning that variable&rsquo;s value.</p>

<h5>respond_to_missing?</h5>

<p>Hook method to return whether the object can respond to id method or not.</p>

<h5>send / __send__</h5>

<p>Invokes the method identified by symbol, passing it any arguments specified. You can use __send__ if the name send clashes with an existing method in obj.</p>

<h5>singleton_class</h5>

<p>Returns the singleton class of object. This method creates a new singleton class if obj does not have one. If object is nil, true, or false, it returns NilClass, TrueClass, or FalseClass, respectively. If object is a Fixnum or a Symbol, it raises a TypeError.</p>

<h5>singleton_method</h5>

<p>Similar to #method, searches singleton method only.</p>

<h5>singleton_methods</h5>

<p>Returns an array of the names of singleton methods for object. Only public and protected singleton methods are returned.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - BasicObject]]></title>
    <link href="http://www.hanyi.name/blog/2015/08/03/metaprogramming-ruby-core-concepts/"/>
    <updated>2015-08-03T07:33:27+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/08/03/metaprogramming-ruby-core-concepts</id>
    <content type="html"><![CDATA[<p>Metaprogramming is one of core features for ruby lang, it&rsquo;s widely used from internal ruby to standard library, also endless magic gems. In next a few articles we will focus on those core stuff. I recommend for <a href="https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2">Metaprogramming ruby 2</a> as a reference, except a little verbose and may be only for primer usage. For more ascent knowledge, perhaps you need to track the <a href="https://github.com/ruby/ruby">trunk</a> of ruby. This essay will concentrate on BasicObject, which is parent for all classes in ruby.</p>

<h3>BasicObject</h3>

<p>As the object oriented hierarchy in ruby core, each type of class is also object of Class except BasicObject, and All the objects of Class has root superclass BasicObject, the one is also object of Class. Thus we&rsquo;ll have whole picture below.</p>

<p><img src="http://content.hanyi.name/images/metaprogramming_ruby/ruby_class.png" alt="Ruby OO hierarchy" /></p>

<h4>i.class methods</h4>

<p>BasicObject only has single public class method, names &ldquo;new&rdquo;.</p>

<h4>ii.instance methods</h4>

<p>logical operators, any instance of BasicObject is almost empty, with only a few methods, like logical operators !, !=, ==. Here == has same meaning with equal? for object level equality, The difference is that == is recommended for descendant overriding, but equal? should always be same as it is defined in BasicObject.</p>

<h5>__id__ / object_id</h5>

<p>An integer identifier of an object, should be unique for a given object. But some objects of builtin classes are reused for optimization, like immediate values (not passed by reference but value, like nil, true, false, Fixnums, Symbols, and some Floats) and frozen string literals.</p>

<h5>__send__ / send</h5>

<p>Double underscore gives a backup for pure alphabet version which may be overrode through other ways. Invokes the method, and passes all arguments using dynamic number of arguments.</p>

<h5>instance_eval / instance_exec</h5>

<p>instance_eval support passing a string of ruby source code, with file path and line number when compilation errors happen, also given block, within the context of receiver. Thus eval code will have access to instance variables and private methods.</p>

<p>instance_exec only support using block as an argument, but allows one more argument to be passed from outer scope into receiver.</p>

<h4>iii.private instance methods</h4>

<h5>method_missing</h5>

<p>In BasicObject, method_missing belongs to private instance methods, any call for this method will raise an error. But descendant can override this method to do dynamic processing, according to user&rsquo;s input like symbol name and arguments. If overrode method does not want to do any processing, super should be called to pass message bottom from up.</p>

<h5>singleton_method_added / singleton_method_removed / singleton_method_undefined</h5>

<p>Callback for singleton method operations. As we already know, ruby will not create the whole clone of the class for any objects. Only with a middle layer between object and class - singleton class. Singleton class is generated when object comes out, and any messages sent to object should be transferred to its singleton class first, then its own class if not matches in singleton class.</p>

<p>class&rsquo;s singleton class is different to object&rsquo;s singleton class. That&rsquo;s because singleton class of a class should be inherited from its parent&rsquo;s singleton class, until BasicObject&rsquo;s singleton class, then it can reach non singleton class. But for object, singleton class should always have parent class of its own class.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[microsevices陷阱: 本质与陷阱]]></title>
    <link href="http://www.hanyi.name/blog/2015/07/21/microservices-why-it-is-trap/"/>
    <updated>2015-07-21T17:32:35+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/07/21/microservices-why-it-is-trap</id>
    <content type="html"><![CDATA[<p>最近两年，“微服务”这个词从最初的争议，到随后的逐渐接受，如今已经成为许多时髦的技术人员常挂在嘴边的词汇。在他们看来，似乎你不“微服务”就落伍了——因为你看，好像全世界都在“微服务”。然而当一些自诩为技术先驱的人开始尝试将其落地，并且后来发现自己当初根本就不了解到底“微服务”真正意味着什么时，我们才发现，要想革现代软件工程的命，远没发几篇文章、或者侃侃而谈来的容易。</p>

<h3>1. 微服务的本质</h3>

<p>可能你见过或者听过某些自称正在构建“微服务架构”的人，坦白的说，“微服务架构”真的不是指什么具体的软件架构，和大多数与之相关的早期技术一样，也没有一个标准告诉你什么是微服务、如何通过以下几个步骤构建微服务、或是让你参加培训，结束之后取得XXX认证，就证明你掌握了微服务架构。</p>

<p>其实微服务更像是一系列前沿软工思想的汇集，至于它为什么叫“微服务”，本系列的第一篇文章就已经提到过（虽然至今都有争议），但你可能会觉得它有点标题党——这也影响不了它拥有这个名字的既定事实。撇开名字，我们来看看微服务所承继的几个软件领域：</p>

<h4>基于业务概念建模</h4>

<p>从稳定性的角度考虑，围绕业务边界上下文所构建的接口要比来源于技术概念的接口更加不易变更，从而降低风险。这部分来源于领域驱动设计的主张。</p>

<h4>自动化</h4>

<p>自动化涉及方方面面，包括自动化测试、自动部署、自动配置管理乃至整个持续交付流程，都被认为是微服务落地的重要途径。</p>

<h4>隐藏内部实现细节</h4>

<p>隐藏实现的好处在于，一方面数据隐藏能够显著降低数据访问代码的耦合性；另外，服务内可以采用异构技术栈来实现，无论使用何种技术，你都可以用REST、RPC来实现服务间通信。</p>

<h4>一切去中心化</h4>

<p>去中心化的核心是组织自服务团队。近年来我们已经尝过自动化带来的好处，但鉴于Conway法则，设计开始来自领域而非现有的技术架构，而为了保证每个团队能够独立开发、测试和部署，按照服务划分现有团队是一个趋势（而非现实）。自服务团队能显著降低实施自动化的复杂度，更加贴近业务领域，并且形成一个分散的系统架构。与ESB或类似的编配系统完全相反的是，去中心化强调采用编排以及哑管道，并且在服务边界上采用智能终端来表现关联逻辑和数据，从而实现低耦合。</p>

<h4>独立部署</h4>

<p>强调每个服务都必须是可独立部署的，甚至当发生重大变更时，也倾向于采用版本共存终端来保证各自的独立性。独立部署能够带来更快的feature发布、强化自动化部署流程的一致性（而非经常需要人工编配部署管线）。推荐采用单服务－单主机的部署架构，从而避免部署单个服务时带来的边际效应；采用蓝绿部署/金丝雀发布来降低出错的风险；并且使用消费者驱动契约测试来保证集成接口的一致性。</p>

<h4>错误隔离</h4>

<p>分布式系统能够做到比单一系统更加可靠——前提是做好应对各种错误的万全准备（这也是人类毕生追求的目标&hellip;）。如果我们不能保证下游服务的正确性，系统就有可能发生级连式的灾难，且比单一系统脆弱的多。因此要时刻考虑网络的不可靠性、服务间通信的各种潜在问题：超时、隔板、断路器等在应对灾难时的作用、理解网络分区带来的后果、以及权衡一致性和可用性两种方案。</p>

<h4>完备监控</h4>

<p>传统意义上的监控，恐怕只是一个简单的dashboard，列出所有运行中节点的状态，并且当某个节点的指标超过阈值时产生警告。但随着去中心化的深入，传统监控方式根本不能应对复杂架构出现的各种问题。因此，采用语义化监控、综合化监控去模拟用户的真实行为，聚合用户日志和统计数据，采用关联ID跟踪消息在系统内的传递路径。</p>

<p>严格的说，不具备上述特征的系统就不能被称作微服务。事实上，当你开始尝试上述某个或某几个新的领域时，多数情况下你的系统无疑蕴涵了极大的风险——因为只有整体采用才能实现微服务的闭环，否则只能是一个摇摇欲坠的怪胎。有的人可能认为可以从简单模型开始演进——但注意，这里所谓的演进并不是从某个独立的方面出发，而是要在一开始就要做通盘设计，并且以简单方式先落地而已。</p>

<p>那么企业费尽千辛万苦、从事如此巨大的迁移工程——效果真的能够立竿见影吗？</p>

<h3>2. 发觉陷阱</h3>

<p>一些谨慎的开发者认为，可以先从单一系统入手，再逐渐向微服务过渡。对此，微服务的拥簇者声称：“你将无法（或很难）精炼出微服务架构，如果不在项目的最开始就设计成那样”。</p>

<p><em>&ldquo;这无疑又在扯过早做大型设计的蛋（That&rsquo;s BDUF Baloney）。&rdquo;</em></p>

<p>Uncle Bob更倾向于“迫使无知”，即好的架构应尽量保证组件对部署和内部通信方式的透明，这样就可以根据实际情况选择部署成微服务，或多个单一系统＋应用服务器，亦或纯粹的单一系统。这种“实际情况”有时可能是需要大规模扩展的、只需要少量部署的、以及单个节点足矣的。</p>

<p>一旦打破了“迫使无知”，则很有可能会造成过度设计，使得太多因素过早被考虑进来，最终却形成一堆烂摊子。对于微服务强调的其它几个方面，例如跨语言的服务实现——确实，采用REST的通信架构使得服务间实现强解耦，包括语言、数据库等。但是，什么样的业务需求会导致项目初期就要切割成不同语言、甚至采用不同的数据库技术呢？这种高配置复杂度的架构随之带来的好处又能有多少？</p>

<p>而对于“单一系统”的说法，Uncle Bob更认为这种广告式的宣传，使得采用非微服务形式的系统听起来就像是一块又大又丑的“石头”，造成受众对微服务架构的盲目崇拜，进而为布道者带来利益。</p>

<p>比起微服务，Uncle Bob更加倾向于一种“<a href="http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">整洁架构</a>”的风格，后者是对近年来一些流行系统架构的全面总结，焦点主要集中在代码架构方面，而对微服务强调的独立部署、异构数据库等持开放的观点。</p>

<h3>3. 稳步向前</h3>

<p>当然，无论是微服务，还是整洁架构，能最终轻松玩转的仍然是极少数。例如，从源头的设计出发，对领域的理解会影响边界上下文的稳定性，你要确信自己真的“彻底认识”了该领域，否则后面的一切都是空谈，还不如老老实实把单一系统做好。</p>

<p>另外，如果任何环节存在未知领域，就尽量不要采取过于激进的做法——这是遏制风险的关键。</p>

<p>对于任何一种架构，只有当整体规模增加到一定限值时，才能够真正考验架构的有效性，而面向未知又十分危险——因此强烈不建议如此激进地改变根本架构。毕竟在整个生态圈中，技术团队只是起到实现和保障作用，过早、过度引入风险是完全没有必要的。</p>

<p>那么何时才能选择向前呢？如今声称自己正或多或少实现微服务架构的团队包括Amazon、Netflix、REA和Gilt等，无一不是从现有实践中持续发掘存在的问题，并为此开发了一系列工具、平台甚至整体实践，其中的部分已经成为流行的开源项目——可见，对于某些技术能力领先世界的公司来说，微服务之路尚且存在各种困难，而剩下积累不深却大谈微服务的团队，要么是盲目追新，要么就是醉翁之意不在酒了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[microsevices陷阱: 层级演进（下）]]></title>
    <link href="http://www.hanyi.name/blog/2015/07/19/microservices-scale-3/"/>
    <updated>2015-07-19T17:32:35+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/07/19/microservices-scale-3</id>
    <content type="html"><![CDATA[<h3>8. 服务发现</h3>

<p>随着服务数量的增加，如何获取某个服务的信息则成为挑战，同时它也是部署监控的前提条件。另一些开发中遇到的例子，如：一、想获取当前环境中运行的服务（也就是采集监控对象）；二、想获取当前系统中的API列表从而避免重新发明轮子；这些需求其实都隐含了一种新的需求：针对“服务”的发现机制，在近年来发展非常迅速，已经形成了几个相当成熟的解决方案。它们基本上都遵循了如下工作模式：首先提供一种针对服务的注册过程，当启动新实例时就将其注册进系统；然后，提供一种发现系统内已注册服务的途径。我们先来看一种历史最悠久也最简单的解决方案：</p>

<h4>DNS</h4>

<p>DNS是解决服务发现问题最直接、简便和有效的手段。因为借助DNS，尽管实例IP可能随时发生变化，但域名是不变的。因此在早期，大多数应用都会采用类似<code>&lt;service-name&gt;-&lt;environment&gt;.company.com</code>这样的二级域名来指定服务地址。有的甚至去掉了environment，直接搭建不同的DNS服务器并设置不同的映射表，从而实现配置管理的一致性。后者看起来很方便，但成熟的解决方案不多，亚马逊的Route53服务是少数优秀的代表。</p>

<p>然而采用DNS也存在一定风险性。在DNS协议中存在TTL的概念，也就是说主机内部会维护一个DNS表，当TTL未失效时系统仍将采用本地的DNS映射表，这种设置让实例的更新带来一定风险。为了解决这一问题，DNS并不直接指向实例IP，而是若干实例前设置的反向代理（这个通常是固定不变的）。</p>

<p>DNS方案由于其易用性而得到了大量的应用，但随着微服务架构规模的增加，这种方法的有效性和可维护性将逐渐降低，特别是DNS服务器节点的存在，于是就出现了更多动态服务发现方案。</p>

<h3>9. 服务注册</h3>

<p>由于DNS本身的局限性，许多基于服务注册的发现方案被提出并得到了广泛应用。</p>

<h4>Zookeeper</h4>

<p>Zookeeper最初是Hadoop项目的一部分，其用途非常广泛，包括配置管理、同步服务间数据、选举Leader、消息队列以及命名服务（这才是本文重点）。Zookeeper首先是高可用的，其后台是一个集群并且实现数据Replica；Zookeeper的核心提供一种存储信息的层级命名空间，客户端可以在该层级插入、修改和查询节点；此外，它们能够添加针对节点的监视以观察该节点是否发生变化；也就是说，我们可以把服务的地址信息保存在这种存储结构，并且当其中的信息发生改动时执行其它变更操作，例如关闭上游服务。</p>

<p>Zookeeper是一个非常通用的系统，你可以只把它看作是一个能够保存信息树，并且能在任何变化时发出警告的高可用服务。由于其底层性和单一性，目前针对Zookeeper的扩展库也非常之多。从现在的时间来看，Zookeeper可能有些过时——因为与更多后起之秀相比，它看起来不是那么开箱即用，但不可否认其曾经十分流行。必须承认，由于Zookeeper底层算法PAXOS实现起来非常困难，而该产品又饱经考验，任何企图重新发明轮子的组织都在此吃过不少苦头。这正是分布式协调系统复杂性的体现。</p>

<h4>Consul</h4>

<p>Consul同样支持配置管理和服务发现，但提供了更多高级功能，从而更加易用。例如针对服务发现的HTTP接口，以及一个简单的DNS服务器，甚至还提供SRV记录，能够同时提供给定名字的IP和端口信息。这就使得曾经采用DNS服务的公司迁移到Consul变得非常容易。</p>

<p>Consul还提供了节点健康检查功能，这就包含了一部分监控系统的能力，并且由于其高容错设计和依赖临时节点机制的系统的针对性，使其有能力在某些情况下完全替代Nagios和Sensu。</p>

<p>Consul的RESTful HTTP接口覆盖了从服务注册、查询信息、以及健康检查等大部分功能，使其与现有系统集成变的十分简便。其底层依赖的Serf能够检测集群内节点，进行错误管理以及发出警告。良好的设计使Consul如今成为该领域极具竞争力的明星之一。</p>

<h4>Eureka</h4>

<p>Eureka是由Netflix开源的、只关注服务发现领域的系统。Eureka提供基本的负载均衡功能，基于REST的集成终端，以及基于Java的客户端库。但是，由于Eureka是基于JVM并且实现了所有客户端，这对于多语言环境来说可能会是一个挑战。</p>

<h4>自己动手</h4>

<p>在某些公有云服务器中，服务发现可以借助一些内置功能来实现，当然这要建立在你对该产品非常熟悉，且系统规模较小的情况之下，通常会与采用上述重型框架相比省去很多麻烦。另一方面，服务发现除了是对分布式系统内部提供信息，任何现有的report和dashboard都可以借此提供实时的节点信息，从而允许人工检查。</p>

<h3>10. 服务文档化</h3>

<p>随着微服务架构的实施，更多时候我们希望能够以API的形式暴露一部分服务缝隙，从而允许其他开发者接入更多类型的服务。但是构建开放API的过程是非常复杂的，特别是在采用微服务架构时，如何保证服务文档的实时性将成为挑战。这里介绍目前流行的两个服务文档技术：Swagger和HAL。</p>

<h4>Swagger</h4>

<p>Swagger能够通过一组Web界面展示当前的API信息，而你只需要定义一套POST模版即可。Swagger要求相关服务暴露一个符合标准的文件（可以通过Swagger提供的标准库实现），例如对于Java你可以使用方法标注描述相关API。</p>

<h4>HAL和HAL浏览器</h4>

<p>HAL即Hypertext Application Language，是一种超媒体资源的描述标准，HAL同样提供用户界面和标准库。通过Web界面，用户不仅可以查看API信息，还能直接调用相关API。不同的是，HAL中所有的文档信息都基于超媒体控制，因此很容易就能够将信息对外展示。这就限制了用户只能使用超媒体描述系统内资源，而从现有系统迁移则远没那么容易。</p>

<h3>11. 自描述系统</h3>

<p>在SOA的发展初期，类似全局描述、发现以及集成UDDI标准被用于帮助人们理解当前运行着什么服务。事实证明，UDDI对大多数项目来说都非常重，从而导致更多替代产品的出现。</p>

<p>不可否认，获取系统的整个框图并理解其架构对于团队成员来说十分重要。通过关联ID跟踪下游服务并理解调用链、从而让我们更快理解系统原理。采用类似Consul的服务发现技术，能够让我们查看当前运行的微服务。HAL能展示出当前终端上包含的所有服务能力，同时状态监控页面和相关系统能够使我们整体和局部的状态。上述信息都能够用于为进一步设计提供线索，且比只有一个简单到随时会过期的wiki页面强得多。尽管多数情况下我们都是从后者开始的，但不要忘了把上述信息逐渐引入到系统中，随着系统复杂性增加，描述信息的演化能让我们更好的理解系统。</p>
]]></content>
  </entry>
  
</feed>
