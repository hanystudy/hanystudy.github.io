<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Wing of Dream 梦境之翼]]></title>
  <link href="http://www.hanyi.name/atom.xml" rel="self"/>
  <link href="http://www.hanyi.name/"/>
  <updated>2019-05-14T11:50:29-04:00</updated>
  <id>http://www.hanyi.name/</id>
  <author>
    <name><![CDATA[Han Yi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(13)]]></title>
    <link href="http://www.hanyi.name/blog/2019/05/14/software-design-and-architecture-notes-13/"/>
    <updated>2019-05-14T11:14:51-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/05/14/software-design-and-architecture-notes-13</id>
    <content type="html"><![CDATA[<h2>设计诊断</h2>

<p><strong>设计诊断</strong>(Design diagnosis)是指获取、分析、检测软件设计及其质量的活动。经济利益是驱动软件设计诊断的重要原因之一，特别是对于具有重要价值的软件设施来说，尽早发现并解决设计中存在的问题是十分必要的。然而一直以来软件设计都被认为是难以度量和评价。一方面是因为设计中包含的决策通常是涉及对领域、技术或其它上下文因素的权衡，这是任何客观标准都难以做到完全覆盖的，因此始终无法100%消除对主观参与的依赖，导致设计诊断的权威性受到限制。另一方面，已有的设计验证方法普遍落后于软件开发技术的创造和更替。尽管<a href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/">设计原则与代码味道</a>具有一定的普适性，但是大部分原则本身缺少明确的定量或定性规则(即使存在这类规则一般也很难适用于新的开发技术)，少量有明确的规则通常被归为静态代码分析和风格检查，尚不足以达到设计诊断的目的。</p>

<p>因此为了实现设计诊断，一方面需要对软件设计进行统一的形式化表示，避免对具体的软件开发技术产生依赖。在前者的基础上进一步分析当前软件设计，帮助分析人员理解现有设计、发现设计中的潜在缺陷、甚至模拟历史和未来的设计演化，从而为工程进度和技术债管理提供依据。本文的剩余部分将详细讨论这些主题。</p>

<h3>设计分析(Design analysis)</h3>

<p>设计分析的目标是研究设计本身，后者通常表示解决问题的方案，也可以指构建解决方案的过程。[BC00]认为，理想的解决方案可被视作具有一系列特性的集合，其中的每种特性都可以被归纳为某个维度，即<strong>设计参数</strong>(Design parameters)。不同的设计参数之间存在一定的依赖关系，即<strong>设计结构</strong>(Design structure)。设计参数的所有可能值的集合被称作<strong>设计空间</strong>(Design space)。在整个设计过程中，每个设计参数由对应的<strong>设计任务</strong>(Design tasks)决定，后者相互之间的依赖关系被称为<strong>任务结构</strong>(Task structure)。例如要设计一个马克杯，“是否包含杯盖”是一个设计参数，而“杯盖直径”则是依赖于前者的另一个设计参数，而对于“容器直径”来说，“杯盖直径”与其存在相互依赖的关系。相应地，分别负责杯盖和容器的设计任务之间也就存在依赖，因此设计结构和任务结构具有一致性。前述这些结构可以用一种邻接方阵进行表示，即接下来要讨论的<strong>设计/任务结构矩阵</strong>(Design/Task structure matrix，DSM/TSM)。</p>

<h4>设计结构矩阵</h4>

<p>在DSM(TSM)中，每个结点表示设计参数(或设计任务)，两个设计参数之间的依赖用符号x进行表示，一个马克杯的设计结构例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/full_dsm.png" alt="Full DSM" /></p>

<p>虽然该DSM只有10x10，但每个结点间依赖都可能包含了丰富的物理和工程属性，真实场景中也许会非常复杂。根据设计参数之间的依赖关系类型，在DSM中可以进一步发掘出一些微结构，例如:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/dsm.png" alt="Micro DSM" /></p>

<p>上图描述了两种微观的设计结构，(a)表示层次结构，(b)表示无层次的相互依赖结构，这两种设计结构实质上体现了不同的关系强度，显然(b)体现了更强的相互关系。</p>

<p>另外，真实案例中的矩阵规模通常要比马克杯大得多，例如一个设计笔记本电脑的TSM如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/computer_tsm.png" alt="A laptop computer TSM" /></p>

<p>上图中的TSM相比于马克杯的例子有几个新的元素。首先矩阵中的设计任务呈现出特定排序(或呈现为下三角矩阵)，即相互之间存在强关联的设计任务被放置的更近，越接近对角线的依赖密度就越高。其次整个矩阵上产生了若干相互关联的区块，这些区块直接反映了系统中的独立组件，例如驱动系统、主板等，被称作<strong>原型模块</strong>(Protomodules)。原型模块通常是由领域知识或者组织结构等上下文决定，但是并非真正意义上的模块，因为其本身不具有接下来要讨论的<strong>模块性</strong>(Modularity)。</p>

<h4>模块性与设计规则</h4>

<p>一般而言，高复杂度的问题会导致同样高复杂度的设计，而一个“好”的设计能够有效地管理其自身复杂性。[BC00]认为，<strong>模块化</strong>(Modularization)是系统管理自身复杂性的核心，也是二十世纪以来计算机乃至更多其它领域得以飞速发展的重要原因。系统的模块化程度体现为<strong>模块性</strong>(Modularity)，其中包含两个重要概念:</p>

<p><strong>模块</strong>，即内部元素间的关系比与外部元素间更强的系统单元，这些关系的相对强弱决定了模块的粒度。</p>

<p><strong>抽象</strong>、<strong>信息隐藏</strong>和<strong>接口</strong>，即当一个系统达到一定复杂度时，需要将其拆分成不同部分，抽象的目的在于隐藏其内部复杂性，且通过接口与系统的其它部分进行交互。</p>

<p>在设计笔记本电脑的TSM中，我们知道主板和显示屏之间的设计任务多存在循环依赖，一个例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/design_rule_tsm.png" alt="Cycling in a laptop computer TSM" /></p>

<p>该例中的多个设计任务因为相应设计参数而存在互相依赖，例如主板要决定CPU的规格和所采用的中断协议，而显示屏需要确定详细规格。当主板中具有独立的图形控制器时，显示屏的规格就会发生改变。否则CPU就要根据显示屏的规格提供更多的计算能力，并且采用不同的中断协议。由此可见，“主板是否包含独立的图形控制器”就成为其它设计参数的关键依赖参数。从系统的角度看，其整体复杂性通常是由一系列关键依赖参数决定的，一旦其中某个设计参数确定，则许多依赖的设计参数也就相应确定。这些关键依赖参数被称作<strong>设计规则</strong>(Design rule)。一个完整的系统设计规则集合应至少包含如下信息:</p>

<ul>
<li><p>模块及其在系统中扮演的角色。</p></li>
<li><p>模块间通信的接口。</p></li>
<li><p>系统集成协议以及测试某个模块是否遵循设计规则。</p></li>
</ul>


<p>通过抽取设计规则可以消除原型模块间的相互依赖，从而形成真正意义的模块。其中，设计规则被称为<strong>显性模块</strong>(Explicit modules)，而其他相互独立的部分被称为<strong>隐性模块</strong>(Implicit modules)。一个模块化后拥有完整设计规则集合的DSM/TSM所下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/modularization.png" alt="Modularization" /></p>

<p>DSM/TSM对于计划设计过程同样具有意义，在上例中，首先进行的是设计规则阶段，然后进入可并行进行的隐性模块设计阶段，最后是系统集成和测试阶段。其中，设计规则作为所有阶段的输入，隐性模块则作为集成和测试阶段的输入。</p>

<h4>模块演化及其模拟</h4>

<p>模块性反映了系统的结构状况。如果一个系统具有嵌套层级结构，每个结构单元对内强关联，对外则相互独立，并且具有良好的功能角色定义——那么该系统就被称作<strong>模块化系统</strong>。值得注意的是，系统结构并非一成不变，一方面是因为某些设计参数间的依赖并不容易在初期就显现出来，另一方面，由于复杂的结构往往导致更高的经济成本，因此在真实场景中更加倾向于寻求结构和经济之间的平衡。为了描述模块的动态特征，可以采用<strong>模块操作符</strong>(Modular operators)，[BC00]提出了六种最基本的模块操作符，后者能够用于表示动态结构的所有可能演化路径:</p>

<ul>
<li><strong>分解</strong>(Splitting)，把现有设计或任务划分成多个模块，在层次结构中这往往意味着产生了新层，例如以下模块化层级设计:</li>
</ul>


<p><img src="http://content.hanyi.name/images/design_diagnosis/dsm_splitting_before.png" alt="Two-level modular design hierarchy" /></p>

<p>上例中描述了A~D四个隐性模块以及一个集成和测试阶段，从模块化的角度来看它们都属于相同层级。当更多设计参数及其依赖显现，并且上下文满足模块化设计需求时，新的设计规则以及相应的接口、测试就会出现，于是就诞生了新的层级，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/dsm_splitting_after.png" alt="Three-level modular design hierarchy" /></p>

<p>在进行分解操作后，新的层级应当只对其所依赖的设计规则负责，而对全局设计规则以及上层的集成和测试部分保持透明，这对设计任务和阶段执行具有重要意义。</p>

<ul>
<li><p><strong>替换</strong>(Substituting)，指替换现有模块设计。替换通常是因为多种设计路径之间存在竞争关系，于是更多受到经济系统因素的驱动。模块的可替换性通常是由分解所决定的，因此分解在此扮演了非常重要的角色。</p></li>
<li><p><strong>增强</strong>(Augmenting)和<strong>排除</strong>(Excluding)，即添加或删除模块，与分解与替换不同的是，增强和排除是针对已经模块化的系统来说的。排除体现了模块化设计的可配置性，也就是说用户可以按需选择模块，这与替换的特性是相当的。增强通常是由于系统中需要引入新特性，为了保证可增强性，需要在设计规则阶段就要考虑这种能力。</p></li>
<li><p><strong>反转</strong>(Inverting)，指创建新的设计规则。我们知道设计规则来自于设计参数，后者广泛存在于隐性模块中。因此有时需要把隐性模块从当前的设计层级中“拉取”上来，使其对更多模块保持可见。</p></li>
<li><p><strong>移植</strong>(Porting)，即把当前模块移植到新系统。某些隐性模块支持从当前系统移植到新系统，那么该模块至少应满足以下条件之一:</p>

<ul>
<li><p>所依赖的设计规则在新系统中存在且不变。</p></li>
<li><p>模块本身不受设计规则的影响。</p></li>
</ul>
</li>
</ul>


<p>采用上述模块操作符可以模拟任何过去、现在和未来所发生的设计变化。例如可以抽取设计演化历史中的连续片段，然后用模块操作符描述每一步的变化。对于进行中乃至未来的设计来说，模块演化则是非确定的，采用公式(j6 X 2) - 1即可计算模块演化的所有可能路径，例如当系统中包含6个模块时，就有93311种演化可能。</p>

<h4>应用DSM分析软件设计</h4>

<p>[NEVD05]首次把DSM用于管理复杂软件系统的<strong>依赖模型</strong>(Dependency model)，具体方法是通过静态分析提取代码的依赖关系，然后在DSM中进行层次结构展示，支持人工选取设计规则，并且检测出违反相关规则的依赖关系。</p>

<p>通过静态分析提取到的大多属于语法依赖，即字面引用所体现的依赖关系。不同编程语言的语法依赖类型存在一定区别，并且语言自身的模块化特性也不尽相同，因此存在多种表示软件依赖模型的方式。一种简单的做法是忽略依赖类型间的差异，选择统一的模块化元素作为DSM的设计参数，例如Java中的类，并且按照元素间存在的引用数量定义依赖强度。下例展示了jEdit v4.2的DSM:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/jedit_dsm.png" alt="DSM for jEdit v4.2" /></p>

<p>当DSM规模较大时，需要支持进一步显示矩阵中的层次结构。尽管许多现代编程语言都在语法上提供了层次化结构的特性(例如包、类、方法等)，这些信息可被直接用于DSM分层。但是，多数情况下软件的层次结构无法满足[BC00]的模块性标准，这种在实际中十分普遍的情况被称作软件结构的<strong>技术债</strong>。为了方便理解和改进现有系统的模块性，业界开发了许多针对DSM的聚类算法，即从DSM中的元素及其依赖出发，通过重新排列元素顺序实现自动聚类，其中有代表性的方法有:</p>

<ul>
<li><p>[JNW73]采用<strong>矩阵分区算法</strong>把初始矩阵划分成若干子矩阵，使后者满足下三角矩阵的特征，从而消除循环依赖。</p>

<p>该算法的基本思路是针对每个元素，首先构建可达性(Reachability)集合R(s)与先导(Antecedent)集合A(s)，前者指从该元素出发能到达的所有元素集合，后者指从非当前元素出发能到达或经过该元素的路径的所有元素集合，以及两者交集R(s)A(s)。算法每次迭代选择满足R(s)A(s) = R(s)的元素集合作为当前矩阵的top-levels，然后将其从剩余元素的集合中删除并重复这一过程，直到剩余元素个数为0。矩阵分区算法的优点是实现简单，能够快速筛选出不存在循环依赖的子矩阵，对DSM分层具有一定意义。但是该方法无法满足更多的模块化特性，例如[BC00]中指出的隐性模块间的相互独立性。</p></li>
<li><p>聚类分析中常用的<strong>启发式算法</strong>同样被用于构建DSM的元素聚类。如果某个系统内存在一系列规模合理且相互独立的子模块，那么这些子模块内的依赖关系一定趋近于DSM对角线，以此推论为基础设计距离惩罚函数作为启发式算法的目标函数[TS94]。与分区算法相比，启发式算法能够实现模块间独立条件下的更优结果，而且实现也比较简单，例如聚类部分采用现有的遗传算法框架[RAC08]。但是，设计软件模块性的目标函数是一项挑战。另外，软件的模块性往往还体现在层次结构方面，这是一般的聚类方法难以同时考虑的。</p></li>
<li><p>由于DSM本质上是有向图，因此可以采用图算法进行DSM分层。[SYG09]是一种基于图算法的DSM层次聚类方法，首先计算DSM的凝聚图(Condensation graph)，然后找出所有出度为0的结点的所有依赖关系路径，再从拥有最长路径的结点出发构建DSM的层次结构。该方法构建出的层次结构一定满足下三角矩阵，同一层的模块间保持相互独立且允许并行开发。其优点在于使用DSM实际反映出软件的层次结构，从而能够进一步诊断软件的设计问题[RYR15]。</p>

<p>如果要根据DSM中依赖关系的强弱寻找更优化的层次结构，则可以采用<strong>图聚类</strong>方法[SS07]，特别是针对有向图聚类[FM13]。[SA14]采用<strong>谱聚类</strong>方法对DSM进行重新聚类，该方法建立在DSM中具有较大特征值的特征向量、特征值、模块层次数以及每层模块数等数量之间的相关性基础上，通过对原始DSM进行奇异值分解、分析和降维，计算每个结点在k维空间的线性表示，最后以结点在k维空间中的距离进行聚类。尽管该方法需要指定k值，但是聚类结果依然能正确反映DSM的层次结构。例如:</p></li>
</ul>


<p><img src="http://content.hanyi.name/images/design_diagnosis/spectral_clustering.png" alt="Spectral clustering" /></p>

<p>其中(a)是原始DSM，(b)&copy;(d)分别表示k=2，k=4，k=8时的谱聚类结果，可以看到随着k值的变化，聚类结果始终能表现出实际DSM的层次结构。</p>

<h3>设计度量(Design metrics)</h3>

<p>设计度量涉及一系列面向软件设计的度量指标，包括针对整体模块性的度量、接口强度和优先级、扇入/扇出、联通度以及可见度等等。值得注意的是，设计的度量结果并不能直接等价于设计质量，通常可以作为支持设计分析结果的辅助证据，帮助定位具体问题并结合具体上下文制定改进计划。</p>

<p><strong>模块度</strong>是一种度量整体模块性的指标。[MAC06]认为可以通过计算DSM中元素间的依赖成本，例如依赖的数量和分布模式等，从而实现模块度的间接计算，并且其中存在两种可能的应用场景:</p>

<ul>
<li><p>比较软件A和软件B的模块性。</p></li>
<li><p>比较软件A在T时刻和T + N时刻的模块性。</p></li>
</ul>


<p>假设DSM的元素数量为n，其中<strong>传播成本</strong>(Propagation cost，Pc)忽略元素所在的位置，假设直接依赖和间接依赖具有同等成本，然后计算所有元素的扇入或扇出数M，则Pc = M / n2。对于整个系统而言，扇入和扇出数是相等的，因此M可以任选其中一种进行计算。<strong>聚集成本</strong>(Clustered cost)把模块内和模块间的依赖进行区别计算，首先指定一个依赖阈值(通常是10%~100%间的数)，并将DSM中被依赖次数超过该阈值的元素计入主控元素，然后根据以下条件计算每项依赖所包含的成本:</p>

<ul>
<li>DependencyCost(i -> j | j is a vertical bus) = d</li>
<li>DependencyCost(i -> j | in same cluster) = d * n^λ</li>
<li>DependencyCost(i -> j | not in same cluster) = d * N^λ
其中d是表示是否存在i -> j依赖的二进制值，n指模块规模，N指DSM规模。λ是自定义参数。</li>
</ul>


<p>除了通过依赖成本计算模块度，另一类方法是直接计算模块度。根据模块从内及外且依赖由强变弱的定义，[GG04]提出了一种通用的模块度计算方法，该方法的前提是DSM中已经包含了精确的模块化信息。当DSM中不包含模块化信息，或者需要直接计算系统的实际依赖复杂度时，可采用<strong>奇异值模块度指数</strong>(Singular Value Modularity Index，SMI)[KO11]。该方法通过对DSM进行奇异值分解，然后计算奇异值的下降率从而表示系统模块度。以下面三种典型的结构模式为例:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/different_patterns.png" alt="Typical structural patterns" /></p>

<p>从模块性来看，单块(Integral)系统的模块性较差，总线(Bus-modular)系统也比较差，模块化系统则相对较好。对这些模式对应的DSM进行奇异值分解，从而得到上面三种结构的奇异值下降模式:</p>

<p><img src="http://content.hanyi.name/images/design_diagnosis/singular_value_decay_pattern.png" alt="Singular value decay pattern" /></p>

<p>可以看出，单块系统的下降趋势非常陡峭，总线型系统比较陡峭，而模块化系统的下降趋势则相对平滑。基于上述关联关系，可以认为当系统的模块性较差时，奇异值会出现迅速下降的情况(SMI较低)，而模块性较好的系统，奇异值下降则通常比较缓慢(SMI较高)，这种相关性也是上文讨论的谱聚类方法的基本假设。</p>

<h2>结论</h2>

<p>设计诊断包括分析和度量两个方面，其中设计分析主要负责设计的形式化表示，例如本文讨论的DSM工具。在DSM的基础上可以进一步分析和模拟设计演化过程，发现设计缺陷以及优化系统模块性。DSM同样可以用于设计度量，设计度量指标不直接等价于设计质量，但可以指导设计及其改进。除了基本的度量指标外，模块度是度量系统整体模块性的核心，可以用于不同软件之间和相同软件的不同版本之间的模块性评价。</p>

<h2>引用</h2>

<p>BC00, <a href="https://mitpress.mit.edu/books/design-rules-volume-1">Design Rules, Vol. 1: The Power of Modularity</a></p>

<p>NEVD05, <a href="https://lattix.com/dev/files/wp/oopsla05.pdf">Using Dependency Models to Manage Complex Software Architecture</a></p>

<p>JNW73, <a href="https://systemsconcept.org/html/Content/BM_1973%20.pdf">Binary Matrices in System Modeling</a></p>

<p>TS94, <a href="http://web.mit.edu/eppinger/www/pdf/Pimmler_DTM1994.pdf">Integration analysis of product decompositions</a></p>

<p>RAC08, <a href="https://www.tandfonline.com/doi/abs/10.1080/09544820802563226">Systematic module and interface definition using component design structure matrix</a></p>

<p>SS07, <a href="http://www.leonidzhukov.net/hse/2018/sna/papers/GraphClustering_Schaeffer07.pdf">Graph clustering</a></p>

<p>FM13, <a href="https://arxiv.org/pdf/1308.0971.pdf">Clustering and Community Detection in Directed Networks: A Survey</a></p>

<p>SYG09, <a href="https://www.cs.drexel.edu/~yfcai/papers/2009/ASE2009_drh.pdf">Design Rule Hierarchies and Parallelism in Software Development Tasks</a></p>

<p>RYR15, <a href="https://apps.dtic.mil/dtic/tr/fulltext/u2/a621415.pdf">Hotspot Patterns: The Formal Definition and Automatic Detection of Architecture Smells</a></p>

<p>SA14, <a href="https://www.researchgate.net/profile/Andy_Dong/publication/269279676_A_spectral_analysis_software_to_detect_modules_in_a_DSM_Risk_and_change_management_in_complex_systems/links/54dc1a540cf28d3de65ea241.pdf">A Spectral Analysis Software to Detect Modules in a DSM</a></p>

<p>MAC06, <a href="https://pdfs.semanticscholar.org/cbfe/a3d346938dba911239502cc97b282668af71.pdf">Exploring the Structure of Complex Software Designs: An Empirical Study of Open Source and Proprietary Code</a></p>

<p>GG04, <a href="https://proceedings.asmedigitalcollection.asme.org/proceeding.aspx?articleid=1651497">A Comparison of Modular Product Design Methods on Improvement and Iteration</a></p>

<p>KO11, <a href="https://hal.archives-ouvertes.fr/hal-00571207/document">Degree of Modularity in Engineering Systems and Products with Technical and Business Constraints</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(12)]]></title>
    <link href="http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12/"/>
    <updated>2019-04-23T15:59:14-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/04/23/software-design-and-architecture-notes-12</id>
    <content type="html"><![CDATA[<h2>设计原则与代码味道</h2>

<p>在此之前我们已经讨论了<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">面向对象分析与设计</a>、<a href="http://www.hanyi.name/blog/2019/03/10/software-design-and-architecture-notes-10/">领域分析及其模式</a>以及<a href="http://www.hanyi.name/blog/2019/03/29/software-design-and-architecture-notes-11/">设计模式</a>。其中朴素的分析和设计方法具有通用性，但需要长期的实际经验积累，在这一过程中不可避免会付出一定代价。虽然模式提供了可复用的设计元素，但基本都存在特定上下文的限制。尽管仍有新的模式不断被提出，但并不意味着其适用性和局限性已被明确认识。同样是来源于经验，有一些设计知识能适用于绝大多数场景，从而具备更广泛的适用性，这就是本文首先要讨论的<strong>设计原则</strong>。设计原则是来源于实际经验且能够指导一般软件设计的法则，其根本动机是发现并解决软件设计问题。</p>

<p>一般而言，发现软件设计问题的终极方法是以真实需求为基础构建软件，然后收集并分析该软件的开发和运行反馈——显然这种方式的代价过于昂贵。一种退而求其次的办法是构建原型系统，在原型阶段只考虑待验证的核心功能，尽早交付给用户使用并收集相关反馈，该方法使软件设计能够更快响应变化。但是我们知道设计复杂度与问题的复杂度是正相关的，而<strong>易变性</strong>又是软件设计的一个重要特征，因此从原型获得一次反馈的效用会随着时间推移和问题复杂度的增加而逐步降低，于是需要缩短反馈周期以实现频繁反馈。高反馈频率意味着更高的交付效率，然而交付效率的提升又有赖于恰当的工程方法和可扩展的设计。因此，“黑盒”式的问题反馈方法虽然为设计问题发现提供了事实依据，但其效率受软件自身设计问题所制约。另一方面，从最初采集得到反馈到定位具体设计问题，对问题根因可能存在不同解读方式，导致最终结论的有效性也可能面临挑战。</p>

<p>幸运的是软件开发并非孤立问题，软件设计实践中遇到的问题及其解决方案往往具有普遍性。在这些知识的基础上诞生了一系列被普遍认可的、“白盒”式的设计原则，使软件设计中的潜在问题能够被更早发现和解决。应注意，某些设计原则是针对特定上下文，例如Liscov替换原则之于OO，更多则适用于广泛的上下文。本文剩余部分首先介绍设计原则背后的核心设计属性，然后按所适应的场景分组并讨论经典的设计原则，最后讨论相比于设计原则更轻量、更贴近日常编程活动、且涵盖更广泛的经验知识——代码味道及其与设计原则之间由表及里的内在联系。</p>

<h3>设计属性和通用设计原则</h3>

<p>每提起设计原则就会出现许多经典的名字和概念，但诸多原则都表现了相对稳定的设计属性，这些属性往往也是软件设计领域中的核心概念，且在前文大多已经讨论过：</p>

<ul>
<li><p><strong>耦合性</strong>(Coupling)，即模块间依赖的程度，耦合越高则意味着该模块将难以被维护，详见<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">结构化设计方法</a>。</p></li>
<li><p><strong>内聚性</strong>(Cohesion)，即模块具有单一目的性的程度，内聚越高则意味着更好的可理解性和可重用性，详见<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">结构化设计方法</a>。</p></li>
<li><p><strong>正交性</strong>(Orthogonality)，即模块能够独立发生变化的程度，具有正交性的模块意味着更容易应对变化。正交性最初被用于描述一种针对关系数据库的设计原则[DC93]，即对于任意两个相互独立的表，其无损分解后的子集不存在相互重叠的情况，该原则能够帮助发现关系数据库设计存在的数据冗余问题。[AD00]详细解释了正交性在更广泛的软件设计问题中的意义，特别是其在模块化、组件化、分层设计等不同设计方法中的一致性体现。</p></li>
<li><p><strong>信息隐藏性</strong>(Information hiding)，即模块尽力隐藏其实现细节的程度，具有信息隐藏的模块通常意味着更低的耦合性，详见<a href="http://www.hanyi.name/blog/2018/10/03/software-design-and-architecture-notes-3/">模块化编程</a>。</p></li>
</ul>


<p>设计属性为评估设计质量建立了基础，但由于更加强调概念完整性，使其在形式上很难直接与具体的设计问题相关联，于是就出现了数量更多且更具实践意义的设计原则。对于早期提出的、通用的设计原则来说，其可能借鉴自其它领域，例如:</p>

<ul>
<li><p><strong>关注点分离</strong>(Separation of concerns, SoC)，即把注意力集中在某个方面，而非与其它无关方面相混淆。该原则最初来源于Dijkstra对计算领域中科学性思维属性的探索[EWD74]，后来被引入软件设计领域，用于强调软件模块之间应具有尽可能少的特性重叠。</p></li>
<li><p><strong>一次且仅一次</strong>(Once and only once)，也称Don&rsquo;t repeat yourself，DRY。指任何知识都应在系统中有唯一、清晰和权威的表示。该原则适用于许多软件设计领域。例如<strong>单一数据源</strong>(Single source of truth, SSOT)，指系统中的任何数据元素都只有一份，任何其它具有相同定义的数据都是该唯一元素的引用，目的是保证数据的完整性和规范性。</p></li>
<li><p><strong>保持简洁</strong>(Keep it simple stupid, KISS)，简洁意味着易于理解、维护和扩展。KISS旨在强调简洁性对于系统设计的重要性。实际上简洁性还普遍适用于设计、建筑和哲学等其它领域，例如Simplicity is the ultimate sophistication，Brevity is the soul of wit，Less is more，Make simple tasks simple以及Simplify, then add lightness等。</p></li>
</ul>


<h3>实体设计原则</h3>

<p>实体通常指软件中表示模块的单位，例如存在于许多编程范式中的类、模块等元素。针对实体的代表性设计原则如下:</p>

<ul>
<li><p><strong>单一职责</strong>(Single responsibility)，指任意实体应只有一个使其产生变更的原因。这里“产生变更的原因”等价于实体的职责，即要求实体具有尽可能少的变化维度。单一职责原则是表述最简单的设计原则之一，也是最难被遵循的原则。这是因为职责的定位和分离会随着上下文变化而不同，这需要一定的实践经验和分析过程，且缺少直观的量化手段。尽管如此，单一职责原则仍有可能通过遵循其它设计原则而间接实现。</p></li>
<li><p><strong>开放-封闭</strong>(Open closed)，指任意实体应对扩展开放，对修改封闭[BM88]。当程序需要发生变更时，应尽可能通过添加新的代码而非修改已有代码来完成，即增量扩展。频繁发生修改的实体通常是难以被预测和重用的。值得注意的是，对大多数软件设计来说，保证100%对修改封闭是难以实现的。因此实际中通常采用一些策略性封闭方法，例如:</p>

<ul>
<li><p>采用抽象加强显式封闭。如果新的需求导致无法满足对修改封闭，首先应考虑当前的抽象设计，是否需要调整或引入新的抽象从而加强显式封闭特性。</p></li>
<li><p>采用数据驱动实现封闭。当修改可能影响同一抽象层级下的许多实体时，可以考虑采用配置数据驱动代码的方式限制修改的影响范围。该方法能够避免引入额外依赖，同时把修改封闭在尽可能小的范围。</p></li>
</ul>


<p>无论是采用抽象还是数据驱动方法，都有可能引入新的封闭性问题。因此实践中往往需要不断考虑并扩展实体对修改的封闭性。</p></li>
<li><p><strong>Liskov替换</strong>(Liskov substitution)，如果S是T的子类型，那么对T的任意对象的引用可以被直接替换为S的对象，且毋须修改已有代码。Liskov原则中的“替换”不仅是指语法上父子类型相互兼容，进一步子类型应当保留父类型中的不变量(见<a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">设计契约</a>)，从而实现在语义层面的兼容。在类型系统中，前述这种更趋严格的子类型定义被称作<strong>行为子类型</strong>(Behavior subtyping)[LB87]。</p></li>
<li><p><strong>接口隔离</strong>(Interface segregation)，指客户端不应被强迫依赖于它们不用的接口。当实体中需要引入一个新的公共方法时，一般会在其接口中声明具有相同签名的方法。如果该抽象层级下对应了多个子类型，但并非所有子类型都需要新声明的方法时，就意味着发生了<strong>接口污染</strong>，这种接口也被称作”胖接口”。依赖于胖接口的客户端代码被迫依赖于许多对它们来说无意义的接口，从而大幅增加了级联变更发生的概率。</p></li>
</ul>


<h3>实体依赖原则</h3>

<p>软件的不同实体之间通常存在着依赖关系，针对实体间依赖的代表性设计原则如下:</p>

<ul>
<li><p><strong>依赖倒置</strong>(Dependency inversion)，指高层实体不应依赖低层实体，两者都应该依赖于抽象;抽象不应依赖细节，细节应依赖抽象。当发生直接依赖的实体之间同时存在层级关系时，应当使其依赖共同的抽象。</p></li>
<li><p><strong>控制反转</strong>(Inversion of control)，指通过框架实现程序的控制流，从而操作客户端代码以实现自定义扩展[MFR05]。传统上软件由客户端代码和所依赖的代码库组成，其中客户端代码扮演了负责控制流的角色。为了实现可扩展性，需要首先建立抽象，框架就是集合了众多抽象设计的代码骨架，其中提供了客户端代码的接口，但控制流就从客户端移交到框架端。该原则也被称作<strong>好莱坞原则</strong>(Hollywood principle)，即<strong>Don&rsquo;t call us, we&rsquo;ll call you</strong>。</p></li>
<li><p><strong>最少知识</strong>(Least knowledge)，也称<strong>迪米特法则</strong>(Law of demeter)[LHR88]。对于任何类C以及C中的方法M，M中发生直接调用的对象的类应符合以下两种情形之一:</p>

<ul>
<li><p>方法M的参数对象所属的类(参数对象可以是M中创建的对象、M中发生的函数调用所创建的对象、或者是M中引用的全局变量对象，包括C)。</p></li>
<li><p>类C中任何实例变量对象所属的类。</p></li>
</ul>


<p>应用最少知识原则能够降低系统本身和对其修改的复杂度。该原则的另一个名字“迪米特”是最初应用该项原则所设计的OO系统[LHR88]。</p></li>
</ul>


<h3>包设计原则</h3>

<p>与Java的package和C++的namespace等关键字不同，包在设计原则的上下文中是指独立的可交付物(有时也被称作<strong>组件</strong>)，例如jar包和dll文件。包是常见于大规模的软件系统中的概念，这里的“规模”没有具体的量化指标，可能是指代码行数、团队大小以及系统复杂度等。针对包的代表性设计原则如下:</p>

<ul>
<li><p><strong>重用-发布等价</strong>(Reuse-Release equivalency)，指可重用代码的粒度不应小于代码的可发布粒度。我们知道可重用性是OOD的一个重要属性，可重用的代码应遵循如下原则:</p>

<ul>
<li><p>可以被独立开发、维护、测试、分发。</p></li>
<li><p>具体实现对外部隐藏，只通过<strong>发布接口</strong>(Published Interface)对外公开[MFR02]。</p></li>
</ul>


<p>违反上述原则的代码重用通常都具有副作用，例如<strong>代码复制</strong>(Code clone)、破坏代码封装导致的<strong>强耦合</strong>等。针对这些问题，在可发布粒度上实现代码重用是一种有效的解决办法，该方法通过封装和可追踪使代码具有更好的可重用性，包就是实现这种可发布粒度的有效途径。</p></li>
<li><p><strong>共同封闭</strong>(Common closure)，指包中的不同实体应当封闭于相似的修改原因。根据前文对开放-封闭原则的讨论，实际中始终存在无法令实体对其封闭的修改。而如果不同实体具有共同的修改，那么应使它们属于同一个包。也就是说，同类型的修改应尽可能被限制于最少数量的包中。</p></li>
<li><p><strong>共同重用</strong>(Common reuse)，指包中的不同实体应当具有被共同使用的倾向。一般情况下，如果某些实体之间存在抽象层级的协作关系，那么它们应属于同一个包。否则，仅针对个别实体的修改可能引起跨包修改，从而存在较高风险。与共同封闭原则类似，该原则有利于加强包的可维护性，这在大多数上下文中比可重用性更加重要。</p></li>
</ul>


<h3>包依赖原则</h3>

<p>与实体间存在依赖关系类似，包之间也存在依赖关系，针对包之间依赖的代表性设计原则如下:</p>

<ul>
<li><p><strong>无环依赖</strong>(Acyclic dependencies)，指包之间的依赖关系图应是一个有向无环图(DAG)。作为可发布的软件单元，不同包之间不可避免着存在着依赖关系。如果软件系统中存在包的循环依赖关系，即环形依赖，则可能导致以下问题:</p>

<ul>
<li><p>依赖环中的所有包存在共同修改的可能，破坏了可独立发布的属性。</p></li>
<li><p>包可能间接依赖于大量其它包，从而降低可维护性。</p></li>
</ul>


<p>一种解决循环依赖的方法是应用依赖倒置原则，提取依赖的共同抽象。另一种方法是把现有包中被依赖的部分抽取出来组成新的包。</p></li>
<li><p><strong>稳定依赖</strong>(Stable dependencies)，指包之间应遵循更加稳定的依赖方向。如果一个模块是易变的，那么对该模块的依赖在很大程度上也是易变的，这种<strong>易变性</strong>(Volatility)会沿着依赖的方向传递，从而影响整个系统的可维护性。然而由于软件的易变性可能存在许多影响因子，不同影响因子所导致的后果也不尽相同。其中<strong>稳定性</strong>(Stability)被用于描述模块修改的难易程度，即当模块越难以被修改即越稳定。Uncle Bob提出了一种稳定性的度量指标，可以用如下形式计算:</p>

<p>Ca: 传入耦合(Afferent coupling)，依赖于当前包内实体的外部实体数量。</p>

<p>Ce: 传出耦合(Efferent coupling)，依赖于外部实体的包内实体数量。</p>

<p>I: 不稳定系数(Instability)，且I = Ce ÷ (Ca + Ce)，则I范围是[0,1]，当I=0时当前包最稳定，I=1时则最不稳定。</p>

<p>因此，被依赖的包应具有比依赖包更大的I值，即满足稳定依赖原则。</p></li>
<li><p><strong>稳定抽象</strong>(Stable abstractions)，指稳定性越高的包也应越抽象，反之则越具体。由于高度稳定的包往往难以被修改，因此其应尽可能抽象，从而使系统的易变部分始终保持在不稳定包的具体实现中。包的抽象程度被称作<strong>抽象性</strong>，与稳定性相同，Uncle Bob提出了抽象性A的计算方式:</p>

<p>A = 抽象实体数 ÷ 实体总数。</p></li>
</ul>


<p>根据稳定性和抽象性的定义，理想情况下的软件系统应呈现类似如下线性关系:</p>

<p><img src="http://content.hanyi.name/images/design_principles/abstraction_instability.png" alt="Abstraction-Instability graph" /></p>

<p>也就是说，当已知某个包的稳定性和抽象性度量时，我们就可以进一步计算它们在上述坐标中偏离理想值的程度，用距离D表示这种程度，从而有:</p>

<p>D = |(A + I - 1) ÷ √2|</p>

<p>在实际中能够通过计算包的D值，从而决定包的设计合理性，D值越大的包应优先被关注和改进。</p>

<h3>代码味道</h3>

<p>相比于设计原则，代码味道是一种更加轻量的、被用于识别设计问题的方法。如果把具有良好设计的代码视作是干净无味的话，那么代码味道则可被用于发现那些“显而易见”的“异常”代码。“味道”一词并不是一个正式的概念，Martin Fowler认为代码味道应具备三个基本特征[MFR06]:</p>

<ul>
<li><p>代码味道应是易于被察觉的。</p></li>
<li><p>代码味道不一定表示代码中存在设计问题，即使存在“问题”，也有可能是因为设计权衡的结果。</p></li>
<li><p>代码味道非常易于被程序员理解和掌握，基于代码异味的重构使新手程序员也有机会持续改进设计，即使在缺少对深层次设计原则理解和相关经验的情况下。</p></li>
</ul>


<p>与设计原则类似，按照作用层级可以把代码异味划分为方法、实体(类和模块)以及通用三个类别。</p>

<ul>
<li><p>具有代表性的方法级代码味道包括:</p>

<ul>
<li><strong>长方法</strong>(Long function)和<strong>长参数列表</strong>(Long parameter list)，不仅导致代码难于理解，还可能违反单一职责原则。</li>
<li><strong>重复switch</strong>(Repeated switches)，尽管switch语句具有易于理解的结构，但可能违反开放-封闭原则，特别是当相似结构的switch语句重复出现时，会相应存在多处需要同时被修改的代码。</li>
<li><strong>循环</strong>(Loops)，随着内循环和管道式编程的普及，常规的外循环语句由于相对复杂的结构已经成为循环计算的备选方案。</li>
<li><strong>特性依恋</strong>(Feature envy)，指实体中的某个方法过度依赖了其它实体中的数据或方法，进而可能违反了关注点分离原则。</li>
</ul>
</li>
<li><p>具有代表性的实体级代码味道包括:</p>

<ul>
<li><strong>临时值域</strong>(Temporary field)，指实体中仅在部分情况下有效的属性，这可能违反单一职责原则和关注点分离原则。</li>
<li><strong>消息链</strong>(Message chains)，如果存在对象的方法的链式调用，且每个阶段的调用都作用于不同对象，这种消息链可能违反了最少知识原则。</li>
<li><strong>中间人</strong>(Middle man)，指缺少实际意义的代理方法。尽管封装被作为是OO的重要特征，但某些时候存在不合理的封装，例如一些实体中存在的代理方法，其作用仅是分离了真正的调用对象和被调用对象，这可能违反了单一职责原则和关注点分离原则。</li>
<li><strong>内幕交易</strong>(Insider trading)，指实体间发生数据处理和相互传递的现象。数据交易可能会引起过度耦合，但有时很难完全避免，因此需要尽可能减少此类现象出现的频率。</li>
<li><strong>过大的类</strong>(Large class)，指一些包含了大量属性的类。这可能违反了单一职责原则和关注点分离原则。</li>
<li><strong>异曲同工的类</strong>(Alternative classes with different interfaces)，指某些具有相同类型特性的类，因其具有不同接口而无法利用OO的多态性。</li>
<li><strong>数据类</strong>(Data class)，指只包含可被外部读写的属性的类，导致有关该类的操作散布在不同的类中，这可能违反单一职责原则。</li>
<li><strong>被拒绝的馈赠</strong>(Refused bequest)，指在继承关系中，子类拒绝或忽略了父类中的某些方法或数据，这可能违反接口隔离原则。一种解决办法是创建父类的兄弟类，使方法和数据相分离——这只在具有良好抽象意义的情况下有效，否则可能会引入更多复杂度，反而得不偿失。如果现有抽象更加稳定，而“被拒绝”的元素又足以影响可维护性，更有效的办法是抽取新的类，并采用对象代理关系替换原有继承关系。</li>
</ul>
</li>
<li><p>具有代表性的通用代码味道包括:</p>

<ul>
<li><strong>数据泥团</strong>(Data clumps)，指某些经常同时出现的数据组合，其出现场景可能包括不同类中的属性、许多方法签名的参数等。通常可以采用创建新的类表示这些数据组合。</li>
<li><strong>重复代码</strong>(Duplicated code)，指相同或相似的代码结构在程序中多次出现的现象。最易被识别的重复代码通常发生在同一个类或拥有继承关系的多个类中，也比较容易被消除。除此之外，对重复代码的识别和解决都可能需要进一步的设计权衡。</li>
<li><strong>全局数据</strong>(Global data)，特别是可变的全局数据，即全局变量。我们已经多次强调了这种共享可变状态的代码可能导致潜在的质量和可维护性问题。实际上，即使是非共享状态的<strong>可变数据</strong>(Mutable data)，依然可能导致代码质量问题。</li>
<li><strong>发散式变化</strong>(Divergent change)，即某个模块可能会由于不同原因而导致不同方式的修改，违反了单一职责原则。如果修改原因只有一种，但引起了其它模块发生多次级联修改，则称作<strong>霰弹式修改</strong>(Shotgun surgery)。</li>
<li><strong>基本类型偏执</strong>(Primitive obsession)，指采用基本类型表示某些复杂数据类型，而非创建独立的类，这可能导致大量的重复代码。</li>
<li><strong>懒元素</strong>(Lazy element)，指某些设计元素(例如类、实体)只有非常简单的功能，甚至使用一、两行代码就能清楚表现该元素的特性，那么他们就没有单独存在的必要。与之表现形式相反，但具有统一思想的<strong>夸夸其谈未来性</strong>(Speculative generality)，或者称作<strong>大设计先行</strong>(Big design up front, BDUF)，则表示发生了过度设计。</li>
<li><strong>过高的圈复杂度</strong>(High cyclomatic complexity)，指代码中存在过度复杂的控制流图。圈复杂度通常用代码中的线性逻辑路径数进行表示。假设用N表示代码中的基本区块(指不包含任何控制分支的连续代码片段)数，E表示连接基本区块的边数，P表示连通子图数，那么圈复杂度M可用公式M = E - N + 2P进行计算。过高的圈复杂度可能意味着过度复杂的逻辑或缺少结构性的代码。</li>
<li><strong>神秘命名</strong>(Mysterious name)和<strong>注释</strong>(Comments)，这两种代码味道经常同时出现，因为合理的命名更加表意，也就降低了额外注释的必要性。当然在某些时候再合理的命名也无法表达某些上下文时，注释则是必要的补充。</li>
</ul>
</li>
</ul>


<p>尽管前述大部分的代码味道都有“程度”的概念，使其具体的应用仍然依赖实际经验，但仍然有一些可以遵循的规则。例如，针对重复代码的<strong>事不过三规则</strong>(Rule of Three)，这里虽然中文成语中的数量是虚指，但具体应用时可以作为实际阈值，也就是说当重复代码出现三次时，就应考虑采取相应解决方案了。当然这种规则只能作为初步判断条件，进一步仍然需要结合设计原则进行恰当分析。</p>

<h2>结论</h2>

<p>为了发现和定位软件设计中存在的问题，人们在实践中总结出了一系列具有普遍意义的设计原则。看似纷繁复杂的设计原则其实体现了一致的设计属性，并在长期的设计分析和验证过程中不断得到认可。为了进一步缩短软件设计的反馈周期，在代码编写活动中就可以通过识别代码味道尽早发现潜在的设计问题，并通过持续重构保证软件的设计质量。</p>

<h2>引用</h2>

<p>DC93, <a href="http://web.archive.org/web/20100224075429/http://www.dbdebunk.com/page/page/622331.htm">The Principle of Orthogonal Design</a></p>

<p>AD00, <a href="https://www.nceclusters.no/globalassets/filer/nce/diverse/the-pragmatic-programmer.pdf">The Pragmatic Programmer: From Journeyman to Master</a></p>

<p>EWD74, <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html">On the role of scientific thought</a></p>

<p>BM88, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/POO-2016-01/documentos/Object%20Oriented%20Software%20Construction-Meyer.pdf">Object Oriented Software Construction</a></p>

<p>LB87, <a href="https://klevas.mif.vu.lt/~plukas/resources/OODPrinciples/Liskov1987.pdf">Data Abstraction and Hierarchy</a></p>

<p>LHR88, <a href="https://www2.ccs.neu.edu/research/demeter/papers/law-of-demeter/oopsla88-law-of-demeter.pdf">Object-Oriented Programming: An Objective Sense of Style</a></p>

<p>MFR00, <a href="https://martinfowler.com/books/refactoring.html">Refactoring: Improving the Design of Existing Code</a></p>

<p>MFR02, <a href="https://martinfowler.com/bliki/PublishedInterface.html">Published Interface</a></p>

<p>MFR05, <a href="https://martinfowler.com/bliki/InversionOfControl.html">Inversion Of Control</a></p>

<p>MFR06, <a href="https://martinfowler.com/bliki/CodeSmell.html">CodeSmell</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(11)]]></title>
    <link href="http://www.hanyi.name/blog/2019/03/29/software-design-and-architecture-notes-11/"/>
    <updated>2019-03-29T15:50:14-04:00</updated>
    <id>http://www.hanyi.name/blog/2019/03/29/software-design-and-architecture-notes-11</id>
    <content type="html"><![CDATA[<h2>设计模式——动机与陷阱</h2>

<p>作为软件设计领域在过去三十多年里最重要的议题之一，时至今日，新的设计模式仍不断被提出和采用。软件设计模式的根本目的是为特定上下文提供经受验证的、可复用的元素，从而提高软件工业的生产效率。该领域在早期是伴随着OO的流行逐渐发展起来的[GHJV95]，前文所讨论的<a href="http://www.hanyi.name/blog/2019/03/10/software-design-and-architecture-notes-10/">领域分析模式</a>就是OOA相关的模式，此类模式侧重分析和描述问题域本身。OOD/OOP等活动中存在的模式被称为<strong>设计模式</strong>，后者用于描述通用代码设计过程中经常重现的组件结构。</p>

<p>为了便于交流和传播，每种设计模式最为人所知的部分就是名字和典型结构。实际上这是一把双刃剑。一方面它确实促进了模式在业界的普及，起到了良好的教育作用；另一方面，对设计模式的描述往往只表现出其中一面，背后其实隐藏了的许多问题，例如:</p>

<ul>
<li><p>根本动机，即模式要解决的原始问题，这对于理解模式的适用性非常重要。在不适用场景中应用模式实际上破坏了模式原本的经济效益。</p></li>
<li><p>复杂性，例如具有较高的实现复杂性，带缺陷的模式实现会引入更加隐蔽的问题。有时候这种复杂性与具体语言相关，因此语言特定的<strong>惯用法</strong>(idioms)也成为一种较底层的模式[BMRSS96]。</p></li>
<li><p>非适用场景，例如缺少明确的非适用场景的描述，而这部分信息有助于快速排除候选模式。</p></li>
<li><p>替代方案，例如缺少对已知的非适用场景的替代解决方案。</p></li>
</ul>


<p>上述问题的存在使应用设计模式面临许多挑战。对于这些经典设计模式的“动机与陷阱”，本文将在剩余部分逐一展开讨论。</p>

<h3>单例模式(Singleton Pattern)</h3>

<p>在OOD中经常会遇到整个系统要求某个类只产生唯一实例的情况，例如Printer spooler、A/D converter等。单例模式通过限制访问构造方法，并向全局提供统一的实例获取接口，从而保证所生产实例的唯一性，如下图所示：</p>

<p><img src="http://content.hanyi.name/images/design_patterns/singleton_pattern.png" alt="Singleton pattern" /></p>

<p>系统也可能允许某个类创建特定数量的实例，此时可以用Map结构的instances存储对应多组实例，即<strong>多例</strong>(Multiton)模式。虽然单例模式利用OO语言的特性实现了对任意创建实例的限制，但实际上可能引入更多问题。以基于Java语言的单例模式实现为例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public final class Singleton {
</span><span class='line'>    private static final Singleton INSTANCE = new Singleton();
</span><span class='line'>
</span><span class='line'>    private Singleton() {}
</span><span class='line'>
</span><span class='line'>    public static Singleton getInstance() {
</span><span class='line'>        return INSTANCE;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>与上述采用普通类的实现相比，Java的<strong>单元素枚举</strong>模式具有更加简洁的实现，例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum Singleton {
</span><span class='line'>    INSTANCE;
</span><span class='line'>
</span><span class='line'>    Singleton();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>依据JVM规范中的类加载机制，作为静态常量的INSTANCE初始化会在Singleton类初始化过程中进行，而后者的发生需要满足且不限于以下条件之一：通过new运算符初始化实例;对类的非常静态变量进行读写操作;调用类的静态方法;通过反射调用类;类包含main函数。可见，由于类初始化条件的复杂性，INSTANCE初始化时机是无法得到有效控制的。一种结合懒求值模式的实现能够把INSTANCE初始化从类初始化的过程中分离出来:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public final class Singleton {
</span><span class='line'>    private static Singleton instance = null;
</span><span class='line'>
</span><span class='line'>    private Singleton() {}
</span><span class='line'>
</span><span class='line'>    public static Singleton getInstance() {
</span><span class='line'>        if (instance == null) {
</span><span class='line'>            instance = new Singleton();
</span><span class='line'>        }
</span><span class='line'>        return instance;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在多线程场景下，上述实现无法保证Singleton只初始化一次。一种解决办法是把getInstance方法声明为synchronized，但会显著影响程序运行效率。另一种办法是采用<strong>双重检查锁</strong>(Double-checked locking)模式，这时需要把instance变量声明为volatile以保证可见性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public final class Singleton {
</span><span class='line'>    private static volatile Singleton instance = null;
</span><span class='line'>
</span><span class='line'>    private Singleton() {}
</span><span class='line'>
</span><span class='line'>    public static Singleton getInstance() {
</span><span class='line'>        if (instance == null) {
</span><span class='line'>            synchronized(Singleton.class) {
</span><span class='line'>                if (instance == null) {
</span><span class='line'>                    instance = new Singleton();
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return instance;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>事实上，如果充分利用Java的类初始化的原理，则可以借助<strong>按需初始化持有者</strong>(Initialization-on-demand holder)模式实现更高效的懒求值单例模式:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public final class Singleton {
</span><span class='line'>    private Singleton() {}
</span><span class='line'>
</span><span class='line'>    private static class LazyHolder {
</span><span class='line'>        static final Singleton INSTANCE = new Singleton();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public static Singleton getInstance() {
</span><span class='line'>        return LazyHolder.INSTANCE;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上述结合多种模式的实现，看似解决了单例模式在Java并发程序中存在的问题，但因其较复杂的代码实现而影响了程序的可理解性。</p>

<p>单例模式的另一个复杂性在于其向系统中引入了全局状态特性，后者被公认为是影响软件质量和可维护性的重要反模式之一。因此，具有可变特性的单例模式实现应受到特别关注。而如果单例模式具有不可变特性，那么可以考虑采用无状态的<strong>工具类</strong>(Utility class)模式，即其携带的所有方法均为静态方法，且无法被用于创建任何实例，例如经典的工具类java.lang.Math。与单例类模式通常会引入额外复杂性相反，工具类模式有时会存在过度简化的问题，因为后者消除了抽象层级存在的可能，使得每次对工具类的引用都造成强依赖关系，即“不够OO”。因此，在采用工具类模式前，应充分理解所在领域与系统核心领域之间的关系及其作用。此外，无论是单例模式还是工具类模式，都可能会影响具体实现代码的可测试性，这点对于Java语言尤为如此。</p>

<p>虽然单例模式使OO在行为上更加接近真实世界，但其可能会引入一系列负面影响。尽管有针对性的模式试图消除这些影响，但始终难以避免引发新的问题，最终仍有可能得不偿失。因此，采用普通类始终是解决前述问题的首选替代方案。</p>

<h3>工厂模式(Factory Patterns)</h3>

<p>工厂模式是指一系列模式，这些模式被用于把实例的创建过程从现有应用逻辑中分离出来，从而更好地管理复杂性。例如，一个Color类可能包含如下构造函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Color(String rgb) {//...}
</span><span class='line'>Color(int red, int green, int blue) {//...}
</span><span class='line'>Color(int hex) {//...}</span></code></pre></td></tr></table></div></figure>


<p>注意上述构造函数的参数其实相当于Color的不同表示形式，这种构造过程更像是在进行类型转换，采用<strong>静态工厂方法</strong>(Static factory method)可以令其更加表意:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static from(String rgb) {//...}
</span><span class='line'>static from(int red, int green, int blue) {//...}
</span><span class='line'>static from(int hex) {//...}</span></code></pre></td></tr></table></div></figure>


<p>上述类型转换也可以支持聚合类型，例如java.util.EnumSet的of方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E first, E... rest) {//...}</span></code></pre></td></tr></table></div></figure>


<p>静态工厂方法也支持创建不属于当前类的实例，例如java.util.Arrays和java.nio.Files等工具类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static &lt;T&gt; List&lt;T&gt; asList(T... a) {//...}
</span><span class='line'>static BufferedReader newBufferedReader(Path path) {//...}</span></code></pre></td></tr></table></div></figure>


<p>除了上述语法糖特性外，静态工厂方法还允许对实例进行缓存，从而控制新实例创建，例如单例模式中的静态方法getInstance。另外，还可以通过设置输入参数返回不同子类型的实例，例如java.util.EnumSet，该抽象类并不提供公共构造函数，而是通过静态工厂方法对输入数据进行分类，按照输入的元素数量自动选择RegularEnumSet或是JumboEnumSet的子类实现。</p>

<p>静态工厂方法是对Java语言中new运算符的替代方案，由于其更好的表意性，该方法通常被用于为编程框架提供统一界面。但是如果某个类只提供静态工厂方法，也就意味着该类无法被正确继承，从而限制OO的抽象类型特性。Java语言中采用静态方法也会影响代码的可测试性。</p>

<p>基于OO的代码框架设计通常采用抽象类或接口表示对象及其相互关系，有时需要负责提供对象创建的功能，但在抽象层级无法确定具体类型。因此先定义抽象的对象创建方法，然后在子类中进行具体实现，该模式被称作<strong>工厂方法</strong>(Factory method):</p>

<p><img src="http://content.hanyi.name/images/design_patterns/factory_method.png" alt="Factory method pattern" /></p>

<p>虽然工厂方法通过采用抽象类型延后了对象的具体类型确定。但是这也意味着始终要配合ConcreteProduct衍生出对应的ConcreteCreator，这种<strong>平行类层级结构</strong>能起到分离职责的作用，但也可能会引入过多的复杂性。</p>

<p>当相关的对象属性或行为随上下文变化时，Client需要根据条件创建不同的对象，于是就产生了对所有相关对象所属类的依赖。这时Client的复杂性会同时受到两个维度的影响：</p>

<ul>
<li><p>对象创建过程的复杂性。</p></li>
<li><p>对象所属的抽象类型数量。</p></li>
</ul>


<p>通过独立的工厂类对相关对象的创建过程进行封装，并从中抽取统一的抽象接口，这就是<strong>抽象工厂</strong>(Abstract factory)模式。其基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/abstract_factory.png" alt="Abstract factory pattern" /></p>

<p>借助抽象工厂模式，Client只需要依赖于Product和Factory的抽象类型，从而具有更好的可扩展性。当面临更复杂的场景时，抽象工厂模式就显得不够灵活，这里所说的复杂性具体存在两种情况:</p>

<ul>
<li><p>创建Product依赖于复杂的初始化参数列表，且具有复杂的实现过程。</p></li>
<li><p>Product具有很多类别且经常发生变化，那么AbstractFactory及其子类也会相应增多且面临频繁修改。</p></li>
</ul>


<p>一种能够避免创建工厂类且同样能够分离对象创建过程的途径是采用<strong>原型</strong>(Prototype)模式，后者允许通过复制一个已存在的对象从而快速创建新对象。原型模式的基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/prototype.png" alt="Prototype pattern" /></p>

<p>当已经存在一个原型对象时，Client就能通过调用原型对象的clone方法快速创建新对象。这里的原型对象可以采用任意方式创建，例如new运算符或者其它工厂模式。原型模式主要解决以下两个问题:</p>

<ul>
<li><p>要创建的对象具有复杂的初始化参数列表。</p></li>
<li><p>在运行时才能确定要创建的对象所属类型。</p></li>
</ul>


<p>Java语言中的Object类提供了默认的clone方法(浅拷贝)，但对象所属的类需要包含Cloneable标记接口才能调用和覆盖Object中的clone方法(例如实现深拷贝)。然而无论是实现浅拷贝还是深拷贝，clone方法都会为对象实现引入额外的复杂度，特别是当对象拥有较深的类层级结构或嵌套引用时，如何保证clone方法的正确性和一致性会遭遇挑战。</p>

<p>原型模式可以看作是对其它工厂模式的补充，其有效性依赖于已经存在的原型对象，因此存在较严格的适用场景。相比之下，<strong>建造者</strong>(Builder)模式则是一种通用性更强、更加灵活的对象创建模式。与抽象工厂通过实例方法直接创建对象不同，建造者模式把复杂对象的创建过程划分为相互独立的子过程，最后通过调用build方法生成所需的完整对象。该模式具有如下结构:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/builder.png" alt="Builder pattern" /></p>

<p>建造者模式允许更加可控的对象创建过程，而非传统上通过构造函数或setter方法准备对象所需的输入，因此具有更加表意、灵活且一致的优点。然而与抽象工厂类似，当具有许多不同类型的Product时，就需要创建对应的ConcreteBuilder，从而可能引入额外的复杂性。</p>

<h3>依赖注入模式(Dependency Injection Pattern)</h3>

<p>借助工厂模式，Client能够方便地创建所需的对象。但无论是工厂方法还是抽象工厂，目标对象始终是由Client通过直接或间接方法调用而创建的，因此两者之间依然存在较强的依赖关系。而在多数情况下，Client只关心依赖对象所提供的相关特性，而非对象的创建过程。另一方面，由于语言自身条件的制约(例如Java)，单元测试难以利用stub/mock技术隔离目标代码内部动态创建的对象，导致单元测试的高实现成本和低运行效率。为了解决前述问题，可以把创建对象的职责从Client彻底分离出来，即在外部完成对象创建，然后依照Client的实际需求“注入”相关依赖，从而使Client能够更聚焦于自身功能特性，这种模式被称作<strong>依赖注入</strong>(DI)。下图进一步解释了该模式的结构和原理:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/dependency_injection.jpg" alt="Dependency injection pattern" /></p>

<p>构建依赖对象的过程被称作<strong>装配</strong>(Assembling)，通常是由<strong>注入器</strong>(Injector)负责装配过程，其中包括向Client注入依赖。一种注入器的实现模式是<strong>服务定位器</strong>(Service locator)，在该模式中Client获取任何外部依赖都需要通过服务定位器进行查询，后者相当于保存相关依赖的注册表服务。其基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/service_locator.png" alt="Service locator pattern" /></p>

<p>虽然采用服务定位器的Client不再关心依赖对象的创建，但前两者之间仍存在强依赖关系，同时由于服务定位器的实现通常是基于单例和静态工厂方法，因此可能成为并发条件下的系统瓶颈，也欠缺可测试性。彻底实现Client与依赖获取分离的方式是<strong>依赖注入容器</strong>模式，该方法通过Client无关的代码或配置文件实现对象装配，然后将其与Client中声明的依赖相互关联以便注入。Client声明所需依赖和实现注入点的方式有三种:</p>

<ul>
<li><p>构造函数注入，即在Client进行初始化的过程中注入依赖。该方法有助于维护Client内部状态的一致性，也让Client的依赖项更易于被理解，这是最常见的一种DI实现方式。</p></li>
<li><p>setter注入，即当Client完成初始化后，通过其提供的setter方法注入依赖。当Client存在很多依赖项时，单纯依赖构造函数注入会面临长参数列表的问题，同时如果Client存在多种依赖组合状态，就需要相应数量的构造函数，相比之下setter注入就更加灵活。</p></li>
<li><p>接口注入，与setter注入类似，区别在于setter方法来自于独立的接口，并由Client实现相关接口的方法。该方法的优势在于外部的注入代码可以完全忽略Client的具体类型，仅通过相关接口类型的引用向其注入所需依赖。</p></li>
</ul>


<p>DI能够最大化分离依赖的创建和实际应用，从而实现显著的模块解耦。由于对象装配完全由注入器提供的机制负责，因此这里往往是DI最核心和最复杂的部分。许多基于动态特性的DI实现也使静态对象追踪更加困难，进而可能增加软件的维护成本。</p>

<h3>组件依赖模式(Component Dependency Patterns)</h3>

<p>软件开发的过程中经常存在独立的软件单元，例如被独立开发的类(如类库)，或是包含一组类的子系统，亦或是相互独立的对象。组件通常具有独立的设计和演化规则，因此不同组件对外提供的接口也不尽相同。实现组件间依赖的一般做法是引用目标组件的原始接口，但这会造成组件间的强耦合，当需要替换某些组件、或者对依赖过程实现扩展时会产生较高代价。组件依赖模式就是为了解决此类问题的一组设计模式。</p>

<p>一种解决组件间依赖的模式是<strong>适配器</strong>(Adapter)，也称<strong>包装</strong>(Wrapper)。该模式会额外创建一个Wrapper类包装目标组件，同时遵循面向Client的一致性接口。具体的包装手段有类适配器和对象适配器两种，其基本结构分别如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/adapter.png" alt="Adapter pattern" /></p>

<p>类适配器具有更加简洁和OO的外观，但也存在一些潜在的限制。首先类适配器只能包装具体类而非接口，因为后者没有可供复用的具体实现。其次继承通常具有侵入性，仅以代码复用为目的的继承可能会破坏原有类的封装能力，从而损害了OO的内核。对象适配器则与之相反，虽然可能需要额外的对象创建和连接操作，但不存在类适配器的问题，因此更容易应对复杂性。</p>

<p>适配器模式主要解决依赖已有类的问题，但类似的结构也可被用于正在开发的类，有时因为希望保持接口和实现相对独立。传统上接口是作为与Client间的契约先于实现而确定的，但是当接口本身也具有一定复杂性时，就可能需要接口和实现分别独立演化，以便必要时还能切换其它替代实现，这种模式被称作<strong>桥接</strong>(Bridge)。其基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/bridge.jpg" alt="Bridge pattern" /></p>

<p>桥接模式具有和对象适配器相似的结构，但要注意其根本动机的不同。桥接模式支持从原有具体类中分离出承担接口职责的部分，从而应对接口和实现同时可能发生快速变更的情况。而适配器是在目标类稳定的情况下利用额外的接口包装以实现代码快速复用。</p>

<p>当目标类的接口满足Client需求，但在具体应用时需要引入额外的<strong>面向切面</strong>(Aspect oriented)功能时(例如访问控制、日志记录等)，可以创建与其拥有相同接口的代理类，通过类似对象适配器的结构对目标类的对象进行包装，这就是<strong>代理</strong>(Proxy)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/proxy.png" alt="Proxy pattern" /></p>

<p>如果一个已有的子系统由若干接口和类组成，且其内部具有复杂的结构关系。为了提高子系统的易用性，可以额外维护一个统一的对外接口类，将系统特性通过简单的接口定义向外部发布，即<strong>外观</strong>(Facade)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/facade.png" alt="Facade pattern" /></p>

<p>与其它模式关注类之间的依赖问题不同，外观模式主要解决子系统间的依赖问题，但其解决问题的基本思路是一致的。有时对象间的依赖也会存在问题，例如可能会生成庞大数量的目标对象，使系统资源过度消耗。当大量目标对象中包含许多重复信息时，一种解决方法是通过创建共享对象以减少资源总消耗，这种模式称作<strong>享元</strong>(Flyweight)。享元模式具有如下基本结构:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/flyweight.png" alt="Flyweight pattern" /></p>

<p>为了实现目标对象共享，可以采用抽象工厂或工厂方法生产被Client依赖的享元对象，当已有的享元对象满足共享条件时，系统会直接返回该对象而非重新创建。享元对象相当于对目标对象的重新包装，但这并不意味着享元对象是一定可以被复用的，例如当目标对象包含特定的外部状态信息时，就需要专门再创建一个非共享享元对象保存这些外部状态信息，并且在对应的共享享元对象中保存对其引用。</p>

<h3>增量扩展模式(Incremental Extension Patterns)</h3>

<p>OO的重要特性之一是通过继承实现增量式扩展，这种特性能帮助我们有效管理系统复杂性。但是正如<a href="http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8/">面向对象——概念与建模</a>一文中提到的，继承除了提供模块能力外还兼有类型概念，这种概念兼有利弊，特别是令继承的适用场景受到一定限制，不合适的继承非但不能有效管理复杂性，反而会带来更多问题，此时就需要考虑用组合替代继承实现模块扩展，这就是<strong>组合优于继承</strong>(Composition over inheritance)长期占据主流观点的原因。接下来要讨论的设计模式或采用继承或采用组合的方法来解决增量扩展的问题。</p>

<p>当系统需要同时维护很多对象时，维护增量式扩展的核心问题之一是如何管理每个对象的定义及其相互间的关系。当所有对象间关系呈现为树形或层级结构、并且Client与这些对象交互存在趋向一致的外部接口时，可以采用<strong>组合</strong>(Composite)模式。该模式为系统中的对象提供了统一的外部接口，作为非叶节点的对象可以包含并将同类型的对象作为其子节点。组合模式的基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/composite.png" alt="Composite pattern" /></p>

<p>组合模式所提供的增量扩展能力在于可以通过实现Component接口任意添加新的节点类型，虽然是等同于继承的扩展方式，但除了具有树形或层级结构这种特殊的对象间关系外，多数时候组合模式并不能适用。相比之下，聚合是一种更加普遍的对象间关系，其中聚合对象可以包含若干个不同类型的局部对象，在实践中聚合关系往往是通过对象间的组合实现的，这被称作<strong>整体和局部</strong>(Whole-Part)模式。下图给出了该模式的基本结构:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/whole_part.png" alt="Whole-part pattern" /></p>

<p>与组合模式最大的区别在于，该模式并不要求“整体”和“局部”对象具有统一的访问接口，通常只有整体对象对外提供服务，而局部对象具有多种类型且一般不会向外界暴露。类似的结构也存在于<strong>主从</strong>(Master-slave)模式，该模式描述的对象间关系一般只有两层——主对象和从对象，其基本结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/master_slave.png" alt="Master-slave pattern" /></p>

<p>其中主对象可以按需把接收到的工作分解并指派给若干从对象，最终再汇总从对象的计算结果并产生最终结果，主从模式有助于提高系统容错性、并行性和计算准确性。</p>

<p>有时需要实现对象的动态扩展，为了保持扩展对Client透明，需要同时借助继承的抽象类型特性保证扩展结果具有与原对象一致的接口，这就是<strong>装饰器</strong>(Decorator)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/decorator.png" alt="Decorator pattern" /></p>

<p>为了描述具体的扩展内容，首先需要创建与目标对象相同接口的装饰器对象，后者只需关心各自要扩展的功能；在对象创建阶段，用装饰器对象包装目标对象，如果存在多个装饰器对象，则继续用其包装装饰后的对象；最终生成的装饰后对象具有与目标对象完全一致的对外接口，因此装饰器模式能够最大限度地保持Client不变。</p>

<p>如果一个上下文需要在不同状态中表现出不同行为，可以把这些状态对应的行为单独抽取出来，利用组合关系使其行为能够被动态替换，这就是<strong>状态</strong>(State)模式。与装饰器模式类似，状态模式也是一种同时结合了继承和组合的增量扩展模式，该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/state.png" alt="State pattern" /></p>

<p>除了内部状态发生改变之外，上下文行为还可能会因为其它因素产生变化，例如需要选择不同的算法策略，此时可以采用与状态模式具有几乎相同结构的<strong>策略</strong>(Strategy)模式:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/strategy.png" alt="Strategy pattern" /></p>

<p>状态模式和策略模式都属于纵向增量扩展模式，即每次扩展相当于对原有功能进行完整替换，这种扩展方式具有较高的灵活度。在某些场景中，上下文行为存在相对固定的套路，延续这种套路虽然可能会引入某些限制，但使后续扩展的关注点更加明确，从而提高增量式扩展的效率。<strong>模板方法</strong>(Template method)模式就是这类横向增量扩展模式的典型代表，其基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/template_method.png" alt="Template method pattern" /></p>

<p>该模式中提供的模板方法就是一个预置的算法框架，任何扩展只需替换其中预设的子步骤。另一种预置了算法框架的模式是<strong>迭代器</strong>(Iterator)，该模式封装了数据结构的基本操作，从而令Client更加关注在具体元素的操作。其基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/iterator.png" alt="Iterator pattern" /></p>

<p>在前述模式的基础上，可以进一步抽象出元素操作，从而满足数据结构及其算法、数据结构中的元素、元素对应的操作的独立扩展，这就是<strong>访问者</strong>(Visitor)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/visitor.png" alt="Visitor pattern" /></p>

<p>由于实现了最大限度的抽象化，访问者模式同时在上述三个维度上提供了增量扩展能力，但同时也引入了较高的复杂度，特别是当元素及其操作分别属于不同的类层级结构，但其相互之间仍然存在着强耦合关系，导致代码的可维护性受到损害。</p>

<h3>消息模式(Messaging Patterns)</h3>

<p>OO中的对象间通信主要通过消息传递进行，最直接的消息传递方式就是调用目标对象的方法。消息模式主要用于解决下述几个方面的复杂性:</p>

<ul>
<li><p>消息的发送者和接收者。</p></li>
<li><p>消息的表示和传递。</p></li>
<li><p>消息的存储和管理。</p></li>
</ul>


<p>当接收者的消息处理过程比较复杂，例如具有层次式的处理结构时(类似多层嵌套的条件分支)，可以把其中每一层的处理逻辑抽取出来构建独立对象，然后将原始的消息接收者替换为一组对象链，即<strong>责任链</strong>(Chain of responsibility)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/chain.png" alt="Chain of responsibility pattern" /></p>

<p>在责任链模式中，原来的消息接收者被划分成多个职责独立的对象，消息由一次处理变为沿着责任链进行传递并被多个对象分别处理。这种变化降低了原始代码的圈复杂度，而且方便复用现有对象组建新的责任链。</p>

<p>对于作为消息发送者的对象，把待发送的消息和接收者从中抽取出来构建独立对象，一方面可以降低发送者的复杂度，满足消息类型的增量扩展；另一方面可以灵活控制消息的发送时机。这种模式被称作<strong>命令</strong>(Command)模式。其基本结构如下所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/command.png" alt="Command pattern" /></p>

<p>上图中的Invoker扮演消息发送者的角色，Receiver则是消息的接收者，Client负责创建命令对象并将其和接收者关联。命令模式中的命令对象是不可变的，这种特性使命令对象能够被重复使用，但无法保存状态。另一种相似的模式——<strong>命令处理器</strong>(Command processor)允许创建具有可变状态的命令对象，其代价是扮演Invoker的命令处理器需要每次从Client获取新建的命令对象，其基本结构如下所示:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/command_processor.png" alt="Command processor pattern" /></p>

<p>如果一次消息发送对应了多个接收者，并且接收者还可能会发生动态增加或减少，那么在每个接收者上实现观察者接口，然后将其动态注册至消息的发送者上，当消息发送时会依次发送至每个已注册的接收者。这就是<strong>观察者</strong>(Observer)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/observer.png" alt="Observer pattern" /></p>

<p>观察者是一种消息传递模式，特别是当存在一对多的消息传递关系时，应用观察者模式能够实现消息发送者和接收者的解耦，并且支持动态的接收者增加和减少特性。观察者模式有时也被称作<strong>发布者-订阅者</strong>(Publisher-subscriber)模式，但后者有时存在更多变种。例如传统的观察者模式主要依赖消息推送(Push)，所有观察者都被动接收消息。但是发布者-订阅者模式中还支持消息拉取(Pull)，这时发布者只会发送很简单的变更通知，由订阅者决定是否读取该消息。消息拉取是一种更加灵活的消息传递方式，特别是当消息量可能超出了接收者的承受能力时，拉取实际上对接收者起到了保护作用。如果不存在消息过载的情况，那么采用推送则更加简单且实时。</p>

<p>如果系统中存在许多对象，并且这些对象间大都存在着某种消息传递关系时，可以创建一个中介对象负责接收并转发对象发送的消息，即<strong>中介者</strong>(Mediator)模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/mediator.png" alt="Mediator pattern" /></p>

<p>与观察者模式类似，中介者模式能够解决多对多的对象间消息传递和动态增减问题。但是该模式会增加获取消息传递路径和参与双方信息的难度，使某些重要的领域逻辑无法在代码中得到清晰呈现，进而间接提高维护成本。因此当消息传递包含关键领域逻辑时，应避免采用中介者模式，当然最终的设计和实现可能会更加复杂，以<strong>视图处理器</strong>(View handler)模式为例:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/view_handler.jpg" alt="View handler pattern" /></p>

<p>该模式用于解决多文档窗口管理的问题。多文档窗口通常存在于Word等文本编辑工具，其特点是系统可以同时打开多个窗口，而且每个窗口可以指向任意文档的内容。该问题的复杂性在于每个窗口中的操作可能会影响其它窗口的显示结果，同时当用户点击退出时系统需要针对每个打开的文档向其询问是否要保存已修改的内容。视图处理器模式定义了系统中存在的三种对象:</p>

<ul>
<li><p>视图处理器，负责管理所有视图，以及对外提供针对视图的操作。</p></li>
<li><p>视图，负责保存当前视图的内部状态，向视图处理器提供基本操作。</p></li>
<li><p>供应者，负责保存数据，并且向其观察者发送数据更新消息。</p></li>
</ul>


<p>该模式的对象间的消息传递存在两种情况:</p>

<ul>
<li><p>当视图内的数据发生修改，该修改被反馈给供应者，然后把更新后的状态通过观察者模式发送给视图处理器和其它相关视图。</p></li>
<li><p>外部触发系统调用视图控制器提供的接口，然后把相关更新依次传递到每个视图。</p></li>
</ul>


<p>当多个对象间消息传递发生在跨进程的对等网络中时，消息传递需要先后经过序列化和反序列化，这时可以采用<strong>转发者-接收者</strong>(Forwarder-receiver)模式。</p>

<p><img src="http://content.hanyi.name/images/design_patterns/forwarder-receiver.png" alt="Forwarder-receiver pattern" /></p>

<p>在该模式下，消息发送者需要首先把消息传递给转发者；后者进行序列化和寻址，然后把消息传递至接收者；接收者接到消息后先进行反序列化，然后把消息返回给接收对象。有时需要保持网络地址对消息双方透明，从而实现信道自动调度，此时可以采用<strong>客户端-调度器-服务器</strong>模式。该模式的基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/client_dispatcher_server.png" alt="Client dispatcher server pattern" /></p>

<p>在处理相关消息时，有时会导致接收者的内部状态发生改变，但消息的发送者可能要求撤销某些消息处理，其实质是恢复消息接收者的状态到历史的某个时刻。一种简单的做法是由消息接收者返回当前内部状态，以备忘录对象的形式在外部进行保存。当回退需求发生时，发送者向接收者发送备忘录对象并要求恢复至指定状态。这种模式被称为<strong>备忘录</strong>(Memento)，其基本结构如下:</p>

<p><img src="http://content.hanyi.name/images/design_patterns/memento.png" alt="Memento pattern" /></p>

<h2>结论</h2>

<p>作为软件设计的最佳实践，设计模式从诞生之初就受到了工业界和学术界的热捧，并把OO进一步推向了金字塔顶端。近年来随着软件开发框架和工具链的日益完善，设计模式在日常应用开发中逐渐退居幕后，成为新技术背后的驱动力。但是，作为软件工业化的必经之路，新模式的发现及传播不可能由此中断。对于任何一种模式，了解其场景和结构固然重要，但深入理解模式的动机和陷阱才意味着做到了正确理解，才能真正将其作为软件设计的最佳实践。</p>

<h2>引用</h2>

<p>GHJV95, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/DSBP-2018-01/recursos/Erich%20Gamma,%20Richard%20Helm,%20Ralph%20Johnson,%20John%20M.%20Vlissides-Design%20Patterns_%20Elements%20of%20Reusable%20Object-Oriented%20Software%20%20-Addison-Wesley%20Professional%20%281994%29.pdf">Design Patterns: Elements of Reusable Object-Oriented Software</a></p>

<p>BMRSS96, <a href="https://github.com/ppizarro/coursera/blob/master/POSA/Books/Pattern-Oriented%20Software%20Architecture/Pattern-Oriented%20Software%20Architecture%2C%20Volume%201%20-%20A%20System%20Of%20Patterns.pdf">Pattern-Oriented Software Architecture Volume 1: A System of Patterns</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(10)]]></title>
    <link href="http://www.hanyi.name/blog/2019/03/10/software-design-and-architecture-notes-10/"/>
    <updated>2019-03-10T03:11:07-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/03/10/software-design-and-architecture-notes-10</id>
    <content type="html"><![CDATA[<h2>面向模式的领域分析与建模</h2>

<p><a href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/">前文</a>讨论了OOA/OOD的基本概念、工具和方法。我们已经知道，当面临稍复杂的问题域或特殊的上下文时，朴素方法会面临许多挑战，使软件开发风险难以得到有效控制。模式的发现和应用为工业界带来了高效的解决方案，也因此成为甚至比朴素方法更易流行的方法论，即<strong>面向模式</strong>(Pattern oriented)。本文是对前文OOA部分的进一步补充和扩展，首先讨论<strong>领域分析</strong>(Domain analysis)，及其与数据建模和OOA的关系，然后深入讨论面向对象分析模式，这些模式大多采用领域特定的概念模型(也称分析模型)进行描述，与纯粹抽象的表达方式相比更易理解，然而其模型结构和分析过程可被应用至更广泛的领域。</p>

<h3>领域分析</h3>

<p><strong>领域分析</strong>是指为了满足跨组件的可复用性，对软件开发信息进行识别、收集、组织的过程[RPD90]。当相似的问题域重现时，期待所构建的软件能够尽可能被复用，从而提高软件的经济效益，这是领域分析的根本动机。因此，相对于可复用的代码，领域分析主要关注于分析和设计的可复用性，这通常反映为组件级的可复用性[JMN80]。</p>

<p>在软件工程的语境下，<strong>领域</strong>是指所构建软件系统的实际应用场景。具体来说，一个领域既可以大至银行业务，也能小至算术运算。一个领域还能被分解成多个子领域，因此复杂的领域可被看成是一种层级的网状结构，层级越高则意味着领域的复杂度也就越高。<strong>领域边界</strong>用于描述领域的范围，定义了每个领域中的对象、操作以及相互之间的关系。<strong>组件</strong>是指一个独立的软件单位，这种独立性可以指独立开发、独立部署或独立运维等特性，并且组件之间还能通过某种协议进行通信。领域是业务单位(例如对应不同的业务部门)，组件则是工程单位(例如对应不同的项目或开发团队)，但二者最终存在一定的映射关系。虽然领域分析有比较明确的目标，但具体的实现方法属于非平凡问题。例如如何确定领域层级、如何确定领域边界以及如何建立与组件之间的映射关系等。</p>

<h4>领域分析的框架模型</h4>

<p>[RPD90]描述了领域分析的结构化上下文视图(SADT Context View)，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/domain_analysis.png" alt="Domain analysis" /></p>

<p>在上述模型看来，领域分析实际上是一种依赖多种输入且高度参数化的框架，其最终产出也可根据参数进行定制。例如，当核心是某个产品而非技术时，领域分析主要关注战略一致性、市场策略、产品定位、风险分析、日常外观等一系列产品特性，这时需要用到通用术语调研、逻辑架构、可靠性标准等方法——这种领域分析活动被称为<strong>产品定义领域分析</strong>(Product definition domain analysis)。当有明确的证据支持当前产品流时，即可进一步就具体产品展开分析，这时往往是概念性领域分析，该活动被称为<strong>需求领域分析</strong>(Requirement domain analysis)。当表示产品线的领域趋于稳定时，就可以考虑构建特定领域的生成器，从而满足高效构建新产品的需求，此过程被称作<strong>生成器领域分析</strong>(Generator domain analysis)。</p>

<h4>领域分析、数据建模、OOA</h4>

<p>我们在<a href="http://www.hanyi.name/blog/2018/12/09/software-design-and-architecture-notes-6/">数据模型与数据建模</a>一文曾讨论过数据建模。从上世纪80年代初期开始，由于关系模型和关系数据库系统的流行，信息系统的构建往往都强依赖于数据库系统。为了保证概念模型能直接用于后续设计和实现，数据建模、特别是概念数据建模成为需求领域分析活动的主要内容之一。其中，实体-关系建模(ER modeling)是数据建模中最具代表性的方法，其分析结果即ER图，后者往往被直接用于数据库设计甚至应用构建[DCH96]。虽然数据建模也重视对真实世界的反映，但其更侧重于表现状态而非过程，而事实上两者对于软件开发同样重要，这也是兼具二者的OOA后来居上的原因。而OO天然具有的<strong>抽象层级</strong>和<strong>抽象边界</strong>等概念，与前文提到的领域和领域边界的概念能够一一对应，且其最终得到的领域概念和对象，亦即需求领域分析的目标。</p>

<p>因此，数据建模和OOA都是领域分析采用相应建模技术的具体实现。在领域分析方法的发展过程中，二者都扮演了重要角色。虽然至今领域分析方法都在不断演进，但从已有经验总结得出的分析模式，能够为常规的领域分析活动提供可靠的候选参考。</p>

<h3>面向对象分析模式</h3>

<p>概念模型是理解和模拟真实世界的基础，但由于后者的复杂性通常都超乎想象，导致概念模型基本不存在正确与否的问题。对此Martin Fowler用模拟斯诺克的例子解释：当需要对球的运动进行建模时，经典牛顿力学和爱因斯坦的狭义相对论都可以作为候选模型，前者非常直观且易于实现，后者实现复杂但具备更好的适应性和精确度。显然，最终生成软件的灵活性和可重用性强烈依赖于所采用的概念模型。但除了个别质量属性外，软件工程中还存在更多的权衡因子，一个典型的例子是可维护性和成本之间的矛盾。一种平衡前述因子的有效办法是构建<strong>极简概念模型</strong>(Simplest conceptual model)——这并非一个容易达成的目标，因为“极简”不是指问题域中最简单的一部分，而是指在更高抽象层级构建概念模型，其内核虽然是“极简”的，却因为良好的伸缩性得以适应更复杂的问题域。在[MFR96]中，Martin用<strong>分析模式</strong>表示用于构建概念模型的模式，随之用<strong>支持模式</strong>表示将概念模型转化为OOD的模式。前者是下面要讨论的重点，后者属于OOD的范畴，本文不做专门讨论。</p>

<ul>
<li><strong>职责模式</strong>(Accountability)，该模式用于表示个人或者组织之间的职责。在一些问题域中经常需要表示相关职责，例如组织结构、合约、雇佣等，这些都无一例外体现为某种真实对象之间的关系。这里我们把个人、组织这种具体领域的词汇统称为更加抽象的词——<strong>实体</strong>。当不同的实体表现出趋同的职责时，应考虑构建一个更高抽象层级的实体。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/generalized_party.png" alt="Generalized party" /></p>

<p>当不同实体之间存在灵活的组织层级关系时，可以从中提取抽象实体，通过递归引用构建这种层级关系，从而易于应对层级变化。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/organization_hierarchy.png" alt="Organization hierarchy" /></p>

<p>当实体的子类型间的层级关系存在某种约束时，可以把其添加至相应的子类型内部，从而避免改变模型结构。此外，实体间还可能存在多个层级关系，可以把上述显式引用的关系替换为<strong>关系类型</strong>(Typed relationship)，后者被用于表示实体间组织结构的对象类型，实体通过关联的多个结构对象实现不同的层级关系。同样，实体的结构类型也可以关联相应的约束规则，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/multiple_organization_hierarchies.png" alt="Multiple organization hierarchies" /></p>

<p>上述方法的优势是如果实体的关系类型比较复杂，约束规则可以对应至每种关系类型进行管理。问题在于，如果实体的子类型变化比关系类型更多，那么任何子类型的增删改都会影响现有规则，这时可以把规则关联到每个实体的子类型，而非关系类型。</p>

<p>显然此时模型的复杂度已经有了明显增加，为了方便分析这种复杂性，把当前模型划分成<strong>运行等级</strong>(Operational level)和<strong>知识等级</strong>(Knowledge level)两个部分，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/knowledge_and_operational_levels.png" alt="Knowledge and operational levels of accountability" /></p>

<p>其中运行等级包含职责、实体和两者的关系，知识等级包含职责类型、实体类型和两者的关系。前者用于记录领域中发生的日常事件，后者记录用于监管前者的规则。</p>

<p>另外，实体类型也可能具有抽象层级，这样就能描述更加复杂的场景。例如对于全科医生和专科医生来说，两种类型既具有共性也具有特殊性，因此可以创建一个更加抽象的层级——医生来管理其共性。</p>

<p>职责类型也具有抽象层级，随着职责类型不断增加，相应规则数量也会随之增加。但是，如果职责类型表现为固定且简单的等级关系，例如常见的办公室、部门、区域等，那么可以采用分级职责类型，即直接在职责类型对象内存储静态等级列表和相应规则。后者比传统按抽象层级创建新的职责类型相比更加简单，但缺少灵活性。</p>

<p>职责类型描述职责的种类，但一个具体的职责通常包含更多细节信息，例如地点、数量、内容等，这里称为<strong>运行范围</strong>(Operating scope)。运行范围也可能具有复杂的抽象层级和关联关系，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/operating_scope.png" alt="Operating scope" /></p>

<p>运行范围的一个典型用例是职位描述(Job description)，也就意味着职位描述是与工作职责相互关联的，而非具体的员工实体，这也更加符合真实世界的场景。假设具有某项职责的员工离职，那么其承担的职责应被移交给接替者，可以在此基础上创建一个新的<strong>职位</strong>(Post)实体，于是就避免了职责与员工的直接关联，而是让两者通过职位间接产生关联，从而实现更好的灵活性。</p>

<ul>
<li><strong>观察与测量模式</strong>(Observations and measurements)，该模式用于表示真实世界对象的信息。以数值类属性为例，体重是人的基本属性之一，一般用数值类型存储。然而如果领域要求更精确一些，数值类属性还需要额外的单位信息，这时就需要构建抽象数据类型，这里称为<strong>Quantity</strong>。几乎一定会用到Quantity类型的领域包括财务(货币单位)、医疗(剂量单位)等。</li>
</ul>


<p>Quantity通常意味着单位转换的问题。一个简单的单位转换率模型如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/unit_conversion.png" alt="Unit conversion" /></p>

<p>如果问题域中包含大量的转换率，可以把单位用量纲表示，这样就可以动态计算单位之间的转换率。对于更复杂的单位转换需求，例如摄氏和华氏这两个温度单位，就需要引入携带计算行为的单位转换模型。在真实世界中，一种物理量的单位经常需要用一些基本单位组合表示，例如平方英尺、米每秒等，这时就需要引入<strong>复合单位</strong>，即引用其它单位的单位。</p>

<p><strong>测量</strong>是一种表示实体中数值属性的抽象数据类型。当一个实体具有大量属性、且这些属性分别用于不同操作时，实体中就可能存在大量针对这些属性的操作。测量的目的就是抽出这些操作，并在此基础上分离出位于知识等级层面的现象类型(Phenomenon type)。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/measurement.png" alt="Measurement" /></p>

<p>实体还可能包含非数值属性，与测量类似，可以采用独立的抽象数据类型表示非数值属性，二者可以共同提取出更高的抽象层级——<strong>观察</strong>。观察中所包含的规则、解释和创建方式等可以进一步提取出来，构成<strong>协议</strong>。观察往往具有一定的时效性，即观察值仅当满足特定时间段时才有效，可以通过关联时间对象解决。在一些问题域中，观察值可能被发现是无效的，但基于可追溯性无法删除已有的观察值，因此通常是给原有观察关联一个新的<strong>不合格观察</strong>。例如在医疗领域中，患者的检测报告有可能因为各种原因被识别为无效，但仍需要保留历史记录以便追踪治疗历史。医生会根据检测结果诊断病因，有时会因为某种测量结果而判断病因，也可能因后续测量结果调整治疗方案。为了表示观察值所带来的影响，可以将其划分为三种子类型:假设、投影和活动观察。其中活动观察指当前最被信任的观察，假设指需要进一步测试才能确定的观察，投影指医生认为未来可能出现的观察。</p>

<p>观察是可以相互关联并产生影响的，这种情况被称为<strong>关联观察</strong>。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/associated_observation.png" alt="Associated observation" /></p>

<ul>
<li><strong>引用对象</strong>(Referring to objects)，这是一种表示对象间引用关系的模式。真实世界的对象大都存在交互，OO首先要解决的问题就是引用对象，这通常是基于一个显式的身份标识。最简单的对象引用方式就是按名字引用其它对象，具体可以是对象名，也可以是对象id。</li>
</ul>


<p>当对象可能在不同场景中具有多种的标识时，简单的名字引用就难以应对各类场景中的特定对象。例如一个学生可能同时有身份证号、学号、甚至准考证号等标识，此时可以采用标识对象表示引用关系，描述场景的对象被称作<strong>标识模式</strong>，这是一种具有上下文信息的人工标识方法。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/identification_scheme.png" alt="Identification scheme" /></p>

<ul>
<li><strong>库存与会计</strong>(Inventory and accounting)，一种跟踪企业资金流动的模式，主要用于财务会计、库存和资源管理等领域。通常用<strong>账户</strong>表示具有实际价值及其历史记录的实体，例如银行账户、库存账户等。对于账户中的每两条历史记录(指包含存和取的“两腿交易”)，都能够对应一个<strong>交易</strong>，后者用于记录价值流动的细节。如果问题域存在多腿交易，例如一次交易超过了两个参与方，则允许一个交易引用多条历史记录。从模型的角度看，两腿交易属于多腿交易的一种特殊情况，因此后者的灵活性更好。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/multilegged_transaction.png" alt="Multilegged transaction" /></p>

<p>如果同时拥有多个账户，那么通常会需要额外创建一种<strong>总结账户</strong>，后者被用于汇总其它细节账户，因此这里可以抽取出账户的一个更高抽象层级表示。在税务领域中还存在另一种账户类型——<strong>备忘录账户</strong>，这种账户并非记录当前的实际价值，而是额外存放一份“应税价值”，优点是能实时监测某种价值的累积和变更情况，从而为领域添加更好的可预测性，例如方便进行年度报税。为了保证备忘录账户能够被及时更新，通常在账户中会创建一个触发器，每当一个新的记录被创建，则根据触发规则(Posting rule)创建另一条记录，后者即应税价值。如果创建新记录需要比较复杂的计算，则需要给触发规则关联一个额外的计算对象。值得注意的是，触发规则通常是可逆的，同时由于规则本身包含了交易细节，备忘录账户中的历史记录也就无须保存相应的交易记录。</p>

<p>不同的账户可能具有不同的触发规则，一种方法是把触发规则与账户类型相关联，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/posting_rule.png" alt="Posting rule" /></p>

<p>该模型体现了良好的概念表示，实则兼有利弊。因为其基本假设是账户类型与触发规则应存在某种强关联性，否则反而会使情况更加复杂。一个替代做法是直接把触发规则关联至某个总结账户，这样灵活性就更好，但在概念表现上则比较隐晦。</p>

<p><strong>会计</strong>的实质就是在触发规则的基础上，构建一个多账户网络。这就需要能随时获取指定类型的账户和指定类型的触发规则记录。一般情况下，如果实体具有多个账户，那么该实体会附带一个相应的会计操作。如果问题域中具有极其复杂的会计操作，例如不同类型的触发规则对应不同的会计操作，那么可以通过添加会计操作类型的概念对逻辑进行合理分配。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/accounting_practice.png" alt="Accounting practice" /></p>

<p>基于上述模型的历史记录具有更强的追溯性，例如每条记录可以查找对应的源——交易，然后根据交易查询其触发规则。同时还能根据问题域创建对应的资产负债表(Balance sheet)账户和损益表(Income statement)账户，前者记录当前实际价值，例如资产总额；后者则记录每笔交易的具体流向。这两种账户虽然具有不完全相同的历史记录，但实际是一个概念的不同方面，被称作<strong>相关账户</strong>。相关性可能存在于多个账户之间，且具有对称性和传递性的特征。</p>

<p>针对一条记录可能存在于多个账户的场景，还需要注意账户间关联应遵循有向无环图(Directed acyclic graph, DAG)，从而保证正确性。如果问题域要求更多的记录类型，可以采用前文讨论的备忘录账户，也可以创建子类型账户。前者具有简单的模型，适合满足简单的报表类需求，对于更加复杂的场景，就需要采用后者负责针对特定记录类型的操作。</p>

<ul>
<li><strong>计划</strong>(Planning)，该模式用于表示计划，包括制定和追踪两部分内容。任何计划都可以被看作由若干基本<strong>动作</strong>(Action)组成，与计划强调整体性不同的是，动作可以拥有不同的粒度，一个简单的动作可以包含人物、时间和地点等信息。</li>
</ul>


<p>动作通常是状态化的，也可能因为不同状态表现出不同的行为，其中最重要的两个状态是<strong>建议</strong>和<strong>实施</strong>，前者是指动作已经被创建，并且可能已经被赋予了某些资源；后者指动作已经开始执行。虽然同时指向一个真实世界的动作，但是建议和实施实际上可能具有很大的区别，因此，通常不使用关联的动作值/对象表示这两种状态，而是通过创建动作的两个子类型做彻底区分，同时同一个动作的两个子类型之间保持关联，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/proposed_and_implemented_action.png" alt="Proposed and implemented action" /></p>

<p>类似地，如果某个动作处于完成状态，但由于完成的动作可能仍需要追溯性，通常可以将其作为实施动作的一个特例。在某些问题域中需要丢弃已经完成的动作，于是需要丢弃状态，丢弃也可能是在实施之前发生，因此丢弃动作应当是独立于建议和实施的动作。如果问题域允许暂停一个动作，那么就需要给动作关联一个暂停对象，该对象携带一个有效期信息，当时间位于该有效期内时，动作将被挂起直到暂停有效期结束。</p>

<p>最基本的计划即一组建议动作的有序集合，这种顺序需要给动作添加依赖保证。当具有多个计划时，一个动作也可能同时位于多个计划中。如果动作允许嵌套，那么计划也可以被看作是一种特殊的动作。</p>

<p>通常企业的运行过程可以用通用的动作进行表示，其中动作和计划位于运行等级，我们把位于知识等级的部分称作<strong>协议</strong>，其结构如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/structure_for_protocol.png" alt="Structure for protocol" /></p>

<p>动作通常是基于协议创建的，最简单的方法是根据协议创建关联的建议动作，也可以在更高层级创建等同于计划的建议动作。如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/plan_action_protocol.png" alt="Relationship of plan, action and protocol" /></p>

<p>我们知道动作在实施前需要分配资源。资源可以被划分为两种基本类型，例如药品、针头、源材料等属于消费型资源，又如设备、房间、人等属于资产型资源。每种资源类型都具备对应的分配方式，这些分配方式具有统一的资源分配接口。</p>

<p>计划是通过观察启动的，后者是基于假设和投影的结果。因此计划的输出结果也应该是观察的形式。与计划类似，观察也是动作的一种子类型，并且可以作为计划的一部分。前述两种观察在知识等级可以采用启动函数和输出函数表示，前者用于触发协议，后者用于把输入的协议和观察组合进行转换并以两个观察概念集合输出:一个表示协议的使用目标，另一个记录边际效应。</p>

<ul>
<li><strong>交易</strong>(Trading)，指在变化的市场条件下销售和购买商品的模式。<strong>合约</strong>是最基本的交易形式，具体的实现手段包括股票、商品、外汇等。例如大多数市场都以货币为交易手段，于是交易价格就以货币方式表示。交易的两种类型做多(Long)和做空(Short)分别代表买入和卖出，一个基本的交易模型如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/contract.png" alt="Contract" /></p>

<p>银行的风控系统通常以<strong>交易组合</strong>(Portfolio)为单位监控异常交易，交易组合一般拥有采用合约构建其自身的方法，该方法通过合约选择器筛选出合约，并保存在自身记录中。交易组合可以是短期或长期的，短期交易组合是按需创建，使用完成后丢弃；而长期交易组合能存在较长一段时间，因此当新的交易产生时，系统会将其与所有的长期交易组合进行匹配，并添加至满足条件的长期交易组合。</p>

<p>任何金融市场的交易都有<strong>报价</strong>(Quote)，多数情况下“报价”其实包含两个值——买入价和卖出价，这被称为<strong>双向价格</strong>(Two way pricing)。相应地，在某些问题域中也存在<strong>单向价格</strong>(One way pricing)，后者可以被看作是双向价格的一种特殊情况。为了同时支持这两种报价类型，需要构建一个更高抽象层次的报价类型，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/quote.png" alt="Quote" /></p>

<p>如果问题域中单向价格和双向价格的差别非常大，那么抽象类型反而会造成很多局限性，此时就需要对两种价格类型分别建模。</p>

<p>市场中的报价是瞬息万变的，因此报价通常会携带时刻信息。如果想查询市场上所有股票的价格，需要抽取每只股票截至某个时刻的最后一次报价，然后把这些报价添加至一个集合——<strong>场景</strong>(Scenario)，即表示市场在某一时刻的状态。从满足需求的角度来说，直接从全部报价中根据时刻抽取相应报价，即可方便获得市场上的公开价格。但场景是对某个时刻市场价格的抽象表示，可以方便后续的价格查询、分析和比较等。问题域在外汇市场变得更加复杂，由于汇率不再是由单一来源发布，因此需要额外添加一个实体作为价格发布者，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/party.png" alt="Party and scenario" /></p>

<ul>
<li><strong>交易包</strong>(Trading package)，一种把较大的领域模型拆分为更多小型领域模型的模式。<strong>包</strong>通常指一个独立且具有一定规模的软件模块，例如在OO中包可以是一些类的集合，其内部可见性也表明了包的内聚性。包之间一般存在<strong>多重访问等级</strong>，例如在交易领域中，交易组合会把市场指标作为其描述，场景则为市场指标提供价格计算，交易组合与合约通过场景对自身进行定价，但反过来场景并不需要依赖交易组合或合约。这种包之间的可见性如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/package_visibility.png" alt="Package visibility" /></p>

<p>进一步，交易组合需要从市场指标中获取价格，但并不需要了解场景是如何被创建的。因此虽然之前我们讨论了包之间存在可见性的必要性，但这种可见性必须是可控的。一种解决办法是通过额外的接口实现包之间的依赖，然后针对这些接口创建新的包，从而实现更细粒度的包可见性依赖。这种方法的缺点是包的概念和结构变得更加复杂，进而引发可维护性问题。另一种办法是在现有概念模型的基础上引入表示应用逻辑和表现层的组件，例如创建一个新的风险管理应用包和场景管理应用包，前者负责沟通交易组合与场景，后者专门负责创建场景，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/pattern_oriented_domain_analysis_and_modeling/application_packages.png" alt="Application package" /></p>

<p>注意在上图中还有一个新的包“场景结构”，其目的是为了保证场景包对外提供统一的接口，从而将部分职责从原始场景包中进行了分离。</p>

<p>如果一个包是另一个包的子类型，那么不应出现后者依赖前者的情况，否则会损害子类型的可扩展性。包有时还会出现<strong>互相依赖</strong>的问题，进而导致过高的耦合性，这时需要考虑把这种双向依赖转变为单向依赖，因为后者的耦合度更低，但也可能会增加使用上的复杂度。例如对于实体和合约来说，实体有时需要知道与之相关的合约，反之合约也需要知道参与的实体。对此如果要消除双向依赖，就必须消除某个方向的依赖关系。但是无论是消除任一种关系，都会造成某些客户端应用的复杂度增加的问题。除此之外还可以选择把两个包合并，但也可能引入不恰当的可见性问题。因此对这种互相依赖的解决需要考虑更多上下文进行综合判断。</p>

<h2>结论</h2>

<p>模式是对实践经验的积累和发散，真实世界的复杂性导致了模式只能被发现而不能被发明出来，也因此很难避免其在面临复杂问题域时的局限性。然而，与后续会讨论的其它类型的模式相比，分析模式其实具备更高的灵活性和适用性，特别是比形式化的模式表述更加接近真实的思维方式。</p>

<h2>引用</h2>

<p>RPD90, <a href="http://www.engr.sjsu.edu/fayad/current.courses/cmpe202-spring2015/docs/CmpE202-SE-Link-Part-Two-Fall2013/11-Domain%20Analysis/Domain%20Analysis%20-%20An%20Introduction.pdf">Domain analysis: introduction</a></p>

<p>JMN80, <a href="http://www.bayfronttechnologies.com/thesis.pdf">Software Construction Using Components</a></p>

<p>DCH96, <a href="http://ptgmedia.pearsoncmg.com/images/9780133492125/samplepages/0133492125.pdf">Data model patterns: conventions of thought</a></p>

<p>MFR96, <a href="https://martinfowler.com/books/ap.html">Analysis patterns
</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(9)]]></title>
    <link href="http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9/"/>
    <updated>2019-02-11T09:28:50-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/02/11/software-design-and-architecture-notes-9</id>
    <content type="html"><![CDATA[<h2>面向对象——分析与设计</h2>

<p><strong>分析</strong>(Analysis)与<strong>设计</strong>(Design)是软件开发过程中的两种重要活动。分析研究需求和问题本身，决定“做正确的事”；设计则侧重于提出概念性解决方案，决定“正确地做事”[CLA01]。在软件工程实践中，分析主要围绕需求进行，这里既包括功能需求，也包括非功能需求；设计则围绕具体实现进行，例如计划设计、技术设计、用户体验设计、测试设计、运维设计等。面向对象建模技术在上世纪90年代中期的兴起，使其被广泛应用于软件的分析和设计过程，逐渐成为企业级开发领域的主宰范式。</p>

<h3>面向对象分析(OOA)</h3>

<p>OOA的目的是识别和描述问题域中的概念和对象。问题域通常以软件需求为主要的呈现形式，其中包括了功能需求和非功能需求。前者描述面向用户的软件行为，后者则包括了其它类型的需求，例如可用性、可靠性、性能和可支持性(可维护性)等，此类软件属性也被称作软件的<strong>质量属性</strong>(Quality attributes)。功能需求可通过<strong>用例模型</strong>描绘出更多细节，非功能需求则作为前者的补充性规格说明进行呈现。如何恰当地描述用例可以进一步参考[ACB99]，本文后续部分假设用例和非功能需求已经被有效地描述，因为这是进行面向对象分析的重要前提。</p>

<h4>用例建模(Use case modeling)</h4>

<p>当具有初步的用例描述时，可以采用用例模型对问题域进一步分析，从而整理出<strong>系统事件</strong>(System event)及其相应的输入和输出，为之后的逻辑设计建立基础。构建用例模型的过程被称为<strong>用例建模</strong>，可用的工具和方法包括<strong>用例图</strong>、<strong>系统时序图</strong>和<strong>系统契约</strong>等。</p>

<ul>
<li><p>用例图实现了对基于文本描述用例的可视化表示，使其在概念级别更易于理解和沟通，通常采用UML用例图作为工具。</p></li>
<li><p>系统时序图与UML的时序图类似，不同之处在于前者把整个系统作为黑盒，主要描述系统的外部交互过程。这些交互可以是位于用户与系统间，也可以位于不同系统之间。在系统时序图中，系统事件是系统与外部交互的唯一方式，而为了描述系统事件则需首先确定<strong>系统边界</strong>(System boundary)，即系统的功能集合。系统时序图着重于描述系统事件类型、参数、发生顺序和其它关键特性。</p></li>
<li><p>系统契约能够进一步描述系统事件所引起的领域模型中对象的状态变化规则，相当于系统级别的<strong>设计契约</strong>，针对后者的讨论可参考下文面向对象设计一节的设计契约部分。</p></li>
</ul>


<p>用例模型是需求分析的重要交付物，其实质是针对领域的过程化描述，但这种形式不足以启发后续的面向对象设计，因此需要进一步建立接近面向对象概念的<strong>领域模型</strong>，针对后者的构建方法就是接下来要讨论的<strong>领域建模</strong>。</p>

<h4>领域建模(Domain modeling)</h4>

<p>领域模型描述了问题域中的<strong>概念类</strong>(Conceptual class)，概念类与面向对象中的类有一定相似性，但与设计和实现阶段创建的类没有必然的对应关系。领域模型有时也被称作概念模型、领域对象模型或分析对象模型，其通常应包含如下信息:</p>

<ul>
<li><p>领域对象或概念类。</p></li>
<li><p>概念类之间的关联关系。</p></li>
<li><p>概念类的属性。</p></li>
</ul>


<p>一个采用UML类图描述的领域模型例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/domain_model.png" alt="Domain model" /></p>

<p>领域建模首先需要识别概念类。[MO95]提出了概念类的三要素:1.符号(Symbol)，用于表示概念类的文字或图像信息；2.含义(Intension)，概念类的定义；3.扩展(Extension)，描述所有同属于该概念类的案例集合。例如，概念类Sale应包含以下信息:1.表示概念类的符号“Sale”；2.其含义是一次购买交易的事件，包括了date和time两个附加属性；3.扩展即是所有销售的案例集合。对概念类Sale的三要素进行可视化的例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/conceptual_classes.png" alt="Conceptual classes" /></p>

<p>在复杂的问题域中，为了识别出所有概念类，需要对领域进行实体分解。一般方法是从用例描述中的名词短语直接提取概念类，但是受限于自然语言的随意性，把任何提取出的词汇都映射为概念类极有可能出错。除了进一步澄清所提取的词汇外，还可以借助<strong>概念类分类表</strong>(Conceptual class category list)，后者是对特定领域中常用概念类的一种分类形式，可用于对照用例描述中的词汇获取预设的概念类。例如在商场中，一次交易可以包含Sale或者Payment等概念，而在机场可能还涉及Reservation等概念。通过上述方法可以获取候选的概念类列表，例如在表示交易的领域模型中，我们可以提取出Store、Register和Sale等作为候选概念类列表。需知候选概念类列表并非是唯一确定的，其具体的覆盖范围应结合上下文综合考虑。</p>

<p>下面讨论领域建模的一般步骤。</p>

<ol>
<li><p>结合上下文列出候选概念类列表。</p></li>
<li><p>采用领域模型对概念类进行可视化表示，即UML类图的最基本形式。</p></li>
<li><p>添加概念类之间的关系记录。作为领域模型的重要信息之一，关联关系有助于深入理解领域模型，下文会做进一步讨论。</p></li>
<li><p>添加概念类内部的属性记录。领域模型中的属性表示概念类中需要被记录的信息，其既可以是由用例描述中显式给出的，也可以是间接获取的。属性通常包含属性名和类型两个部分，其中属性类型可以是原始类型(Primitive type)或值对象(Value object)。此外，领域模型的属性应当排除外键属性的情况，后者应在设计阶段再予以考虑。</p></li>
</ol>


<p>关联是指概念类之间的、持续一定时长的关系，这里主要是为了强调关联的时间概念，用于和瞬间性关系进行区别。领域模型中的关系主要包含以下两类:1.<strong>须知型关系</strong>，即用例中明确指出的关联关系，属于领域模型的核心内容；2.<strong>理解型关系</strong>，即用例未显式说明但实际有助于理解领域模型的关联关系。</p>

<p>与概念类的三要素类似，关联也具有三个重要组成部分，分别是<strong>关联名字</strong>(Name)、<strong>多重性</strong>(Multiplicity)和<strong>导航性</strong>(Navigability)。其中关系命名可以遵照TypeName-VerbPhrase-TypeName的规则，在UML类图中体现为由上至下、由左至右的顺序；多重性与UML类图的概念基本一致；导航性是指关联关系在其两端概念类各自的可见性，例如可以是单向关联或是双向关联。</p>

<p>与提取概念类相似，关联关系可以通过从用例描述中提取动词短语发现，也可以对照<strong>通用关联关系表</strong>(Common Associations List)——一种领域特定的常见关联关系分类表。虽然在真实场景中可能存在非常多的概念类间关系，领域模型中仅需要表示重要关系，具体应依用例描述和上下文而定。</p>

<p>一个完整的领域模型例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/complete_domain_model.png" alt="A complete domain model" /></p>

<h4>基于彩色UML的通用领域建模模式</h4>

<p>当面对复杂问题域或特殊上下文时，朴素的领域建模方法会面临挑战。为了控制风险，常见解决办法是在分析过程中应用<strong>模式</strong>(Pattern)。模式是一种经过验证的经验性方法，且能够满足大多数的软件开发需求。领域建模的模式可以是基于特定领域的，也可以不限领域——即所谓的通用模式。本文不会就模式本身或其它类型的领域建模模式展开，下面仅讨论一种较为通用的领域建模模式。</p>

<p>[CDL99]描述了一种基于彩色UML的通用领域建模模式。该模式的作者从数百种领域模型中总结出了一种<strong>领域中立组件</strong>(Domain-neutral component)模型，该模型可以被应用至大部分的领域建模过程，从而得到理想的领域模型。领域中立组件模型由下面四种最基本的<strong>原型</strong>(Archetype)组成:</p>

<ul>
<li>时刻或时段(Moment-interval)原型，表示在某个时刻或时段内出于业务或合法性原因需要追踪的事物。例如一次销售在某个时刻发生，那么这次销售就有日期和时间；一次租赁发生在某个时间段，于是有起始时间和终止时间；一次销售甚至可以发生在某个时间段，从而允许对整个销售过程的效率进行评估。采用UML类图表示如下:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/moment.png" alt="Moment-interval" /></p>

<ul>
<li>角色(Role)原型，表示参与者、地点或事物(统称实体或Player)的参与方式。同一个实体可能扮演了多个角色，同一个角色也可能由多个实体扮演。实体自身拥有与角色无关的核心属性和行为，但有时也会具有跨角色的接口方法，用UML表示如下:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/role.png" alt="Role" /></p>

<ul>
<li><p>参与者、地点或事物(Party, place or thing)原型，表示问题域中的人、组织、地点或者事物，即实体。</p></li>
<li><p>描述(Description)原型，这种原型与目录项类似(Catalog-entry-like)，表示反复出现的值的集合以及这些集合项所共有的行为。例如一辆汽车拥有序列号、购买日期、颜色、里程表等多种信息，其中与目录项类似的描述主要是指车辆描述，例如制造商、型号、生产日期以及可选颜色等。</p></li>
</ul>


<p>为了在UML中描述前述原型，一般可以采用UML中的构造型(Stereotype)工具，但是当复杂性进一步增加时这种方式就不够直观，进而妨碍理解和后续建模。[CDL99]给UML添加了一个新的视觉维度，即采用粉-黄-绿-蓝四种颜色分别代表上述四种原型，颜色体现了原型的重要性程度，下图描述了原型、颜色及其相互关联:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/color_uml.png" alt="Archetypes and their colors" /></p>

<p>每个原型在属性、链接、方法、插入点和交互等方面具有相应特征:</p>

<p>时刻或时段原型是领域模型的核心，该原型的对象通常用于封装最有价值的内容，包含序号、日期、时刻或时段、优先级、总数和状态等属性。该对象方法包括创建支持业务流程的对象、添加细节、计算总数、完成或取消时刻或时段对象、以及访问其它同类对象，例如获取同类对象列表、计算平均时刻或时段等。当某些业务流程较复杂时，需要引入插入点使其更加适应变化。</p>

<p>角色原型是第二重要的部分，该原型的对象包含序号、状态等属性。角色原型对象通常会链接到对应的时刻或时段对象。该对象方法包括确定相应实体的可用性、提供业务值或性能估算，且都需要和对应的时刻或时段对象交互。</p>

<p>接下来是实体原型，该原型的对象通常作为角色对象的容器，包含序号、地址和自定义值等属性。实体对象通常会链接到角色对象。该对象方法包括查询可用性(自身状态或角色对象上的状态)、获取自定义值(当其不可用时则从对应的描述对象获取默认值)以及提供业务值或性能估算(与对应的角色对象交互)。</p>

<p>最后是描述原型，该原型的对象包含类型、描述、编号和默认值等属性。描述对象通常会链接到实体对象，但某些时候也会直接链接到时刻或时段对象。该对象方法包括查询可用的实体、计算可用实体的数量，这些方法都需要和对应的实体对象交互。当对象具备复杂算法的行为时，需要引入一个支持提供替代行为的插入点。</p>

<p>在领域建模中，根据所属原型的特征定义概念类的职责，从而使原本偏向静态表示的UML类图进一步表达了类似时序图或协作图的动态交互信息，这也是彩色UML工具的一大优势。此外，[CDL99]借助领域中立组件模式构建了12种<strong>领域特定组件</strong>(Domain-specific component)，经验表明这些领域特定组件能够直接应用于大多数领域建模过程。在面临复杂系统时，可以通过恰当的领域特定模型描述系统中不同的子概念，然后基于是否需要可扩展性，采用直接连接或插入点连接实现组件间联通，从而组装成最终的领域模型。</p>

<h3>面向对象设计(OOD)</h3>

<p>OOA通常要求领域专家、需求分析和技术专家共同参与，体现的是团队对问题域的一致性描述，也就是本文最开始提到的“做正确的软件”。为了“正确的做软件”，OOD更多需要技术团队的更多参与，进一步描述实现中所需对象及其协作的定义。与OOA不同的是，OOD更关注实现细节，例如创建与实际编码中对应的对象、定义对象行为以及对象间的交互等。在过去数十年中，一系列工具、方法、原则、模式等被提出和应用至OOD，限于篇幅本文不可能覆盖前述所有主题，下面仅讨论具有代表性的工具和方法。</p>

<h4>GRASP:基于通用职责分配软件模式的面向对象设计</h4>

<p>[CLA01]提出了一种基于<strong>通用职责分配软件模式</strong>(General Responsibility Assignment Software Patterns, GRASP)的OOD方法，该方法被用于生成可供参考实现的<strong>设计模型</strong>(Design Model)。其基本思路是从用例模型和领域模型出发创建交互图，采用GRASP模式对交互图进行不断优化，并随时补全所需的类图，最终得到的交互图和类图就是设计模型的主要内容。前文已经介绍过时序图和通信图，这里不再赘述。下面讨论GRASP模式及其在设计中的应用。</p>

<p>在UML中，职责是指契约或者义务，这些通常是通过对象的行为体现出来的。职责包含以下两种类型:</p>

<ul>
<li><p>行为型(Doing)责任，例如自身行为、驱动其它对象的行为以及在其它对象中起到控制和协调作用的行为。</p></li>
<li><p>知识型(Knowing)责任，例如自身封装的数据和功能以及与自身相关的其它对象。</p></li>
</ul>


<p>在领域模型中，概念类的职责通常是显式的。但在实际设计中，来自领域模型的职责需要被分配至不同粒度的类或方法。例如“创建一个销售”这类职责可能只需要一两个方法，但是“提供关系数据库的连接”这类职责就可能需要更多类和方法了。为了完成某项职责，对象可以仅通过自身方法完成，也可能依赖其它对象的方法，因此可以认为OOD的本质就是把职责分配到不同的对象中，这也是GRASP的核心思想。</p>

<p>由职责的定义可知，最能完整体现职责的UML工具是交互图，因为后者同时包含了对象、方法和交互信息，这也是从交互图出发进行OOD的原因。GRASP为职责分配提供了一系列指南，以下用其中5个代表性条目为例:</p>

<ul>
<li><p>信息专家(Information Expert)，指如果某个对象具有满足职责的必要信息，那么职责就分配给该对象。同时满足该职责所需的信息可能保存在不同对象中，那么就需要把职责分配至不同的对象，并通过对象协作完成整个职责。</p></li>
<li><p>创造者(Creator)，指如果对象A的职责是创建对象B，那么需要满足A对B的紧密包含关系，例如组合、聚合、强使用关联、强数据关联等场景。</p></li>
<li><p>高内聚(High Cohesion)，指职责分配应保证高内聚，低内聚意味着对象包含了许多无关或者过多的职责，从而影响可理解性、可复用性、可维护性等方面，同时极易被外部影响而发生改动。</p></li>
<li><p>低耦合(Low Coupling)，指职责分配应保证低耦合，强耦合意味着对象更易受到外部变的影响，低可理解性和低可复用性。</p></li>
<li><p>控制器(Controller)，指接收和处理系统消息的职责应分配给具备以下条件的对象:1.代表整个子系统;2.代表某个用例场景。前者相当于系统的外观控制器(Facade Controller)，后者则只表示一个事件处理器(Handler)或协调器(Coordinator)。</p></li>
</ul>


<p>基于GRASP的设计过程相当于把职责从领域模型转移到设计模型，优先从设计模型中选择已有的类，如果没有该类再从领域模型中抽取概念类，直到满足全部用例。</p>

<h4>类职责协作卡(Class-responsibility-collaboration card, CRC)</h4>

<p>目前为止，UML在OOA和OOD中都占据了主流地位，但是我们仅采用了其中不到5%的内容。同时，UML及相关的<strong>计算机辅助软件工程</strong>(Computer-aided software engineering, CASE)工具，使OOD在纸面上花费了大量时间，却难以应付软件工程中出现的各种变化。强调团队协作是应对变化的重要手段之一，因此OOD需要与之相适应的轻量级工具，其中有代表性的就是本节将讨论的<strong>类职责协作卡</strong>(CRC)。</p>

<p>CRC是一种专注于描述类的职责分配和对象协作的轻量级OOD工具，其最初被用于针对团队的OOD培训并取得了良好效果[BC89]，后来因其面向团队协作的特点，被广泛应用至协作式的OOD活动。下图展示了CRC的基本格式:</p>

<p><img src="http://content.hanyi.name/images/object_oriented_analysis_and_design/crc.png" alt="CRC" /></p>

<p>CRC的形式很容易理解，也比UML的交互图更加轻便，但其可表达的信息类型数和精确性不如后者，其优势在于团队协作设计。基于CRC的团队协作设计流程大致如下:</p>

<ol>
<li><p>集合团队，首先解释当前用例及其具体场景描述。</p></li>
<li><p>从场景中提取相应职责，并将其分配给合适的CRC卡(即类)。</p></li>
<li><p>确定该职责是否需要协作类，并且移动卡片使相互关联的类挨在一起。</p></li>
<li><p>如果存在替代方案，可以快速创建新的卡片，并将其和原方案放在一起比较，经过团队讨论做出进一步设计决定。</p></li>
</ol>


<p>应当注意，上述活动中除了步骤1之外，都离不开OOD原则和模式的指导。经过准确解释和高效协作，CRC能够帮助团队快速理解上下文并就OOD达成一致的方案。当然，CRC的成功应用离不开一系列敏捷实践的共同作用，否则很容易导致“欲速则不达”的后果。</p>

<h4>设计契约(Design by contract)</h4>

<p>随着OOD/OOP在软件设计和开发中流行，如何保证对象间协作的可靠性逐渐受到重视。软件的可靠性包含了正确性和鲁棒性(或者可直观表达为bug的数量)。我们知道，检验软件本身及其设计的正确性是非常困难的。因此，在设计和开发阶段采取措施是加强可靠性的重要手段。例如采用<strong>防御式编程</strong>(Defensive programming)，即意味着在对象方法的执行过程中做大量检查，例如参数合法性、状态合法性、返回结果合法性等。但是，防御式编程会引入大量冗余且复杂的代码，进而降低软件的可维护性，也不利于维持可靠性。[BM92]提出了设计契约的概念，通过在面向对象的类和方法级别定义合适的契约，从而在设计阶段就引入可靠性保障，该思想同时被引入到实现过程中，成为软件开发的重要技巧之一。</p>

<p><strong>断言</strong>(Assertion)是设计契约的核心，断言要求对应的布尔表达式返回值必须为True，否则即意味着异常和潜在bug并且立即报错。同时，断言应当仅被用于表示OOD的契约，而非具体用例场景，因此其只能被用于debug和测试场景。OOD的设计契约包含三种类型的断言:</p>

<ul>
<li><p>前提条件(Pre-condition)，指某个方法执行前的期望，例如检查输入参数是否合法。采用断言作为前置条件，即意味着输入合法性应实际由方法的调用者保证。而断言的引入则确保在debug和测试阶段验证调用者是否实现了正确的参数检查。</p></li>
<li><p>后置条件(Post-condition)，指某个方法执行后的期望。与方法体本身不同的是，后置条件语句侧重于描述执行结果，而非前者的过程。</p></li>
<li><p>不变量(Invariant)，指某个类本身的断言。不变量应当对类的所有对象都始终为True，也就是说，不变量实际上是所有公共方法的默认前提条件和后置条件。</p></li>
</ul>


<p>面向对象中的继承给断言带来了一定的复杂性。对于不变量和后置条件来说，子类只能选择强化父类中的断言或维持不变；但是对前提条件而言，子类只能选择弱化父类断言或维持不变。前述约束是由继承引入的动态绑定特性所带来的[MFR03]。</p>

<h2>结论</h2>

<p>本文所讨论的OOA和OOD分别对应了不同的动机、方法论和评价方式。工具和方法离不开原则和模式的指导，原则和模式在工具和方法的帮助下实现了解释和落地，这些设计元素已然形成了有机整体。前述这些方法论极大促进了软件分析和设计朝着“两个正确”的方向前进。另一方面，以80年代末SEI发起的CMM(Capability Maturity Model)和90年代中期UML的标准化为标志，软件设计乃至整个软件工程开始迈向标准化时代。但是，看似科学的设计和过程随即受到互联网时代巨大变化的冲击，敏捷的思想就是在这种背景下诞生和发展起来的。例如，敏捷强调良好的沟通和协作胜于功能强大的工具，在OOD中正如UML这类大杀器，但也有更轻量的CRC，因此后者被更多用于敏捷软件设计活动。无论如何，在可以预见的未来，业界在“两个正确”的方向上仍有很长一段路要走。</p>

<h2>引用</h2>

<p>CLA01, <a href="https://www.utdallas.edu/~chung/SP/applying-uml-and-patterns.pdf">Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and the Unified Process</a></p>

<p>ACB99, <a href="https://www.infor.uva.es/~mlaguna/is1/materiales/BookDraft1.pdf">Writing Effective Use Cases</a></p>

<p>MO95, <a href="https://dl.acm.org/citation.cfm?id=561612">Object-oriented methods: a foundation</a></p>

<p>CDL99, <a href="https://dl.acm.org/citation.cfm?id=554136">Java Modeling in Color with UML</a></p>

<p>BC89, <a href="http://c2.com/doc/oopsla89/paper.html">A Laboratory For Teaching
Object-Oriented Thinking</a></p>

<p>BM92, <a href="http://se.inf.ethz.ch/~meyer/publications/computer/contract.pdf">Applying “Design by Contract”</a></p>

<p>MFR03, <a href="https://martinfowler.com/books/uml.html">UML Distilled</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(8)]]></title>
    <link href="http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8/"/>
    <updated>2019-02-06T16:23:31-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/02/06/software-design-and-architecture-notes-8</id>
    <content type="html"><![CDATA[<h2>面向对象——概念与建模</h2>

<p>由前文<a href="blog/2019/01/24/software-design-and-architecture-notes-7/">编程范式</a>我们知道，对象作为最基础的编程概念广泛存在于各类编程范式中，采用这种范式的语言被称为基于对象语言(Object based language)。本文讨论的<strong>面向对象</strong>(Object oriented)的概念则首次出现在1967年诞生的Simula 67，其中除了对象概念本身外，还进一步提出了<strong>继承</strong>和<strong>多态</strong>这两个重要特性，成为此后长期影响学术界的语言之一。而面向对象在工业界的兴起则始于上世纪80年代，以Smalltalk和C++的相继发明为标志，深刻影响了此后近四十年的软件工程。</p>

<h3>基本概念</h3>

<p>继承是区分面向对象和基于对象的重要特征，大部分面向对象语言的继承是采用<strong>类</strong>(Class)实现的(注意“类”和“对象”是完全不同的编程概念)。我们知道类可被看作是能够创建对象的工厂对象，继承则允许增量式地进行对象扩展。因此，类作为数据抽象的核心，在其基础上实现继承就自然地支持增量式的数据抽象。除了类之外，面向对象还支持一种基于<strong>原型</strong>(Prototype)的特殊实现，后者通常并不包含类定义，任何对象都能够唯一地指定另一个对象作为其原型，其中对象的属性和事件沿原型链传递查找，从而实现继承。从支持增量式对象扩展的角度看，类继承和原型继承没有本质区别。下面讨论在面向对象语境下的一些重要概念。</p>

<ul>
<li>类。类是一个可能同时包含部分具体实现的抽象数据类型[BMR97]，其被用于描述一组存在于内存中且可直接被用于计算的实例。类的特点在于其同时扮演了<strong>模块</strong>和<strong>类型</strong>两种角色。其中模块作为一种语法概念，通常被用于表示软件分解单元，而类型则被用于动态对象的静态描述，相当于一种语义概念。在非面向对象模式中，上述两种概念通常是被分开表示的。</li>
</ul>


<p>在某些面向对象系统中(例如Smalltalk和Ruby)，类自身也可能是通过对象实现的，这种实例依然是其本身的类被称作<strong>元类</strong>(Metaclass)，面向对象语言或编程环境的作者可以利用元类方便地实现某些动态扩展特性，例如Ruby的<a href="http://www.hanyi.name/blog/2015/08/29/metaprogramming-ruby-core-concepts-object-oriented-hierarchies/">单例类</a>。</p>

<ul>
<li>对象。对象是指某个类的运行时实例[BMR97]。</li>
</ul>


<p>虽然“对象”一词最初来源于对真实世界物体的描述，但在实际编程场景中对象已经不仅仅被用于描述真实物体，例如用于描述一组配置属性等因技术需求而诞生的对象。对象是通过<strong>引用</strong>(Reference)进行表示的，并且可以被自身或其它对象引用。一个对象引用唯一地指向了该对象唯一且不变的<strong>标识</strong>(Identity)。对象标识是用于区分不同对象的唯一凭证。</p>

<p>对象的创建过程通常是在面向对象系统中默认定义的，一般包括分配内存空间和初始化两个步骤，前者由系统自身负责，后者允许在程序中自定义初始化过程。以Java的面向对象系统为例，类支持以构造函数(Constructor)定义初始化过程，如果某个类没有包含显式的构造函数，编译器会自动加入一个默认的无参构造函数并在其中调用父类的无参构造函数。</p>

<ul>
<li>组合与聚合。如果采用引用表示对象，那么对象之间就可以通过引用产生<strong>关联</strong>(Association)。但是仅使用引用不足以描述对象间真实的关系特征，从而无法满足<strong>忠实建模</strong>(Faithful modeling)。<strong>组合</strong>(Composition)关系是指一个对象包含了另一个对象的值，这种关系超过了一般引用的定义，特别是指被包含对象的生命周期被限制在其父对象内。<strong>聚合</strong>(Aggregation)关系指一个对象由另外多个对象组成，其组成关系通过引用实现。与组合的区别在于，聚合中被包含对象的生命周期不受父对象限制。</li>
</ul>


<p>从面向对象中对关系分类的角度看，组合与聚合可以统一被看作<strong>客户</strong>(Client)关系，其实质是对对象间关系的描述。</p>

<ul>
<li><p>继承。继承描述了一种类之间的扩展关系。在面向对象中，类本身具备良好的模块化特性，从而能够满足信息隐藏的原则，但模块化并不直接提供增量式设计和开发的途径。继承支持了类之间的扩展、特化和组成关系，显著增强了面向对象的可重用性和可扩展性。其中包括四个重要的衍生概念:</p>

<ul>
<li>重定义(Redefinition)，指子类能够重新实现父类中定义的过程，有时也称作<strong>覆盖</strong>(Override)。</li>
<li>多态(Polymorphism)，指一个变量实体或数据结构元素，在具备可控静态声明的前提下能够在运行时阶段绑定至不同类型的对象。例如当类A继承类B，那么类A的对象a，可以被赋于类型为B的变量b，且并不违反类型检查。</li>
<li>静态类型(Static typing)，前面提到多态的前提是具备“可控静态声明”，具体是指对于一个变量的声明类型(也称变量的静态类型)，尽管允许其被赋予不同类型(也称变量的动态类型)，但其动态类型必须是静态类型的后代(后代定义包含其自身)。</li>
<li>动态绑定(Dynamic binding)，是指变量所指向对象的动态类型决定被调用操作的具体位置。</li>
</ul>
</li>
</ul>


<p>本质上，继承同时包含了两个角色且互有重叠:模块和类型。从模块的角度看，继承提供了一种有效的可重用特性。这里提到的有效是指当类A继承类B时，A就立即拥有了B的全部特性，且无须进行任何改动。从类型的角度看，继承同时增强了可重用性和可扩展性，这主要体现在: 1.对于类Rectangle继承类Polygon，即Rectangle的全部实例同时也是Polygon全部实例的子集。2.对于类A继承类B，那么B的任意实例所具有的操作也同时存在于A。在许多文献中，继承也被称作is-a关系。</p>

<ul>
<li>多重继承。在真实世界中，对象可能同时包含了不同领域的抽象，对应在面向对象中就是多重继承，即一个类可以同时拥有多个父类。例如，类Teacher和类Student都继承了类UniversityPerson，这时需要一个类TeachingAssistant且同时继承自类Teacher和类Student，也就是说通过两个父类间接继承了类UniversityPerson，即<strong>重复继承</strong>。重复继承可能会造成一定的函数访问冲突，特别是当调用类TeachingAssistant的对象的name函数，而其实际上位于类UniversityPerson时，系统就面临多重函数查找路径的问题。而由此引发的复杂性使得多重继承在许多现代面向对象实践中被认为弊大于利，且不被推荐使用。但不可否认，多重继承实际上体现了真实世界原本的复杂性。</li>
</ul>


<p>在支持多重继承的面向对象系统中，通常采用<strong>复制</strong>(Replication)和<strong>共享</strong>(Sharing)两个策略解决前述重复继承问题。复制是指当遇到重复继承时，子类实际上包含了所有继承路径上属性和函数的副本，程序这时需要具体指定被调用副本的名称。共享是指程序可以指定在子类中只保留一份来自祖先的副本，这样就避免了名字冲突的问题，例如C++的<strong>虚继承</strong>(Virtual inheritance)。</p>

<p>许多现代面向对象语言不支持多重继承，但同时为了保留一定的设计能力大多采用了折衷方案，例如Java的<strong>接口</strong>(Interface)、Ruby的<strong>混入</strong>(Mixin)等。</p>

<ul>
<li>泛型。继承本质上体现了一种纵向的层级扩展关系，由上至下可以被看作是面向对象从抽象化到特化。而<strong>泛型</strong>(Genericity)则支持横向的同级扩展关系，即类型参数化。</li>
</ul>


<p>泛型最经典的案例就是编程语言标准库中常见的容器类，例如Set、List、Map等，这些容器类实际上是参数化的抽象数据类型，其本身包含了抽象数据类型中的具体操作，并藉由客户代码通过指定参数决定具体的元素类型。由于历史的原因，许多现代编程语言中虽然提供了泛型特性，但其实现原理差别巨大。例如C++的模板能完整地重新编译目标代码，最终根据模板参数生成不同的函数和类；而Java的泛型实际上是一种为了增强代码类型安全的语法特性，编译器对泛型语法进行类型检查，并最终通过<strong>类型擦除</strong>(Type erasure)生成无类型参数的目标代码；C#的泛型实现则介于C++的灵活和Java的简易之间，通过运行时<strong>实化</strong>(Reification)进行类型检查和具体操作，从而避免了类型擦除的缺点(例如无法实现泛型数组)，同时把类型参数保留在运行时，从而满足在泛型条件下支持反射。</p>

<h3>面向对象建模(Object Oriented Modeling)</h3>

<p>从上世纪80年代起，随着工业界对面向对象语言从逐渐认识到深入实践，面向对象开始代替传统的结构化方法成为主宰范式。但是，基于面向对象的软件开发很快就面临了更多数量的对象以及更加复杂的关系，实现系统设计也变得空前复杂。作为OO的早期布道者之一，Grady Booch等分别在面向对象的基本概念基础上发展出了一系列全新的建模方法，被统称为<strong>面向对象建模</strong>。</p>

<h4>统一建模语言(Unified Modeling Language, UML)</h4>

<p>1997年，Three amigos在Grady Booch的Booch method、James Rumbaugh的Object modeling technique(OMT)以及Ivar Jacobson的Object oriented software engineering(OOSE)的基础上，正式发布了UML 1.1。UML是一种编程语言无关的通用建模技术，旨在采用统一语言对复杂问题的不同关注点进行建模。</p>

<p>UML由<strong>图形标记</strong>(Graphical notations)和<strong>元模型</strong>(Meta-model)组成。其中图形标记定义了相关概念的图形表示法，也是UML建模的主要工具。元模型是一种对UML模型的形式化表示方法，用于对UML规格说明的精确表达。后者常被用于构建基于UML的计算机辅助软件工程(Computer Aided Software Engineering, CASE)系统。这里只讨论UML的图形标记方法。</p>

<p>下图展示了UML 2.5.1的图形标记分类[UML17]。其中<strong>结构图</strong>(Structure diagrams)用于代表系统中对象的静态结构，通常能够表示系统的核心概念及行为定义，但并不包括行为的动态细节。<strong>行为图</strong>(Behavior diagrams)表示系统中的动态行为，包括方法、协作、活动和状态历史记录等。</p>

<p><img src="http://content.hanyi.name/images/object_oriented/uml_diagrams_overview.png" alt="The taxonomy of UML diagrams" /></p>

<p>随着UML被纳入国际标准，其复杂度不断增加，即使由对象管理组织(Object Management Group, OMG)定义的狭义UML规范也已经十分臃肿，使其逐渐脱离了日常的软件设计实践。但不可否认，UML的核心内容依然在面向对象建模中占据权威地位。为了保证UML的实用性，本文接下来只讨论核心的图形标记[MFR03]。</p>

<ul>
<li>类图(Class diagrams)，表示系统中的对象类型及其相互之间的静态关系。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/class_diagrams_overview.png" alt="Class diagram" /></p>

<p>在上图中，每个方框表示类的属性和操作，方框间的实线表示类的相互关系，在每种关系上还标记了两个类之间的<strong>多重关系</strong>(Multiplicity)。关系是UML中最复杂的概念之一，甚至允许通过构造型(Stereotype)对关系进一步扩充。UML的基本关系种类包括：1. 关联(Association)，指类之间的持续性关系，例如类的属性类型，关联采用实线表示，并且可以是无向、单向和双向，带方向的关联进一步揭示了源类中包含以目标类作为类型的属性；2. 依赖(Dependency)，指一个元素(Supplier)的变更可能引起另一个元素(Client)的变更，依赖采用单向的虚线表示；3. 泛化(Generalization)，表示类之间的类型层级关系，例如继承采用带三角箭头的实线表示，如果目标类是接口类，那么采用带三角箭头的虚线表示，抽象类需要额外使用斜体表示。</p>

<p>从上述关系的定义来看，依赖是含义最广泛的关系，也是面向对象建模中需要仔细考虑的问题。过多的依赖路径会导致修改时发生涟漪效应(Ripple effect)，从而降低系统的可维护性。关联进一步包含了前文讨论的组合和聚合关系，其中组合使用一端实心菱形和单向箭头的实线表示，聚合采用一端空心菱形和单向箭头的实线表示，分别如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/aggregation.png" alt="Aggregation" /></p>

<p><img src="http://content.hanyi.name/images/object_oriented/composition.png" alt="Composition" /></p>

<p>UML中的大部分工具实质上都是为了设置约束，但仅通过图形标记无法表示所有类型的约束，因此UML支持使用{}表示自定义的约束。自定义约束的具体形式没有严格限定，可以是自然语言、伪代码，也可以采用对象约束语言(Object constraint language, OCL)。</p>

<ul>
<li>对象图(Object diagrams)，是指系统在某个时间点的对象快照，也被称作实例图。虽然类图能够完整表达对象的结构信息，但有时候并不容易理解，对象图能够以某个真实案例对前者进行补充。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/object_diagram.png" alt="Object diagram" /></p>

<ul>
<li>包图(Package diagrams)，指一组类或嵌套包的集合。包也被称作命名空间(Namespace)，其作用是定义比类层次更高的系统结构。包图在UML中使用带标签名的方框表示，包之间也可以定义类似类图中关系。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/package_diagram.png" alt="Package diagrams" /></p>

<ul>
<li>部署图(Deployment diagrams)，指系统的物理结构，特别是软件及其所运行的硬件框架。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/deployment_diagram.png" alt="Deployment diagram" /></p>

<ul>
<li>组合结构图(Composite diagrams)，指对一个类的内部结构进行层级表示，从而使其更容易被理解。以类TV Viewer为例，下面是TV Viewer的类图:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/composite_structure_1.png" alt="Class diagram of TV Viewer" /></p>

<p>如果用组合结构图进一步描述TV Viewer，则如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/composite_structure_2.png" alt="Composite structure diagram of TV Viewer" /></p>

<ul>
<li>组件图(Component diagrams)。在UML中，组件是一种从功能角度上看可以独立分发和升级的模块。组件图用于表示组件之间的交互关系，如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/component_diagram.png" alt="Component diagram" /></p>

<ul>
<li>时序图(Sequence diagrams)，表示一组对象及其之间的协作关系。具体来说，时序图通常限定在一个单独的场景下，包含了一组对象以及依据用例而发生的对象间消息传递，特别是展示了消息发生的顺序信息。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/sequence_diagram.png" alt="Sequence diagram" /></p>

<p>在时序图中，由于第一个消息通常不在参与者(Participants)中，因此也被称作<strong>创始消息</strong>(Found message)。另外，时序图中的参与者是可以被动态创建和销毁的。同时消息传递过程也支持循环、分支以及异步等特性。</p>

<ul>
<li>状态机图(State machine diagrams)，也称作状态图，表示单个对象的整个生命周期行为。在面向对象中状态具体包括了对象中所有属性值的集合，而状态图则侧重于抽象的状态定义，即提供不同的事件响应方式。一个简单的状态图例子如下:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/state_machine_diagram.png" alt="State machine diagram" /></p>

<p>该状态图表示了一座城堡中的安全机关。图中方框表示一个状态，除了状态名之外，还可以填入状态的内部活动，包括状态事件(Event)、看守(Guard)和活动(Activity)，当某个事件发生时，可根据当前状态选择迁移(Transition)或保持状态不变。更进一步，状态既可以是静止的也可以是活动的，例如当前对象某个正在发生的动作。状态也可以被分组，其作用是表示组内所有子状态的同一个向外部某个超状态(Superstate)迁移的路径。</p>

<p>在并发场景中，单个状态可以被分割成几个正交的子状态图，一个闹钟的例子如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/concurrent_state_diagram.png" alt="Concurrent state diagram" /></p>

<p>该图中用一个历史伪状态标记代替了初始状态标记，意味着当开关打开时，初始状态应为上一次开关关闭时所处的状态。</p>

<p>值得注意的是，状态图对应着两种可能的实现，一种是采用控制流代码或面向对象实现，另一种是基于状态表的解析和查询。前者具有更加复杂的代码结构，且需要持续维护相关代码；后者需要在初期实现一个较复杂的状态表解析和查询特性，后期则主要集中于状态表的数据维护。无论采用哪一种实现，其最终代码都具有一定的样板特征，因此结合代码生成技术都是更好的选择。</p>

<ul>
<li>活动图(Activity diagrams)，表示过程逻辑的业务流程的行为，且通常是跨多个用例或线程的行为。先看一个活动图的例子:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram.png" alt="Activity diagram" /></p>

<p>从上例可以看出，该活动图与传统的流程图十分类似，最主要的区别在于前者支持并发活动，例如<strong>分叉</strong>(fork)操作可以产生并发的子活动，所有子活动的同步操作通过<strong>结合</strong>(join)进行。活动图中的动作(Action)之间使用流(Flow)或者边(Edge)进行连接，且可以被进一步分解成更多子活动，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_2.png" alt="Action decomposition" /></p>

<p>一般而言，活动图更多聚焦于描述业务过程而非实现，但通过分区(Partition)可以进一步表示不同动作的负责对象，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_3.png" alt="Partition" /></p>

<p>活动图支持基于信号的动作触发场景，信号可以被直接触发并接收，也可以通过定时器触发，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_4.png" alt="Signal" /></p>

<p>活动图还进一步支持采用动作方框下放置别针(Pin)表示该动作的输入和输出参数，如果某个动作的输出与下一个动作的输入参数不同，还需要使用参数变换(Transformation)使其一致。当一个动作会导致下一个动作触发多次时，可以采用扩展区域(Expansion regions)标记需要响应多次的动作集合，如下图所示:</p>

<p><img src="http://content.hanyi.name/images/object_oriented/activity_diagram_5.png" alt="Expansion regions" /></p>

<p>在该例中，扩展区域中的动作流程可能会部分导致终止，因此采用终止流(Flow final)进行标记。</p>

<ul>
<li>通信图(Communication diagrams)，在UML 1.x中被称作协作图(Collaboration diagram)，用于表示对象交互过程中的数据连接，如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/communication_diagram.png" alt="Communication diagram" /></p>

<p>通信图所表达的信息与时序图类似，形式相对灵活但不如后者规整，因此其受欢迎程度也不如后者。</p>

<ul>
<li>交互概述图(Interaction overview diagrams)，指结合了活动图和时序图的概述表示。如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/interaction_overview_diagram.png" alt="Interaction overview diagram" /></p>

<p>交互概述图实际上是一种针对对象交互行为的整体表现方案的总结。</p>

<ul>
<li>时间图(Timing diagrams)，表示单个或一组对象交互的时间约束。特别是当对象的某个状态存在一定时间约束时，如下图所示:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/timing_diagram.png" alt="Timing diagram" /></p>

<ul>
<li>用例图(Use case diagrams)，表示系统的功能需求。用例(Use case)是一种对用户与系统或系统自身交互的描述。用例更注重用户的一般目标，与用户场景(User scenario)不同，后者详细描述了用户与系统的每一步交互(这里的用户不仅指人类)，如果交互过程中发生分支则产生新的场景。也就是说，一个用例包含了许多用户场景。下图是一个用例图的例子:</li>
</ul>


<p><img src="http://content.hanyi.name/images/object_oriented/use_case_diagram.png" alt="Use case diagram" /></p>

<p>用例是对系统功能的更高级描述，与极限编程中的用户故事(User stories)相比，后者侧重于表示系统特性，且可以用于安排迭代计划，而用例则是单纯的系统功能性描述。在具体实践中，一个特性可能直接对应用例，或者用例中的一个步骤，也可能对应于其中一个场景。而大多数情况下用例要比特性具有更粗的粒度。</p>

<h2>结论</h2>

<p>本文首先讨论了面向对象的核心概念；随着面向对象编程的流行，开发中面临的问题复杂度不断提升，由此催生了面向对象建模技术。UML旨在实现语言无关的通用建模语言，被广泛用于面向对象分析(OOA)和设计(OOD)等活动。另一方面，随着相关国际标准的建立，UML也逐渐变得更加臃肿，因此实践中，视实际情况选择性地对工具进行裁剪就变得尤为重要。</p>

<h2>引用</h2>

<p>BMR97, <a href="https://sophia.javeriana.edu.co/~cbustaca/docencia/POO-2016-01/documentos/Object%20Oriented%20Software%20Construction-Meyer.pdf">Object-Oriented Software Construction</a></p>

<p>UML17, <a href="https://www.omg.org/spec/UML/">The unified modeling language specification</a></p>

<p>MFR03, <a href="https://martinfowler.com/books/uml.html">UML Distilled</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(7)]]></title>
    <link href="http://www.hanyi.name/blog/2019/01/24/software-design-and-architecture-notes-7/"/>
    <updated>2019-01-24T14:29:52-05:00</updated>
    <id>http://www.hanyi.name/blog/2019/01/24/software-design-and-architecture-notes-7</id>
    <content type="html"><![CDATA[<h2>编程范式(Programming Paradigms)</h2>

<p><em>作为专业程序员，对方法论的持续抽象绝对是一项明智的长期投资。</em></p>

<p>Robert W. Floyd在1978年图灵奖颁奖礼上如是说[RWF79]，这里所说的“方法论”即<strong>编程范式</strong>(Programming Paradigms)。<strong>范式</strong>一词源自Thomas S. Kuhn的《科学革命的结构》，Kuhn认为过去数个世纪的科学变革，实质上是主宰范式的更替，而这些范式却都曾在一段时期内常自认为能够独立揭示科学的内涵[TSK62]。具体到程序设计领域，范式表示为编程活动中存在的公共风格或方法论。例如，结构化编程可看作是上世纪70年代的主宰范式，但并非唯一。即使是忠实的拥趸也必须承认，结构化编程在解决某些问题时并不理想，于是持续有诸如分支限定(branch-and-bound)、分治(divide-and-conquer)、状态机(state machine)等其他更高层级范式的提出。或许有人认为使用较为底层的编程范式照样可以完成绝大部分任务，但却低估了软件的运行效率和经济效益等重要因素。因此Floyd认为，编程技术得以持续进步的重要前提即是新范式的发明、阐释和交流。</p>

<h3>编程范式的概念组成(Conceptual Composition of Programming Paradigms)</h3>

<p>任何一种编程范式都可以被看作是由一组编程概念(Programming concepts)，通过组装内核语言(Kernel language)而形成[PVR04]。从数量上看，编程语言要比编程范式种类更多，编程概念则较少，假设存在n种概念，则理论上可以有2<sup>n</sup>种范式。下面以一些重要的编程概念为例：</p>

<ul>
<li><strong>变量</strong>(Variables)，通常由标识符(Identifier)和存储变量(Store variable)组成，前者相当于变量的名字，后者则是变量在内存中的实际位置。一个变量需要使用声明语句加以创建，例如：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>V=9999*9999</span></code></pre></td></tr></table></div></figure>


<p>这里declare语句的作用相当于执行创建标识符和存储变量两个任务。</p>

<ul>
<li><strong>函数</strong>(Functions)。函数由标识符、参数列表和函数体组成，标识符的作用与变量一致，参数列表规定函数的输入，而函数体用于容纳一段程序代码，例如：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>fun {Fact N}
</span><span class='line'>if N==0 then 1 else N*{Fact N-1} end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>在该例中，Fact函数接受参数N，并且计算并返回N的阶乘。值得注意的是，函数体中的代码包含了条件表达式，以及对应于阶乘数学定义的<strong>递归</strong>表达式。递归使函数具有相对复杂的数学表达能力，例如求解组合数函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>fun {Comb N K}
</span><span class='line'>{Fact N} div ({Fact K}*{Fact N-K})
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>尽管该函数体只有一条语句，但精确反映了组合数的数学定义。但需要注意，Comb函数本身需要依赖之前定义的Fact函数，这种使用已有函数组成新函数的形式，被称作<strong>函数抽象</strong>(Functional abstraction)。</p>

<ul>
<li><strong>表</strong>(Lists)。当参与计算的数达到一定数量，就需要一个方便的方式表示数的集合了。例如计算杨辉三角( Pascal’s triangle)，其实质是对组合数在自然数序列上的枚举，即“从n中取k个数”，其中n为自然数序列，k则是从0到n范围内的自然数，在杨辉三角中n表示三角形的行数，而k表示为列数。那么为了保存该问题中的数列，就需要引出表的定义：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>T=[5, 6, 7, 8]</span></code></pre></td></tr></table></div></figure>


<p>表实际上是一条由连接构成的链，其中每个连接由两部分组成：表元素和剩余链部分的引用。Lisp语言使用cons函数动态地在表中创建新的连接，类似地这里用H|T表示cons，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>H=4
</span><span class='line'>T=[5, 6, 7, 8]
</span><span class='line'>M=H|T</span></code></pre></td></tr></table></div></figure>


<p>该例中M的值为[4, 5, 6, 7, 8]。反过来，也可以在一个表中实现逆cons操作，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>L=[5 6 7 8]
</span><span class='line'>{Browse L.1}
</span><span class='line'>{Browse L.2}</span></code></pre></td></tr></table></div></figure>


<p>这里L.1输出5，L.2输出为6, 7, 8。</p>

<p>表通常支持<strong>模式匹配</strong>(Pattern matching)操作，目的是更方便对表进行分解，例如该例中的case指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>L=[5 6 7 8]
</span><span class='line'>case L of H|T then {Browse H} {Browse T} end</span></code></pre></td></tr></table></div></figure>


<p>这里case通过指定一种cons模式对表L进行分解，并使用H和T两个局部变量保存分解后的值，该局部变量的作用域仅限于case语句的then..end代码块内。</p>

<ul>
<li><strong>基于表的函数应用</strong>(Functions over lists)</li>
</ul>


<p>现在设计函数计算杨辉三角，计算原理是，对于第n行数列，分别将其左移一位和右移一位生成两个新的数列(末端补0)，然后将两列相加，即得到第n+1行数列。下面用自上而下法编程解决该问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare Pascal AddList ShiftLeft ShiftRight
</span><span class='line'>fun {Pascal N}
</span><span class='line'>  if N==1 then [1]
</span><span class='line'>  else
</span><span class='line'>      {AddList {ShiftLeft {Pascal N-1}} {ShiftRight {Pascal N-1}}}
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>该函数在最顶端模拟了前述文字描述的算法，其余函数可分别表示为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun {ShiftLeft L}
</span><span class='line'>  case L of H|T then
</span><span class='line'>  H|{ShiftLeft T}
</span><span class='line'>  else [0] end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun {ShiftRight L} 0|L end</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun {AddList L1 L2}
</span><span class='line'>  case L1 of H1|T1 then
</span><span class='line'>      case L2 of H2|T2 then
</span><span class='line'>          H1+H2|{AddList T1 T2}
</span><span class='line'>      end
</span><span class='line'>  else nil end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>可以看出，当程序引入了函数和表操作时，其复杂度也相应增加。那么应如何判别该程序的正确性呢？</p>

<ul>
<li><p><strong>正确性</strong>(Correctness)。程序的正确性验证是一个非常复杂的问题，因为它不仅涉及编写的程序本身，还依赖对编译器、运行时系统、操作系统、硬件环境乃至其它物理因素的正确性验证。因此对程序的正确性验证首先要确定一个合理范围，并假设范围之外的部分是可信的，例如要验证前面计算阶乘的代码片段，通常需要经过以下步骤：1. 建立对应编程语言中各种操作的数学模型，称作语义模型。2. 定义程序的行为，通常是对程序输入和输出的数学定义，称作程序的规格说明。3. 基于1的语义模型，借助数学方法推导程序的运行结果，从而证明程序符合2定义的规格说明。</p></li>
<li><p><strong>复杂度</strong>(Complexity)。这里主要指时间复杂度。观察前面给出的Pascal函数，{Pascal N-1}在函数体中出现了两次，由于其递归的特性，最终计算量将正比于2<sup>n</sup>，从而当输入稍大时就会导致很长的运行时间。为了提高程序运行效率，可以消除一次{Pascal N-1}的计算，所以有：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun {FastPascal N}
</span><span class='line'>  if N==1 then [1]
</span><span class='line'>  else L in
</span><span class='line'>      L={FastPascal N-1}
</span><span class='line'>      {AddList {ShiftLeft L} {ShiftRight L}}
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>改进后的程序时间复杂度达到了n<sup>2</sup>的多项式时间，从而远好于之前的指数时间。理想状态的时间复杂度应尽量满足低阶多项式时间。</p>

<ul>
<li><strong>懒求值</strong>(Lazy evaluation)。一般而言被直接调用的函数会立即被计算，这种模式被称作及早求值(Eager evaluation)，与之相反则被称作懒求值。在懒求值下，计算只会在其结果被需要时发生。懒求值对于程序代码的优化有一定意义，如下例：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun lazy {Ints N}
</span><span class='line'>  N|{Ints N+1}
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>如果Ints函数是及早求值，那么调用该函数会直接进入死循环，直到调用栈溢出，但懒求值则不会。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>L={Ints 0}
</span><span class='line'>case L of A|B|C|_ then {Browse A+B+C} end</span></code></pre></td></tr></table></div></figure>


<p>该例只会导致Ints被执行三次，模式匹配中抽出的A、B、C将等于列表中的前三个数。与及早求值相比，懒求值其实意味了对程序的更多控制权，避免像普通的递归函数一样过早进行了大量计算。</p>

<ul>
<li><strong>高阶编程</strong>(Higher-order programming)。如果需要计算一个杨辉三角的变种，例如每行数列的获取不是通过对上一行的数做加法，而是改用减法、异或等算术表达式，那么最直观的方法就是对Pascal程序进行改造，特别是替换FastPascal函数中的AddList为新的函数调用。这就导致FastPascal函数可能需要频繁修改，甚至重复才能满足不同类型的计算需求。高阶编程允许将函数作为另一个函数调用的参数，从而满足统一的代码实现：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun {GenericPascal Op N}
</span><span class='line'>  if N==1 then [1]
</span><span class='line'>  else L in
</span><span class='line'>      L={GenericPascal Op N-1}
</span><span class='line'>      {OpList Op {ShiftLeft L} {ShiftRight L}}
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>GenericPascal就是理想的统一代码实现，允许通过Op传递所需的计算函数，避免了计算功能需要扩展时再次发生修改的可能。</p>

<ul>
<li><strong>并发</strong>(Concurrency)。真实世界中存在大量相互独立、且根据自身情况决定执行节奏的活动，这被称为“并发”。除非程序建立了通信机制，否则并发的活动相互间不会发生干涉。程序中的并发通常借助线程实现，如下例所示：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>thread P in
</span><span class='line'>  P={Pascal 30}
</span><span class='line'>  {Browse P}
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>当线程代码开始运行时，尽管Pascal函数的执行需要较长时间，但程序本身依然会继续向下执行。</p>

<ul>
<li><strong>数据流</strong>(Dataflow)。如果某个操作引用了一个尚无法被绑定的变量，例如在并发编程中，该变量正在被另一个线程所绑定，那么理想的行为是请求绑定的一方陷入阻塞，直到获得该变量的绑定，这被称为数据流。例如：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare X in
</span><span class='line'>thread {Delay 10000} X=99 end
</span><span class='line'>{Browse start} {Browse X*X}</span></code></pre></td></tr></table></div></figure>


<p>上例中X*X会发生阻塞，直到X被主线程绑定。</p>

<ul>
<li><strong>显式状态</strong>(Explicit state)。与并发类似，真实世界中也会存在某种行为依赖于历史记录的情况，这就需要程序语言的函数具有维持内部状态的能力，大多数情况下我们把这种状态保存在变量中，这里使用<strong>内存单元</strong>(Memory cell)表示，以便和前文同样提到的变量概念进行区分。下例显示了如何在FastPascal中引入显式状态：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>C={NewCell 0}
</span><span class='line'>fun {FastPascal N}
</span><span class='line'>C:=@C+1
</span><span class='line'>{GenericPascal Add N}
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>对象</strong>(Objects)。对象即带有内部状态的函数，一个包含多个函数的对象例子如下：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>  local C in
</span><span class='line'>  C={NewCell 0}
</span><span class='line'>  fun {Bump}
</span><span class='line'>    C:=@C+1
</span><span class='line'>    @C
</span><span class='line'>  end
</span><span class='line'>  fun {Read}
</span><span class='line'>    @C
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>本例中local..end定义了变量C的作用域范围，也就是说C对local..end定义的代码范围之外的部分不可见，即<strong>封装</strong>(Encapsulation)。封装意味着隔离了对象状态与程序的其它部分，从而具有了信息隐藏的特性。此外，该对象还包含两个方法：Bump和Read实现对其状态的操作，即对象的<strong>接口</strong>(Interface)。一旦对象的接口能维持一致，那么客户程序就无需了解对象具体的方法实现，并能够直接调用任何具有相同接口的对象方法，这种特性即多态(Polymorphism)。在封装和多态背后，针对接口与其实现的分离即<strong>数据抽象</strong>(Data abstraction)的实质。</p>

<ul>
<li><strong>类</strong>(Classes)。对象极大提升了程序的可复用性和可维护性，那么如果程序中需要超过一个对象呢？一种解决办法就是创建一个“工厂对象”，将其用于生产更多的对象，这个工厂对象即<strong>类</strong>(Class)。下例演示了如何利用函数创建类：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>fun {NewCounter}
</span><span class='line'>C Bump Read in
</span><span class='line'>  C={NewCell 0}
</span><span class='line'>  fun {Bump}
</span><span class='line'>    C:=@C+1
</span><span class='line'>    @C
</span><span class='line'>  end
</span><span class='line'>  fun {Read}
</span><span class='line'>      @C
</span><span class='line'>  end
</span><span class='line'>  counter(bump:Bump read:Read)
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>该例中NewCounter函数每次调用都能返回一个具有独立内部状态以及Bump和Read函数的新函数(对象)，即利用了前文提到的高阶编程的概念。对类的使用如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>Ctr1={NewCounter}
</span><span class='line'>Ctr2={NewCounter}</span></code></pre></td></tr></table></div></figure>


<p>其中Ctr1和Ctr2相当于独立的对象，程序进而可以通过.操作符调用其中的方法，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{Browse {Ctr1.bump}}</span></code></pre></td></tr></table></div></figure>


<p>值得注意的是，截至目前我们介绍了类和对象的概念，但这并非<strong>面向对象编程</strong>(Object oriented programming)的全部，也不意味着使用类和对象的编程概念就可以被称为“面向对象语言”。</p>

<ul>
<li><strong>非确定性和时间</strong>(Nondeterminism and time)。当程序具有并发和状态等概念时，问题就会变得更加复杂，这是因为并发所引起的线程时序是非确定的，而状态的改变也会因此变得不稳定。这里需要强调，非确定性本身不会带来问题，只有当程序中的非确定性具有可观测性时，进而引发的竞争条件才会导致潜在问题。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>C={NewCell 0}
</span><span class='line'>thread
</span><span class='line'>  C:=1
</span><span class='line'>end
</span><span class='line'>thread
</span><span class='line'>  C:=2
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>在本例中，从字面上无法判断出在某个时刻变量C的值，即所谓的可观测非确定性。在这种情况下，程序的线程之间会因为<strong>交叉存取</strong>(Interleaving)问题而变得极不稳定，因此避免和限制交叉存取是保证高质量程序的重要经验之一。</p>

<ul>
<li><strong>原子性</strong>(Atomicity)。解决交叉存取问题的途径之一就是引入原子操作(Atomic operation)。原子性意味着任何中间状态都无法被观测，即从初始态直接跳跃至最终态。原子操作的实现方法之一即引入锁(Lock)对象，锁保证了在任何时刻只有一个线程在其中执行，此时其它线程只能在锁外等待。例如：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>declare
</span><span class='line'>C={NewCell 0}
</span><span class='line'>L={NewLock}
</span><span class='line'>thread
</span><span class='line'>  lock L then I in
</span><span class='line'>    I=@C
</span><span class='line'>    C:=I+1
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>thread
</span><span class='line'>  lock L then J in
</span><span class='line'>    J=@C
</span><span class='line'>    C:=J+1
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>锁的使用一般包含两步操作：1.创建锁对象；2.使用锁对象加锁并执行目标代码。代码运行结束后锁对象被立即释放，后续线程可以继续对该对象加锁。</p>

<h3>编程范式的分类(Taxonomy of Programming Paradigms)</h3>

<p>由于概念——范式——语言之间的组合构成关系，理论上说出于更上层次范式和语言的数量相比较于编程概念而言是十分巨大的。然而在多数情况下，实用的范式应当是图灵完备的。例如函数式编程，基于头等函数(First-class function)或闭包(Clusure)的概念，因此其相当于和λ算子等价，从而可以被证明图灵完备。下面讨论由基本编程概念组合而成的编程范式类别，这种分类法覆盖了绝大多数的实用编程范式(在[PVR04]中也被称作计算模型)。</p>

<h4>声明式模型(Declarative model)</h4>

<p>作为最早出现也是最简单的编程范式类别，声明式是指通过定义数学函数实现编程，从而使其最易被推导和测试，也是所有其它类别的编程范式的基础。</p>

<p>声明式编程首先定义了语法(Syntax)和语义(Semantics)的概念，其中语法用于规定合法的语言形式，由于编程不可能像自然语言完全一样灵活自由，因此通常具有极为限定的语法形式和约束。一种常用的语法标记即扩展巴科斯范式(Extended Backus-Naur Form, EBNF)，其基本形式是从非终结符开始，由左向右列出记号(Token)序列，其中任何遇到的终结符可以被直接加入序列，而非终结符则需要被它的展开式替换，并在选择项(Choice)前任选一个作为替换。上述这种语法定义形式被称为上下文无关文法(Context-free grammars)，因为其非终结符在任何情况下的展开都是唯一确定的。须知上下文无关文法是可能会存在歧义的，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;exp&gt; ::= &lt;int&gt;|&lt;exp&gt; &lt;op&gt; &lt;exp&gt;
</span><span class='line'>&lt;op&gt; ::= + | *</span></code></pre></td></tr></table></div></figure>


<p>对于表达式2 * 3 + 4来说，其解析树存在两种可能，一种的叶结点是2 * 3和4，另一种的叶结点是2和3 + 4。为了消除这种歧义性，编程语言层面会定义更多约束以保证确定性：例如确定运算符优先级或者定义计算表达式的默认方向。</p>

<p>在语义方面，无论现代编程语言被设计得多复杂，其底层一定是基于一个纯数学的、易于推导的模型，这种模型被称作内核语言。实际上，本文所讨论的编程范式，就是通过定义内核语言形成对编程语言的语义化翻译，进而更容易被机器或操作系统所识别。</p>

<p>声明式编程有时也被称为无状态式编程，也即以下两种编程范式的核心思想——<strong>函数式编程</strong>(Functional programming，例如Scheme和Standard ML)和<strong>逻辑式编程</strong>(Logic programming，例如Prolog)。以该范式为基础为编程语言构建了庞大的特性集合，例如大部分常用的语法规则、编译技术、内存管理技术和异常管理技术等，都超出了本文的主题。</p>

<h4>并发声明式模型(Concurrent declarative model)</h4>

<p>该范式在声明式编程的基础上引入并发的概念。在本文的编程概念部分就已经讨论过，并发本身并不显著提高复杂度，只有并发和状态同时存在时问题才可能会出现，即前文提到的可观测非确定性问题。并发声明式的主要特点在于数据流概念的引入，既保留了声明式编程的基本特征，也允许更加灵活的增量执行属性，且避免引入可观测非确定性。</p>

<p>一般的声明式编程都是按照语句的出现顺序、由左至右依次执行，这种执行方式即所谓的及早求值或数据驱动求值(Data driven evaluation)。在某些应用场景中，及早求值并非最佳方案。例如在同时包含生产者和消费者的程序中，传统的及早求值要求生产者确定是否已经发送了完整的数据，而如果由消费者来负责就能进一步保证处理后的数据完整性，后者就采用了懒求值的思想，也被称作需求驱动求值(Demand driven evaluation)。在声明式编程中引入懒求值的特性，即<strong>懒声明式模型</strong>(Lazy declarative model)。该范式允许在某些潜在的无限制数据结构基础上实现编程，更有利于资源管理和程序结构的模块化。</p>

<p>懒求值最早是在函数式编程中被发现，最初仅被视为声明式编程的一种执行策略，可用于帮助设计具有良好平摊性或最坏时间上界的算法；后来被进一步应用于包含声明式子集且更具表达性的范式中，强化其模块化特性。采用懒求值的例子包括Haskell和Miranda。</p>

<h4>消息传递并发式模型(Message-passing concurrent model)</h4>

<p>由于前文所描述的并发声明式编程不具备可观测非确定性，使其在描述能力上有所限制。例如经典的C/S系统，任何时刻服务器都无法预知客户端发来的下一条消息，而这在并发声明式编程中就无法实现。而消息传递并发式编程则在前者的基础上引入了一个异步通信信道，任何程序中的实体都能从该信道中写入和读取消息，从而满足了可观测非确定性编程的需求。该范式创建了一个具有关联流的信道——<strong>端口</strong>(Port)。任何实体可以向该端口发送消息，一个具体的作法是创建一个流对象并将其和对应端口相关联，这里称其为端口对象。于是，实体就可以通过该端口对象对其它端口对象发送和接收消息。一个端口对象通常是一个声明式的递归过程，从而使其拥有声明式编程的一部分特性。</p>

<p>采用消息传递并发式的例子包括Actor模型和Erlang。</p>

<h4>状态式模型(Stateful model)</h4>

<p>状态式编程，也称命令式编程(Imperative programming)。本质上状态式相当于声明式+显式状态的组合，这里的显式状态是指某个过程调用依赖于超出该过程生命周期的状态，且该状态没有出现在过程的调用参数列表中。状态式编程增强了范式的抽象能力，这种能力被视为构建复杂系统的关键。以传统的无状态编程为例，尽管程序中的一个过程可以根据外界传递的参数做出对应的行为，但这始终是针对特定输入而产生确定性结果。而对于状态式编程而言，其自身拥有了更多能力从而变得相对较“智能”，这也更接近对真实世界活动的模拟。</p>

<p>范式的抽象能力可以通过以下特性衡量：1.封装性；2.组合性；3.可实例化和可调用性。其中，封装性的意义在于，我们知道程序的可推导性能够保证其正确性，但显式状态的引入会使得程序推导变得十分困难，一个例子是带有<strong>边际效应</strong>(Side effect)的函数。而封装性的提高可以降低状态带来的不利影响，特别是维持不变量(Invariant)，这在一定程度上提高可推导性。</p>

<p>状态式编程能够描述出行为依据状态而发生变化的程序，从而进一步有利于模块化程序，且如果封装和不变量使用得当，则其会拥有与声明式编程相当的可推导能力。</p>

<p>在状态式编程的基础上，采用一组交互式数据抽象的集合描述最终程序，即<strong>面向对象式模型</strong>(Object oriented model)。这里的数据抽象具有状态化和对象化二元特性。状态化意味着模块化能力，而对象化则进一步启发了多态和继承——这就是面向对象编程的基本原理。多态允许更细粒度的模块化，在合理的职责划分下依旧能保证统一接口；而继承则开辟了增量式的抽象构建，使程序模块易于复用，从而降低潜在的开发成本。</p>

<p>在最近40年里，面向对象编程在工业界和学术界都得到了深入研究和广泛应用，并且在绝大多数现代编程语言中都得到了支持。</p>

<h4>共享状态并发式模型(Shared-state concurrent model)</h4>

<p>与消息传递并发式类似，共享状态并发式也提供了可观测非确定性编程的能力，区别在于后者借助了共享且可变的显式状态（这里称作单元）而非异步通信信道来实现。尽管实质上都是状态化，但共享状态并发式编程较前者具有更加复杂的实现。</p>

<p>前文已经提到，并发声明式编程不具备可观测非确定性，这点其实兼有利弊，特别是无法实现完全独立的并发线程，或是超过两条线程以上的通信，这也是状态化并发编程的主要目的。但是为了应对随之而来的即交叉存取问题，除了异步消息信道外，还可以通过引入锁、监控和事务等实现针对共享状态单元的原子操作，这些解决方案适用于不同的问题。</p>

<p>事实上，共享状态并发式编程在绝大多数语言中都得到了支持，这主要得益于状态式编程（特别是面向对象编程）的广泛应用。颇为讽刺的是，尽管这种范式可能受到了更加彻底的研究，但建立在其基础上的应用程序至今仍面临复杂且严峻的挑战。</p>

<h4>关系式模型(Relational model)</h4>

<p>声明式编程的基本特性源于数学计算，包括过程、输入参数、输出参数等概念。当一个给定输入参数集合仅有一组输出参数集合时，同样可以用关系式编程实现。后者比声明式具有更高的灵活性：1.允许有0至多个结果；2.输入参数和输入参数可以在每次调用时都不同。从而令关系式编程在数据库、歧义性语法解析和复杂组合问题的枚举实现等领域具有一定优势。</p>

<p>具体实现上，关系式在声明式基础上引入了<strong>选择</strong>(Choice)语句，这种选择语句能够通过搜索自由抽取出一个结果集，虽然算法是确定的，但最终结果仍然是非确定。Prolog的search特性就是基于这种范式的逻辑式编程语言。</p>

<h3>编程范式的比较(Comparison of Programming Paradigms)</h3>

<p>编程范式对软件工程的意义在于满足<strong>天然性</strong>(Natural)和<strong>高效性</strong>(Efficient)。天然性意味着相关程序使用了尽可能少的、与问题本身不相干的代码，例如某些纯技术原因导致的代码。一般采用<strong>模块化</strong>、<strong>非确定性</strong>和<strong>对接真实世界</strong>来衡量范式的天然性。高效性则意味着程序与解决同一问题的嵌入式编程只存在常数级差别。由于通常无法同时兼顾这两种属性，于是它们就成为衡量编程范式的重要工具。</p>

<p>声明式编程的简洁和可推导性，使得程序较易于保证正确性，尽管多数时候由于不可变(Immutable)数据类型而需要为计算结果开辟新空间，但这引来的性能损耗在真实场景中几乎可以忽略不计，因此总体上说声明式编程具有高效性。但在满足天然性方面，朴素的声明式编程首先并不具备模块化特性，除非向其注入显式状态；其次，虽然声明式编程支持并发，但由于本身不支持状态，从而不具备可观测非确定性；由于前两者不满足，声明式编程也就不具备对接真实世界的特性。因此可以认为声明式编程并不具备良好的天然性。</p>

<p>状态式编程一般要求程序采用顺序执行，但真实世界的实体通常既是状态的也是平行的，这就需要引入并发来解决这一问题，即增加可观测非确定性。另一方面，在分布式环境中，状态的存储也面临一致性和效率问题，于是导致了一套复杂的一致性等级和协调算法解决方案，极大提升了状态式编程在解决分布式问题中的复杂度。这些问题对面向对象编程同样适用，而对后者而言，其相较于其它范式显然更符合天然性要求，这也是其流行至今的原因之一。</p>

<p>在并发编程方面，并发声明式作为基于数据流的、最简单的并发编程范式，无疑是实现确定性并发编程的最佳工具；真实世界中更多时候面临着可观测非确定性问题的挑战，于是推动了消息传递和共享状态两种应对方案的出现。对于消息传递并发式来说，程序描述了一批相互协调的活动实体，更加适用于多代理场景，例如通信；而对于共享状态并发式来说，程序描述了一批实现一致性修改的数据仓库，适用于以数据为中心的计算场景。而事实上，这两种范式在真实的软件工程实践中是可以并存使用的。</p>

<h2>结论</h2>

<p>编程范式用于描述编程活动中的风格和方法论，该问题是软件设计和实现的共同基础。本文首先介绍了编程范式的基本组成和重要的编程概念，并在此基础上进一步介绍了一种编程范式分类法[PVR04]，并在此基础上对不同类型的编程范式进行了比较。了解这种分类法能够便于理解编程语言的动机和设计原理，并且掌握语言发展的历史、现状和趋势，从而为进一步构建得以实用的软件设计提供更好的理论和技术储备。</p>

<h2>引用</h2>

<p>[RWF79], <a href="https://dl.acm.org/citation.cfm?id=359140">The Paradigms of Programming</a></p>

<p>[TSK62], <a href="https://projektintegracija.pravo.hr/_download/repository/Kuhn_Structure_of_Scientific_Revolutions.pdf">The Structure of Scientific Revolutions</a></p>

<p>[PVR04], <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.7366&amp;rep=rep1&amp;type=pdf">Concepts, Techniques, and Models of Computer Programming</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(6)]]></title>
    <link href="http://www.hanyi.name/blog/2018/12/09/software-design-and-architecture-notes-6/"/>
    <updated>2018-12-09T10:53:07-05:00</updated>
    <id>http://www.hanyi.name/blog/2018/12/09/software-design-and-architecture-notes-6</id>
    <content type="html"><![CDATA[<h2>数据模型与数据建模(Data Model and Data Modeling)</h2>

<p><strong>信息系统</strong>(Information Systems)是人类社会重要的基础应用之一，也是计算机自诞生起最重要的应用领域。在计算机信息系统中，<strong>数据</strong>(Data)作为信息的主要载体，也是沟通人与硬件系统的桥梁，其复杂性不言而喻。可以说，本文涉及的数据模型与数据建模技术的发展，始终是以弥补人机之间的鸿沟为目标的。</p>

<h3>数据模型</h3>

<p>在设计信息系统时，为了应对信息的复杂性，人们利用<strong>数据模型</strong>描述数据元素、元素间关系及其与真实世界实体的映射，从而达成抽象且一致的信息表示。初期的数据模型包括<strong>文件系统模型</strong>(File System Model)、<strong>层级模型</strong>(Hierarchical Model)和<strong>网络模型</strong>(Network Model)等。</p>

<p>文件系统模型利用计算机文件系统模拟制表(Tabulation)，包含一般表格中的字段、记录等概念、且具备顺序和随机访问文件的能力，数据可按文本或二进制类型进行存储。这是一种非常简洁的数据模型，诸如csv、dsv等标准格式至今仍被广泛使用。</p>

<p>层级模型与文件系统模型拥有类似的字段和记录等概念，所不同的是记录之间可以按树形结构进行关联，从而表示记录之间的关系。相比较于文件系统模型，层级模型能够显式表达记录间的连接关系，并允许按照标准的树遍历算法进行数据遍历；缺点在于子记录只能拥有唯一的父记录，反过来则没有限制。发布于1966年的IBM Information Management System(IMS)就是基于层级模型构建。</p>

<p>网络模型旨在克服层级模型对关系限制的缺陷，允许每条记录拥有多个父记录和子记录。从<strong>数据模式</strong>(Data Schema)的描述上来看，网络模型的对象关系呈现出一个通用的网状结构，从而具有较层级模型更好的表达能力。1969年，数据系统语言委员会(CODASYL)下属的数据仓库任务小组(DBTG)发布了网络模型规范，该规范包括了一种用于定义数据模式的<strong>数据定义语言</strong>(DDL)，以及能够被嵌入宿主语言的<strong>数据操纵语言</strong>(DML)，首次提出了独立于宿主语言的数据语言的概念，并且通过国际标准化组织制定了多项标准。但是自诞生后，网络模型并未被工业界和学术界广泛接纳，并在此后十年的竞争中败给更具形式化能力的<strong>关系模型</strong>(Relational Model)和后续模型。</p>

<p>Edgar F. Codd在1970年提出了关系模型[EFC70]，其包含两个主要内容：</p>

<ol>
<li><p>对应于N个数据集合，使用N元关系组表达集合间的关系，使模型具备更精确的数学表达能力。</p></li>
<li><p>一种具有强描述能力的全局数据子语言，该语言基于结构化一阶谓词逻辑算子，能够用于表达基于关系模型的数据操作。</p></li>
</ol>


<p>关系模型为设计人员提供了统一抽象的界面，很好地隐藏了数据操作与底层系统交互的实现细节。但是也存在一些不足：</p>

<ol>
<li><p>根据关系模型的数学定义，集合之间的关系通过维护单独的N元关系组实现，其实质是集合间的笛卡尔积。但是通过这种形式化表示无法进一步揭示笛卡尔积的基数信息，而实践证明这种数量关系在描述数据模型时非常重要。</p></li>
<li><p>与问题1类似，关系模型的形式化表达缺乏一定的语义信息，无法进一步揭露关系的实质。尽管这种针对关系的语义信息不是始终必要的，但实践证明语义对数据模型的可表达能力具有重要意义。</p></li>
</ol>


<p>为了解决上述问题，Peter Chen进一步发展出了<strong>实体-关系模型</strong>(ER模型)，后者成为当前数据模型的重要描述工具和行业标准[PPC76]。ER模型包含四个主要概念：<strong>实体</strong>(Entity)，即现实世界的实例，通常是名词形式；<strong>关系</strong>(Relationship)，实体间的关联方式，通常是动词形式；<strong>类型</strong>(Type)，对实体的类别定义，通常是名词形式；<strong>角色</strong>(Role)，对实体在某个关系下的特殊定义，通常也是名词形式[PPC02]。</p>

<p>ER模型的一个重要技术是<strong>实体-关系图</strong>(ER Diagram，ER图)，即用图展示前述的概念及其联系，其中方框表示实体的类型；菱形表示关系；圆圈表示实体或关系类型的属性；实体类型关系和实体属性关系上还标注了数量关系。一个典型的ER图如下图所示。</p>

<p><img src="http://content.hanyi.name/images/data_model_and_data_modeling/er_diagram.png" alt="er diagram" /></p>

<p>尽管本节介绍的数据模型为数据表达提供了形式化工具，但是在面对复杂系统时，设计人员不可能凭空得出系统终极的数据表示，于是<strong>数据建模</strong>就成为支撑构建数据模型的重要方法论。</p>

<h3>数据建模</h3>

<p>实践表明，在软件需求分析起初就需要开始构建数据模型，数据建模应关注数据的需求和实现等特定方面。一般的数据建模过程依次产生下列三种数据模型：</p>

<ol>
<li><p>概念数据模型(Conceptual Data Model)，从高层角度描述系统的信息需求，具体包括主要的信息概念及其相互关系。1969年，网络模型之父Charles W. Bachman提出了数据结构图(Data Structure Diagram)[CWB69]，并将其用于描述概念数据模型。
<img src="http://content.hanyi.name/images/data_model_and_data_modeling/data_structure_diagram.png" alt="data structure diagram" /></p></li>
<li><p>逻辑数据模型(Logical Data Model)，描述信息中领域的具体结构，例如表、列及其关系等。在复杂度较低时，设计人员往往可以跳过概念数据模型，从而直接得出逻辑数据模型。该模型与概念数据模型都是独立于具体的持久化技术（例如通用的数据库管理系统）。</p></li>
<li><p>物理数据模型(Physical Data Model)，满足非功能需求的且可立即被实现的数据模型。该模型与存储技术、维护技术和更新/查询场景等因素密切相关。</p></li>
</ol>


<h4>数据分类</h4>

<p>在开始构建数据模型之前，需要首先识别系统需求中的数据分类，从而确定相应的问题范围，并使用相应的数据模型进行建模。实践中存在多种逻辑思维实践以实现前期的数据分析，[DMG08]描述了一种被广泛认可的数据分类方式，把数据按照特性划分为下列六类：</p>

<p><strong>主数据</strong>(Master Data)，表示业务需求中出现的人物、地点、事物等信息。</p>

<p><strong>事务性数据</strong>(Transactional Data)，表示业务发生时伴随的内部或外部事件或事务，例如发起订单、创建发票、支付等活动。</p>

<p><strong>引用数据</strong>(Reference Data)，表示被系统、应用、数据存储、进程、报表乃至事务性或主数据所引用的值或分类模式的集合，例如状态码、名词简写、产品类型等静态数据。</p>

<p><strong>元数据</strong>(Metadata)，表示数据本身的数据，方便数据的检索、解释和使用。</p>

<p><strong>历史数据</strong>(Historical Data)，表示在某个时刻发生、且不可修改的数据，例如日志。</p>

<p><strong>临时数据</strong>(Temporary Data)，表示因为某些技术需求而被临时创建的数据，通常没有独立的业务含义。</p>

<p>值得一提的是，上述分类方法只应被看作一个指导性原则，具体实践时应视上下文灵活调整。在本例中，对应前面提到的三种数据模型，概念数据模型通常考虑主数据和元数据，逻辑数据模型进一步包括了事务性和引用数据，物理数据模型最终实现覆盖全部类型的数据。采用前文提到的ER模型即可对这三种数据模型分别建模。</p>

<h4>关系范式</h4>

<p>在构建逻辑和物理数据模型时，为了能尽可能降低关系模型中的关系表示所带来的数据冗余，从而加强数据的一致性，关系模型提出了<strong>规范化</strong>(Normalization)的概念，以对关系表示本身进行约束，并在此后一段时间相继发展出了多种范式。其中常用的范式包括：第一范式(1NF)，即没有多值属性的关系；第二范式(2NF)，即满足第一范式且非主属性不依赖任何候选键的子集；第三范式(3NF)，即在第二范式的基础上不存在传递依赖。虽然规范化对强化数据一致性约束方面有促进作用，但其造成的后果是使许多数据表示被物理隔离，从而在实现数据操作方面引起额外耗费。因此在实际设计数据模型时，规范化设计的采用是和系统的非功能需求(Non-functional requirement)密切相关的。</p>

<h2>结论</h2>

<p>数据模型是信息系统设计的重要内容，在经历上世纪70年代的激烈竞争后，关系模型因占据理论高位更加受到学术界青睐，最终成就了80年代起通用关系型数据库系统的统治地位。ER模型和ER图因其更具表达能力，从而成为最重要的数据建模工具。数据模型方法领域的先驱Bachman(网络模型)、Codd(关系模型)和Chen(ER模型)也先后因其开创性贡献而获颁图灵奖。</p>

<h2>引用</h2>

<p>CWB69, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.172.3370&amp;rep=rep1&amp;type=pdf">Data Structure Diagrams</a></p>

<p>EFC70, <a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf">A Relational Model of Data for Large Shared Data Banks</a></p>

<p>PPC76, <a href="https://www.csc.lsu.edu/~chen/pdf/erd-5-pages.pdf">The Entity-Relationship Model-Toward a Unified View of Data</a></p>

<p>PPC02, <a href="https://csc.lsu.edu/~chen/pdf/Chen_Pioneers.pdf">Entity-Relationship Modeling: Historical Events, Future Trends, and Lessons Learned</a></p>

<p>DMG08, <a href="https://dl.acm.org/citation.cfm?id=2821563">Executing Data Quality Projects: Ten Steps to Quality Data and Trusted Information</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(5)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5/"/>
    <updated>2018-10-23T11:42:00-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/23/software-design-and-architecture-notes-5</id>
    <content type="html"><![CDATA[<p>上接<a href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/">软件设计与架构笔记(4)</a></p>

<p>前文描述的HIPO模型是一个典型的基于结构图的IPO系统设计模型，其基本思想依然是由顶至下，逐步求精。基于经验Larry进一步总结了通用的系统设计准则[SMC74]。</p>

<ol>
<li><p><strong>程序结构</strong>和<strong>问题结构</strong>。减少程序变更所造成影响的重要方法之一，就是保证设计结构匹配问题本身的结构。由顶至下的思维模式会天然形成一种层级结构，因此重点在于如何决定设计单元在相同层级，或隶属于不同层级，而关键又在于理解问题本身。</p></li>
<li><p><strong>模块控制范围</strong>和<strong>决策影响范围</strong>。控制范围指模块以及归属于该模块的子模块的集合；影响范围指某个设计决策所造成变更的所有模块集合。当设计决策的影响范围尽可能位于该决策所在的模块控制范围之内时，该系统设计就可以被认为是“简洁”的。保持简洁性的方法之一可以是提升某些决策相关的元素的层级；或者把受到相同决策影响，但位于不同控制结构的模块重新划分至相同控制范围。</p></li>
<li><p><strong>模块大小</strong>。模块的实际大小可被用于描述潜在问题的信号。过小的模块可能缺少功能性绑定，而过大的模块可能涵盖了超过一个功能性绑定。前者可以通过inline的方式消除以减少模块规模，后者由于可理解性和可读性问题需要进行进一步拆分。</p></li>
<li><p><strong>错误</strong>和<strong>文件终止处理</strong>。当模块的一部分功能需要通知其调用者发生某件错误时，可通过返回某种错误参数实现，该参数的值最好是二元类型，对于流数据处理的EOF标记也需要进行类似处理。同时这些参数也不应该包含如何处理当前错误的信息，而是由调用者决定。当然，如果模块本身不需要错误标记时，系统设计就更简洁了。</p></li>
<li><p><strong>初始化</strong>。某些模块由于需要依赖初始化操作，从而可能存在“简洁”但导致“弱绑定”的设计。例如，读模块的access方法可能会遇到“文件未打开”的错误，如果选择将错误信息返回，调用者自然会选择调用open方法然后重新read；但另一种维护“黑盒性”的做法是，在access内部遇到该错误时自动通过open和reread进行恢复，那么调用者就不需要知道“文件未打开”这种错误并且重复进行处理了。</p></li>
<li><p><strong>模块选择</strong>。消除重复的功能，而非消除重复的代码。如果只是通过抽取的方式简单消除重复代码，那么有可能导致某个变更造成更多的修改。一种识别该问题的方法是，关注那些被其它不同模块调用，以及调用其它不同模块的对象，判断是否存在其子功能与不同的模块集合关联的情况，如果是则意味着存在层级或模块缺失的可能。</p></li>
<li><p><strong>隔离软件规格说明</strong>。软件设计规格的重要内容就是描述特定的数据类型、记录布局以及索引结构，设计应尽量使其与系统其他模块进行隔离，从而减少规格变更导致的重写。</p></li>
<li><p><strong>参数数量</strong>。尽量减少模块间调用的参数数量（不只是个数），如果参数中存在一个完整的数据记录，应尽量只传递必要的数据记录，否则也会导致该记录的变更对模块造成潜在影响。</p></li>
</ol>


<h3>结构化分析(Structured Analysis)</h3>

<p>随着软件设计方法论的发展和问题复杂度的增加，人们发现设计不再是解决复杂系统面临的唯一难题。比如，传统的软件设计过程一般是按由顶至下的方法，依照<strong>需求规格说明(requirement specification)</strong>给出具体的软件对象定义，那么如何构建规范合理的需求规格说明呢？另外，如果软件设计过程愈加复杂，是否可以按照经典的分治法(divide-and-conquer)对其进行分解和简化呢？</p>

<p>世界上存在多种多样的原始需求形态，例如采用<strong>文字叙述(narrative)</strong>可以说是最普遍的形式之一。当问题复杂度增加时，软件设计已经不能从简单的叙述中加以消化并诞生，于是就出现了<strong>需求分析</strong>的过程。这种把问题从原始形式转换成可进一步规范设计的规格说明的过程，被称为<strong>系统分析</strong>。<strong>结构化分析</strong>作为软件系统分析最早流行起来的方法论，是在早期工业界数十年的探索中发展起来的。</p>

<p>由于传统的文字叙述不足以表达复杂系统，人们开始重视并使用符号语言，例如德国数学家Carl Adam Petri发表于1962年的<strong>Petri Net</strong>。60年代中期，女数学家Erna Schneider Hoover在贝尔实验室领导了一支团队，其目标是分析电话交换机系统的性能和宕机时间，Erna使用了Petri Net来模拟复杂的电话交换系统。受此启发，同时困扰于晦涩难懂的叙述式规格说明的年轻工程师Tom DeMarco由此开始开发一套网络符号语言，由此发展并最终在1978年发表了<strong>结构化分析</strong>方法[TOM78]。</p>

<h4>结构化分析与传统系统分析</h4>

<p>Tom认为传统的系统分析包含如下目标：</p>

<ol>
<li><p>确定最优化目标。</p></li>
<li><p>生成该目标的细节描述，并且能够被后期的实现过程用于评估该目标是否实现。</p></li>
<li><p>生成该目标相关的重要参数预测，包括花费、收益、日程以及性能特性。</p></li>
<li><p>得出所有被影响部分之上的项的并发性。</p></li>
</ol>


<p>为了达成这些目标，系统分析活动需要涉及用户沟通、撰写规格说明、损耗收益研究、可行性分析以及估算等。然而，这些活动都因高复杂性存在很多问题。针对这些问题，结构化分析进一步拓展了系统分析的目标：</p>

<ol>
<li><p>分析的产生物必须是<strong>可维护</strong>的，特别是针对<strong>目标文档(Target Document)</strong>。</p></li>
<li><p>必须采用有效的分割方法解决大小的问题，摒弃维多利亚小说式的规格说明。</p></li>
<li><p>尽可能使用<strong>图形表达</strong>。</p></li>
<li><p>必须区分逻辑和物理设计，并且基于此在分析师和用户之间合理分配职责。</p></li>
<li><p>必须在具体实现之前构建逻辑系统模型，使用户熟悉系统特性。</p></li>
</ol>


<p>同时，结构化分析描述了一系列可被用于不同分析阶段的工具：<strong>数据流程图(Data Flow Diagram, DFD)</strong>、<strong>数据字典(Data Dictionary)</strong>以及逻辑策略表达工具，例如<strong>结构化英语(Structured English)</strong>、<strong>决策表(Decision Tables)</strong>以及<strong>决策树(Decision Trees)</strong>等。</p>

<h4>数据流程图</h4>

<p>DFD是一种描述相互关联的过程的网络，其作用是帮助分割需求，并在撰写规格说明之前记录这种分割。与普通流程图的区别是，DFD只聚焦在数据流动的过程，因此基本没有任何关于循环或逻辑决策的控制信息。为了举例说明DFD，[TOM78]描述了一个软件咨询公司的自动化管理和运营辅助系统，该系统的功能包含了学员注册、支付、人员管理、课程管理等方面。下图是对该公司的早期运营模型的描述：</p>

<p><img src="http://content.hanyi.name/images/structured_analysis/logical_dfd.png" alt="Logical DFD" /></p>

<p>该图是一种Logical DFD，图中的输入被称作<strong>事务(Transaction)</strong>。以其中一条主要路径的部分为例，该路径共描述了5种事务：Cancellations, Enrollments, Payments, Inqueries和Rejects(这里指不属于前4种类型的事务的统称)，以及数据在这些事务间可能的流动关系。此外还有一种包含了系统具体实现信息的DFD，被称作Physical DFD。</p>

<p>DFD有时又被称作<strong>气泡图(Bubble Diagram)</strong>，原因是其描述数据转换过程的符号——气泡。此外DFD还包含<strong>命名向量</strong>，用于表示数据路径；<strong>直线段</strong>，表示文件或数据库；<strong>矩形(或称为源/入节点)</strong>，表示网络的起点或数据的接收者(通常是当前领域外的人或组织)。</p>

<p>DFD清晰地表达了工具的自然特征——如果DFD存在任何错误，也应当是显而易见、毋庸置疑的，这无疑减少了分析师与用户间产生认知分歧的可能。另一方面，实践证明DFD无论在概念描述或是建模方面都有显著价值。更重要的是，它提供了一种基于功能的系统分割方法，并且描述了不同部分之间的接口。在系统评审中，任何接口或过程的缺失都能够证明当前DFD的缺陷——这比纯粹的数学方式更加直观和有效。</p>

<p>在实际分析活动中通常使用分级数据流程图(Levelled DFD, LDFD)逐步求精分割系统功能。在LDFD中，通常存在3层、有时甚至更多层具有不同功能解析度的DFD。</p>

<p>Level 0，也被称为上下文图，通常仅包含一个气泡——也就是系统总的过程单位以及其它元素。这种图可以被用于和最宽泛的用户进行交流，例如干系人、业务分析员、数据分析员以及程序员。</p>

<p>Level 1，对上下文图的唯一气泡进行细分，将其分解成不同过程单位，以及相关的文件或数据库。</p>

<p>Level 2，进一步对Level 1进行划分，因此需要更多的文字和符号标记。</p>

<p>Level 3+，一般很少出现Level 3+的DFD，原因是这种级别的DFD可能存在过多的细节，从而导致难以沟通、比较和有效建模的问题。</p>

<h4>数据字典</h4>

<p>数据字典用于追踪和评估系统不同部分之前的接口，是对DFD的一种有效补充。以前面描述的系统DFD为例，过程3和7之间的数据流动Payment-Data，可以用如下公式进一步描述：</p>

<pre><code>Payment-Data = Customer-Name +              
               Customer-Address +
               Invoice-Number +
               Amount-of-Payment
</code></pre>

<p>换句话说，Payment-Data包括了该公式右值的所有数据项，且这些数据项需依序且非空。更进一步，数据字典还可能需要对某些数据项进行进一步描述，例如Invoice-Number：</p>

<pre><code>Invoice-Number = State-Code +
                 Customer-Account-Number +
                 Salesman-ID +
                 Sequential-Invoice-Count
</code></pre>

<p>与DFD类似，数据字典也是呈现了由顶至下的细分过程。每个DFD应该携带相应的数据字典描述，二者共同组成了系统分析的图形化产生物。</p>

<h4>逻辑策略表达</h4>

<p>逻辑策略表达用于替代传统冗长的文字叙述式的规格说明。最常见的结构化表达方式被称作结构化英语，例如采用按行缩进的方式表述不同层级的规格说明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>If the amount of the voice exceeds $500.
</span><span class='line'>    If the account has any invoice more than 60 days overdue.
</span><span class='line'>        hold the confirmation pending resolution of the debt.
</span><span class='line'>    Else (account is in good standing).
</span><span class='line'>        issue confirmation and invoice.
</span><span class='line'>Else (invoice $500 or less).
</span><span class='line'>    If the account has any invoice more than 60 days overdue.
</span><span class='line'>        issue confirmation, invoice and write message on the 
</span><span class='line'>        credit action report.
</span><span class='line'>    Else (account is in good standing).
</span><span class='line'>        issue confirmation and invoice.</span></code></pre></td></tr></table></div></figure>


<p>使用决策表表达上述规格说明，结果如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>                       RULES
</span><span class='line'>CONDITIONS              1  2  3  4
</span><span class='line'>
</span><span class='line'>1.Invoice &gt; $500        Y  N  Y  N
</span><span class='line'>2.Account overdue
</span><span class='line'>by 60+ days             Y  Y  N  N
</span><span class='line'>
</span><span class='line'>ACTIONS
</span><span class='line'>
</span><span class='line'>1.Issue confirmation    N  Y  Y  Y
</span><span class='line'>2.Issue Invoice         N  Y  Y  Y
</span><span class='line'>3.Msg to C.A.R.         N  Y  N  N</span></code></pre></td></tr></table></div></figure>


<p>决策树的表达结果如下：</p>

<p><img src="http://content.hanyi.name/images/structured_analysis/decision_tree.png" alt="Decision Tree" /></p>

<h2>结论</h2>

<p>结构化设计为软件设计提供了有效的结构图工具，以及作者Larry富有经验的设计准则，至今仍极具指导意义。为了保证设计阶段能使用清晰有效的规格说明，结构化分析提供了强大的DFD分析工具和规格说明描述工具，尽管其核心依然是逐步求精的设计思想，但已经开始涉足于比编程活动更加宽泛的软件工业领域，最终形成了较为独立的需求工程，成为软件构建过程中不可或缺的环节。</p>

<h2>引用</h2>

<p>SMC74, <a href="https://ieeexplore.ieee.org/document/5388187">Structured design</a></p>

<p>TOM78, <a href="https://books.google.com/books/about/Structured_Analysis_and_System_Specifica.html?id=7o0-AAAAIAAJ">Structured Analysis and System Specification</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(4)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4/"/>
    <updated>2018-10-12T15:28:06-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/12/software-design-and-architecture-notes-4</id>
    <content type="html"><![CDATA[<h2>结构化分析与设计方法(Structured Analysis and Design Methods)</h2>

<p>除了指导<a href="http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2/">程序设计</a>，结构化方法还被广泛应用于系统分析和设计领域，成为软件设计方法论的开端。从时间轴来看，从结构化编程到结构化程序设计，再到软件的结构化设计和分析，软件设计的方法论是从底向上发展的，其根本推动力是日益增加的系统复杂性。</p>

<h3>结构化设计(Structured Design)</h3>

<p>1974年，Larry Constantine等提出了一系列通过降低系统复杂性，从而提高编码、调试、修改等工作效率的软件设计思想，并将其统一命名为结构化设计[SMC74]。通用的结构化设计思想包括<strong>简洁性</strong>和<strong>可观测性</strong>，其中，简洁性作为衡量和评估设计方案的主要度量指标，体现在分割后的系统模块间具有设计、开发、更正、修改的独立性；可观测性则体现了软件易被感知功能和原理的能力。尽管系统分割具有良好的工程意义，但其引起的模块间重叠部分代码以及相互关系反而可能会增加复杂性。前文我们已经介绍了信息隐藏这一重要的模块化概念，结构化设计则提出了一个更具实践意义的设计指标：<strong>耦合(coupling)</strong>。</p>

<h4>耦合</h4>

<p>通常情况下，更少或更简洁的模块间连接就意味着更好的可理解性，同时变更或出错所引起的模块间传递也会受到抑制。系统复杂度不仅体现在模块间的连接数量，更体现在每个连接所承担的关联强度，这种强度的度量被称作<strong>耦合度</strong>。强耦合意味着高复杂度，造成模块难以被理解、修改和更正的后果。因此，软件设计可以通过建立模块间的弱耦合降低系统复杂度。</p>

<p>一个特定连接产生的耦合度是一个包含多重因子的函数，这些因子包括连接复杂度、连接指向模块自身亦或其内部、连接所发送或接收的内容等，Larry将其归纳为三个主要的耦合因子：接口复杂度、连接类型和通信类型。耦合度受这三个因子的变化规律如下表所示：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">Coupling</th>
<th style="text-align:center;">Interface complexity</th>
<th style="text-align:center;">Type of connection  </th>
<th style="text-align:center;">Type of communication</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">Low     </td>
<td style="text-align:center;">simple,obvious      </td>
<td style="text-align:center;">to module by name   </td>
<td style="text-align:center;">data                 </td>
</tr>
<tr>
<td style="text-align:center;">        </td>
<td style="text-align:center;">                    </td>
<td style="text-align:center;">                    </td>
<td style="text-align:center;">control              </td>
</tr>
<tr>
<td style="text-align:center;">High    </td>
<td style="text-align:center;">complicated,obscure </td>
<td style="text-align:center;">to internal elements</td>
<td style="text-align:center;">hybrid               </td>
</tr>
</tbody>
</table>


<p>Larry认为，弱耦合应具有接口简单直观，只通过名字引用其它模块，以及尽量仅通过数据进行通信等特征，反之则会增加耦合度。具体来说：</p>

<ol>
<li><p>接口复杂度，指模块间接口是否能清晰地表述连接，而不是包含了过多的信息导致难以理解。特别当多个模块通过共享一个公共环境(common environment)实现交互时，该公共环境中任意元素的增加都可能会导致系统整体复杂度的显著提升。例如在M个对象中，存在M(M-1)对相互关系，假设这些对象之间的公共环境包含N个元素，那么就有NM(M-1)对一阶关系，亦即变更或错误传递的可能路径数量。可见接口复杂度对系统整体复杂度的显著影响。</p></li>
<li><p>连接类型，指模块间相互关联的形式，例如仅通过模块名字进行关联，还是进一步引用了模块内部的元素。在后一种情况下，该模块内部的修改很可能传递至其它依赖它的模块，导致潜在的复杂度增加。</p></li>
<li><p>通信类型，指模块间通信内容的形式。对于系统中任何有效模块，其或者通过传递数据实现通信，或者通过被“控制”进行某项任务。显然，仅通过数据实现通信的接口更易被理解，而控制类型的通信使模块功能难以被直观理解。</p></li>
</ol>


<p>实现<strong>弱耦合</strong>的途径不一，一个方向是尽量降低元素间关系发生在不同模块间的可能，简单来说就是最小化模块间的关联，并且保证元素间关系只发生在相同模块内部。为了验证元素间关系是否都存在于模块内，Larry同时给出了一个描述模块内部元素间相互绑定程度的指标：<strong>内聚(Cohesiveness)</strong>。</p>

<h4>内聚</h4>

<p>由前述可知，实现内部高度绑定的模块，就能够达到降低耦合的目标，即模块自身的强内聚性。一般而言，对模块内聚程度的描述可以被划分成如下六个层级（由弱到强的非线性关系）：</p>

<ol>
<li><p>巧合的(Coincidental)。例如元素通过某种模块化方法被“无意间”划分到某个共同模块中，或者某个模块的创建仅仅是为了消除重复代码。在这种情况下，模块极易因为变更而变得“不可重用”，因此这类绑定只是发生于巧合之中。</p></li>
<li><p>逻辑的(Logical)。这种关系通常隐含了某种逻辑联系，例如负责程序中所有输入输出的模块，或者负责操作所有数据的模块。其问题在于，以此类关系实现的模块易存在内部元素间的相互缠绕，从而降低元素间的独立性，同时也会导致模块接口的复杂性增加。</p></li>
<li><p>一时的(Temporal)。该关系建立在逻辑层面的关系基础上，同时元素间还存在某种时间上的一致性。例如程序的初始化、终止、清理等阶段的操作，其元素间存在一定的功能逻辑，同时也常一起发生。尽管如此，这种关系依然存在于逻辑层面类似的缺陷。</p></li>
<li><p>通信的(Communicational)。元素间通过相同输入/输出数据集合的引用进行关联，例如“打印”和“装订”文件，显示出更强的绑定关系。</p></li>
<li><p>连续的(Sequential)。如果某个元素的输出恰好是另一个元素的输入，即意味着目标问题可以通过简单流程图进行描述和解决，那么其存在连续的强绑定关系。但需要注意，这种过程式处理会导致该模块独立于程序的其它功能部分，从而使其难以被其它系统模块复用。这也是连续层面与进一步功能层面关系所导致的内聚度存在较大差距的原因。</p></li>
<li><p>功能的(Functional)。在这种层面的关系下，模块中的元素都与同一个独立功能相关。一种判断某个模块是否为功能层面的绑定的方法是，通过一句话描述该模块功能，然后进行验证：</p>

<ol type="a">
<li><p>该句是否为复合句，是否包含逗号、多个动词等等，如果是则该模块可能包含连续或通信层面的绑定；</p></li>
<li><p>如果语句中包含时间相关的词，那么可能存在一时或连续层面的绑定；</p></li>
<li><p>如果语句中动词的操作对象不是一个特定对象，那么可能存在逻辑层面绑定；</p></li>
<li><p>如果语句中包含初始化、清理等词，说明可能是一时层面的绑定。</p></li>
</ol>
</li>
</ol>


<p>值得注意，元素间可能存在多个上述的关系，而通常我们可以使用其中内聚度表现最高的关系表示整体程度。但是如果模块中没有一组元素的关系表现为功能层面绑定，那么该模块的内聚性就表现较低。</p>

<h4>可预测模块</h4>

<p>模块的可预测性是指当给定相同的输入时，该模块每次被调用所发生的操作也完全相同，亦即独立于环境的特性。不可预测的模块不一定是存在错误的，例如当模块内部维持某种状态，该状态在针对当前模块的操作下会发生不断变化，从而导致返回结果或实际发生操作的不同。这种不可预测的模块在实际应用中经常发生，尽管是无错误的。模块的可预测性，有时也被成为“黑盒性”，使该模块能较容易被清楚地理解，例如通过简单的注释、描述性的名字或者良好定义的接口等方法。</p>

<h3>结构化设计技术</h3>

<p>软件设计过程可以被看作包含一般设计和详细设计两个部分。一般设计的目的在于确定系统需要的函数有哪些(回答what)，详细设计描述如何实现这些函数(回答how)。这些设计阶段需要确定函数标识、函数范围结构的调用参数和调用关系、所关联的模块等信息，并且保证模块能够被独立设计、实现和测试。</p>

<h4>结构图(Structure Chart)</h4>

<p>传统的流程图方法能够描述代码块执行的顺序和条件分支，但是在一般设计阶段，由于我们侧重于了解what，流程图会不可避免地增加设计复杂度。因此这里介绍一种较为简单的结构图用于表述函数及其调用关系。结构图所包含的符号标记如下图所示：</p>

<p><img src="http://content.hanyi.name/images/structured_design/definitions_of_symbols_used_in_structure_charts.png" alt="Definitions of symbols used in structure charts" /></p>

<p>假设某系统设计包含三个模块，分别是A、B和C，其中模块间的关系是A调用B，B调用C；从执行顺序上看，B的代码会首先执行，然后是C，最后是A。那么上述信息可以分别用结构图和流程图表示如下：</p>

<p><img src="http://content.hanyi.name/images/structured_design/structure_chart_vs_flowchart.png" alt="Structure Chart vs Flowchart" /></p>

<p>从上图可以看出，相比于流程图，结构图能够清楚表示模块间关系，并且有潜力进一步描述模块的接口信息，这恰好是在一般程序设计阶段需要进行的工作，流程图就不具有优势。</p>

<h4>基于结构图的软件设计过程</h4>

<p>下面以设计一个较为复杂的模拟输入——处理——输出(Input Process Output, IPO)类型的系统为例，给出一种衍生自结构图、由IBM开发的基于层次输入处理输出(Hierarchical IPO)图的一般设计过程：</p>

<p>Step 1. 根据问题描述，绘出系统大致的功能性草图。本例中模拟系统的大致功能是一个数据输入、处理和输出的过程，其大致可以被描述如下：</p>

<p><img src="http://content.hanyi.name/images/structured_design/rough_structure_of_simulation_system.png" alt="Rough structure of simulation system" /></p>

<p>Step 2. 识别外部的概念数据流，指来源于系统外的、独立于具体物理I/O设备的相关数据流。在本例中，概念数据流包括输入参数、格式化的返回结果等。</p>

<p>Step 3. 识别问题中的主要概念数据流(包括输入和输出)，确定该问题的功能图中的“最高级抽象”节点。对于输入的数据流而言，其抽象节点存在于距离物理输入形态最远，但依然可以视作输入数据的阶段。本例中该节点可能在于构建矩阵阶段。同时，针对输出数据流可以把结果矩阵作为输出的抽象节点，如下图所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/determining_points_of_highest_abstraction.png" alt="Determining points of highest abstraction" /></p>

<p>Step 4. 根据前面步骤得到的信息，针对每个抽象输入数据节点，使用一个源模块(source module)表示其结构。相应设计对应的入模块(sink module)。通常系统存在一个源和入分支，具体参数依赖问题描述而定，但其通用模式如下图所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/the_top_level.png" alt="The Top Level" /></p>

<p>在本例中，模块A即系统入口，也就是说模块A的功能意味着整个问题的解决；模块B用于获取主要数据流；模块C用于把主要输入流变换成主要输出流；模块D用于处理主要的输出数据流。</p>

<p>Step 5. 针对源模块，通过识别其中最后一次变换操作，生成当前模块的数据返回形式，然后再识别前一次变换的抽象节点。对于入模块，与源模块相反，通过识别其中第一次处理操作，确认抽象输出节点，直到获取期望的输出形式。基于逐步求精的思想重复步骤5，直到抵达最初的源模块和最后的入模块。构建出的部分结构图如下所示。</p>

<p><img src="http://content.hanyi.name/images/structured_design/lower_levels.png" alt="Lower Levels" /></p>

<p>在这一逐步求精的设计过程中，划分的终止条件因具体问题而异，通用的判断方法之一即前文提到的耦合与内聚等设计思想。</p>

<p>（未完待续）</p>

<h2>结论</h2>

<p>结构化设计的兴起使结构图及其衍生工具成为软件设计领域的重要工具。同时，在软件设计模块化道路上的深入实践也促使许多重要的软件设计思想被提出，诸如耦合、内聚等重要概念被广泛用于指导包括结构化设计及后续的设计方法论，影响至今。</p>

<h2>引用</h2>

<p>SMC74, <a href="https://ieeexplore.ieee.org/document/5388187">Structured design</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(3)]]></title>
    <link href="http://www.hanyi.name/blog/2018/10/03/software-design-and-architecture-notes-3/"/>
    <updated>2018-10-03T14:34:10-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/10/03/software-design-and-architecture-notes-3</id>
    <content type="html"><![CDATA[<h2>模块化编程(Modular Programming)：信息隐藏与职责分割</h2>

<p>上世纪60年代起，人们意识到实现复杂系统的前提是把系统合理分割为相互独立的部分，这些独立的部分被称作<strong>模块</strong>。与前文提到的结构化编程和过程式编程的区别是，一个模块可包含若干个子程，也允许组装不同模块以实现子程或程序。D.L. Parnas把这种编程技术称为<strong>模块化编程</strong>[DLP72]，其中模块意味着任务职责，而模块化设计则表示一系列的跨模块的“系统级”设计决策。自此，模块化成为软件设计领域的重要主题之一。</p>

<p>针对模块化的研究包含两个基本组成部分：</p>

<ol>
<li><p>一个良好的模块化系统（设计）应具备哪些特征？</p></li>
<li><p>一个良好的模块化系统（设计）应如何实现？</p></li>
</ol>


<h3>信息隐藏(Information Hiding)</h3>

<p>最初的软件设计方法论认为，组织应当建立统一的文档管理系统，软件由设计人员设计好后开放给全体人员，从而让每个人都尽量了解设计背后包含的一系列<strong>决策</strong>。1971年，Parnas首次提出<strong>信息隐藏</strong>的概念，反驳了前述的传统设计“广播”实践[DLP71]。</p>

<p>从软件结构的角度看，软件设计包含了对模块自身特征以及模块间的连接(connetion)的描述，其中连接意味着设计对模块间作用的假设。而我们已经知道软件结构最重要的两个目标：<strong>系统变更</strong>和<strong>正确性检验</strong>，而一个好的软件结构应使上述目标变得更加容易。以简化系统变更为例，如何使针对当前模块的变更不会传递到其它模块呢？答案当然是应尽量使针对当前模块的变更不至于打破其它模块对其所做的假设，即连接的稳定性。那么如何保证连接的稳定呢？直观来看当然是尽量减少假设的规模，即减少连接所包含的信息。</p>

<p>再以软件文档系统为例，实践证明，保证系统设计文档和代码的一致性需要花费可观的成本，这在大多数组织来说都难以实现。同时为了保证文档自身的可理解性，一个好的实践是建立组织统一的标准和术语，但实践证明这也很难做到，因为假设总会根据需求发生变更，而一旦新的假设违反了组织统一标准，则会引起标准的误用，而反过来扩展标准又有可能造成对已有文档假设的破坏。上述复杂性意味着，在一个实践统一文档标准的组织内，标准会尽量维持系统设计的最小假设，而这又会与文档本身的知识传递作用相违背。</p>

<p>Parnas认为设计人员应尽量“控制”信息的传播，例如在设计中只使用外部<strong>接口</strong>描述该模块，从而避免细节过早暴露，对外部隐藏那些尚待决定、不稳定或不应被外部了解的具体实现。</p>

<h3>职责分割(Responsibility Segment)</h3>

<p>人们普遍认为应根据功能职责划分系统模块，但缺少统一的划分方法，导致具体划分时会出现不同结果，原因在于实际问题域的复杂性。以比较简单的经典<a href="https://en.wikipedia.org/wiki/Key_Word_in_Context">KWIC</a>系统为例，考虑如下两种模块化设计方案：</p>

<ol>
<li><p>系统被划分成5个部分：分别是输入模块I、循环移位(circular shift)模块C、字母排序(Alphabetizing)模块A、输出模块O和主控制模块M。具体来说，I接受行格式的数据输入，把每个单词用四个字母进行压缩表示，其余字母作为单词的结尾，然后将其存储到系统核心(core)；当I读完所有数据，C先对核心中每行数据进行循环移位处理，并记录每条新数据到原始数据的索引，最后把数据存储回核心；然后，A从核心中读取数据，把C中生成的数据按字母进行排序并存储回核心；最后O把A中排序好的数据结合I中获得的原始数据进行匹配和格式化输出；主控制模块M负责控制其余模块的调用顺序，进行错误处理和进行一些必要的空间分配等操作。从实践角度考虑，该方案具备良好的职责分割和接口设计。</p></li>
<li><p>系统被划分成6个部分：行存储模块L、输入模块I&#8217;、循环移位器C&#8217;、排序器A&#8217;、输出模块O&#8217;
和主控制模块M&#8217;。具体来说，L负责提供对行数据进行操作的功能，例如常见的增删改查等；I&#8217;负责读入数据并调用L写入数据；C&#8217;用来计算并返回所有的循环移位索引。A&#8217;的功能是返回给定索引序号的字母序序号；O&#8217;用于输出L或C&#8217;中包含的数据；M&#8217;与方案1中M的功能类似。该方案也具有良好的职责分割和接口设计。</p></li>
</ol>


<p>为了进一步比较这两种方案的区别，首先来看两者在分析该问题时所作出的设计决策及其可能影响：</p>

<ol>
<li><p>输入格式。</p></li>
<li><p>存储介质，例如把所有行数据存储在core中，那么假设数据集较大，则该决策就会面临挑战。</p></li>
<li><p>存储压缩，例如对每个单词进行压缩，假设数据集不大，处理时间反而会因为不必要的压缩而增加。</p></li>
<li><p>为循环移位器创建索引，而非直接存储所有数据，对于较小的数据集而言，后一选项可能更加合适。</p></li>
<li><p>为所有数据进行一次性按字母序排序，而非只在需要时进行搜索或只进行部分排序。在某些场景中，可能更希望把索引计算量分配至不同时间的字母序操作中。</p></li>
</ol>


<p>以下分别使用<strong>是否容易变更</strong>、<strong>是否可独立开发</strong>和<strong>是否便于理解</strong>三个具有共识的软件设计目标分析和比较上述方案。</p>

<p><strong>易变更性</strong>，由于都拥有唯一的输入模块，那么决策1的任何潜在变化都不会导致输入模块以外的变化；对决策2和3来说，由于涉及数据的格式表示，方案1中由于多个模块都需要直接读写core中的数据，一旦存储格式因假设发生变化就会导致所有关联模块的修改，相应的方案2由于独立出了行存储功能，因此依旧把改动影响限制在了一个模块之内。同样，决策4的变更可能导致存储格式的变化，方案2中的C&#8217;模块只用于计算而非存储，因此变更影响小于方案1；决策5的情况则与决策4类似，方案2具有更好的易变更性。</p>

<p><strong>可独立开发</strong>，方案1的模块间接口实际上是通过数据存取间接实现的，其实质是数据格式和表结构的设计，在这种情况下，所有相关模块的接口设计都存在一定联系。而方案2通过若干个函数及其参数就实现了模块间的接口，因此对模块分别可独立开发有更好的支持。</p>

<p><strong>可理解性</strong>，根据方案1，为了理解模块职责，需要至少理解模块I、C、A内部的实现，特别是数据存取的设计和实现，才能了解模块间的相互关系；相反方案2只需要通过接口函数的定义就可以了解模块职责了。</p>

<p>从职责分割的角度来说，上述两种方案都给出了初看相当合理的划分，但经过分析我们的结论显然是方案2比方案1更好，那么如何实现诸如本例中更好的职责分割呢？</p>

<h2>一种用于模块分割的标准与系统设计方法</h2>

<p>实际经验表明，人们直观上会倾向于作出符合上节提到的方案1的设计，这是因为方案1更加显而易见：例如借助流程图(flowchart)工具描述系统功能和流程，再自然映射在模块的划分上。而方案2的核心在于每个模块都努力隐藏其设计决策，包括接口和定义也都以较少的信息呈现，Panars认为这反映了一种以隐藏自身设计决策为目标的模块间分割标准，与传统的流程式思考模式有显著区别。</p>

<p>由于构建计算机系统的复杂性，设计人员在60年代起开始采用一些系统模拟语言(Simulation languages)辅助系统设计。显然，当系统需求越复杂，模拟语言也就会变得更复杂，就越难以满足设计人员的目标，因此模拟语言最初的应用并不成功。1968年，沃森研究院的F. W. Zurcher描述了一种迭代式的多层建模方法，通过在不同的抽象层级(Levels of abstraction)上安排设计决策，为设计人员提供了有效的系统思考工具。</p>

<p>Zurcher提出在一个模型中构建系统的多重表示，即<strong>抽象层级</strong>。以计算机系统为例，在最上层，该模型只表示系统的若干基本任务，并且给定这些功能所达到的目标，即始终优先回答what；进一步，在下一层引入CPU、存储层级和文件系统的概念，并指定连接上层每个任务的程序和数据的划分；然后，再下一层级描述更加细节的系统表示，直到完整描述了整个系统设计，即回答how。<strong>迭代</strong>在实现上述方法中同样重要。在采用模拟语言时，先实现上一层的系统设计描述程序，程序应包括本层所含的所有抽象定义；在进入下一层时，构建一个独立的可被上层操作的实现本层抽象意义的模拟程序，从而实现迭代式的层次设计结构。</p>

<p>这种层级建模方法中，每一层都仅包含该层定义范围内的设计决策，即令设计人员更容易理解模型及其具体行为，并且把针对设计的修改限定在本层级范围内，降低了设计变更的影响范围。当进入正式实现阶段时，编程人员可以用具体的算法和数据结构实现替换最底层的模拟程序，从而构建完整系统。</p>

<h2>结论</h2>

<p>如果说结构化编程奠定了现代编程语言的基础，那么模块化编程则为软件设计提供了应对复杂问题的有效工具。与结构化编程和过程式编程几乎一锤定音相比，模块化编程在过去50年间历经了长期演进，虽然70年代开始大量编程语言开始引入模块(module)的概念，但抽象表达本身的复杂性使整个软件设计和开发过程经历了飞速的变革，而这一切源于模块化的设计思想。</p>

<h2>引用</h2>

<p>[DLP72], <a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">On the Criteria to be Used in Decomposing Systems into Modules</a></p>

<p>[DLP71], <a href="http://cseweb.ucsd.edu/~wgg/CSE218/Parnas-IFIP71-information-distribution.PDF">Information distribution aspects of design methodology</a></p>

<p>[FWZ68], <a href="https://pdfs.semanticscholar.org/d99a/732db8e249be47bdf4aacd260f608b632099.pdf">ITERATIVE MULTI-LEVEL MODELLING - A METHODOLOGY FOR COMPUTER SYSTEM DESIGN</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(2)]]></title>
    <link href="http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2/"/>
    <updated>2018-09-25T09:46:21-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/09/25/software-design-and-architecture-notes-2</id>
    <content type="html"><![CDATA[<h2>结构化编程(Structured Programming)：计算语言的突破</h2>

<p>上世纪50-60年代，人类的计算能力实现了迅猛发展，各界对计算机的应用也有很高期许，越来越多的领域希望得到强大的计算赋能从而实现飞跃。然而当面临的问题越多、越复杂时，人们在解决问题的道路上发现了一条巨大的鸿沟，即以现有的软件构建理论和方法难以应对这些挑战。机遇与挑战并存，这场<strong>软件危机</strong>(Software Crisis)最终促成了软件工程作为一门独立的学科从计算机科学的襁褓中成长起来。</p>

<p>软件危机这个词最早在1968年的北约组织软件工程会议上被诸多与会者提出[NATO68]，由此引发的技术创新和组织行为思辨至今依然活跃。而更现实的影响是，科学家们首先在编程语言本身找到了突破口——<strong>结构化编程</strong>。</p>

<p>发明于上世纪50年代的ALGOL语言，首次用begin&hellip;end语句引入了<strong>代码块</strong>的概念，通过限定其中变量声明的词法作用域，提高程序的<strong>可读性</strong>，从此引起了围绕代码块的研究。1966年，论文[Bohm66]证明使用三种基本的程序结构就能表达任何可计算函数：顺序执行、条件选择和循环迭代，这为随后针对结构化编程的讨论提供了理论依据。1968年，Dijkstra发表了著名的”GOTO语句有害“的观点，并且肯定了如条件选择、循环等语句的应用，同时称GOTO语句应该在所有“高级语言”（这里指除了机器码之外的语言）中被废除[EWD68]。Dijkstra认为应当尽可能减少静态程序和动态运行进程之间的差距，而GOTO语句造成了大量程序难以被理解，即人很难从混乱的静态代码中认识程序的真正意图。这一废除GOTO语句的言论激起旷日持久的争论，反对者认为GOTO所具有的灵活性能满足持续的系统优化工作，但争论两方基本同意应当对GOTO限制使用。于是，结构化编程开始被广泛接受。</p>

<p>伴随着结构化编程的普及，过程式编程(Procedural programming)也在60年代起被许多流行语言采纳，如COBOL和BASIC。这种编程方法以代码块为基础，允许使用子过程（也称子程或函数）编写程序单元，并且可以被程序随时调用。使得来自不同程序员甚至不同组织的代码变得简单可复用，为随后代码库的流行奠定基础。</p>

<h2>结构化程序设计与分析</h2>

<p>结构化编程实现了编程语言的巨大进步，作为首席布道者，Dijkstra发表了很多关于程序的可理解性以及结构化编程实践的原则性观点[EWD70]，但如何设计结构化程序还需要进一步说明。1971年，在计算机教育领域功勋卓著的Niklaus Wirth详细解释了一种自顶而下逐步求精的程序设计方法，并以数学中经典的八皇后问题（把这个著名问题作为编程案例，原因之一是尚无该问题的已知解析解）为例演示了程序设计从问题分析到实现的过程[NW71]。</p>

<p>简单分析可以得到八皇后问题的直观解法：对于全体候选解的集合A，其中每个解元素x满足条件函数p，即(x ∈ A) ∧ p(x)，则：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>repeat Generate the next element of A and call it x
</span><span class='line'>until p(x) ∨ (no more elements in A);
</span><span class='line'>if p(x) then x = solution</span></code></pre></td></tr></table></div></figure>


<p>由排列组合知识可知，集合A的空间可达2<sup>32</sup>，枚举算法效率较低。通过对问题进一步的分析，使用回溯法解决该问题的算法效率较高，即：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>j := l;
</span><span class='line'>repeat trystep j;
</span><span class='line'>if successful then advance else regress
</span><span class='line'>until (j &lt; 1) ∨ (j &gt; n) </span></code></pre></td></tr></table></div></figure>


<p>以上述程序分析结果为基础构建程序，按照回溯算法的基本思想，首先依照specification给出初步实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>variable board, pointer, safe;
</span><span class='line'>considerfirstcolumn;
</span><span class='line'>repeat trycolumn;
</span><span class='line'>  if safe then
</span><span class='line'>  begin setqueen; considernextcolumn
</span><span class='line'>  end else regress
</span><span class='line'>until lastcoldone ∨ regressoutoffirstcol</span></code></pre></td></tr></table></div></figure>


<p>根据现有结构化编程语言的表达能力，对如下指令进一步分解：</p>

<p>trycolumn:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure trycolumn;
</span><span class='line'>repeat advancepointer; testsquare
</span><span class='line'>until safe ∨ lastsquare </span></code></pre></td></tr></table></div></figure>


<p>regress:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure regress;
</span><span class='line'>begin reconsiderpriorcolumn
</span><span class='line'>  if ¬ regressoutoffirstcol then
</span><span class='line'>  begin removequeen;
</span><span class='line'>      if lastsquare then
</span><span class='line'>      begin reconsiderpriorcolumn;
</span><span class='line'>          if ¬ regressoutoffirstcol then
</span><span class='line'>              removequeen
</span><span class='line'>      end
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>截至目前，如需对上述程序中的指令做进一步分解，就需要设计额外的数据表示了。通过分析待分解语句，可知需要设计一个记录每位皇后位置的数据表示，例如使用二维数组表达棋盘上的每个方块。这里给出一个优化的数据表示方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>integer j (0 ≤ j ≤ 9)
</span><span class='line'>integer array x[1:8] (0 ≤ x[i] ≤ 8) </span></code></pre></td></tr></table></div></figure>


<p>其中j表示当前被检查的列序号，一维数组x用于存储上一次被检查方块的坐标，程序的部分指令可以被进一步细化为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure considerfirstcolumn;
</span><span class='line'>  begin j := 1; x[1] := 0 end
</span><span class='line'>procedure considernextcolumn;
</span><span class='line'>  begin j := j + 1; x[j] := 0 end
</span><span class='line'>procedure reconsidetpriorcolumn; j := j - 1
</span><span class='line'>procedure advancepointer;
</span><span class='line'>  x[j] := x[j] + 1
</span><span class='line'>Boolean procedure lastsquare;
</span><span class='line'>  lastsquare := x[j] = 8
</span><span class='line'>Boolean procedure lastcoldone;
</span><span class='line'>  lastcoldone := j &gt; 8
</span><span class='line'>Boolean procedure regressoutoffirstcol;
</span><span class='line'>  regressoutoffirstcol := j &lt; 1 </span></code></pre></td></tr></table></div></figure>


<p>接下来考虑剩余指令testsquare、setqueen和removequeen。</p>

<p>指令testsqaure需要验证是否满足问题条件，通过已知的x数组应不难通过计算进行判定，问题是可能导致较高的计算量，同时考虑到testsquare的调用频次较高，这里采用额外数据表示进行优化，设计三个Boolean型数组，其意义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a[k] = true : no queen is positioned in row k
</span><span class='line'>b[k] = true : no queen is positioned in the /-diagonal k
</span><span class='line'>c[k] = true : no queen is positioned in the \-diagonal k </span></code></pre></td></tr></table></div></figure>


<p>那么testsquare就可以用简单的布尔运算表示，其余指令也可以通过上述结构完成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure testsquare;
</span><span class='line'>  safe := a[x[j]] ∧ b[j+x[j]] ∧ c[j-x[j]]
</span><span class='line'>procedure setqueen;
</span><span class='line'>  a[x[j]] := b[j+x[j]] := x[j-x[j]] := false
</span><span class='line'>procedure removequeen;
</span><span class='line'>  a[x[j]] := b[j+x[j]] := c[j-x[j]] := true </span></code></pre></td></tr></table></div></figure>


<p>此时发现上述实现的x[j]调用次数过多，为了进一步优化，把x[j]用变量i表示，从而有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>procedure testsquare;
</span><span class='line'>  safe := a[i] ∧ b[i+j] ∧ c[i-j]]
</span><span class='line'>procedure setqueen;
</span><span class='line'>  a[i] := b[i+j] := c[i-j] := false
</span><span class='line'>procedure removequeen;
</span><span class='line'>  a[i] := b[i÷j] := c[i-j] := true
</span><span class='line'>procedure considerflrstcolumn ;
</span><span class='line'>  begin j:= 1; i:= 0 end
</span><span class='line'>procedure advancepointer; i := i + l
</span><span class='line'>procedure considernextcolumn
</span><span class='line'>  begin x[j] := i; j:=j+l; i := 0 end
</span><span class='line'>Boolean procedure lastsquare;
</span><span class='line'>  lastsquare := i = 8 </span></code></pre></td></tr></table></div></figure>


<p>通过inline替换程序中的部分指令，其余采用过程调用，从而最终实现如下程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>j := 1; i := 0;
</span><span class='line'>repeat
</span><span class='line'>  repeat i := i + 1 ; testsquare
</span><span class='line'>  until safe ∨ (i = 8);
</span><span class='line'>  if safe then
</span><span class='line'>  begin setqueen; x[j] := i; j := j + 1; i := 0
</span><span class='line'>  end else regress
</span><span class='line'>until (j &gt; 8) ∨ (j &lt; 1);
</span><span class='line'>if i &gt; 8 then PRINT(x) else FAILURE </span></code></pre></td></tr></table></div></figure>


<p>前述过程清晰解释了逐步求精这种非常经典的结构化程序的分析和设计过程，从早期分析确定适用算法，然后利用基本的结构化编程元素描述初步程序，对复杂过程进一步分解，同时考虑额外必要的数据表示和程序运行效率优化，最终使用目标编程语言实现程序。这是一种具有普遍适用意义的编程方法论，也呼应了Wirth的那句名言：程序=算法+数据结构。</p>

<h2>结论</h2>

<p>50年前的软件危机所揭露的问题成为今天软件工程研究的基石。GOTO语句的争论直至今天，从历史发展看，更多人选择支持Dijkstra的GOTO有害论，许多90年代以后出现的编程语言并没有在应用层面设计GOTO语句。但是，GOTO争论背后有关编程语言灵活和统一的争辩还远未结束。另一方面，结构化编程促成了一套良好的编程方法论，迄今Wirth的逐步求精方法还被采用于程序设计课程，为计算机教育的普及和广泛应用打下了坚实基础。同时，软件设计所要解决的问题也得以提升到更高的复杂度水平。</p>

<h2>引用</h2>

<p>NATO68, <a href="http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF">NATO Software Engineering Conference</a></p>

<p>Bohm66, <a href="http://www.cs.unibo.it/~martini/PP/bohm-jac.pdf">Flow Diagrams, Turing Machines and Languages with Only Two Formation Rules</a></p>

<p>EWD68, <a href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF">Go-to statement considered harmful</a></p>

<p>EWD70, <a href="https://pure.tue.nl/ws/files/2408738/252825.pdf">Notes on structured programming</a></p>

<p>NW71, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.119.8111&amp;rep=rep1&amp;type=pdf">Program Development by Stepwise Refinement</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计与架构笔记(1)]]></title>
    <link href="http://www.hanyi.name/blog/2018/09/24/software-design-and-architecture-notes/"/>
    <updated>2018-09-24T11:57:34-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/09/24/software-design-and-architecture-notes</id>
    <content type="html"><![CDATA[<p><strong><em>《软件设计与架构笔记》系列，是笔者对自上世纪60年代末至今在工业界和学术界皆有一定影响的软件设计方法的学习和记录，期望通过历史的时间轴把握相关技术发展的脉络，尝试理解推动了这一领域中概念、方法、原则、模式、实践不断演进的若干基本动机，倚靠巨人的肩膀，但求一条少些人云亦云的实践之路。</em></strong></p>

<p>自诞生之日起，软件设计就同时在工业界和学术界探索和实践着，然而二者的动机和方法大相径庭。例如计算机科学家Edsger W. Dijkstra，一生就致力于对计算的简洁性和精确性的探索，其工作背后蕴含了严谨的数学美学；而工业界则侧重于使用由计算衍生的自动化方法解决传统生产的问题，根本目的是追求经济利益的最大化。有趣的是，二者的偶然交汇就迸发出这一系列文章的主题——软件设计，而软件架构——作为稍晚出现的buzz word，有时也被本文采用以和行业用语保持一致。</p>

<h2>THE Multiprogramming system：早期探索</h2>

<p>1965年，Dijkstra在埃因霍温科技大学领导了一支团队在Electrologica(EL) X8上开发多道程序系统，该系统的主要目标是能够平滑地处理持续的用户程序流，并将其作为服务提供给学校。该系统的设计目标是：1.降低短程序运行的周转时间； 2.更经济地使用外设; 3.结合后备存储器的自动控制和中央处理器的经济使用; 4.验证一种经济可行性，即将EL X8用于运行在不依赖容量和计算能力，仅需要通用计算机灵活性的应用程序。</p>

<p>出于多道程序系统的<strong>复杂性</strong>，实时触发中断的偶然性和不可复现性使系统开发的debug面临挑战。为此，团队决定在系统构建之初就重视对debug能力的设计，从而在具体实现前就能证明系统的逻辑可靠性，并显著降低了实际bug数量。在论文EWD68中，为了提高<strong>可测试性</strong>，设计者采用层级结构划分整个系统，并以不同的职责区分系统层级：</p>

<p>0级，负责把逻辑可用的进程分配给处理器。为了防止任何进程独占处理器，该层实现了一个实时时钟中断功能。</p>

<p>1级，实现“段控制器”，通过中断与上层的顺序进程保持同步，负责从自动后备存储器中记录数据。</p>

<p>2级，实现“消息解释器”，负责在控制键盘的输入时产生中断，并且联接系统对话的操作员和特定的目标进程。</p>

<p>3级，实现与输入流缓冲和输出流解缓冲相关的顺序进程，通过逻辑通信单元实现对具体外设的抽象，并按照资源限制采用同步方法限制外设运行的数量。</p>

<p>4级，实现独立用户程序。</p>

<p>根据上述层级划分，团队制定了需求规格说明书，并依此实现系统。在验证阶段，在添加下一层级前，需要对前一层进行充分测试，例如针对0级中实现的实时中断和处理器分配，首先设计一个完整的测试状态空间，然后依次进行测试。而当对1级的“段控制器”进行测试时，可以在0级时制定的测试状态空间的基础上，通过引入“请求页”操作，实现状态空间的扩展，只需引入少量新的测试就可以满足当前层的测试需求，直至完成整个系统。</p>

<p>Dijkstra认为，虽然在概念和设计阶段花费了较长时间，但是该过程为系统贡献了良好的设计，避免传统非层级实现可能面临的测试状态空间“爆炸”问题，从而对系统质量提供保证。</p>

<p>虽然缺少定量的研究方法，发布于1968年的THE Multiprogramming System可以说是首次定性地证明了<strong>结构</strong>在软件设计中的重要作用，并且以系统的可测试性为例进行了深入阐释。</p>

<h2>结论</h2>

<p>系统的复杂性引出了软件设计问题。Dijkstra把软件开发过程划分成三个阶段：概念、构建和验证，并且由一个基于层级划分的设计案例指出结构因素在软件设计中的重要性。虽然工业界可能面临更多的问题（例如成本、人员、规模、业务复杂程度等），但是概念阶段产出的良好设计，能使验证阶段受益，从而实现整体的系统质量保证（笔者注：某种程度上也起到控制成本的作用），是THE多道程序系统的一项重要结论，也启发后人对软件概念阶段本身和其边际效应的进一步研究。</p>

<p>值得一提的是，按照不同职责划分层级，底层能够对上层隐藏其核心概念和具体实现，例如0级隐藏了处理器操作，1级隐藏了“页存储”机制，2级隐藏了电传打印控制台等。但是“信息隐藏”作为一个基本设计概念被明确提出，则是若干年以后了。</p>

<h2>引用</h2>

<p>[EWD68] EW Dijkstra, <a href="http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD196.PDF">The structure of the &lsquo;THE&rsquo;-multiprogramming system.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Working with Legacy Engineering]]></title>
    <link href="http://www.hanyi.name/blog/2018/08/23/working-with-legacy-engineering/"/>
    <updated>2018-08-23T15:04:57-04:00</updated>
    <id>http://www.hanyi.name/blog/2018/08/23/working-with-legacy-engineering</id>
    <content type="html"><![CDATA[<p>Looking back to the past five years, my common experience for joining a project is always looking like this:</p>

<p>Learning business knowledge -> Revealing technical context -> Launching a new project and instilling good practices into the team to make better software as usual.</p>

<p>While it&rsquo;s not always true for software engineers, I rarely got chance to work on the pre-existing codebase, not to mention a whole legacy engineering.</p>

<p>Things have changed since I stepped on a new journey. My very first challenge is taking over a legacy engineering. I call it legacy engineering because all I have to care is far more than only the codebase, although it is absolutely focal to tackle with the legacy code. The rest of this article will introduce the steps and thoughts I&rsquo;ve taken during this process.</p>

<h3>Communication</h3>

<p>A good teacher can at least half the work. Everyone who ever worked in the team can teach and benefit, but the following question is how to learn from people more effectively. My answer is no doubt through good communication.</p>

<p>For those who are interested, I would suggest some great learnings like <a href="https://www.nonviolentcommunication.com/">Nonviolent Communication</a> and <a href="https://www.amazon.com/Crucial-Conversations-Talking-Stakes-Second/dp/1469266822">Crucial Conversations</a>. No follow-up discussion since we&rsquo;re not talking about psychology here, but remember it&rsquo;s indeed the first priority soft skill as a professional.</p>

<h3>Documentation</h3>

<p>For a hand-over stage, documentation in any form is less effective than a good communication. But it&rsquo;s worthy to keep valuable knowledge and make it more efficient to spread those to broader stakeholders. Again, it always depends on requirement at the moment for determining the scope of what should be documented. My personal inclination is several topics listed as follows:</p>

<ol>
<li>Team specific knowledge that everyone should be aware of.</li>
<li>Any confusing/complicated part.</li>
<li>The reason for counter-intuitive decisions made by former team members.</li>
</ol>


<p>It finally leads to three basic documents for me:</p>

<ol>
<li>Feature list (Rough is good).</li>
<li>Team engineering practice, like workflow definition and release cycle.</li>
<li>Crucial code design.</li>
</ol>


<p>Of course, the Evernote in hand to prepare for any unknown technologies and skills.</p>

<h3>Codebase</h3>

<p>Being familiar with codebase is always the top priority for a newbie, but former topics we just discussed would influence the effectiveness of codebase learning. As software engineering today has adopted many common practices like CI/CD and DevOps, those automation practices can help to    guide people along with the code or script, rather than outdated document and lengthy tutorial.</p>

<h4>Build (Pipeline)</h4>

<p>Build automation is the most matured practice in nowadays software engineering. For a newbie, the build script provides panorama and coarse-grained view of system modularity and dependency, it would be even clearer if the team is maintaining an effective CI pipeline.</p>

<p>A undoubted fact is that the more matured for build automation, the more efficiency for a newbie to get first wave things done. Otherwise, it would take weeks to set up a local environment by referring to  an far outdated guide and consulting different team members!</p>

<h4>Test</h4>

<p>It&rsquo;s not very common to see &ldquo;effective tests&rdquo; in the codebase, not to mention the practice of the whole test pyramid or <a href="http://www.hanyi.name/blog/2017/12/17/owl-exploratory-testing/">sandwich</a>. Automation test is a proven practice to assure quality, sometimes it is promoted to be the specification of the codebase. However, bad practice for automation test also does harm other than keeping high quality.</p>

<p>For a newbie, in most cases, the tests especially the  bad tests cannot help for specification at all, it shows less value than a good naming practice. My personal experience is that the test is not so good for early learning if it&rsquo;s not well organized and properly implemented. That&rsquo;s not saying that it doesn&rsquo;t play vital role to indicate the consistency when any changes happen.</p>

<p>It&rsquo;s usually easy for everyone to see the value of automation test, while it also  makes this practice be one of the most confusing parts in modern software engineering as  lack of deep understanding.</p>

<h4>Operation</h4>

<p>As DevOps is more adopted, it turns to be more necessary for a newbie to understand operation knowledge. Must-have topics include configuration management and specification of cloud platform and core systems.</p>

<h4>Design (Structural) and Refactor</h4>

<p>The core of codebase learning is about design. A design could be regarded as a collection of decisions along the software development. For a newbie, it&rsquo;s more important to concentrate on the crucial design points than knowing every corners.</p>

<p>Although it varies for the different roles, as a backend newbie, the top concern comes into the structural design. To learn software structure,a  good starting point could be any selected feature from both business and technical perspective, it can help dive into the deeper codebase to understand the structure, then forms into whole picture of modularity design.</p>

<p>A good approach is to elaborate design with some tools, CRC even Naked CRC is agiler, but UML is also very cool and common, it again depends on team background for these tools selection. More important is that whichever tool is used, only the leading design rules need to be considered, rather than drawing a full system map. During this process, design pattern may benefit but also cause restriction.</p>

<p>It&rsquo;s not exactly same for design of software structure and logical data model, but the latter could also be learned via any cleaner ways (like E-R diagram), not necessary to dig into physical data model too early unless there is significant reason to do that.</p>

<h3>Feature Enhancement</h3>

<p>I wouldn&rsquo;t suggest making big change or refactor on the legacy codebase which is just taken over unless the change is too small to cause any visible influence. Before doing any work alone, a newbie still needs to learn from core team members about:</p>

<ol>
<li>Architecture Roadmap.</li>
<li>Non-functional requirements.</li>
<li>Technical debts and roadmap of resolution.</li>
</ol>


<p>Despite the  following work would be feature enhancement in most cases. I&rsquo;d take different strategy depends on the potential influence of the change.</p>

<p>Here I&rsquo;m not going to discuss the case of a tiny change, that wouldn&rsquo;t be a big deal anyway. But if the change is going to happen on the higher level design rule but not touch leading yet (which usually implies a broader influence across code), I could try to add new features via extensional way (rather than editing as is code and making feature changes directly, methods metioned in <a href="https://www.amazon.com/Working-Effectively-Legacy-Robert-Martin-ebook/dp/B005OYHF0A">Working effectively with legacy code</a> are good guidance), and extra feature toggles may help for QA and CD.</p>

<p>The worst case is the desired change must happen on leading design rule, which means it won&rsquo;t work with just simple extension, a big change is definitely required. Even in this case, I wouldn&rsquo;t edit any as is code in an early stage, and purely technical refactor without guidance from business requirement is also not a good option. Instead, I&rsquo;d create a separate package or namespace as the neighbor of the code which is going to die, and naming it &ldquo;experiment&rdquo; or anything makes sense. Using least effort to make experiment code work as well as automation test, without breaking any as is feature or code. Once new feature and refactor direction is confirmed, the experiment code can be transformed into formal and replace dead one.</p>

<p>The benefit of this &ldquo;experimental duplication&rdquo; is that I can continue looking at two implementations and making a trade-off when thinking of the design for following refactor until the new feature is completed and confirmed. Later on, refactor and clean-up can be done to completely remove the deprecation.</p>

<h3>Conclusion</h3>

<p>In this article, we discussed the strategies I would take while working with legacy engineering. Someone calls it reverse engineering to imply the   digestion for an incredibly overdue but complicated legacy codebase or engineering. While in most cases it does not have to make upfront &ldquo;reverse engineering&rdquo; to reach critical decision for future, nor do a hasty change on codebase to cause risk. We can certainly take actions to delay that decision making, by mitigating waste and respecting the economic model of our beloved software industry.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试三明治和雪鸮探索测试]]></title>
    <link href="http://www.hanyi.name/blog/2017/12/17/owl-exploratory-testing/"/>
    <updated>2017-12-17T16:12:58+08:00</updated>
    <id>http://www.hanyi.name/blog/2017/12/17/owl-exploratory-testing</id>
    <content type="html"><![CDATA[<p>测试金字塔理论被广泛应用于计划和实施敏捷软件开发所倡导的的测试自动化，并且取得了令人瞩目的成就。本文尝试从产品开发的角度出发，结合Kent Beck最近提出的3X模型和近年来迅速发展的自动化测试技术，提出并讨论一种新的测试层级动态平衡观：<strong>三明治模型</strong>。同时，为了应对端到端测试在实践中面临的种种挑战，设计并实现了一种面向用户旅程的端到端自动化测试框架——<strong>雪鸮</strong>。实际项目经验表明，雪鸮能够显著提升端到端测试的可维护性，减少不确定性影响，帮助开发人员更快定位和修复问题，对特定时期的产品开发活动更具吸引力。</p>

<h2>背景</h2>

<h3>测试金字塔</h3>

<p>按照自动化测试的层级，从下至上依次为<strong>单元测试</strong>、<strong>集成测试</strong>和<strong>端到端测试</strong>，尽量保持数量较多的低层单元测试，以及相对较少的高层端到端测试，这就是<strong>测试金字塔理论</strong>。随着敏捷软件开发的日益普及，测试金字塔逐渐为人所知，进而得到广泛应用。<a href="https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid">Mike Cohn</a>、<a href="https://martinfowler.com/bliki/TestPyramid.html">Martin Fowler</a>以及<a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html">Mike Wacker</a>等先后对测试金字塔进行了很好的诠释和发展，其主要观点如下：</p>

<ul>
<li>测试层级越高，运行效率就越低，进而延缓持续交付的构建-反馈循环。</li>
<li>测试层级越高，开发复杂度就越高，如果团队能力受限，交付进度就会受到影响。</li>
<li>端到端测试更容易遇到测试结果的不确定性问题，按照Martin Fowler的说法，这种结果不确定性的测试毫无意义。</li>
<li>测试层级越低，测试的代码隔离性越强，越能帮助开发人员快速定位和修复问题。</li>
</ul>


<h3>3X模型</h3>

<p>2016年起，敏捷和TDD先驱Kent Beck开始在个人facebook主页撰写<a href="https://www.facebook.com/notes/kent-beck/comparing-explore-expand-and-extract-topics-in-3x/1241983035834558">系列文章</a>，阐述产品开发的三个阶段——Explore、Expand和Extract，以及在不同阶段中产品与工程实践之间的关系问题，即<strong>3X模型</strong>。近二十年软硬件技术的飞速发展，使得软件开发活动面临敏捷早期从未遇到的市场变革，而根据在facebook工作的经历，Kent Beck把产品开发总结为三个阶段：</p>

<ul>
<li><strong>探索（Explore）</strong>，此时的产品开发仍处于非常初期的阶段，仍然需要花费大量时间寻找产品和市场的适配点，收益也是最低的阶段。</li>
<li><strong>扩张（Expand）</strong>，一旦产品拥有助推器（通常意味着已经找到了市场的适配点），市场需求就会呈现指数级上升，产品本身也需要具备足够的伸缩性以满足这些需求，由此收益也会快速上升。</li>
<li><strong>提取（Extract）</strong>，当位于该阶段时，公司通常希望最大化产品收益。但此时收益的增幅会小于扩张阶段。</li>
</ul>


<p><img src="http://content.hanyi.name/images/owl_exploratory_testing/3x.png" alt="3X" /></p>

<p>Kent Beck<a href="http://redgreenrepeat.com/2016/11/18/kent-beck-3x-and-software-tests/">认为</a>，如果以产品是否成功作为衡量依据，那么引入自动化测试在探索阶段的作用就不大，甚至会延缓产品接受市场反馈循环的速度，对产品的最终成功毫无用处，还不如不引入；当位于扩张阶段时，市场一方面要求产品更高的伸缩性，另一方面也开始要求产品保证一致的行为（例如质量需求），那么此时就该引入自动化测试来保证产品的行为一致性；当产品最终处于提取阶段时，任何改动都应以不牺牲现有行为为前提，否则由此引发的损失可能远高于改动带来的收益，此时自动化测试就扮演了非常重要的角色。</p>

<h3>测试工具爆炸式增长和综合技能学习曲线陡升</h3>

<p>根据<a href="http://www.softwareqatest.com/">SoftwareQATest</a>网站的历史数据，2010年记录的测试工具有440个，共划分为12个大类。这个数字到2017年已经变为560个，共15个大类，且其中有340个在2010年之后才出现。也就是说，平均每年就有50个新的测试工具诞生。</p>

<p>面对测试工具的爆炸式增长，一方面所支持的测试类型更加完善，更加有利于在产品开发过程中保证产品的一致性；另一方面也导致针对多种测试工具组合的综合技能学习曲线不断上升。在实践中，团队也往往对如何定义相关测试的覆盖范围感到不知所措，难以真正发挥测试工具的效用，也很难对产品最终成功作出应有的贡献。</p>

<h2>从金字塔到三明治</h2>

<p>作为敏捷在特定时期的产物，测试金字塔并不失其合理性，甚至还对自动化测试起到了重要推广作用。但是，随着行业整体技术能力的不断提升，市场需求和竞争日趋激烈，在项目中具体实施测试金字塔时往往遭遇困难，即便借助外力强推，其质量和效果也难以度量。</p>

<p>此外，随着软件设计和开发技术的不断发展，低层单元测试的<a href="https://martinfowler.com/articles/mocksArentStubs.html">传统测试技术</a>和落地，因前、后端技术栈的多样化而大相径庭；同时，在经历过<a href="https://stackoverflow.com/questions/90002/what-is-a-reasonable-code-coverage-for-unit-tests-and-why">覆盖率之争</a>，如何确保单元测试的规范和有效，也成为工程质量管理的一大挑战；高层的端到端测试则基本不受技术栈频繁更替的影响，随着不同载体上driver类技术的不断成熟，其开发复杂度反而逐渐降低。</p>

<p>这里讨论一种新的测试层级分配策略，我们称之为<strong>三明治模型</strong> 。如下图所示，该模型允许对不同测试层级的占比进行动态调整，说明了倒金字塔形、沙漏形以及金字塔形分配对特定产品开发阶段的积极作用。</p>

<p><img src="http://content.hanyi.name/images/owl_exploratory_testing/sandwich.png" alt="Sandwich" /></p>

<h3>产品开发的自动化测试策略</h3>

<p>根据3X模型，在探索初期往往选择避开自动化测试。一旦进入扩张期，产品的可伸缩性和行为一致性就成为共同目标，但此时也常会发生大的代码重构甚至重写，如果沿用测试金字塔，无论补充缺失的单元测试，还是只对新模块写单元测试，都既损害了产品的快速伸缩能力，也无法保证面向用户的产品行为一致性。因此，如果在探索后期先引入高层的端到端测试，覆盖主要用户旅程，那么扩张期内所产生的一系列改动都能够受到端到端测试的保障。</p>

<p>需要注意的是，用户旅程在产品即将结束探索期时通常会趋于稳定，在扩张期出现颠覆性变化的概率会逐渐减少，端到端测试的增长率会逐步下降。</p>

<p>除此以外，随着扩张期内不断产生的模块重构和服务化，团队还应增加单元测试和集成测试的占比。其中，单元测试应确保覆盖分支场景（可以在CI中引入基于模块的覆盖率检测）；集成测试和某些团队实践的验收测试，则需进一步覆盖集成条件和验收条件（在story sign-off和code review时验收）。</p>

<p>许多新兴的测试技术和工具擅长各自场景下的验收测试，但更重要的仍是识别产品阶段和当前需求，以满足收益最大化。</p>

<p><img src="http://content.hanyi.name/images/owl_exploratory_testing/sandwich-3x.png" alt="Sandwich-3x" /></p>

<p>由此我们认为，随着产品开发的演进，测试层级的分配应参考三明治模型，动态调整层级占比，更加重视运营和市场反馈，致力于真正帮助产品走向成功。</p>

<h3>端到端测试的机遇和挑战</h3>

<p>与其他测试层级相比，端到端测试技术的发展程度相对滞后。一方面，作为其基础的driver工具要在相应载体成熟一段时间之后才能趋于稳定，web、mobile无不如是。另一方面，端到端测试偏向黑盒测试，更加侧重描述用户交互和业务功能，寻求硬核技术突破的难度较高，于是较少受开发人员青睐。但是，由于端到端测试更接近真实用户，其在特定产品开发活动中的性价比较高，有一定的发展潜力。</p>

<p>然而，当前实践中的端到端测试，普遍存在如下问题：</p>

<ul>
<li><strong>低可维护性</strong>。一般实践并不对测试代码质量作特别要求，而这点在端到端测试就体现得更糟。因为其涉及数据、载体、交互、功能、参照（oracle）等远比单元测试复杂的<a href="https://martinfowler.com/bliki/BroadStackTest.html">broad stack</a>。虽然也有<a href="https://www.thoughtworks.com/insights/blog/using-page-objects-overcome-protractors-shortcomings">Page Object</a>等模式的广泛应用，但仍难以应对快速变化。</li>
<li><strong>低运行效率</strong>。如果拿单次端到端测试与单元测试相比，前者的运行效率肯定更低。因此只一味增加端到端测试肯定会损害构建-反馈循环，进而影响持续交付。</li>
<li><strong>高不确定性</strong>。同样因为broad stack的问题，端到端测试有更高的几率产生不确定测试，表现为测试结果呈随机性成功／失败，进一步降低运行效率，使得真正的问题很容易被掩盖，团队也逐渐丧失对端到端测试的信心。</li>
<li><strong>难以定位问题根因</strong>。端到端测试结果很难触及代码级别的错误，这就需要额外人工恢复测试环境并尝试进行问题重现。其中所涉及的数据重建、用户交互等会耗费可观的成本。</li>
</ul>


<h2>方法</h2>

<p>为了解决传统端到端测试遇到的种种挑战，本文设计了一种面向用户旅程的端到端自动化测试框架——<strong>雪鸮（snowy_owl）</strong>，通过用户旅程优先、数据分离、业务复用和状态持久化等方法，显著提高了端到端测试的可维护性，降低不确定性的影响，并且能够帮助团队成员快速定位问题。</p>

<h3>用户旅程驱动</h3>

<p>端到端测试应尽量贴近用户，从用户旅程出发能保证这一点。在雪鸮中，用户旅程使用被称作play books的若干yaml格式的文件进行组织，例如下列目录结构：</p>

<pre><code>play_books/
  core_journey.yml
  external_integration.yml
  online_payment.yml
</code></pre>

<p>其中每个play book由若干plots所组成，plot用于表示用户旅程中的“情节”单位，其基本特征如下：</p>

<ul>
<li>单一plot可以作为端到端测试独立运行，例如发送一条tweet的情节：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SnowyOwl</span><span class="o">::</span><span class="no">Plots</span><span class="o">.</span><span class="n">write</span> <span class="s1">&#39;send a plain text tweet&#39;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">visit</span> <span class="s1">&#39;/login&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;username&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;password&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Sign In&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already login?</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Home&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already on home page?</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;Hello World&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Send&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already sent?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>单一plot应是紧密关联的一组用户交互，并且具备体现一个较小业务价值的测试参照。</li>
<li>plot可以被play book引用任意次从而组成用户旅程，play book同时定义了所引用plots之间的顺序关系，基本语法如下所示：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">---</span>
</span><span class='line'><span class="o">-</span> <span class="ss">plot_name</span><span class="p">:</span> <span class="nb">send</span> <span class="n">a</span> <span class="n">plain</span> <span class="n">text</span> <span class="n">tweet</span>
</span><span class='line'>  <span class="ss">digest</span><span class="p">:</span> <span class="mi">2</span><span class="n">aae6c35c94fcfb415dbe95f408b9ce91ee846ed</span>
</span><span class='line'>  <span class="ss">parent</span><span class="p">:</span> <span class="n">d6b0d82cea4269b51572b8fab43adcee9fc3cf9a</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中plot_name表示情节的标题，digest和parent分别表示当前情节引用在整个端到端测试过程中的唯一标识和前序情节标识，初期开发人员可以通过各个情节的引用顺序定义用户旅程，大多数情况下digest和parent将由系统自动生成并维护。</p>

<p>整个play books集合将是一个以plots为基础组成的森林结构，而端到端测试的执行顺序则是针对其中每棵树进行深度遍历。</p>

<h3>通用业务复用</h3>

<p>由于plot本身必须是一个独立可运行的端到端测试，那么plots之间通常会共享一部分交互操作，例如用户登录。雪鸮允许把高度可复用的交互代码进行二次抽取，称作determination：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SnowyOwl</span><span class="o">::</span><span class="no">Determinations</span><span class="o">.</span><span class="n">determine</span><span class="p">(</span><span class="s1">&#39;user login&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="p">,</span> <span class="n">user_profile</span><span class="o">|</span>
</span><span class='line'>  <span class="c1"># return if already login</span>
</span><span class='line'>  <span class="n">visit</span> <span class="s1">&#39;/login&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="n">user_profile</span><span class="o">[</span><span class="ss">:username</span><span class="o">]</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="n">user_profile</span><span class="o">[</span><span class="ss">:password</span><span class="o">]</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Sign In&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already login?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，plot的代码就可以简化成:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SnowyOwl</span><span class="o">::</span><span class="no">Plots</span><span class="o">.</span><span class="n">write</span> <span class="s1">&#39;send a plain text tweet&#39;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">determine_user_login</span><span class="p">({</span><span class="ss">username</span><span class="p">:</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="ss">password</span><span class="p">:</span> <span class="s1">&#39;password&#39;</span><span class="p">})</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Home&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already on home page?</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="s1">&#39;Hello World&#39;</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Send&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already sent?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里应注意Determination和Page Object的区别。看似使用Page Object可以达到相同的目的，但是后者与Page这一概念强绑定。而Determination更加侧重描述业务本身，更符合对用户旅程的描述，因此比Page Object在plot中更具适用性。当然，在描述更低层的组件交互时，Page Object仍然是最佳选择。</p>

<h3>测试数据分离</h3>

<p>合理的数据设计对描绘用户旅程非常重要，雪鸮对测试逻辑和数据进行了进一步分离。例如用户基本数据（profile），同样是使用yaml文件进行表示：</p>

<pre><code>data/
  tweets/
    plain_text.yml
  users/
    plain_user.yml
</code></pre>

<p>那么在plot的实现中，就可以使用同名对象方法替代字面值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SnowyOwl</span><span class="o">::</span><span class="no">Plots</span><span class="o">.</span><span class="n">write</span> <span class="s1">&#39;send a plain text tweet&#39;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">determine_user_login</span><span class="p">({</span><span class="ss">username</span><span class="p">:</span> <span class="n">plain_user</span><span class="o">.</span><span class="n">username</span><span class="p">,</span> <span class="ss">password</span><span class="p">:</span> <span class="n">plain_user</span><span class="o">.</span><span class="n">password</span><span class="p">})</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Home&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already on home page?</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">fill_in</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="ss">with</span><span class="p">:</span> <span class="n">plain_text</span><span class="o">.</span><span class="n">value</span>
</span><span class='line'>  <span class="n">page</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s1">&#39;Send&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">click</span>
</span><span class='line'>  <span class="c1"># verify already sent?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>情节状态持久化</h3>

<p>雪鸮的另一个重要功能是情节状态的持久化和场景复原。为了启用情节状态持久化，开发人员需要自己实现一个持久化脚本，例如对当前数据库进行dump，并按照雪鸮提供的持久化接口把dump文件存储至指定位置。</p>

<p>当端到端测试运行每进入一个新的情节之前，系统会自动执行持久化脚本。也就是说，雪鸮支持保存每个情节的前置运行状态。</p>

<p>当端到端测试需要从特定的情节重新开始运行时，雪鸮同样会提供一个恢复接口，通过用户自定义的数据恢复脚本把指定位置的dump文件恢复至当前系统。</p>

<p>该功能有两处消费场景：</p>

<ul>
<li>由于broad stack的问题，端到端测试不确定性的技术因素一般较为复杂。实际经验表明，测试的随机失败率越低，就越难以定位和修复问题，而通过不断改进测试代码的方式消除这种不确定性的成本较高，效果也不好。但是，可以尽量消除不确定性带来的影响。例如，不确定测试导致的测试失败，通常会导致额外人工验证时间，完全可以选择让系统自动重试失败的测试。另一方面，重试会造成测试运行效率降低，特别是针对端到端测试。当一轮端到端测试结束后，雪鸮只会自动重试失败的情节测试，同时利用该情节对应的数据dump文件保证场景一致性，这就减少了重试整个端到端测试带来的运行效率下降问题。</li>
<li>当团队成员发现端到端测试失败，通常需要在本地复现该问题。而借助测试dump文件，可以直接运行指定plot测试，从而避免额外的人工设置数据和交互操作，加快问题定位和解决。</li>
</ul>


<h2>实践</h2>

<p>雪鸮在笔者所在的项目有超过6个月的应用时间。该项目在产品开发方面长期陷入困境，例如过程中同时兼具了3X每个阶段的特点，不仅缺少清晰的产品主线，还背负了接棒遗留系统的包袱。这种状况对工程质量管理提出了更大挑战。</p>

<p>项目采用雪鸮对已有端到端测试进行了重构，生成了一个核心用户旅程和三个涉及外部系统集成的重要用户旅程，包含24个plots，9个determinations，使端到端测试实现了长期稳定运行。在本地相同软硬件环境下，不确定性导致的随机失败从原有10%降低至1%以内，部署至云环境并采用headless模式后，连续15天测试失败记录为零，运行效率的损失可以忽略不计。同时，当用户旅程产生新分支时，可以引入新的情节测试节点，并且根据业务需求将其加入现有play book树，从而实现端到端测试的快速维护。</p>

<h3>持续集成与常态化运行</h3>

<p>项目完整的端到端测试的平均运行时间保持在19分钟左右，为了不影响现有持续集成节奏，CI每30分钟自动更新代码并运行端到端测试，结果在dashboard同步显示，一旦发生测试失败，第一优先级查找失败原因并尝试在本地复现和修复。</p>

<p>常态化运行端到端测试的另一个好处是，能够以低成本的方式实现24小时监控系统各个组件的功能正确性，有助于更早发现问题：一次，产品即将上线的支付功能发生异常，查看CI记录发现端到端测试在晚上9:15左右出现了首次告警。通过及时沟通，确认是海外团队在当时擅自改动了支付网关的一个配置，造成服务不可用的问题，并迅速得以解决。</p>

<h2>结论与展望</h2>

<p>Kent Beck的3X模型，提出了从不同产品开发阶段看待工程实践的新视角。而敏捷一贯推崇的TDD等实践，更多体现在个人技术专长（Expertise）方面，与产品是否成功并无必然联系。然而，程序员的专业主义（Professionalism）的确同时涵盖了技术专长和产品成功两个方面，二者相辅相成。因此，如何通过平衡众多因素并最终提高整体专业性，这才是软件工程面临的经典问题。本文给出的测试三明治模型，目的就是帮助思考产品开发过程中测试层级间的平衡问题。</p>

<p>为了应对现有端到端测试面临的挑战，本文设计并实现了一种新的面向用户旅程的端到端测试框架，通过职责隔离、业务复用和状态持久化等手段，构建了易于维护且更加有效的端到端测试。同时，基于上述方法构建的测试代码，更易于和自动化测试的其他研究领域相结合，在诸如测试数据构建、用例生成、随机测试和测试参照增强等方向有进一步的应用潜力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微情境混合现实]]></title>
    <link href="http://www.hanyi.name/blog/2016/11/20/micro-situational-mixed-reality/"/>
    <updated>2016-11-20T13:37:28+08:00</updated>
    <id>http://www.hanyi.name/blog/2016/11/20/micro-situational-mixed-reality</id>
    <content type="html"><![CDATA[<p><em>从前有一池清潭，在附近的居民眼里它和普通池塘并没有什么区别。某天一位富绅来到池边，搬起一块巨石砸进了池中心，泛起的沉渣顿时把池水变成了浊潭。富绅见人就说，突然变浑浊的潭水里其实是出土了宝藏，价值万贯。消息传开，好奇的人们不远万里赶到潭边，有的确实想发笔横财，有的只是为了观光。富绅自己则在潭边围起一段栅栏，向来访者销售门票，不日累积万贯。不久，别处的清潭都变浊了。</em></p>

<p>近年火爆的VR/AR在大众眼中是“黑科技”，其实早在50年前(<a href="https://www.youtube.com/watch?v=ISJWZpFIAlQ">The Sword of Damocles，1965</a>)就被人玩剩了，他的创作者是图形学界祖师之一Ivan Sutherland。但可能是发现自己已经走得太远（实际上当时现代图形学基础还没有完全确立），于是萨大爷就带着他一票学生和下属回去后方铺路，后者们先后发明了Smalltalk编程语言、Gouraud着色算法、图形反走样算法，创办创意设计巨头Adobe以及高性能计算鼻祖SGI，甚至还联合乔帮主创办了Pixar（现任Pixar/Disney动画总裁的Edwin Catmull也是图形学巨擘，发明了灰常实用的Catmull-Rom样条函数，直到现在还被用于关键帧插值和<a href="http://www.cemyuksel.com/research/catmullrom_param/">渲染头发丝</a>）。</p>

<p>有意思的是，VR/AR在理论上的研究早已从感知器官上升到哲学范畴&hellip;&hellip;多年来在实践上却仍然停留在科技馆和特殊行业应用领域。最终，geek们期待的科技大跃进并没有真正到来，尘埃褪去，呈现的却是更加亲民的头显（HMD）和各种奇思妙想的控制器（Controller），无不体现着以人为本的时代理念。而如果你能尝试SteamVR上的应用、特别是体验下Proto奖的获奖作品时，你会欣慰地发现，原来真正有梦想、有创造力的人还在不断涌现，你就会从各种捞钱、炫富的纸金现实中暂时解脱出来了。</p>

<p>如果避开硬科幻，从终极关怀的角度审视VR/AR，我们所处时代的主题原来并非“黑科技”，而是“低门槛”和“大众化”。这里，本文提出一种特定场景下的混合现实产品思路，最后以一个真实的开源Demo为例，希望能为许多有想法的人打开一扇窗，鼓励更多人能参与到这一领域中来。</p>

<p><img src="http://content.hanyi.name/images/c22/full.jpg" alt="C22-Full" /></p>

<h4>为什么是特定场景？</h4>

<p>门槛是首要考虑因素。以Daydream为例，在如今诸多VR/AR平台中，Daydream的优势是非常易见的：它太容易接近大众了。对于其它竞品平台，则更多聚焦在高端和行业应用上，不利于小团队做快速原型开发和内容创新（就是说只适合憋大招）。</p>

<p>而Daydream的劣势目前也很明显：3-DOF的控制器无法捕捉用户的全身动作，反馈缺失导致了沉浸感不足（Vive的这一优势在市面上目前还无人匹敌）；另外，移动设备受限的性能、参差不齐的规格也导致潜在的用户体验问题，这恐怕也是Google率先携Pixel发布的初衷。</p>

<p>因此在设计VR/AR产品时，需要首先考虑平台对应用场景的限制。</p>

<h4>微情境（Micro-Situation）</h4>

<p>理论上说，VR/AR技术几乎可以被用于任何情境。基于现实考量，在“微情境”中实现的性价比则更高。</p>

<p>例如<strong>非厨师职业学习做饭</strong>，传统上可能是一对一的学徒体系；后来发展成书籍报刊、电视传播。前者属于文字模式更多得靠个人天赋，后者的声音＋图像模式就更容易被大众所接受。</p>

<p>但有人可能会质疑为什么不真的去尝试做一顿饭？其实这相当于混淆了学习和实践两种活动，“学做饭”和“做饭”本身不是一回事（当然你也可以说在实践中学习，但你也不能证明你是在完全未经过学习的情况下做了一顿饭，况且如果真的是这样，那么满足各位食客的可能性恐怕微乎其微）。</p>

<p>再来看“虚拟学做饭”这一活动的价值，最大的劣势就是你无法从外观之外获得任何的有效反馈，包括直接吃掉自己的学习成果。而优势是节省钱、食材、时间，切身经历每一道工序，这是现有的学习形式都不具备的。</p>

<p>从这一情境本身来说，用户只需要一间整洁的厨房，摆放整齐的食材和调味品，再加上面前一座灶台即可。而交互内容仅需要双手参与。那么即将进入寻常百姓家的Daydream平台完全满足需求，于是皆大欢喜。</p>

<p>其实这里需要考虑的重点在“微”上，什么样的情境才算是“微情境”呢？我们不尝试进一步去做更多的文字游戏，对于“微情境”的发现要更多依赖对情境本身、以及对VR/AR技术的理解和运用，这也是不可避免的过程。</p>

<p>这里再延伸到一个稍“大”一些的微情境：<strong>产品说明书</strong>。</p>

<p>相信大家对各式各样的产品说明书都不陌生，但从现实的生活经验来看，在大多数情况下，要么产品自身完全做到了自说明，要么很难快速（或者根本无法）从说明书中找到自己需要的答案。多年来，尽管平面设计不断进步，多媒体新招层出不穷，也很难断言一个真正有效的用户-产品沟通方式，而VR/AR的普及将为此带来全新的维度。</p>

<p>例如你网购了一套书柜，然而需要自己动手安装，原本自信满满的你花了很长时间，终于无奈地瘫坐在沉甸甸的零件旁，边满头大汗地研究起貌似手绘的安装说明&hellip;&hellip;在当前情境中，家具的零件都可以被虚拟化，用户也不需要真的在场景中走来走去，而是直接上手了解零件功能和安装步骤即可——可以想见，当平台越廉价，“微情境”中的VR/AR应用所带来的附加价值就会越高（例如直接嵌入产品官网Web，并借助移动设备进行VR/AR显示，具体实现请参考文末Demo）。</p>

<p>或许，人们会在不久之后的春晚上体验到VR/AR抢红包之类的全民娱乐呢？</p>

<h4>为什么是混合现实（MR）？</h4>

<p>在这波VR行情之前，就有许多AR应用运行在智能手机上，此外还包括不久前的google glass，却始终没有杀手级应用出现（酝酿多年也才蹦出一只Pokemon Go&hellip;）。原因甚多，其中市场太小、远离大众是一个非常重要的因素。难道VR就没有市场的疑问？否则巨头们为何集体押注在后者身上？由此可猜想投资VR的回报率明显要更高一筹，却万不能沉迷于只做游客。</p>

<p>值得一提的是Hololens展示了当前无与伦比的MR技术，无奈距离大众太过遥远，注定只会面向专业领域。实际上基于现有的VR设备要想直接实现接近Hololens的MR并不困难，毕竟只需要一个透明显示和空间位置标定，如果要做进一步的场景感知会稍复杂（但也已经不是壁垒），不过由此发展的成本肯定比一步到位要低许多。</p>

<p>（这里不得不说句题外话，平台大战可以造就繁荣的假象，但也可能扰乱了内容创造者们的思想，从而延缓技术的最终普及，这种风险在当前看来是不可避免的）</p>

<p>然而如果单纯比拼想象力，MR更胜VR/AR，虽然前者只是模糊了后者之间的界限。在接受程度上，人们总会倾向于那些更加抽象、简洁且表现力更强的形式，MR无疑将会最终胜出。</p>

<p>真正的困难之处在于，MR不仅仅在于两幅人眼画面的结合，也意味着更加复杂的应用场景，以及更具挑战的交互模式，而不是一个看起来更高级的HMD。</p>

<h4>来自22世纪的程序员（C22）</h4>

<p><a href="https://github.com/hanystudy/coder-from-22nd-century">C22</a>是一个基于传统PC+Cardboard的微情境应用。它展示了未来的程序员，能够摆脱固定显示器的束缚，使用HMD、键鼠就可以编写代码，并且在自身环境周围展示各种信息的技术。</p>

<p><img src="http://content.hanyi.name/images/c22/right.png" alt="C22-Right" /></p>

<p>如上图所示，PC中的应用信息被独立传送至HMD中创建的每个虚拟屏幕上，程序员可以在三维场景中浏览各种信息。</p>

<p>除了信息浏览外，C22允许程序员在盲打的情况下使用键盘、鼠标在对应的应用上进行操作，并且能够实时同步。</p>

<p>由于当前C22无法显示在一块透明质的HMD上（类似Hololens），因此也无法真正让普通用户感受到在现实中操作应用。此外由于分辨率的限制，C22目前能实现的用户体验也比较<a href="https://github.com/hanystudy/coder-from-22nd-century#resolution">受限</a>。</p>

<p><img src="http://content.hanyi.name/images/c22/left.png" alt="C22-Left" /></p>

<p>为了快速实现产品原型，C22全部使用JavaScript编写，并且采用了许多尚未广泛兼容的技术（详见<a href="https://github.com/hanystudy/coder-from-22nd-century">项目github主页</a>），由此带来的好处是核心部分搭建只用了两个晚上的时间，后期为了提高体验可能会进一步扩展当前技术栈。</p>

<p>同样由于兼容问题，C22目前只支持Android设备，并计划在<a href="http://www.roadtovr.com/googles-josh-carpenter-bringing-webvr-daydream-2017/">2017年第一季度支持Daydream</a>，届时，用户可以在周围自由设置信息布局。并且由于WebVR将得到浏览器原生支持，C22的渲染能力也将得到显著提升。</p>

<p>2015年举行的<a href="https://www.protoawards.com/">Proto颁奖大会</a>上，年近八旬的萨大爷<a href="https://www.youtube.com/watch?v=R2BfcKxpB8U">获虚拟现实“创始人奖”</a>，大神激励台下一帮天才后辈说：“内容意味着一切，摄像机（指技术）并不创造内容，只有最伟大的创造者才得以使用技术把现实带给人们”。</p>

<p>闻者深受共鸣。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - extensions]]></title>
    <link href="http://www.hanyi.name/blog/2015/11/03/metaprogramming-ruby-core-concepts-extensions/"/>
    <updated>2015-11-03T16:08:28+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/11/03/metaprogramming-ruby-core-concepts-extensions</id>
    <content type="html"><![CDATA[<p>As we already know, ruby provides several ways to extend our classes and objects including but not limit to OO inheritance, Module mix-in, Dynamic Methods, Monkey patching / Refinement, Eval family, Ghost methods, Callable objects, Singleton classes / methods, etc. But there are still some important tips deserve to be mentioned, before we moving forward.</p>

<h3>1. Include vs Extend</h3>

<p>Firstly let’s see an example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">foo</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello world&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello world&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Foo</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Bar</span><span class="o">.</span><span class="n">foo</span> <span class="c1">#NoMethodError: undefined method `foo&#39; for Bar:Class</span>
</span><span class='line'><span class="no">Bar</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">say_hi</span> <span class="c1">#Hello world</span>
</span></code></pre></td></tr></table></div></figure>


<p>It seems that module mix-in can only involve instance methods but not others like class methods. But how to do similar thing at class level? You must hear about extend:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello world&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">Foo</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Bar</span><span class="o">.</span><span class="n">foo</span> <span class="c1">#Hello world</span>
</span></code></pre></td></tr></table></div></figure>


<p>Extend is used in object level, so we are sure it can also be used for any class in ruby. But in previous article, we know that class method is actually saved as a singleton method of the original class, also instance method of its singleton class. So that should also happen on include:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello world&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span>
</span><span class='line'>  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">Foo</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Bar</span><span class="o">.</span><span class="n">foo</span> <span class="c1">#Hello world</span>
</span></code></pre></td></tr></table></div></figure>


<p>Thus we can regard extend as a kind of special usage on include through above examples.</p>

<h3>2. Method wrappers</h3>

<p>Method wrapper means wrapping an existing method inside a new method, which is very useful when you want to make extension without changing the source, like code in standard library or other cases.</p>

<p>There are several ways to implement method wrappers in ruby, and they are all in composite form of primitives which’ve already been introduced in previous articles. We’ll go through below.</p>

<h4>Around Alias</h4>

<p>Module#alias_method (also the key word ‘alias’) is used to give another name to ruby methods. It will involve more accessibility if an usual method could have different domain names(e.g. size, length and count). Also more flexibilities if you want, like code below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="n">alias_method</span> <span class="ss">:say_hello</span><span class="p">,</span> <span class="ss">:say_hi</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="n">say_hello</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;World&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">say_hi</span> <span class="c1">#Hello\nWorld\n</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is just a kind of wrapper using open class, alias_method, and method redefinition.</p>

<h4>Refinement</h4>

<p>We talked about refinement and suggested using refine instead of monkey patch. Actually refinement is even more powerful than that.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">FooRefinement</span>
</span><span class='line'>  <span class="n">refine</span> <span class="no">Foo</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>      <span class="k">super</span>
</span><span class='line'>      <span class="nb">p</span> <span class="s1">&#39;World&#39;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">using</span> <span class="no">FooRefinement</span>
</span><span class='line'>
</span><span class='line'><span class="no">Foo</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">say_hi</span> <span class="c1">#Hello\nWorld\n</span>
</span></code></pre></td></tr></table></div></figure>


<p>Only thing you need to notice is that the key word ‘using’ may not work well with your IRB environment, which means you couldn’t get result in mind for some versions of ruby if you run those code in IRB. See more information <a href="https://bugs.ruby-lang.org/issues/9580">here</a>.</p>

<p>The benefit of refinement wrapper is controllable scope of wrapper unlike around alias which affects globally. However, accessibility to original method is also lower than alias way.</p>

<h4>Prepending</h4>

<p>Module#prepend is the simplest way to implement method wrapper without scope configurability like refinement. But much more clear than other two.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">FooPrepending</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">say_hi</span>
</span><span class='line'>    <span class="k">super</span>
</span><span class='line'>    <span class="nb">p</span> <span class="s1">&#39;World&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Foo</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">prepend</span> <span class="no">FooPrepending</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Foo</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">say_hi</span> <span class="c1">#Hello\nWorld\n</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. Class Macros</h3>

<p>Ruby objects have no attributes - May this won’t surprise or confuse you too much. Indeed we’ve hear about instance variables or class variables, but you can not access them directly from outside. That means getter or writer can not be avoided:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">bar</span><span class="o">=</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@bar</span> <span class="o">=</span> <span class="n">value</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">bar</span>
</span><span class='line'>    <span class="vi">@bar</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="c1">#Hello</span>
</span></code></pre></td></tr></table></div></figure>


<p>It’s just not ruby style! Ruby provides series accessors for class definition using metaprogramming api, like attr_accessor, attr_reader and attr_writer, they are quite intuitive to use:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="kp">attr_accessor</span> <span class="ss">:bar</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">bar</span> <span class="c1">#Hello</span>
</span></code></pre></td></tr></table></div></figure>


<p>attr_* come from Module as private instance methods, thus they all can be used in module or class definitions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - eval family II]]></title>
    <link href="http://www.hanyi.name/blog/2015/09/16/metaprogramming-ruby-core-concepts-eval-family-ii/"/>
    <updated>2015-09-16T09:20:27+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/09/16/metaprogramming-ruby-core-concepts-eval-family-ii</id>
    <content type="html"><![CDATA[<p>In previous article several basic scope controlling tools are introduced, like block, proc, lambda, and method object. All of them should work well when you organize them in your code reasonably. There are more flexible way to mix code and bindings in ruby - eval, which may not be used broadly than others, so that considerable traps about it are still unclear for us.</p>

<h3>3. instance_eval / instance_exec</h3>

<p>BasicObject#instance_eval can be used almost everywhere in ruby, you can use it like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="vi">@bar</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span> <span class="p">}</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">instance_variable_get</span><span class="p">(</span><span class="s1">&#39;@bar&#39;</span><span class="p">)</span> <span class="c1">#hello</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the block of instance_eval, the scope changes to the instance foo, thus any operations inner it should bind to the instance, except closure variables.</p>

<p>BasicObject#instance_exec has similar feature to eval one, but with arguments support. This benefit shows as below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span>
</span><span class='line'>    <span class="vi">@bar</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;world&#39;</span>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="n">instance_exec</span><span class="p">(</span><span class="n">output</span><span class="p">){</span><span class="o">|</span><span class="n">output</span><span class="o">|</span> <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@bar</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
</span><span class='line'><span class="n">output</span> <span class="c1">#world</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4. class_eval / class_exec</h3>

<p>Module#class_eval works for evaluating a block in the context of an existing class. It seems to be similar to instance_eval which will have scope changes to instance self, but also changes current class (excluding singleton class).</p>

<p>class_eval can be used to open a existing class, without using keyword ‘class’. That means it has no scope changing issue compared with keyword way. Actually it even does not need to know the constant name of the target, while keyword way indeed needs.</p>

<p>Also Module#class_exec plays same role like instance_exec for instance_eval.</p>

<p>Think about the thing what we’ve discussed several weeks ago, in ruby all items are instance of class, including classes no matter internal or customized. Which means instance_eval and class_eval both can work for classes in many cases, but indeed have different self meaning.</p>

<p>You may also notice that there is also Module#module_eval / Module#module_exec methods, but they are just alias for class_eval / class_exec without any other changes.</p>

<h3>5. Kernel#eval</h3>

<p>Unlike instance_eval/class_eval, Kernel#eval only accept a string of ruby code as its argument, run the code and give the result. Even it’s so powerful, using string of code is not a good choice if you have other ways. The most issue for string of code is security.</p>

<p>Suppose you have eval expression in your code, which means others can evaluate any code using such method, including get/set operations. Ruby defines safe levels, which actually limits the evaluation of code from outside. By default, ruby will mark potentially unsafe objects which many come from external sources. And user could config a global variable $SAFE, it’s range from 0 to 3(0 by default) with more strict.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vg">$SAFE</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'><span class="nb">eval</span> <span class="s2">&quot;p &#39;hello </span><span class="si">#{</span><span class="nb">gets</span><span class="p">()</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
</span><span class='line'><span class="n">world</span> <span class="c1">#SecurityError: Insecure operation - eval</span>
</span></code></pre></td></tr></table></div></figure>


<p>By default, eval can accept almost any code from outside. However, it will not be permitted for code from I/O device(tainted object) if $SAFE is none zero. Below gives more details about $SAFE:</p>

<table>
<thead>
<tr>
<th>$SAFE</th>
<th style="text-align:center;"> Constraints</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center;">No checking of the use of externally supplied (tainted) data is performed. This is Ruby’s default mode.</td>
</tr>
<tr>
<td>>= 1</td>
<td style="text-align:center;">Ruby disallows the use of tainted data by potentially dangerous operations.</td>
</tr>
<tr>
<td>>= 2</td>
<td style="text-align:center;">Ruby prohibits the loading of program files from globally writable locations.</td>
</tr>
<tr>
<td>>= 3</td>
<td style="text-align:center;">All newly created objects are considered tainted.</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - eval family I]]></title>
    <link href="http://www.hanyi.name/blog/2015/09/14/metaprogramming-ruby-core-concepts-eval-family/"/>
    <updated>2015-09-14T23:08:19+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/09/14/metaprogramming-ruby-core-concepts-eval-family</id>
    <content type="html"><![CDATA[<p>In ruby, block is the cornerstone of metaprogramming with a surprisingly powerful scope controlling capability. Based on this definition, much brilliant interfaces are introduced, and help to implement many valuable features, like callable objects, eval and its huge family.</p>

<h3>1. blocks</h3>

<p>Block represents a snippet of code, it permits to be called immediately or lately depends on different cases. But compared with some similar concepts in functional programming languages, like Lisp, block still has more limits, and more readability respectively.</p>

<p>In commonly, block can be used like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">show_hello</span>
</span><span class='line'>  <span class="k">yield</span> <span class="s1">&#39;hello&#39;</span> <span class="k">if</span> <span class="nb">block_given?</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">show_hello</span> <span class="p">{</span> <span class="o">|</span><span class="n">say</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">say</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">show_hello</span> <span class="k">do</span> <span class="o">|</span><span class="n">say</span><span class="o">|</span>
</span><span class='line'>  <span class="n">file</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;/tmp/output.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">file</span><span class="o">.</span><span class="n">write</span> <span class="n">say</span>
</span><span class='line'>  <span class="n">file</span><span class="o">.</span><span class="n">close</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>&lsquo;yield&rsquo; is a ruby keyword used to call blocks sent to the current method. block_given? is an instance method from Kernel to probe whether there is a block for current method.</p>

<p>One of the most useful aspect of block is closure, it captures bindings where it&rsquo;s defined, and avoid impact of scope changing by connecting to those bindings, like flat scopes, and shared scopes.</p>

<p>Frankly speaking, block is actually not responsible for running code, but only representation (Except yield, which indeed means running code immediately). There are more powerful tools to help enhance block usage.</p>

<h3>2. callable objects</h3>

<p>Block is just like a package of code, and you need to use yield to execute it if you like. However, there are more ways to package code in ruby, including Proc and lambda.</p>

<h4>Proc</h4>

<p>We already know that block is not an object in ruby which is really quite a few, but Proc is basically a block turned object, can be seen as a consistent form of block, and you do not have to use yield to run it immediately, it will be running later as you want (Deferred Evaluation). you can define a Proc like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">inc</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'><span class="n">inc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#2</span>
</span><span class='line'><span class="n">dec</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'><span class="n">inc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#1</span>
</span></code></pre></td></tr></table></div></figure>


<h4>lambda</h4>

<p>Except for Proc, lambda can also be used for transferring blocks, but with simpler and a little different way:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">inc</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'><span class="n">inc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#2</span>
</span><span class='line'><span class="n">dec</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
</span><span class='line'><span class="n">dec</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#1</span>
</span></code></pre></td></tr></table></div></figure>


<h4>&amp; operator</h4>

<p>Once you have defined a block for a method, there is a way to convert it to a Proc inner method by using &amp;. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">bar</span>
</span><span class='line'>  <span class="k">yield</span> <span class="s1">&#39;ruby&#39;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">operation</span><span class="p">)</span>
</span><span class='line'>  <span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">operation</span><span class="p">)</span>
</span><span class='line'>  <span class="n">operation</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">puts</span> <span class="s2">&quot;hello </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
</span><span class='line'><span class="c1"># hello ruby</span>
</span><span class='line'><span class="c1"># hello world</span>
</span></code></pre></td></tr></table></div></figure>


<p>&amp; can be seen like transferring a block into Proc, but you need to remove &amp; if you want to use it as a Proc.</p>

<h4>Comparison between procs and lambdas</h4>

<p>You may notice that lambda is also a Proc, but you can still use Proc#lambda? to see the actual type of the target. Besides there are two important differences: keyword &lsquo;return&rsquo; and arguments checking.</p>

<h5>a. return</h5>

<p>As plain blocks, the program will return out of scope where block defined if return statement is set inner block, so does Proc (which may mean that the return may cause exception when the block is called in nonreturnable scope, like top-level). While for lambda, the return only runs out of block, not even farther.</p>

<h5>b. arity</h5>

<p>Arity means the number of arguments. In real case, lambda has less tolerance than Proc, which means that lambda requires correct number of arity, which is no need for procs.</p>

<h4>Method objects</h4>

<p>All methods are objects of Method. You can use Kernel#method or Kernel#singleton_method to get the object of method, then use Method#call to run the method. Also you may use Method#to_proc and define_method to convert method and proc to each other. Eventhough the method still has scope of it&rsquo;s defined.</p>

<h5>Unbound Methods</h5>

<p>Method object can also be unbound from original scopes by using Method#unbind, or Module#instance_method. Generated UnboundMethod object can not be called directly, but you can still call it after bind it to another scope by using UnboundMethod#bind. The only notice is that UnboundMethod object can only be bound to same class or sub if it&rsquo;s from class, and no such limitation when it&rsquo;s from module.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[metaprogramming ruby: core concepts - open classes &amp; refinements]]></title>
    <link href="http://www.hanyi.name/blog/2015/09/08/metaprogramming-ruby-core-concepts-open-classes-and-refinements/"/>
    <updated>2015-09-08T22:40:23+08:00</updated>
    <id>http://www.hanyi.name/blog/2015/09/08/metaprogramming-ruby-core-concepts-open-classes-and-refinements</id>
    <content type="html"><![CDATA[<h3>Opening Classes</h3>

<p>Opening classes brings much flexibility for ruby. It permits you to modify existed classes or modules permanently, without having to implement whole world in case you just need to give a simple patch for current tool. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">String</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">to_alphanumeric</span>
</span><span class='line'>    <span class="nb">gsub</span><span class="p">(</span><span class="sr">/[^\w\s]/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>to_alphanumeric is new interface to return only alpha and numeric part of a string. However, opening class may not work well, especially it&rsquo;s commonly dangerous to opening a frequently used target which would cause unexpected error in code. Due to this reason someone calls opening classes monkey patch and just leaves far from this feature.</p>

<p>While whatever, monkey patch continues conciseness in ruby, sometimes you are able to save your life gracefully with such powerful tool, except the trap behind it.</p>

<h3>Refinements</h3>

<p>From ruby 2.0, there is a more advanced form of monkey patch which is called refinements. Refinements are providing a way to extend classes only under specific scope, but not including modules. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">C</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;C#foo&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">module</span> <span class="nn">M</span>
</span><span class='line'>  <span class="n">refine</span> <span class="n">C</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;C#foo in M&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Module#refine creates an anonymous module that contains the changes or refinements to the class (C in the example). self in the refine block is this anonymous module similar to Module#module_eval.</p>

<h4>Scope</h4>

<p>We use using to activate refinements defined in any places, but you may only activate refinements at top-level, not inside any class, module or method scope. You may activate refinements in a string passed to Kernel#eval that is evaluated at top-level. Refinements are active until the end of the file or the end of the eval string, respectively.</p>

<p>Refinements are lexical in scope. When control is transferred outside the scope the refinement is deactivated. This means that when you require or load a file or call a method that is defined outside the current scope the refinement will be deactivated.</p>

<p>If a method is defined in a scope where a refinement is active the refinement will be active when the method is called.</p>

<p>When defining multiple refinements in the same module, inside a refine block all refinements from the same module are active when a refined method is called.</p>

<p>You may also activate refinements in a class or module definition, in which case the refinements are activated from the point where using is called to the end of the class or module definition.</p>

<h4>Method lookup under refinement</h4>

<p>When looking up a method for an instance of class C Ruby checks:</p>

<h5>1. If refinements are active for C, in the reverse order they were activated:</h5>

<p>  The prepended modules from the refinement for C</p>

<p>  The refinement for C</p>

<p>  The included modules from the refinement for C</p>

<h5>2. The prepended modules of C</h5>

<h5>3. C</h5>

<h5>4. The included modules of C</h5>

<p>If no method was found at any point this repeats with the superclass of C.</p>

<p>Note that methods in a subclass have priority over refinements in a superclass. For example, if the method / is defined in a refinement for Integer 1 / 2 invokes the original Fixnum#/ because Fixnum is a subclass of Integer and is searched before the refinements for the superclass Integer.</p>

<p>If a method foo is defined on Integer in a refinement, 1.foo invokes that method since foo does not exist on Fixnum.</p>

<h4>Super</h4>

<p>When super is invoked method lookup checks:</p>

<h5>The included modules of the current class. Note that the current class may be a refinement.</h5>

<h5>If the current class is a refinement, the method lookup proceeds as in the Method Lookup section above.</h5>

<h5>If the current class has a direct superclass, the method proceeds as in the Method Lookup section above using the superclass.</h5>

<p>Note that super in a method of a refinement invokes the method in the refined class even if there is another refinement which has been activated in the same context.</p>

<h4>Refinements and module inclusion</h4>

<p>Refinements are inherited by module inclusion. That is, using activates all refinements in the ancestors of the specified module. Refinements in a descendant have priority over refinements in an ancestor.</p>

<p>After all, refinement is still an experiment feature in ruby 2.x series, there is a detailed <a href="https://bugs.ruby-lang.org/projects/ruby-trunk/wiki/RefinementsSpec">specification</a> in official website, which should cover most aspect of it.</p>
]]></content>
  </entry>
  
</feed>
